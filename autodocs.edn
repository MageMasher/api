{:release {:cljs-version "0.0-927",
           :cljs-tag "r927",
           :cljs-date "2012-01-18",
           :clj-version "1.3.0",
           :clj-tag "clojure-1.3.0",
           :gclosure-lib "20110323-r790"},
 :clj-not-cljs #{"clojure.core/conj!"
                 "clojure.core/the-ns"
                 "clojure.core/create-struct"
                 "clojure.data/diff-similar"
                 "clojure.data/EqualityPartition"
                 "clojure.core/*in*"
                 "clojure.core/unchecked-subtract-int"
                 "clojure.main/demunge"
                 "clojure.core/release-pending-sends"
                 "clojure.reflect/flag-descriptors"
                 "clojure.core/shorts"
                 "clojure.core/shutdown-agents"
                 "clojure.core/restart-agent"
                 "clojure.java.io/input-stream"
                 "clojure.stacktrace/print-cause-trace"
                 "clojure.test/use-fixtures"
                 "clojure.java.io/file"
                 "clojure.test/*load-tests*"
                 "clojure.test/deftest-"
                 "clojure.core/unchecked-add"
                 "clojure.core/assoc!"
                 "clojure.core/doubles"
                 "clojure.inspector/inspect-tree"
                 "clojure.core/remove-ns"
                 "clojure.core/unchecked-byte"
                 "clojure.repl/thread-stopper"
                 "clojure.core/+'"
                 "clojure.core/rationalize"
                 "clojure.main/repl"
                 "clojure.pprint/simple-dispatch"
                 "clojure.repl/dir-fn"
                 "clojure.pprint/write-out"
                 "clojure.core/proxy-super"
                 "clojure.core/unchecked-divide-int"
                 "clojure.core/refer"
                 "clojure.repl/apropos"
                 "clojure.stacktrace/print-trace-element"
                 "clojure.core/future-call"
                 "clojure.core/persistent!"
                 "clojure.pprint/print-table"
                 "clojure.core/var?"
                 "clojure.core.protocols/InternalReduce"
                 "clojure.core/loaded-libs"
                 "clojure.core/commute"
                 "clojure.core/agent-errors"
                 "clojure.main/repl-caught"
                 "clojure.core/printf"
                 "clojure.core/ArrayChunk"
                 "clojure.pprint/*print-base*"
                 "clojure.core/into-array"
                 "clojure.core/load-string"
                 "clojure.core/pmap"
                 "clojure.test/file-position"
                 "clojure.core/double-array"
                 "clojure.core/float"
                 "clojure.test/do-report"
                 "clojure.core/send"
                 "clojure.core/unchecked-float"
                 "clojure.test/testing"
                 "clojure.core/ref-history-count"
                 "clojure.core/iterator-seq"
                 "clojure.pprint/pprint-indent"
                 "clojure.core/find-var"
                 "clojure.core/defstruct"
                 "clojure.core/-'"
                 "clojure.core/agent-error"
                 "clojure.core/ns-refers"
                 "clojure.core/num"
                 "clojure.core/*clojure-version*"
                 "clojure.reflect/do-reflect"
                 "clojure.core/future-cancelled?"
                 "clojure.core/unchecked-short"
                 "clojure.java.io/make-writer"
                 "clojure.test/test-var"
                 "clojure.stacktrace/print-stack-trace"
                 "clojure.core/sorted-map"
                 "clojure.core/init-proxy"
                 "clojure.core/unchecked-inc-int"
                 "clojure.walk/postwalk-demo"
                 "clojure.core/read-line"
                 "clojure.core/alter-var-root"
                 "clojure.core/bases"
                 "clojure.core/ints"
                 "clojure.repl/source-fn"
                 "clojure.core/class"
                 "clojure.reflect/ClassResolver"
                 "clojure.reflect/type-reflect"
                 "clojure.test/testing-contexts-str"
                 "clojure.core/byte-array"
                 "clojure.pprint/print-length-loop"
                 "clojure.test/join-fixtures"
                 "clojure.java.shell/with-sh-dir"
                 "clojure.test/run-tests"
                 "clojure.core/short"
                 "clojure.core/unchecked-dec-int"
                 "clojure.core/unchecked-subtract"
                 "clojure.core/sorted-map-by"
                 "clojure.core/*err*"
                 "clojure.pprint/*print-pretty*"
                 "clojure.test/successful?"
                 "clojure.core/await"
                 "clojure.test/testing-vars-str"
                 "clojure.core/supers"
                 "clojure.test/is"
                 "clojure.reflect/Field"
                 "clojure.core/sorted?"
                 "clojure.core/vector-of"
                 "clojure.core/accessor"
                 "clojure.inspector/inspect-table"
                 "clojure.core/class?"
                 "clojure.core/ns-map"
                 "clojure.core/unchecked-negate"
                 "clojure.java.io/make-output-stream"
                 "clojure.core/import"
                 "clojure.pprint/fresh-line"
                 "clojure.core/aset-boolean"
                 "clojure.reflect/typename"
                 "clojure.walk/prewalk-demo"
                 "clojure.core/require"
                 "clojure.pprint/pprint-tab"
                 "clojure.core/case"
                 "clojure.reflect/reflect"
                 "clojure.core/with-bindings"
                 "clojure.core/sync"
                 "clojure.pprint/pprint-logical-block"
                 "clojure.java.javadoc/javadoc"
                 "clojure.repl/find-doc"
                 "clojure.core/ref-set"
                 "clojure.core/booleans"
                 "clojure.test/run-all-tests"
                 "clojure.test.tap/with-tap-output"
                 "clojure.core/*print-length*"
                 "clojure.java.io/copy"
                 "clojure.pprint/write"
                 "clojure.core/transient"
                 "clojure.core/with-redefs"
                 "clojure.core/use"
                 "clojure.test.junit/with-junit-output"
                 "clojure.pprint/*print-right-margin*"
                 "clojure.core/future?"
                 "clojure.core/proxy-mappings"
                 "clojure.core/*read-eval*"
                 "clojure.template/do-template"
                 "clojure.core/spit"
                 "clojure.core/Vec"
                 "clojure.core/longs"
                 "clojure.core/monitor-enter"
                 "clojure.core/alter"
                 "clojure.core/bytes"
                 "clojure.core/char?"
                 "clojure.java.io/resource"
                 "clojure.repl/root-cause"
                 "clojure.core/inc'"
                 "clojure.pprint/formatter"
                 "clojure.java.io/make-parents"
                 "clojure.core/ref-min-history"
                 "clojure.core/get-proxy-class"
                 "clojure.core/memfn"
                 "clojure.core/type"
                 "clojure.core/aset-double"
                 "clojure.pprint/formatter-out"
                 "clojure.pprint/*print-miser-width*"
                 "clojure.test/set-test"
                 "clojure.core/ref"
                 "clojure.core/future-cancel"
                 "clojure.core/nthrest"
                 "clojure.core/with-local-vars"
                 "clojure.core/agent"
                 "clojure.core/ns-name"
                 "clojure.pprint/pprint-newline"
                 "clojure.core/bean"
                 "clojure.test/compose-fixtures"
                 "clojure.core/aset-float"
                 "clojure.core/*file*"
                 "clojure.core/*out*"
                 "clojure.core/clojure-version"
                 "clojure.core/sorted-set-by"
                 "clojure.core/with-in-str"
                 "clojure.core/test"
                 "clojure.core/list?"
                 "clojure.repl/pst"
                 "clojure.xml/parse"
                 "clojure.core/with-bindings*"
                 "clojure.test/test-ns"
                 "clojure.test/assert-predicate"
                 "clojure.core/to-array-2d"
                 "clojure.core/update-proxy"
                 "clojure.java.io/make-input-stream"
                 "clojure.core/reversible?"
                 "clojure.core/promise"
                 "clojure.core/*compile-files*"
                 "clojure.core/print-str"
                 "clojure.core/pop!"
                 "clojure.pprint/set-pprint-dispatch"
                 "clojure.core/float?"
                 "clojure.core/eval"
                 "clojure.core/*compile-path*"
                 "clojure.core/gen-class"
                 "clojure.core/macroexpand-1"
                 "clojure.test.tap/print-tap-diagnostic"
                 "clojure.core/find-keyword"
                 "clojure.core/bound-fn*"
                 "clojure.core/find-ns"
                 "clojure.core/unchecked-double"
                 "clojure.reflect/Constructor"
                 "clojure.test/*stack-trace-depth*"
                 "clojure.core/array-map"
                 "clojure.reflect/resolve-class"
                 "clojure.java.io/as-file"
                 "clojure.core/dissoc!"
                 "clojure.core/ns-aliases"
                 "clojure.main/stack-element-str"
                 "clojure.core/extend"
                 "clojure.core/char-name-string"
                 "clojure.reflect/JavaReflector"
                 "clojure.inspector/inspect"
                 "clojure.core/shuffle"
                 "clojure.core/*e"
                 "clojure.core/defonce"
                 "clojure.core/unchecked-inc"
                 "clojure.core/create-ns"
                 "clojure.core/hash-set"
                 "clojure.repl/doc"
                 "clojure.core/aset-int"
                 "clojure.test/test-all-vars"
                 "clojure.stacktrace/print-throwable"
                 "clojure.pprint/*print-suppress-namespaces*"
                 "clojure.pprint/code-dispatch"
                 "clojure.pprint/*print-radix*"
                 "clojure.main/repl-prompt"
                 "clojure.core/int-array"
                 "clojure.test/with-test"
                 "clojure.core/unchecked-remainder-int"
                 "clojure.pprint/pp"
                 "clojure.core/struct-map"
                 "clojure.core/val"
                 "clojure.template/apply-template"
                 "clojure.core/cast"
                 "clojure.core/load"
                 "clojure.java.shell/with-sh-env"
                 "clojure.main/repl-read"
                 "clojure.core/io!"
                 "clojure.repl/dir"
                 "clojure.core/char"
                 "clojure.core/ensure"
                 "clojure.core/*print-level*"
                 "clojure.core/re-groups"
                 "clojure.core/pvalues"
                 "clojure.core/ifn?"
                 "clojure.core/deliver"
                 "clojure.main/load-script"
                 "clojure.core/numerator"
                 "clojure.core/VecNode"
                 "clojure.core/VecSeq"
                 "clojure.core/var-get"
                 "clojure.core/clear-agent-errors"
                 "clojure.core/var-set"
                 "clojure.core/slurp"
                 "clojure.core/make-array"
                 "clojure.core/bound-fn"
                 "clojure.core/special-symbol?"
                 "clojure.core/push-thread-bindings"
                 "clojure.core/*unchecked-math*"
                 "clojure.core/aset-short"
                 "clojure.java.io/make-reader"
                 "clojure.core/ns-resolve"
                 "clojure.core/long"
                 "clojure.core/locking"
                 "clojure.core/char-array"
                 "clojure.stacktrace/root-cause"
                 "clojure.core/ratio?"
                 "clojure.core/rational?"
                 "clojure.java.io/as-url"
                 "clojure.core/future"
                 "clojure.core/object-array"
                 "clojure.core/aset-byte"
                 "clojure.core/send-off"
                 "clojure.test/are"
                 "clojure.java.io/IOFactory"
                 "clojure.reflect/Method"
                 "clojure.core/float-array"
                 "clojure.core/rseq"
                 "clojure.core/thread-bound?"
                 "clojure.core/with-precision"
                 "clojure.core/proxy"
                 "clojure.core/macroexpand"
                 "clojure.core/floats"
                 "clojure.core/aset-char"
                 "clojure.java.io/output-stream"
                 "clojure.test/inc-report-counter"
                 "clojure.java.io/delete-file"
                 "clojure.core/compile"
                 "clojure.repl/stack-element-str"
                 "clojure.core/sorted-set"
                 "clojure.core/resolve"
                 "clojure.core/xml-seq"
                 "clojure.test/with-test-out"
                 "clojure.core/lazy-cat"
                 "clojure.core/file-seq"
                 "clojure.core/ns-interns"
                 "clojure.core/short-array"
                 "clojure.core/future-done?"
                 "clojure.core/comparator"
                 "clojure.core/get-thread-bindings"
                 "clojure.core/var"
                 "clojure.stacktrace/e"
                 "clojure.core/unchecked-add-int"
                 "clojure.pprint/cl-format"
                 "clojure.core/ns-unmap"
                 "clojure.core/struct"
                 "clojure.repl/set-break-handler!"
                 "clojure.core/&"
                 "clojure.java.javadoc/add-remote-javadoc"
                 "clojure.test.tap/print-tap-pass"
                 "clojure.main/root-cause"
                 "clojure.core/extenders"
                 "clojure.core/key"
                 "clojure.core/construct-proxy"
                 "clojure.core/intern"
                 "clojure.pprint/with-pprint-dispatch"
                 "clojure.core/unchecked-int"
                 "clojure.core/error-mode"
                 "clojure.core/subseq"
                 "clojure.core/all-ns"
                 "clojure.walk/macroexpand-all"
                 "clojure.core/*ns*"
                 "clojure.core/char-escape-string"
                 "clojure.repl/demunge"
                 "clojure.core/line-seq"
                 "clojure.core/disj!"
                 "clojure.core/enumeration-seq"
                 "clojure.core/bigdec"
                 "clojure.java.javadoc/add-local-javadoc"
                 "clojure.core/decimal?"
                 "clojure.core/pcalls"
                 "clojure.core/with-out-str"
                 "clojure.core/long-array"
                 "clojure.core/ns-unalias"
                 "clojure.core/double"
                 "clojure.core/error-handler"
                 "clojure.core/biginteger"
                 "clojure.pprint/get-pretty-writer"
                 "clojure.core/ref-max-history"
                 "clojure.reflect/TypeReference"
                 "clojure.test/function?"
                 "clojure.data/Diff"
                 "clojure.pprint/pprint"
                 "clojure.test/deftest"
                 "clojure.core/unchecked-negate-int"
                 "clojure.core/definline"
                 "clojure.core/namespace-munge"
                 "clojure.core/pop-thread-bindings"
                 "clojure.data/diff"
                 "clojure.main/main"
                 "clojure.core/unchecked-multiply"
                 "clojure.core/ns-imports"
                 "clojure.core/aset-long"
                 "clojure.core/dosync"
                 "clojure.core/chars"
                 "clojure.core/*'"
                 "clojure.core/seque"
                 "clojure.test/try-expr"
                 "clojure.main/skip-whitespace"
                 "clojure.main/with-bindings"
                 "clojure.core/load-reader"
                 "clojure.core/await-for"
                 "clojure.test.tap/print-tap-plan"
                 "clojure.core/*command-line-args*"
                 "clojure.test/report"
                 "clojure.core/unchecked-char"
                 "clojure.java.browse/browse-url"
                 "clojure.core/monitor-exit"
                 "clojure.core/re-matcher"
                 "clojure.java.io/as-relative-path"
                 "clojure.test/assert-any"
                 "clojure.core/println-str"
                 "clojure.core/gen-interface"
                 "clojure.core/with-redefs-fn"
                 "clojure.core/extends?"
                 "clojure.java.io/Coercions"
                 "clojure.core/set-error-mode!"
                 "clojure.core/format"
                 "clojure.core/int"
                 "clojure.core/*agent*"
                 "clojure.core/alias"
                 "clojure.core/ns-publics"
                 "clojure.core/bound?"
                 "clojure.java.io/writer"
                 "clojure.core/prn-str"
                 "clojure.pprint/*print-pprint-dispatch*"
                 "clojure.core/with-open"
                 "clojure.core/set-error-handler!"
                 "clojure.repl/source"
                 "clojure.java.shell/sh"
                 "clojure.core/byte"
                 "clojure.core/unchecked-dec"
                 "clojure.core/sequence"
                 "clojure.core/denominator"
                 "clojure.main/skip-if-eol"
                 "clojure.core/dec'"
                 "clojure.data/equality-partition"
                 "clojure.core/refer-clojure"
                 "clojure.core/unchecked-long"
                 "clojure.java.io/reader"
                 "clojure.reflect/Reflector"
                 "clojure.main/repl-exception"
                 "clojure.test.tap/print-tap-fail"
                 "clojure.core/bigint"
                 "clojure.core/resultset-seq"
                 "clojure.test/get-possibly-unbound-var"
                 "clojure.core/unchecked-multiply-int"
                 "clojure.core.protocols/internal-reduce"
                 "clojure.reflect/AsmReflector"
                 "clojure.core/boolean-array"
                 "clojure.core/add-classpath"
                 "clojure.core/*warn-on-reflection*"
                 "clojure.core/rsubseq"},
 :library-api {:symbols {"cljs.core/keys" {:ns "cljs.core",
                                           :name "keys",
                                           :signature ["[hash-map]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_keys",
                                           :source {:code "(defn keys\n  [hash-map]\n  (seq (map first hash-map)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2376 2379],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2376-L2379"},
                                           :full-name "cljs.core/keys",
                                           :clj-symbol "clojure.core/keys",
                                           :docstring "Returns a sequence of the map's keys."},
                         "cljs.core/reset!" {:ns "cljs.core",
                                             :name "reset!",
                                             :signature ["[a new-value]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_reset_BANG_",
                                             :source {:code "(defn reset!\n  [a new-value]\n  (when-let [validate (.-validator a)]\n    (assert (validate new-value) \"Validator rejected reference state\"))\n  (let [old-value (.-state a)]\n    (set! (.-state a) new-value)\n    (-notify-watches a old-value new-value))\n  new-value)",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [3011
                                                              3020],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3011-L3020"},
                                             :full-name "cljs.core/reset!",
                                             :clj-symbol "clojure.core/reset!",
                                             :docstring "Sets the value of atom to newval without regard for the\ncurrent value. Returns newval."},
                         "clojure.set/select" {:ns "clojure.set",
                                               :name "select",
                                               :signature ["[pred xset]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.set_select",
                                               :source {:code "(defn select\n  [pred xset]\n    (reduce (fn [s k] (if (pred k) s (disj s k)))\n            xset xset))",
                                                        :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                        :lines [61 65],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/set.cljs#L61-L65"},
                                               :full-name "clojure.set/select",
                                               :clj-symbol "clojure.set/select",
                                               :docstring "Returns a set of the elements for which pred is true"},
                         "cljs.core/delay" {:ns "cljs.core",
                                            :name "delay",
                                            :signature ["[& body]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_delay",
                                            :source {:code "(defn delay\n  [& body]\n  (Delay. (fn [] (apply identity body)) (atom nil)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [3147
                                                             3153],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3147-L3153"},
                                            :full-name "cljs.core/delay",
                                            :clj-symbol "clojure.core/delay",
                                            :docstring "Takes a body of expressions and yields a Delay object that will\ninvoke the body only the first time it is forced (with force or deref/@), and\nwill cache the result and return it on all subsequent force\ncalls."},
                         "cljs.core/bit-not" {:ns "cljs.core",
                                              :name "bit-not",
                                              :signature ["[x]"],
                                              :shadowed-sources ({:code "(defmacro bit-not [x]\n  (list 'js* \"(~ ~{})\" x))",
                                                                  :filename "clojurescript/src/clj/cljs/core.clj",
                                                                  :lines [131
                                                                          132],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L131-L132"}),
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_bit-not",
                                              :source {:code "(defn bit-not\n  [x] (js* \"(~~{x})\"))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [924
                                                               926],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L924-L926"},
                                              :full-name "cljs.core/bit-not",
                                              :clj-symbol "clojure.core/bit-not",
                                              :docstring "Bitwise complement"},
                         "cljs.core/partition" {:ns "cljs.core",
                                                :name "partition",
                                                :signature ["[n coll]"
                                                            "[n step coll]"
                                                            "[n step pad coll]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_partition",
                                                :source {:code "(defn partition\n  ([n coll]\n     (partition n n coll))\n  ([n step coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (when (= n (count p))\n             (cons p (partition n step (drop step s))))))))\n  ([n step pad coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (if (= n (count p))\n             (cons p (partition n step pad (drop step s)))\n             (list (take n (concat p pad)))))))))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1831
                                                                 1851],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1831-L1851"},
                                                :full-name "cljs.core/partition",
                                                :clj-symbol "clojure.core/partition",
                                                :docstring "Returns a lazy sequence of lists of n items each, at offsets step\napart. If step is not supplied, defaults to n, i.e. the partitions\ndo not overlap. If a pad collection is supplied, use its elements as\nnecessary to complete last partition upto n items. In case there are\nnot enough padding elements, return a partition with less than n items."},
                         "cljs.core/parents" {:ns "cljs.core",
                                              :name "parents",
                                              :signature ["[tag]"
                                                          "[h tag]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_parents",
                                              :source {:code "(defn parents\n  ([tag] (parents @global-hierarchy tag))\n  ([h tag] (not-empty (get (:parents h) tag))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [3276
                                                               3282],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3276-L3282"},
                                              :full-name "cljs.core/parents",
                                              :clj-symbol "clojure.core/parents",
                                              :docstring "Returns the immediate parents of tag, either via a Java type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
                         "cljs.core/aclone" {:ns "cljs.core",
                                             :name "aclone",
                                             :signature ["[array-like]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_aclone",
                                             :source {:code "(defn aclone\n  [array-like]\n  #_(goog.array.clone array-like)\n  (js* \"Array.prototype.slice.call(~{array-like})\"))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [65 69],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L65-L69"},
                                             :full-name "cljs.core/aclone",
                                             :clj-symbol "clojure.core/aclone",
                                             :docstring "Returns a javascript array, cloned from the passed in array"},
                         "cljs.core/reset-meta!" {:ns "cljs.core",
                                                  :name "reset-meta!",
                                                  :signature ["[iref m]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_reset-meta_BANG_",
                                                  :source {:code "(defn reset-meta!\n  [iref m]\n  (set! (.-meta iref) m))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [3078
                                                                   3081],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3078-L3081"},
                                                  :full-name "cljs.core/reset-meta!",
                                                  :clj-symbol "clojure.core/reset-meta!",
                                                  :docstring "Atomically resets the metadata for an atom"},
                         "special/defrecord*" {:full-name "special/defrecord*",
                                               :ns "special",
                                               :name "defrecord*",
                                               :type "special form",
                                               :source {:code "(defmethod parse 'defrecord*\n  [_ env [_ tsym fields] _]\n  (let [t (munge (:name (resolve-var (dissoc env :locals) tsym)))]\n    (swap! namespaces update-in [(-> env :ns :name) :defs tsym]\n           (fn [m]\n             (let [m (assoc (or m {}) :name t)]\n               (if-let [line (:line env)]\n                 (-> m\n                     (assoc :file *cljs-file*)\n                     (assoc :line line))\n                 m))))\n    {:env env :op :defrecord* :t t :fields fields}))",
                                                        :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                        :lines [855
                                                                866],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/compiler.clj#L855-L866"},
                                               :full-name-encode "special_defrecord_STAR_",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.reader/dispatch-macros" {:full-name "cljs.reader/dispatch-macros",
                                                        :ns "cljs.reader",
                                                        :name "dispatch-macros",
                                                        :type "var",
                                                        :source {:code "(def dispatch-macros\n  {\"{\" read-set\n   \"<\" (throwing-reader \"Unreadable form\")\n   \"\\\"\" read-regex\n   \"!\" read-comment\n   \"_\" read-discard})",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [331
                                                                         336],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L331-L336"},
                                                        :full-name-encode "cljs.reader_dispatch-macros",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/ICollection" {:ns "cljs.core",
                                                  :name "ICollection",
                                                  :type "protocol",
                                                  :full-name-encode "cljs.core_ICollection",
                                                  :source {:code "(defprotocol ICollection\n  (-conj [coll o]))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [99
                                                                   100],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L99-L100"},
                                                  :methods [{:name "-conj",
                                                             :signature ["[coll o]"],
                                                             :docstring nil}],
                                                  :full-name "cljs.core/ICollection",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/every?" {:ns "cljs.core",
                                             :name "every?",
                                             :signature ["[pred coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_every_QMARK_",
                                             :source {:code "(defn every?\n  [pred coll]\n  (cond\n   (nil? (seq coll)) true\n   (pred (first coll)) (recur pred (next coll))\n   :else false))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1403
                                                              1410],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1403-L1410"},
                                             :full-name "cljs.core/every?",
                                             :clj-symbol "clojure.core/every?",
                                             :docstring "Returns true if (pred x) is logical true for every x in coll, else\nfalse."},
                         "clojure.zip/node" {:ns "clojure.zip",
                                             :name "node",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_node",
                                             :source {:code "(defn node\n  [loc] (loc 0))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [60 62],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L60-L62"},
                                             :full-name "clojure.zip/node",
                                             :clj-symbol "clojure.zip/node",
                                             :docstring "Returns the node at loc"},
                         "cljs.core/IEmptyableCollection" {:ns "cljs.core",
                                                           :name "IEmptyableCollection",
                                                           :type "protocol",
                                                           :full-name-encode "cljs.core_IEmptyableCollection",
                                                           :source {:code "(defprotocol IEmptyableCollection\n  (-empty [coll]))",
                                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                    :lines [96
                                                                            97],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L96-L97"},
                                                           :methods [{:name "-empty",
                                                                      :signature ["[coll]"],
                                                                      :docstring nil}],
                                                           :full-name "cljs.core/IEmptyableCollection",
                                                           :history [["+"
                                                                      "0.0-927"]]},
                         "clojure.zip/right" {:ns "clojure.zip",
                                              :name "right",
                                              :signature ["[loc]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.zip_right",
                                              :source {:code "(defn right\n  [loc]\n    (let [[node {l :l  [r & rnext :as rs] :r :as path}] loc]\n      (when (and path rs)\n        (with-meta [r (assoc path :l (conj l node) :r rnext)] (meta loc)))))",
                                                       :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                       :lines [135
                                                               140],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L135-L140"},
                                              :full-name "clojure.zip/right",
                                              :clj-symbol "clojure.zip/right",
                                              :docstring "Returns the loc of the right sibling of the node at this loc, or nil"},
                         "cljs.core/==" {:ns "cljs.core",
                                         :name "==",
                                         :signature ["[x]"
                                                     "[x y]"
                                                     "[x y & more]"],
                                         :shadowed-sources ({:code "(defmacro ==\n  ([x] true)\n  ([x y] (list 'js* \"(~{} === ~{})\" x y))\n  ([x y & more] `(and (== ~x ~y) (== ~y ~@more))))",
                                                             :filename "clojurescript/src/clj/cljs/core.clj",
                                                             :lines [98
                                                                     101],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L98-L101"}),
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core__EQ__EQ_",
                                         :source {:code "(defn ==\n  ([x] true)\n  ([x y] (-equiv x y))\n  ([x y & more]\n   (if (== x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (== y (first more)))\n     false)))",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [947 957],
                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L947-L957"},
                                         :full-name "cljs.core/==",
                                         :clj-symbol "clojure.core/==",
                                         :docstring "Returns non-nil if nums all have the equivalent\nvalue (type-independent), otherwise false"},
                         "special/." {:full-name "special/.",
                                      :ns "special",
                                      :name ".",
                                      :type "special form",
                                      :source {:code "(defmethod parse '.\n  [_ env [_ target & [field & member+]] _]\n  (disallowing-recur\n   (let [{:keys [dot-action target method field args]} (build-dot-form [target field member+])\n         enve        (assoc env :context :expr)\n         targetexpr  (analyze enve target)\n         children    [enve]]\n     (case dot-action\n           ::access {:env env :op :dot :children children\n                     :target targetexpr\n                     :field field}\n           ::call   (let [argexprs (map #(analyze enve %) args)]\n                      {:env env :op :dot :children (into children argexprs)\n                       :target targetexpr\n                       :method method\n                       :args argexprs})))))",
                                               :filename "clojurescript/src/clj/cljs/compiler.clj",
                                               :lines [934 949],
                                               :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/compiler.clj#L934-L949"},
                                      :full-name-encode "special__DOT_",
                                      :clj-symbol "clojure.core/.",
                                      :history [["+" "0.0-927"]]},
                         "clojure.browser.net/*timeout*" {:full-name "clojure.browser.net/*timeout*",
                                                          :ns "clojure.browser.net",
                                                          :name "*timeout*",
                                                          :type "var",
                                                          :source {:code "(def *timeout* 10000)",
                                                                   :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                   :lines [21
                                                                           21],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/net.cljs#L21-L21"},
                                                          :full-name-encode "clojure.browser.net__STAR_timeout_STAR_",
                                                          :history [["+"
                                                                     "0.0-927"]]},
                         "cljs.core/remove-method" {:ns "cljs.core",
                                                    :name "remove-method",
                                                    :signature ["[multifn dispatch-val]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_remove-method",
                                                    :source {:code "(defn remove-method\n [multifn dispatch-val]\n (-remove-method multifn dispatch-val))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [3483
                                                                     3486],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3483-L3486"},
                                                    :full-name "cljs.core/remove-method",
                                                    :clj-symbol "clojure.core/remove-method",
                                                    :docstring "Removes the method of multimethod associated with dispatch-value."},
                         "cljs.core/frequencies" {:ns "cljs.core",
                                                  :name "frequencies",
                                                  :signature ["[coll]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_frequencies",
                                                  :source {:code "(defn frequencies\n  [coll]\n  (reduce\n   (fn [counts x]\n     (assoc counts x (inc (get counts x 0))))\n   {}\n   coll))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [2675
                                                                   2683],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2675-L2683"},
                                                  :full-name "cljs.core/frequencies",
                                                  :clj-symbol "clojure.core/frequencies",
                                                  :docstring "Returns a map from distinct items in coll to the number of times\nthey appear."},
                         "cljs.core/pop" {:ns "cljs.core",
                                          :name "pop",
                                          :signature ["[coll]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_pop",
                                          :source {:code "(defn pop\n  [coll]\n  (-pop coll))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [524 529],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L524-L529"},
                                          :full-name "cljs.core/pop",
                                          :clj-symbol "clojure.core/pop",
                                          :docstring "For a list or queue, returns a new list/queue without the first\nitem, for a vector, returns a new vector without the last item.\nNote - not the same as next/butlast."},
                         "cljs.core/not-every?" {:ns "cljs.core",
                                                 :name "not-every?",
                                                 :signature ["[pred coll]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_not-every_QMARK_",
                                                 :source {:code "(defn not-every?\n  [pred coll] (not (every? pred coll)))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [1412
                                                                  1415],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1412-L1415"},
                                                 :full-name "cljs.core/not-every?",
                                                 :clj-symbol "clojure.core/not-every?",
                                                 :docstring "Returns false if (pred x) is logical true for every x in\ncoll, else true."},
                         "cljs.core/some-fn" {:ns "cljs.core",
                                              :name "some-fn",
                                              :signature ["[p]"
                                                          "[p1 p2]"
                                                          "[p1 p2 p3]"
                                                          "[p1 p2 p3 & ps]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_some-fn",
                                              :source {:code "(defn some-fn\n  ([p]\n     (fn sp1\n       ([] nil)\n       ([x] (p x))\n       ([x y] (or (p x) (p y)))\n       ([x y z] (or (p x) (p y) (p z)))\n       ([x y z & args] (or (sp1 x y z)\n                           (some p args)))))\n  ([p1 p2]\n     (fn sp2\n       ([] nil)\n       ([x] (or (p1 x) (p2 x)))\n       ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n       ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n       ([x y z & args] (or (sp2 x y z)\n                           (some #(or (p1 %) (p2 %)) args)))))\n  ([p1 p2 p3]\n     (fn sp3\n       ([] nil)\n       ([x] (or (p1 x) (p2 x) (p3 x)))\n       ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n       ([x y z] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z)))\n       ([x y z & args] (or (sp3 x y z)\n                           (some #(or (p1 %) (p2 %) (p3 %)) args)))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn spn\n         ([] nil)\n         ([x] (some #(% x) ps))\n         ([x y] (some #(or (% x) (% y)) ps))\n         ([x y z] (some #(or (% x) (% y) (% z)) ps))\n         ([x y z & args] (or (spn x y z)\n                             (some #(some % args) ps)))))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1600
                                                               1637],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1600-L1637"},
                                              :full-name "cljs.core/some-fn",
                                              :clj-symbol "clojure.core/some-fn",
                                              :docstring "Takes a set of predicates and returns a function f that returns the first logical true value\nreturned by one of its composing predicates against any of its arguments, else it returns\nlogical false. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical true result against the original predicates."},
                         "clojure.browser.event/remove-all" {:full-name "clojure.browser.event/remove-all",
                                                             :ns "clojure.browser.event",
                                                             :name "remove-all",
                                                             :type "function",
                                                             :signature ["[opt_obj opt_type opt_capt]"],
                                                             :source {:code "(defn remove-all [opt_obj opt_type opt_capt])",
                                                                      :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                      :lines [98
                                                                              98],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/event.cljs#L98-L98"},
                                                             :full-name-encode "clojure.browser.event_remove-all",
                                                             :history [["+"
                                                                        "0.0-927"]]},
                         "cljs.core/doto" {:ns "cljs.core",
                                           :name "doto",
                                           :signature ["[x & forms]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_doto",
                                           :source {:code "(defmacro doto\n  [x & forms]\n    (let [gx (gensym)]\n      `(let [~gx ~x]\n         ~@(map (fn [f]\n                  (if (seq? f)\n                    `(~(first f) ~gx ~@(next f))\n                    `(~f ~gx)))\n                forms)\n         ~gx)))",
                                                    :filename "clojure/src/clj/clojure/core.clj",
                                                    :lines [3395 3410],
                                                    :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L3395-L3410"},
                                           :full-name "cljs.core/doto",
                                           :clj-symbol "clojure.core/doto",
                                           :docstring "Evaluates x then calls all of the methods and functions with the\nvalue of x supplied at the front of the given arguments.  The forms\nare evaluated in order.  Returns x.\n\n(doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))"},
                         "cljs.core/take-while" {:ns "cljs.core",
                                                 :name "take-while",
                                                 :signature ["[pred coll]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_take-while",
                                                 :source {:code "(defn take-while\n  [pred coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (when (pred (first s))\n       (cons (first s) (take-while pred (rest s)))))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2576
                                                                  2583],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2576-L2583"},
                                                 :full-name "cljs.core/take-while",
                                                 :clj-symbol "clojure.core/take-while",
                                                 :docstring "Returns a lazy sequence of successive items from coll while\n(pred item) returns true. pred must be free of side-effects."},
                         "cljs.reader/escape-char-map" {:full-name "cljs.reader/escape-char-map",
                                                        :ns "cljs.reader",
                                                        :name "escape-char-map",
                                                        :type "var",
                                                        :source {:code "(def escape-char-map {\\t \"\\t\"\n                      \\r \"\\r\"\n                      \\n \"\\n\"\n                      \\\\ \\\\\n                      \\\" \\\"\n                      \\b \"\\b\"\n                      \\f \"\\f\"})",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [137
                                                                         143],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L137-L143"},
                                                        :full-name-encode "cljs.reader_escape-char-map",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "clojure.browser.event/all-listeners" {:full-name "clojure.browser.event/all-listeners",
                                                                :ns "clojure.browser.event",
                                                                :name "all-listeners",
                                                                :type "function",
                                                                :signature ["[obj type capture]"],
                                                                :source {:code "(defn all-listeners [obj type capture])",
                                                                         :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                         :lines [90
                                                                                 90],
                                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/event.cljs#L90-L90"},
                                                                :full-name-encode "clojure.browser.event_all-listeners",
                                                                :history [["+"
                                                                           "0.0-927"]]},
                         "cljs.core/vals" {:ns "cljs.core",
                                           :name "vals",
                                           :signature ["[hash-map]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_vals",
                                           :source {:code "(defn vals\n  [hash-map]\n  (seq (map second hash-map)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2381 2384],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2381-L2384"},
                                           :full-name "cljs.core/vals",
                                           :clj-symbol "clojure.core/vals",
                                           :docstring "Returns a sequence of the map's values."},
                         "cljs.core/IDeref" {:ns "cljs.core",
                                             :name "IDeref",
                                             :type "protocol",
                                             :full-name-encode "cljs.core_IDeref",
                                             :source {:code "(defprotocol IDeref\n (-deref [o]))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [134 135],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L134-L135"},
                                             :methods [{:name "-deref",
                                                        :signature ["[o]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/IDeref",
                                             :history [["+" "0.0-927"]]},
                         "clojure.browser.dom/log-obj" {:full-name "clojure.browser.dom/log-obj",
                                                        :ns "clojure.browser.dom",
                                                        :name "log-obj",
                                                        :type "function",
                                                        :signature ["[obj]"],
                                                        :source {:code "(defn log-obj [obj]\n  (.log js/console obj))",
                                                                 :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                 :lines [22
                                                                         23],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/dom.cljs#L22-L23"},
                                                        :full-name-encode "clojure.browser.dom_log-obj",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/for" {:ns "cljs.core",
                                          :name "for",
                                          :signature ["[seq-exprs body-expr]"],
                                          :shadowed-sources ({:code "(defmacro for\n  [seq-exprs body-expr]\n  (assert-args for\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [to-groups (fn [seq-exprs]\n                    (reduce1 (fn [groups [k v]]\n                              (if (keyword? k)\n                                (conj (pop groups) (conj (peek groups) [k v]))\n                                (conj groups [k v])))\n                            [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (IllegalArgumentException. ^String (apply str msg))))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (cond\n                                     (= k :let) `(let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(let [iterys# ~(emit-bind next-groups)\n                                             fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      (if next-groups\n                        #_\"not the inner-most loop\"\n                        `(fn ~giter [~gxs]\n                           (lazy-seq\n                             (loop [~gxs ~gxs]\n                               (when-first [~bind ~gxs]\n                                 ~(do-mod mod-pairs)))))\n                        #_\"inner-most loop\"\n                        (let [gi (gensym \"i__\")\n                              gb (gensym \"b__\")\n                              do-cmod (fn do-cmod [[[k v :as pair] & etc]]\n                                        (cond\n                                          (= k :let) `(let ~v ~(do-cmod etc))\n                                          (= k :while) `(when ~v ~(do-cmod etc))\n                                          (= k :when) `(if ~v\n                                                         ~(do-cmod etc)\n                                                         (recur\n                                                           (unchecked-inc ~gi)))\n                                          (keyword? k)\n                                            (err \"Invalid 'for' keyword \" k)\n                                          :else\n                                            `(do (chunk-append ~gb ~body-expr)\n                                                 (recur (unchecked-inc ~gi)))))]\n                          `(fn ~giter [~gxs]\n                             (lazy-seq\n                               (loop [~gxs ~gxs]\n                                 (when-let [~gxs (seq ~gxs)]\n                                   (if (chunked-seq? ~gxs)\n                                     (let [c# (chunk-first ~gxs)\n                                           size# (int (count c#))\n                                           ~gb (chunk-buffer size#)]\n                                       (if (loop [~gi (int 0)]\n                                             (if (< ~gi size#)\n                                               (let [~bind (.nth c# ~gi)]\n                                                 ~(do-cmod mod-pairs))\n                                               true))\n                                         (chunk-cons\n                                           (chunk ~gb)\n                                           (~giter (chunk-rest ~gxs)))\n                                         (chunk-cons (chunk ~gb) nil)))\n                                     (let [~bind (first ~gxs)]\n                                       ~(do-mod mod-pairs)))))))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n        (iter# ~(second seq-exprs)))))",
                                                              :filename "clojure/src/clj/clojure/core.clj",
                                                              :lines [4074
                                                                      4159],
                                                              :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L4074-L4159"}),
                                          :history [["+" "0.0-927"]],
                                          :type "macro",
                                          :full-name-encode "cljs.core_for",
                                          :source {:code "(defmacro for\n  [seq-exprs body-expr]\n  (assert-args for\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [to-groups (fn [seq-exprs]\n                    (reduce (fn [groups [k v]]\n                              (if (keyword? k)\n                                (conj (pop groups) (conj (peek groups) [k v]))\n                                (conj groups [k v])))\n                            [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (apply str msg)))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (cond\n                                     (= k :let) `(let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(let [iterys# ~(emit-bind next-groups)\n                                             fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      `(fn ~giter [~gxs]\n                         (lazy-seq\n                           (loop [~gxs ~gxs]\n                             (when-first [~bind ~gxs]\n                               ~(do-mod mod-pairs)))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n       (iter# ~(second seq-exprs)))))",
                                                   :filename "clojurescript/src/clj/cljs/core.clj",
                                                   :lines [522 569],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L522-L569"},
                                          :full-name "cljs.core/for",
                                          :clj-symbol "clojure.core/for",
                                          :docstring "List comprehension. Takes a vector of one or more\n binding-form/collection-expr pairs, each followed by zero or more\n modifiers, and yields a lazy sequence of evaluations of expr.\n Collections are iterated in a nested fashion, rightmost fastest,\n and nested coll-exprs can refer to bindings created in prior\n binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n :while test, :when test.\n\n(take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))"},
                         "cljs.core/instance?" {:full-name "cljs.core/instance?",
                                                :ns "cljs.core",
                                                :name "instance?",
                                                :type "function",
                                                :signature ["[t o]"],
                                                :source {:code "(defn instance? [t o]\n  (js* \"(~{o} != null && (~{o} instanceof ~{t} || ~{o}.constructor === ~{t} || ~{t} === Object))\"))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [615
                                                                 616],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L615-L616"},
                                                :full-name-encode "cljs.core_instance_QMARK_",
                                                :clj-symbol "clojure.core/instance?",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.reader/read-comment" {:full-name "cljs.reader/read-comment",
                                                     :ns "cljs.reader",
                                                     :name "read-comment",
                                                     :type "var",
                                                     :source {:code "(def read-comment skip-line)",
                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                              :lines [207
                                                                      207],
                                                              :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L207-L207"},
                                                     :full-name-encode "cljs.reader_read-comment",
                                                     :history [["+"
                                                                "0.0-927"]]},
                         "cljs.reader/read-number" {:full-name "cljs.reader/read-number",
                                                    :ns "cljs.reader",
                                                    :name "read-number",
                                                    :type "function",
                                                    :signature ["[reader initch]"],
                                                    :source {:code "(defn read-number\n  [reader initch]\n  (loop [buffer (gstring/StringBuffer. initch)\n         ch (read-char reader)]\n    (if (or (nil? ch) (whitespace? ch) (contains? macros ch))\n      (do\n        (unread reader ch)\n        (let [s (. buffer (toString))]\n          (or (match-number s)\n              (reader-error reader \"Invalid number format [\" s \"]\"))))\n      (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [220
                                                                     230],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L220-L230"},
                                                    :full-name-encode "cljs.reader_read-number",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "cljs.core/ILookup" {:ns "cljs.core",
                                              :name "ILookup",
                                              :type "protocol",
                                              :full-name-encode "cljs.core_ILookup",
                                              :source {:code "(defprotocol ILookup\n  (-lookup [o k] [o k not-found]))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [112
                                                               113],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L112-L113"},
                                              :methods [{:name "-lookup",
                                                         :signature ["[o k]"
                                                                     "[o k not-found]"],
                                                         :docstring nil}],
                                              :full-name "cljs.core/ILookup",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/when" {:ns "cljs.core",
                                           :name "when",
                                           :signature ["[test & body]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_when",
                                           :source {:code "(defmacro when\n  [test & body]\n  (list 'if test (cons 'do body)))",
                                                    :filename "clojure/src/clj/clojure/core.clj",
                                                    :lines [454 458],
                                                    :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L454-L458"},
                                           :full-name "cljs.core/when",
                                           :clj-symbol "clojure.core/when",
                                           :docstring "Evaluates test. If logical true, evaluates body in an implicit do."},
                         "clojure.browser.dom/set-value" {:full-name "clojure.browser.dom/set-value",
                                                          :ns "clojure.browser.dom",
                                                          :name "set-value",
                                                          :docstring "Set the value property for an element.",
                                                          :type "function",
                                                          :signature ["[e v]"],
                                                          :source {:code "(defn set-value\n  [e v]\n  (set-properties e {\"value\" v}))",
                                                                   :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                   :lines [140
                                                                           143],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/dom.cljs#L140-L143"},
                                                          :full-name-encode "clojure.browser.dom_set-value",
                                                          :history [["+"
                                                                     "0.0-927"]]},
                         "cljs.reader/read-past" {:full-name "cljs.reader/read-past",
                                                  :ns "cljs.reader",
                                                  :name "read-past",
                                                  :docstring "Read until first character that doesn't match pred, returning\nchar.",
                                                  :type "function",
                                                  :signature ["[pred rdr]"],
                                                  :source {:code "(defn read-past\n  [pred rdr]\n  (loop [ch (read-char rdr)]\n    (if (pred ch)\n      (recur (read-char rdr))\n      ch)))",
                                                           :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                           :lines [159
                                                                   166],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L159-L166"},
                                                  :full-name-encode "cljs.reader_read-past",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/to-array" {:ns "cljs.core",
                                               :name "to-array",
                                               :signature ["[s]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_to-array",
                                               :source {:code "(defn to-array\n  [s]\n  (let [ary (array)]\n    (loop [s s]\n      (if (seq s)\n        (do (. ary push (first s))\n            (recur (next s)))\n        ary))))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [1279
                                                                1287],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1279-L1287"},
                                               :full-name "cljs.core/to-array",
                                               :clj-symbol "clojure.core/to-array",
                                               :docstring "Naive impl of to-array as a start."},
                         "cljs.core/interpose" {:ns "cljs.core",
                                                :name "interpose",
                                                :signature ["[sep coll]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_interpose",
                                                :source {:code "(defn interpose\n  [sep coll] (drop 1 (interleave (repeat sep) coll)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1759
                                                                 1761],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1759-L1761"},
                                                :full-name "cljs.core/interpose",
                                                :clj-symbol "clojure.core/interpose",
                                                :docstring "Returns a lazy seq of the elements of coll separated by sep"},
                         "clojure.browser.net/ICrossPageChannel" {:ns "clojure.browser.net",
                                                                  :name "ICrossPageChannel",
                                                                  :type "protocol",
                                                                  :full-name-encode "clojure.browser.net_ICrossPageChannel",
                                                                  :source {:code "(defprotocol ICrossPageChannel\n  (register-service [this service-name fn] [this service-name fn encode-json?]))",
                                                                           :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                           :lines [88
                                                                                   89],
                                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/net.cljs#L88-L89"},
                                                                  :methods [{:name "register-service",
                                                                             :signature ["[this service-name fn]"
                                                                                         "[this service-name fn encode-json?]"],
                                                                             :docstring nil}],
                                                                  :full-name "clojure.browser.net/ICrossPageChannel",
                                                                  :history [["+"
                                                                             "0.0-927"]]},
                         "special/finally" {:ns "special",
                                            :name "finally",
                                            :signature ["[expr*]"],
                                            :history [["+" "0.0-927"]],
                                            :type "special form",
                                            :full-name-encode "special_finally",
                                            :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (list? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                     :lines [470 498],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L470-L498"},
                                            :full-name "special/finally",
                                            :clj-symbol "clojure.core/finally",
                                            :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions."},
                         "cljs.core/Cons" {:full-name "cljs.core/Cons",
                                           :ns "cljs.core",
                                           :name "Cons",
                                           :type "type",
                                           :signature ["[meta first rest]"],
                                           :source {:code "(deftype Cons [meta first rest]\n  IWithMeta\n  (-with-meta [coll meta] (Cons. meta first rest))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] first)\n  (-rest [coll] (if (nil? rest) () rest))\n\n  ICollection\n  (-conj [coll o] (Cons. nil o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] coll))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1157 1182],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1157-L1182"},
                                           :full-name-encode "cljs.core_Cons",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/re-find" {:ns "cljs.core",
                                              :name "re-find",
                                              :signature ["[re s]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_re-find",
                                              :source {:code "(defn re-find\n  [re s]\n  (let [matches (.exec re s)]\n    (when-not (nil? matches)\n      (if (= (count matches) 1)\n        (first matches)\n        (vec matches)))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2773
                                                               2783],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2773-L2783"},
                                              :full-name "cljs.core/re-find",
                                              :clj-symbol "clojure.core/re-find",
                                              :docstring "Returns the first regex match, if any, of s to re, using\nre.exec(s). Returns a vector, containing first the matching\nsubstring, then any capturing groups if the regular expression contains\ncapturing groups."},
                         "cljs.core/IMeta" {:ns "cljs.core",
                                            :name "IMeta",
                                            :type "protocol",
                                            :full-name-encode "cljs.core_IMeta",
                                            :source {:code "(defprotocol IMeta\n  (-meta [o]))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [140 141],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L140-L141"},
                                            :methods [{:name "-meta",
                                                       :signature ["[o]"],
                                                       :docstring nil}],
                                            :full-name "cljs.core/IMeta",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/assoc-in" {:ns "cljs.core",
                                               :name "assoc-in",
                                               :signature ["[m [k & ks] v]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_assoc-in",
                                               :source {:code "(defn assoc-in\n  [m [k & ks] v]\n  (if ks\n    (assoc m k (assoc-in (get m k) ks v))\n    (assoc m k v)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [1872
                                                                1879],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1872-L1879"},
                                               :full-name "cljs.core/assoc-in",
                                               :clj-symbol "clojure.core/assoc-in",
                                               :docstring "Associates a value in a nested associative structure, where ks is a\nsequence of keys and v is the new value and returns a new nested structure.\nIf any levels do not exist, hash-maps will be created."},
                         "clojure.string/join" {:ns "clojure.string",
                                                :name "join",
                                                :signature ["[coll]"
                                                            "[separator coll]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.string_join",
                                                :source {:code "(defn join\n  ([coll]\n     (apply str coll))\n  ([separator coll]\n     (apply str (interpose separator coll))))",
                                                         :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                         :lines [45
                                                                 51],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/string.cljs#L45-L51"},
                                                :full-name "clojure.string/join",
                                                :clj-symbol "clojure.string/join",
                                                :docstring "Returns a string of all elements in coll, as returned by (seq coll),\nseparated by an optional separator."},
                         "clojure.zip/rights" {:ns "clojure.zip",
                                               :name "rights",
                                               :signature ["[loc]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.zip_rights",
                                               :source {:code "(defn rights\n  [loc]\n    (:r (loc 1)))",
                                                        :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                        :lines [92 95],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L92-L95"},
                                               :full-name "clojure.zip/rights",
                                               :clj-symbol "clojure.zip/rights",
                                               :docstring "Returns a seq of the right siblings of this loc"},
                         "cljs.core/split-at" {:ns "cljs.core",
                                               :name "split-at",
                                               :signature ["[n coll]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_split-at",
                                               :source {:code "(defn split-at\n  [n coll]\n  [(take n coll) (drop n coll)])",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [1719
                                                                1722],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1719-L1722"},
                                               :full-name "cljs.core/split-at",
                                               :clj-symbol "clojure.core/split-at",
                                               :docstring "Returns a vector of [(take n coll) (drop n coll)]"},
                         "clojure.zip/append-child" {:ns "clojure.zip",
                                                     :name "append-child",
                                                     :signature ["[loc item]"],
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "clojure.zip_append-child",
                                                     :source {:code "(defn append-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (concat (children loc) [item]))))",
                                                              :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                              :lines [200
                                                                      204],
                                                              :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L200-L204"},
                                                     :full-name "clojure.zip/append-child",
                                                     :clj-symbol "clojure.zip/append-child",
                                                     :docstring "Inserts the item as the rightmost child of the node at this loc,\nwithout moving"},
                         "cljs.core/binding" {:ns "cljs.core",
                                              :name "binding",
                                              :signature ["[bindings & body]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "macro",
                                              :full-name-encode "cljs.core_binding",
                                              :source {:code "(defmacro binding\n  [bindings & body]\n  (let [names (take-nth 2 bindings)\n        vals (take-nth 2 (drop 1 bindings))\n        tempnames (map (comp gensym name) names)\n        binds (map vector names vals)\n        resets (reverse (map vector names tempnames))]\n    `(let [~@(interleave tempnames names)]\n       (try\n        ~@(map\n           (fn [[k v]] (list 'set! k v))\n           binds)\n        ~@body\n        (finally\n         ~@(map\n            (fn [[k v]] (list 'set! k v))\n            resets))))))",
                                                       :filename "clojurescript/src/clj/cljs/core.clj",
                                                       :lines [403
                                                               426],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L403-L426"},
                                              :full-name "cljs.core/binding",
                                              :clj-symbol "clojure.core/binding",
                                              :docstring "binding => var-symbol init-expr\n\nCreates new bindings for the (already-existing) vars, with the\nsupplied initial values, executes the exprs in an implicit do, then\nre-establishes the bindings that existed before.  The new bindings\nare made in parallel (unlike let); all init-exprs are evaluated\nbefore the vars are bound to their new values."},
                         "cljs.core/Set" {:full-name "cljs.core/Set",
                                          :ns "cljs.core",
                                          :name "Set",
                                          :type "type",
                                          :signature ["[meta hash-map]"],
                                          :source {:code "(deftype Set [meta hash-map]\n  IWithMeta\n  (-with-meta [coll meta] (Set. meta hash-map))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (Set. meta (assoc hash-map o nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Set/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (= (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (count (seq coll)))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if (-contains-key? hash-map v)\n      v\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (Set. meta (dissoc hash-map v))))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [2426 2467],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2426-L2467"},
                                          :full-name-encode "cljs.core_Set",
                                          :history [["+" "0.0-927"]]},
                         "cljs.reader/macro-terminating?" {:full-name "cljs.reader/macro-terminating?",
                                                           :ns "cljs.reader",
                                                           :name "macro-terminating?",
                                                           :type "function",
                                                           :signature ["[ch]"],
                                                           :source {:code "(defn macro-terminating? [ch]\n  (and (not= ch \"#\") (not= ch \\') (not= ch \":\") (contains? macros ch)))",
                                                                    :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                    :lines [73
                                                                            74],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L73-L74"},
                                                           :full-name-encode "cljs.reader_macro-terminating_QMARK_",
                                                           :history [["+"
                                                                      "0.0-927"]]},
                         "cljs.core/prefers" {:ns "cljs.core",
                                              :name "prefers",
                                              :signature ["[multifn]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_prefers",
                                              :source {:code "(defn prefers\n  [multifn] (-prefers multifn))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [3503
                                                               3505],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3503-L3505"},
                                              :full-name "cljs.core/prefers",
                                              :clj-symbol "clojure.core/prefers",
                                              :docstring "Given a multimethod, returns a map of preferred value -> set of other values"},
                         "cljs.core/vary-meta" {:ns "cljs.core",
                                                :name "vary-meta",
                                                :signature ["[obj f & args]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_vary-meta",
                                                :source {:code "(defn vary-meta\n [obj f & args]\n (with-meta obj (apply f (meta obj) args)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1386
                                                                 1390],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1386-L1390"},
                                                :full-name "cljs.core/vary-meta",
                                                :clj-symbol "clojure.core/vary-meta",
                                                :docstring "Returns an object of the same type and value as obj, with\n(apply f (meta obj) args) as its metadata."},
                         "cljs.core/when-let" {:ns "cljs.core",
                                               :name "when-let",
                                               :signature ["[bindings & body]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "macro",
                                               :full-name-encode "cljs.core_when-let",
                                               :source {:code "(defmacro when-let\n  [bindings & body]\n  (assert-args when-let\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n    `(let [temp# ~tst]\n       (when temp#\n         (let [~form temp#]\n           ~@body)))))",
                                                        :filename "clojure/src/clj/clojure/core.clj",
                                                        :lines [1685
                                                                1698],
                                                        :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L1685-L1698"},
                                               :full-name "cljs.core/when-let",
                                               :clj-symbol "clojure.core/when-let",
                                               :docstring "bindings => binding-form test\n\nWhen test is true, evaluates body with binding-form bound to the value of test"},
                         "cljs.core/drop" {:ns "cljs.core",
                                           :name "drop",
                                           :signature ["[n coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_drop",
                                           :source {:code "(defn drop\n  [n coll]\n  (let [step (fn [n coll]\n               (let [s (seq coll)]\n                 (if (and (pos? n) s)\n                   (recur (dec n) (rest s))\n                   s)))]\n    (lazy-seq (step n coll))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1678 1686],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1678-L1686"},
                                           :full-name "cljs.core/drop",
                                           :clj-symbol "clojure.core/drop",
                                           :docstring "Returns a lazy sequence of all but the first n items in coll."},
                         "cljs.core/while" {:ns "cljs.core",
                                            :name "while",
                                            :signature ["[test & body]"],
                                            :history [["+" "0.0-927"]],
                                            :type "macro",
                                            :full-name-encode "cljs.core_while",
                                            :source {:code "(defmacro while\n  [test & body]\n  `(loop []\n     (when ~test\n       ~@body\n       (recur))))",
                                                     :filename "clojure/src/clj/clojure/core.clj",
                                                     :lines [5569
                                                             5577],
                                                     :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L5569-L5577"},
                                            :full-name "cljs.core/while",
                                            :clj-symbol "clojure.core/while",
                                            :docstring "Repeatedly executes body while test expression is true. Presumes\nsome side-effect will cause test to become false/nil. Returns nil"},
                         "cljs.core/import-macros" {:full-name "cljs.core/import-macros",
                                                    :ns "cljs.core",
                                                    :name "import-macros",
                                                    :type "macro",
                                                    :signature ["[ns [& vars]]"],
                                                    :source {:code "(defmacro import-macros [ns [& vars]]\n  (core/let [ns (find-ns ns)\n             vars (map #(ns-resolve ns %) vars)\n             syms (map (core/fn [^clojure.lang.Var v] (core/-> v .sym (with-meta {:macro true}))) vars)\n             defs (map (core/fn [sym var]\n                                `(def ~sym (deref ~var))) syms vars)]\n            `(do ~@defs\n                 :imported)))",
                                                             :filename "clojurescript/src/clj/cljs/core.clj",
                                                             :lines [27
                                                                     34],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L27-L34"},
                                                    :full-name-encode "cljs.core_import-macros",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "cljs.core/string-print" {:full-name "cljs.core/string-print",
                                                   :ns "cljs.core",
                                                   :name "string-print",
                                                   :type "function",
                                                   :signature ["[x]"],
                                                   :source {:code "(defn string-print [x]\n  (*print-fn* x)\n  nil)",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [2807
                                                                    2809],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2807-L2809"},
                                                   :full-name-encode "cljs.core_string-print",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "cljs.core/-" {:ns "cljs.core",
                                        :name "-",
                                        :signature ["[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :shadowed-sources ({:code "(defmacro -\n  ([] 0)\n  ([x] (list 'js* \"(- ~{})\" x))\n  ([x y] (list 'js* \"(~{} - ~{})\" x y))\n  ([x y & more] `(- (- ~x ~y) ~@more)))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [60
                                                                    64],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L60-L64"}),
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core_-",
                                        :source {:code "(defn -\n  ([x] (js* \"(- ~{x})\"))\n  ([x y] (js* \"(~{x} - ~{y})\"))\n  ([x y & more] (reduce - (- x y) more)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [780 785],
                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L780-L785"},
                                        :full-name "cljs.core/-",
                                        :clj-symbol "clojure.core/-",
                                        :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
                         "clojure.zip/vector-zip" {:ns "clojure.zip",
                                                   :name "vector-zip",
                                                   :signature ["[root]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.zip_vector-zip",
                                                   :source {:code "(defn vector-zip\n  [root]\n    (zipper vector?\n            seq\n            (fn [node children] (with-meta (vec children) (meta node)))\n            root))",
                                                            :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                            :lines [42
                                                                    48],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L42-L48"},
                                                   :full-name "clojure.zip/vector-zip",
                                                   :clj-symbol "clojure.zip/vector-zip",
                                                   :docstring "Returns a zipper for nested vectors, given a root vector"},
                         "cljs.core/js->clj" {:full-name "cljs.core/js->clj",
                                              :ns "cljs.core",
                                              :name "js->clj",
                                              :docstring "Recursively transforms JavaScript arrays into ClojureScript\nvectors, and JavaScript objects into ClojureScript maps.  With\noption ':keywordize-keys true' will convert object fields from\nstrings to keywords.",
                                              :type "function",
                                              :signature ["[x & options]"],
                                              :source {:code "(defn js->clj\n  [x & options]\n  (let [{:keys [keywordize-keys]} options\n        keyfn (if keywordize-keys keyword str)\n        f (fn thisfn [x]\n            (cond\n             (seq? x) (doall (map thisfn x))\n             (coll? x) (into (empty x) (map thisfn x))\n             (goog.isArray x) (vec (map thisfn x))\n             (goog.isObject x) (into {} (for [k (js-keys x)]\n                                          [(keyfn k)\n                                           (thisfn (aget x k))]))\n             :else x))]\n    (f x)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [3171
                                                               3188],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3171-L3188"},
                                              :full-name-encode "cljs.core_js-_GT_clj",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/List" {:full-name "cljs.core/List",
                                           :ns "cljs.core",
                                           :name "List",
                                           :type "type",
                                           :signature ["[meta first rest count]"],
                                           :source {:code "(deftype List [meta first rest count]\n  IWithMeta\n  (-with-meta [coll meta] (List. meta first rest count))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] first)\n  (-rest [coll] rest)\n\n  IStack\n  (-peek [coll] first)\n  (-pop [coll] (-rest coll))\n\n  ICollection\n  (-conj [coll o] (List. meta o coll (inc count)))\n\n  IEmptyableCollection\n  (-empty [coll] cljs.core.List/EMPTY)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ICounted\n  (-count [coll] count))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1079 1111],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1079-L1111"},
                                           :full-name-encode "cljs.core_List",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/identical?" {:ns "cljs.core",
                                                 :name "identical?",
                                                 :signature ["[x y]"],
                                                 :shadowed-sources ({:code "(defmacro identical? [a b]\n  (list 'js* \"(~{} === ~{})\" a b))",
                                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                                     :lines [45
                                                                             46],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L45-L46"}),
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_identical_QMARK_",
                                                 :source {:code "(defn identical? [x y]\n  \"Tests if 2 arguments are the same object\"\n  (js* \"(~{x} === ~{y})\"))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [176
                                                                  178],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L176-L178"},
                                                 :full-name "cljs.core/identical?",
                                                 :clj-symbol "clojure.core/identical?"},
                         "cljs.core/*main-cli-fn*" {:full-name "cljs.core/*main-cli-fn*",
                                                    :ns "cljs.core",
                                                    :name "*main-cli-fn*",
                                                    :docstring "When compiled for a command-line target, whatever\nfunction *main-fn* is set to will be called with the command-line\nargv as arguments",
                                                    :type "var",
                                                    :source {:code "(def\n  ^{:doc \"When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments\"}\n  *main-cli-fn* nil)",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [52
                                                                     56],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L52-L56"},
                                                    :full-name-encode "cljs.core__STAR_main-cli-fn_STAR_",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "clojure.browser.dom/html->dom" {:full-name "clojure.browser.dom/html->dom",
                                                          :ns "clojure.browser.dom",
                                                          :name "html->dom",
                                                          :type "function",
                                                          :signature ["[s]"],
                                                          :source {:code "(defn html->dom [s]\n  (gdom/htmlToDocumentFragment s))",
                                                                   :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                   :lines [99
                                                                           100],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/dom.cljs#L99-L100"},
                                                          :full-name-encode "clojure.browser.dom_html-_GT_dom",
                                                          :history [["+"
                                                                     "0.0-927"]]},
                         "cljs.core/some" {:ns "cljs.core",
                                           :name "some",
                                           :signature ["[pred coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_some",
                                           :source {:code "(defn some\n  [pred coll]\n    (when (seq coll)\n      (or (pred (first coll)) (recur pred (next coll)))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1417 1424],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1417-L1424"},
                                           :full-name "cljs.core/some",
                                           :clj-symbol "clojure.core/some",
                                           :docstring "Returns the first logical true value of (pred x) for any x in coll,\nelse nil.  One common idiom is to use a set as pred, for example\nthis will return :fred if :fred is in the sequence, otherwise nil:\n(some #{:fred} coll)"},
                         "cljs.core/doall" {:ns "cljs.core",
                                            :name "doall",
                                            :signature ["[coll]"
                                                        "[n coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_doall",
                                            :source {:code "(defn doall\n  ([coll]\n   (dorun coll)\n   coll)\n  ([n coll]\n   (dorun n coll)\n   coll))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2748
                                                             2760],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2748-L2760"},
                                            :full-name "cljs.core/doall",
                                            :clj-symbol "clojure.core/doall",
                                            :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. doall can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, retains the head and returns it, thus causing the entire\nseq to reside in memory at one time."},
                         "cljs.core/condp" {:ns "cljs.core",
                                            :name "condp",
                                            :signature ["[pred expr & clauses]"],
                                            :history [["+" "0.0-927"]],
                                            :type "macro",
                                            :full-name-encode "cljs.core_condp",
                                            :source {:code "(defmacro condp\n  [pred expr & clauses]\n  (let [gpred (gensym \"pred__\")\n        gexpr (gensym \"expr__\")\n        emit (fn emit [pred expr args]\n               (let [[[a b c :as clause] more]\n                       (split-at (if (= :>> (second args)) 3 2) args)\n                       n (count clause)]\n                 (cond\n                  (= 0 n) `(throw (js/Error. (str \"No matching clause: \" ~expr)))\n                  (= 1 n) a\n                  (= 2 n) `(if (~pred ~a ~expr)\n                             ~b\n                             ~(emit pred expr more))\n                  :else `(if-let [p# (~pred ~a ~expr)]\n                           (~c p#)\n                           ~(emit pred expr more)))))\n        gres (gensym \"res__\")]\n    `(let [~gpred ~pred\n           ~gexpr ~expr]\n       ~(emit gpred gexpr clauses))))",
                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                     :lines [428 468],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L428-L468"},
                                            :full-name "cljs.core/condp",
                                            :clj-symbol "clojure.core/condp",
                                            :docstring "Takes a binary predicate, an expression, and a set of clauses.\nEach clause can take the form of either:\n\ntest-expr result-expr\n\ntest-expr :>> result-fn\n\nNote :>> is an ordinary keyword.\n\nFor each clause, (pred test-expr expr) is evaluated. If it returns\nlogical true, the clause is a match. If a binary clause matches, the\nresult-expr is returned, if a ternary clause matches, its result-fn,\nwhich must be a unary function, is called with the result of the\npredicate as its argument, the result of that call being the return\nvalue of condp. A single default expression can follow the clauses,\nand its value will be returned if no clause matches. If no default\nexpression is provided and no clause matches, an\nIllegalArgumentException is thrown."},
                         "clojure.zip/down" {:ns "clojure.zip",
                                             :name "down",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_down",
                                             :source {:code "(defn down\n  [loc]\n    (when (branch? loc)\n      (let [[node path] loc\n            [c & cnext :as cs] (children loc)]\n        (when cs\n          (with-meta [c {:l [] \n                         :pnodes (if path (conj (:pnodes path) node) [node]) \n                         :ppath path \n                         :r cnext}] (meta loc))))))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [98 109],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L98-L109"},
                                             :full-name "clojure.zip/down",
                                             :clj-symbol "clojure.zip/down",
                                             :docstring "Returns the loc of the leftmost child of the node at this loc, or\nnil if no children"},
                         "cljs.core/IPending" {:ns "cljs.core",
                                               :name "IPending",
                                               :type "protocol",
                                               :full-name-encode "cljs.core_IPending",
                                               :source {:code "(defprotocol IPending\n  (-realized? [d]))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [167
                                                                168],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L167-L168"},
                                               :methods [{:name "-realized?",
                                                          :signature ["[d]"],
                                                          :docstring nil}],
                                               :full-name "cljs.core/IPending",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/count" {:ns "cljs.core",
                                            :name "count",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_count",
                                            :source {:code "(defn count\n  [coll]\n  (-count coll))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [458 462],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L458-L462"},
                                            :full-name "cljs.core/count",
                                            :clj-symbol "clojure.core/count",
                                            :docstring "Returns the number of items in the collection. (count nil) returns\n0.  Also works on strings, arrays, and Maps"},
                         "cljs.core/bit-test" {:ns "cljs.core",
                                               :name "bit-test",
                                               :signature ["[x n]"],
                                               :shadowed-sources ({:code "(defmacro bit-test [x n]\n  (list 'js* \"((~{} & (1 << ~{})) != 0)\" x n))",
                                                                   :filename "clojurescript/src/clj/cljs/core.clj",
                                                                   :lines [156
                                                                           157],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L156-L157"}),
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_bit-test",
                                               :source {:code "(defn bit-test\n  [x n]\n  (js* \"((~{x} & (1 << ~{n})) != 0)\"))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [933
                                                                936],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L933-L936"},
                                               :full-name "cljs.core/bit-test",
                                               :clj-symbol "clojure.core/bit-test",
                                               :docstring "Test bit at index n"},
                         "cljs.core/fixture2" {:full-name "cljs.core/fixture2",
                                               :ns "cljs.core",
                                               :name "fixture2",
                                               :type "var",
                                               :source {:code "(def fixture2 2)",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [3131
                                                                3131],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3131-L3131"},
                                               :full-name-encode "cljs.core_fixture2",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/loop" {:ns "cljs.core",
                                           :name "loop",
                                           :signature ["[bindings & body]"],
                                           :shadowed-sources ({:code "(def\n ^{:macro true\n   :added \"1.0\"}\n loop (fn* loop [&form &env & decl] (cons 'loop* decl)))",
                                                               :filename "clojure/src/clj/clojure/core.clj",
                                                               :lines [37
                                                                       40],
                                                               :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L37-L40"}),
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_loop",
                                           :source {:code "(defmacro loop\n  [bindings & body]\n    (assert-args loop\n      (vector? bindings) \"a vector for its binding\"\n      (even? (count bindings)) \"an even number of forms in binding vector\")\n    (let [db (destructure bindings)]\n      (if (= db bindings)\n        `(loop* ~bindings ~@body)\n        (let [vs (take-nth 2 (drop 1 bindings))\n              bs (take-nth 2 bindings)\n              gs (map (fn [b] (if (symbol? b) b (gensym))) bs)\n              bfs (reduce1 (fn [ret [b v g]]\n                            (if (symbol? b)\n                              (conj ret g v)\n                              (conj ret g v b g)))\n                          [] (map vector bs vs gs))]\n          `(let ~bfs\n             (loop* ~(vec (interleave gs gs))\n               (let ~(vec (interleave bs gs))\n                 ~@body)))))))",
                                                    :filename "clojure/src/clj/clojure/core.clj",
                                                    :lines [4025 4048],
                                                    :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L4025-L4048"},
                                           :full-name "cljs.core/loop",
                                           :clj-symbol "clojure.core/loop",
                                           :docstring "Evaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein. Acts as a recur target."},
                         "cljs.core/subvec" {:ns "cljs.core",
                                             :name "subvec",
                                             :signature ["[v start]"
                                                         "[v start end]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_subvec",
                                             :source {:code "(defn subvec\n  ([v start]\n     (subvec v start (count v)))\n  ([v start end]\n     (Subvec. nil v start end)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2052
                                                              2061],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2052-L2061"},
                                             :full-name "cljs.core/subvec",
                                             :clj-symbol "clojure.core/subvec",
                                             :docstring "Returns a persistent vector of the items in vector from\nstart (inclusive) to end (exclusive).  If end is not supplied,\ndefaults to (count vector). This operation is O(1) and very fast, as\nthe resulting vector shares structure with the original and no\ntrimming is done."},
                         "cljs.core/bit-clear" {:ns "cljs.core",
                                                :name "bit-clear",
                                                :signature ["[x n]"],
                                                :shadowed-sources ({:code "(defmacro bit-clear [x n]\n  (list 'js* \"(~{} & ~(1 << ~{}))\" x n))",
                                                                    :filename "clojurescript/src/clj/cljs/core.clj",
                                                                    :lines [150
                                                                            151],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L150-L151"}),
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_bit-clear",
                                                :source {:code "(defn bit-clear\n  [x n]\n  (js* \"(~{x} & ~(1 << ~{n}))\"))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [914
                                                                 917],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L914-L917"},
                                                :full-name "cljs.core/bit-clear",
                                                :clj-symbol "clojure.core/bit-clear",
                                                :docstring "Clear bit at index n"},
                         "cljs.core/gensym" {:ns "cljs.core",
                                             :name "gensym",
                                             :signature ["[]"
                                                         "[prefix-string]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_gensym",
                                             :source {:code "(defn gensym\n  ([] (gensym \"G__\"))\n  ([prefix-string]\n     (when (nil? gensym_counter)\n       (set! gensym_counter (atom 0)))\n     (symbol (str prefix-string (swap! gensym_counter inc)))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [3118
                                                              3126],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3118-L3126"},
                                             :full-name "cljs.core/gensym",
                                             :clj-symbol "clojure.core/gensym",
                                             :docstring "Returns a new symbol with a unique name. If a prefix string is\nsupplied, the name is prefix# where # is some unique number. If\nprefix is not supplied, the prefix is 'G__'."},
                         "special/recur" {:full-name "special/recur",
                                          :ns "special",
                                          :name "recur",
                                          :type "special form",
                                          :source {:code "(defmethod parse 'recur\n  [op env [_ & exprs] _]\n  (let [context (:context env)\n        frame (first *recur-frames*)]\n    (assert frame \"Can't recur here\")\n    (assert (= (count exprs) (count (:names frame))) \"recur argument count mismatch\")\n    (reset! (:flag frame) true)\n    (assoc {:env env :op :recur}\n      :frame frame\n      :exprs (disallowing-recur (vec (map #(analyze (assoc env :context :expr) %) exprs))))))",
                                                   :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                   :lines [758 767],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/compiler.clj#L758-L767"},
                                          :full-name-encode "special_recur",
                                          :clj-symbol "clojure.core/recur",
                                          :history [["+" "0.0-927"]]},
                         "cljs.core/+" {:ns "cljs.core",
                                        :name "+",
                                        :signature ["[]"
                                                    "[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :shadowed-sources ({:code "(defmacro +\n  ([] 0)\n  ([x] x)\n  ([x y] (list 'js* \"(~{} + ~{})\" x y))\n  ([x y & more] `(+ (+ ~x ~y) ~@more)))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [54
                                                                    58],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L54-L58"}),
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core__PLUS_",
                                        :source {:code "(defn +\n  ([] 0)\n  ([x] x)\n  ([x y] (js* \"(~{x} + ~{y})\"))\n  ([x y & more] (reduce + (+ x y) more)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [773 778],
                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L773-L778"},
                                        :full-name "cljs.core/+",
                                        :clj-symbol "clojure.core/+",
                                        :docstring "Returns the sum of nums. (+) returns 0."},
                         "cljs.core/comp" {:ns "cljs.core",
                                           :name "comp",
                                           :signature ["[]"
                                                       "[f]"
                                                       "[f g]"
                                                       "[f g h]"
                                                       "[f1 f2 f3 & fs]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_comp",
                                           :source {:code "(defn comp\n  ([] identity)\n  ([f] f)\n  ([f g] \n     (fn \n       ([] (f (g)))\n       ([x] (f (g x)))\n       ([x y] (f (g x y)))\n       ([x y z] (f (g x y z)))\n       ([x y z & args] (f (apply g x y z args)))))\n  ([f g h] \n     (fn \n       ([] (f (g (h))))\n       ([x] (f (g (h x))))\n       ([x y] (f (g (h x y))))\n       ([x y z] (f (g (h x y z))))\n       ([x y z & args] (f (g (apply h x y z args))))))\n  ([f1 f2 f3 & fs]\n    (let [fs (reverse (list* f1 f2 f3 fs))]\n      (fn [& args]\n        (loop [ret (apply (first fs) args) fs (next fs)]\n          (if fs\n            (recur ((first fs) ret) (next fs))\n            ret))))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1457 1484],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1457-L1484"},
                                           :full-name "cljs.core/comp",
                                           :clj-symbol "clojure.core/comp",
                                           :docstring "Takes a set of functions and returns a fn that is the composition\nof those fns.  The returned fn takes a variable number of args,\napplies the rightmost of fns to the args, the next\nfn (right-to-left) to the result, etc."},
                         "cljs.reader/desugar-meta" {:full-name "cljs.reader/desugar-meta",
                                                     :ns "cljs.reader",
                                                     :name "desugar-meta",
                                                     :type "function",
                                                     :signature ["[f]"],
                                                     :source {:code "(defn desugar-meta\n  [f]\n  (cond\n   (symbol? f) {:tag f}\n   (string? f) {:tag f}\n   (keyword? f) {f true}\n   :else f))",
                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                              :lines [269
                                                                      275],
                                                              :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L269-L275"},
                                                     :full-name-encode "cljs.reader_desugar-meta",
                                                     :history [["+"
                                                                "0.0-927"]]},
                         "cljs.core/pr" {:ns "cljs.core",
                                         :name "pr",
                                         :signature ["[& objs]"],
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core_pr",
                                         :source {:code "(defn pr\n  [& objs]\n  (pr-with-opts objs (pr-opts)))",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [2872 2878],
                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2872-L2878"},
                                         :full-name "cljs.core/pr",
                                         :clj-symbol "clojure.core/pr",
                                         :docstring "Prints the object(s) using string-print.  Prints the\nobject(s), separated by spaces if there is more than one.\nBy default, pr and prn print in a way that objects can be\nread by the reader"},
                         "clojure.string/upper-case" {:ns "clojure.string",
                                                      :name "upper-case",
                                                      :signature ["[s]"],
                                                      :history [["+"
                                                                 "0.0-927"]],
                                                      :type "function",
                                                      :full-name-encode "clojure.string_upper-case",
                                                      :source {:code "(defn upper-case\n  [s]\n  (. s (toUpperCase)))",
                                                               :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                               :lines [53
                                                                       56],
                                                               :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/string.cljs#L53-L56"},
                                                      :full-name "clojure.string/upper-case",
                                                      :clj-symbol "clojure.string/upper-case",
                                                      :docstring "Converts string to all upper-case."},
                         "clojure.browser.event/expose" {:full-name "clojure.browser.event/expose",
                                                         :ns "clojure.browser.event",
                                                         :name "expose",
                                                         :type "function",
                                                         :signature ["[e]"],
                                                         :source {:code "(defn expose [e]\n  (goog.events/expose e))",
                                                                  :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                  :lines [79
                                                                          80],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/event.cljs#L79-L80"},
                                                         :full-name-encode "clojure.browser.event_expose",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "clojure.browser.event/listen-once" {:full-name "clojure.browser.event/listen-once",
                                                              :ns "clojure.browser.event",
                                                              :name "listen-once",
                                                              :type "function",
                                                              :signature ["[src type fn]"
                                                                          "[src type fn capture?]"],
                                                              :source {:code "(defn listen-once\n  ([src type fn]\n     (listen-once src type fn false))\n  ([src type fn capture?]\n     (goog.events/listenOnce src\n                             (get (event-types src) type type)\n                             fn\n                             capture?)))",
                                                                       :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                       :lines [53
                                                                               60],
                                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/event.cljs#L53-L60"},
                                                              :full-name-encode "clojure.browser.event_listen-once",
                                                              :history [["+"
                                                                         "0.0-927"]]},
                         "cljs.core/empty?" {:ns "cljs.core",
                                             :name "empty?",
                                             :signature ["[coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_empty_QMARK_",
                                             :source {:code "(defn empty?\n  [coll] (not (seq coll)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [546 549],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L546-L549"},
                                             :full-name "cljs.core/empty?",
                                             :clj-symbol "clojure.core/empty?",
                                             :docstring "Returns true if coll has no items - same as (not (seq coll)).\nPlease use the idiom (seq x) rather than (not (empty? x))"},
                         "cljs.core/newline" {:full-name "cljs.core/newline",
                                              :ns "cljs.core",
                                              :name "newline",
                                              :type "function",
                                              :signature ["[opts]"],
                                              :source {:code "(defn newline [opts]\n  (string-print \"\\n\")\n  (when (get opts :flush-on-newline)\n    (flush)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2851
                                                               2854],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2851-L2854"},
                                              :full-name-encode "cljs.core_newline",
                                              :clj-symbol "clojure.core/newline",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/replace" {:ns "cljs.core",
                                              :name "replace",
                                              :signature ["[smap coll]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_replace",
                                              :source {:code "(defn replace\n  [smap coll]\n  (if (vector? coll)\n    (let [n (count coll)]\n      (reduce (fn [v i]\n                (if-let [e (find smap (nth v i))]\n                  (assoc v i (second e))\n                  v))\n              coll (take n (iterate inc 0))))\n    (map #(if-let [e (find smap %)] (second e) %) coll)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2485
                                                               2497],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2485-L2497"},
                                              :full-name "cljs.core/replace",
                                              :clj-symbol "clojure.core/replace",
                                              :docstring "Given a map of replacement pairs and a vector/collection, returns a\nvector/seq with any elements = a key in smap replaced with the\ncorresponding val in smap"},
                         "cljs.core/rand" {:ns "cljs.core",
                                           :name "rand",
                                           :signature ["[]" "[n]"],
                                           :shadowed-sources ({:code "(defn rand\n  ([]  (Math/random))\n  ([n] (* n (rand))))",
                                                               :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                               :lines [889
                                                                       892],
                                                               :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L889-L892"}),
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_rand",
                                           :source {:code "(defn rand\n  ([] (rand 1))\n  ([n] (js* \"Math.random() * ~{n}\")))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [3220 3224],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3220-L3224"},
                                           :full-name "cljs.core/rand",
                                           :clj-symbol "clojure.core/rand",
                                           :docstring "Returns a random floating point number between 0 (inclusive) and\nn (default 1) (exclusive)."},
                         "cljs.core/add-watch" {:ns "cljs.core",
                                                :name "add-watch",
                                                :signature ["[iref key f]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_add-watch",
                                                :source {:code "(defn add-watch\n  [iref key f]\n  (-add-watch iref key f))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [3083
                                                                 3105],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3083-L3105"},
                                                :full-name "cljs.core/add-watch",
                                                :clj-symbol "clojure.core/add-watch",
                                                :docstring "Alpha - subject to change.\n\nAdds a watch function to an atom reference. The watch fn must be a\nfn of 4 args: a key, the reference, its old-state, its\nnew-state. Whenever the reference's state might have been changed,\nany registered watches will have their functions called. The watch\nfn will be called synchronously. Note that an atom's state\nmay have changed again prior to the fn call, so use old/new-state\nrather than derefing the reference. Keys must be unique per\nreference, and can be used to remove the watch with remove-watch,\nbut are otherwise considered opaque by the watch mechanism.  Bear in\nmind that regardless of the result or action of the watch fns the\natom's value will change.  Example:\n\n    (def a (atom 0)) \n    (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n    (swap! a inc)\n    ;; Assertion Error\n    (deref a)\n    ;=> 1"},
                         "clojure.string/capitalize" {:ns "clojure.string",
                                                      :name "capitalize",
                                                      :signature ["[s]"],
                                                      :history [["+"
                                                                 "0.0-927"]],
                                                      :type "function",
                                                      :full-name-encode "clojure.string_capitalize",
                                                      :source {:code "(defn capitalize\n  [s]\n  (if (< (count s) 2)\n    (upper-case s)\n    (str (upper-case (subs s 0 1))\n         (lower-case (subs s 1)))))",
                                                               :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                               :lines [63
                                                                       70],
                                                               :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/string.cljs#L63-L70"},
                                                      :full-name "clojure.string/capitalize",
                                                      :clj-symbol "clojure.string/capitalize",
                                                      :docstring "Converts first character of the string to upper-case, all other\ncharacters to lower-case."},
                         "cljs.core/replicate" {:ns "cljs.core",
                                                :name "replicate",
                                                :signature ["[n x]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_replicate",
                                                :source {:code "(defn replicate\n  [n x] (take n (repeat x)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1729
                                                                 1731],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1729-L1731"},
                                                :full-name "cljs.core/replicate",
                                                :clj-symbol "clojure.core/replicate",
                                                :docstring "Returns a lazy seq of n xs."},
                         "special/do" {:full-name "special/do",
                                       :ns "special",
                                       :name "do",
                                       :type "special form",
                                       :source {:code "(defmethod parse 'do\n  [op env [_ & exprs] _]\n  (merge {:env env :op :do} (analyze-block env exprs)))",
                                                :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                :lines [721 723],
                                                :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/compiler.clj#L721-L723"},
                                       :full-name-encode "special_do",
                                       :clj-symbol "clojure.core/do",
                                       :history [["+" "0.0-927"]]},
                         "cljs.core/sequential?" {:ns "cljs.core",
                                                  :name "sequential?",
                                                  :signature ["[x]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_sequential_QMARK_",
                                                  :source {:code "(defn sequential?\n  [x] (satisfies? ISequential x))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [569
                                                                   571],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L569-L571"},
                                                  :full-name "cljs.core/sequential?",
                                                  :clj-symbol "clojure.core/sequential?",
                                                  :docstring "Returns true if coll satisfies ISequential"},
                         "cljs.core/underive" {:ns "cljs.core",
                                               :name "underive",
                                               :signature ["[tag parent]"
                                                           "[h tag parent]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_underive",
                                               :source {:code "(defn underive\n  ([tag parent]\n     ;; (alter-var-root #'global-hierarchy underive tag parent)\n     (swap! global-hierarchy underive tag parent) nil)\n  ([h tag parent]\n    (let [parentMap (:parents h)\n          childsParents (if (parentMap tag)\n                          (disj (parentMap tag) parent) #{})\n          newParents (if (not-empty childsParents)\n                      (assoc parentMap tag childsParents)\n                      (dissoc parentMap tag))\n          deriv-seq (flatten (map #(cons (first %) (interpose (first %) (second %)))\n                                  (seq newParents)))]\n      (if (contains? (parentMap tag) parent)\n        (reduce #(apply derive %1 %2) (make-hierarchy)\n                (partition 2 deriv-seq))\n        h))))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [3335
                                                                3354],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3335-L3354"},
                                               :full-name "cljs.core/underive",
                                               :clj-symbol "clojure.core/underive",
                                               :docstring "Removes a parent/child relationship between parent and\ntag. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
                         "cljs.core/get-method" {:ns "cljs.core",
                                                 :name "get-method",
                                                 :signature ["[multifn dispatch-val]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_get-method",
                                                 :source {:code "(defn get-method\n  [multifn dispatch-val] (-get-method multifn dispatch-val))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [3498
                                                                  3501],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3498-L3501"},
                                                 :full-name "cljs.core/get-method",
                                                 :clj-symbol "clojure.core/get-method",
                                                 :docstring "Given a multimethod and a dispatch value, returns the dispatch fn\nthat would apply to that value, or nil if none apply and no default"},
                         "cljs.core/=" {:full-name "cljs.core/=",
                                        :ns "cljs.core",
                                        :name "=",
                                        :type "function",
                                        :signature ["[x y]"],
                                        :source {:code "(defn = [x y]\n  (-equiv x y))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [180 181],
                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L180-L181"},
                                        :full-name-encode "cljs.core__EQ_",
                                        :clj-symbol "clojure.core/=",
                                        :history [["+" "0.0-927"]]},
                         "cljs.core/defn-" {:ns "cljs.core",
                                            :name "defn-",
                                            :signature ["[name & decls]"],
                                            :history [["+" "0.0-927"]],
                                            :type "macro",
                                            :full-name-encode "cljs.core_defn-",
                                            :source {:code "(defmacro defn-\n  [name & decls]\n    (list* `defn (with-meta name (assoc (meta name) :private true)) decls))",
                                                     :filename "clojure/src/clj/clojure/core.clj",
                                                     :lines [4331
                                                             4335],
                                                     :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L4331-L4335"},
                                            :full-name "cljs.core/defn-",
                                            :clj-symbol "clojure.core/defn-",
                                            :docstring "same as defn, yielding non-public def"},
                         "cljs.reader/read-symbol" {:full-name "cljs.reader/read-symbol",
                                                    :ns "cljs.reader",
                                                    :name "read-symbol",
                                                    :type "function",
                                                    :signature ["[reader initch]"],
                                                    :source {:code "(defn read-symbol\n  [reader initch]\n  (let [token (read-token reader initch)]\n    (if (gstring/contains token \"/\")\n      (symbol (subs token 0 (.indexOf token \"/\"))\n              (subs token (inc (.indexOf token \"/\")) (.-length token)))\n      (get special-symbols token (symbol token)))))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [248
                                                                     254],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L248-L254"},
                                                    :full-name-encode "cljs.reader_read-symbol",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "cljs.reader/push-back-reader" {:full-name "cljs.reader/push-back-reader",
                                                         :ns "cljs.reader",
                                                         :name "push-back-reader",
                                                         :type "function",
                                                         :signature ["[s]"],
                                                         :source {:code "(defn push-back-reader [s]\n  \"Creates a StringPushbackReader from a given string\"\n  (StringPushbackReader. s (atom 0) (atom nil)))",
                                                                  :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                  :lines [30
                                                                          32],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L30-L32"},
                                                         :full-name-encode "cljs.reader_push-back-reader",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "cljs.core/deftype" {:full-name "cljs.core/deftype",
                                              :ns "cljs.core",
                                              :name "deftype",
                                              :type "macro",
                                              :signature ["[t fields & impls]"],
                                              :source {:code "(defmacro deftype [t fields & impls]\n  (let [adorn-params (fn [sig]\n                       (cons (vary-meta (second sig) assoc :cljs.compiler/fields fields)\n                             (nnext sig)))\n        ;;reshape for extend-type\n        dt->et (fn [specs]\n                 (loop [ret [] s specs]\n                   (if (seq s)\n                     (recur (-> ret\n                                (conj (first s))\n                                (into\n                                 (reduce (fn [v [f sigs]]\n                                           (conj v (cons f (map adorn-params sigs))))\n                                         []\n                                         (group-by first (take-while seq? (next s))))))\n                            (drop-while seq? (next s)))\n                     ret)))]\n    (if (seq impls)\n      `(do\n         (deftype* ~t ~fields)\n         (extend-type ~t ~@(dt->et impls)))\n      `(deftype* ~t ~fields))))",
                                                       :filename "clojurescript/src/clj/cljs/core.clj",
                                                       :lines [236
                                                               257],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L236-L257"},
                                              :full-name-encode "cljs.core_deftype",
                                              :clj-symbol "clojure.core/deftype",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/Subvec" {:full-name "cljs.core/Subvec",
                                             :ns "cljs.core",
                                             :name "Subvec",
                                             :type "type",
                                             :signature ["[meta v start end]"],
                                             :source {:code "(deftype Subvec [meta v start end]\n  IWithMeta\n  (-with-meta [coll meta] (Subvec. meta v start end))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (-nth v (dec end)))\n  (-pop [coll]\n    (if (= start end)\n      (throw (js/Error. \"Can't pop empty vector\"))\n      (Subvec. meta v start (dec end))))\n\n  ICollection\n  (-conj [coll o]\n    (Subvec. meta (-assoc-n v end o) start (inc end)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Vector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (let [subvec-seq (fn subvec-seq [i]\n                       (when-not (= i end)\n                         (cons (-nth v i)\n                               (lazy-seq\n                                (subvec-seq (inc i))))))]\n      (subvec-seq start)))\n\n  ICounted\n  (-count [coll] (- end start))\n\n  IIndexed\n  (-nth [coll n]\n    (-nth v (+ start n)))\n  (-nth [coll n not-found]\n    (-nth v (+ start n) not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll key val]\n    (let [v-pos (+ start key)]\n      (Subvec. meta (-assoc v v-pos val)\n               start (max end (inc v-pos)))))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [coll f]\n    (ci-reduce coll f))\n  (-reduce [coll f start]\n    (ci-reduce coll f start)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1986
                                                              2050],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1986-L2050"},
                                             :full-name-encode "cljs.core_Subvec",
                                             :history [["+" "0.0-927"]]},
                         "special/ns" {:full-name "special/ns",
                                       :ns "special",
                                       :name "ns",
                                       :type "special form",
                                       :source {:code "(defmethod parse 'ns\n  [_ env [_ name & args] _]\n  (let [excludes\n        (reduce (fn [s [k exclude xs]]\n                  (if (= k :refer-clojure)\n                    (do\n                      (assert (= exclude :exclude) \"Only [:refer-clojure :exclude [names]] form supported\")\n                      (into s xs))\n                    s))\n                #{} args)\n        {uses :use requires :require uses-macros :use-macros requires-macros :require-macros :as params}\n        (reduce (fn [m [k & libs]]\n                  (assert (#{:use :use-macros :require :require-macros} k)\n                          \"Only :refer-clojure, :require, :require-macros, :use and :use-macros libspecs supported\")\n                  (assoc m k (into {}\n                                   (mapcat (fn [[lib kw expr]]\n                                             (case k\n                                               (:require :require-macros)\n                                               (do (assert (and expr (= :as kw))\n                                                           \"Only (:require [lib.ns :as alias]*) form of :require / :require-macros is supported\")\n                                                   [[expr lib]])\n                                               (:use :use-macros)\n                                               (do (assert (and expr (= :only kw))\n                                                           \"Only (:use [lib.ns :only [names]]*) form of :use / :use-macros is supported\")\n                                                   (map vector expr (repeat lib)))))\n                                           libs))))\n                {} (remove (fn [[r]] (= r :refer-clojure)) args))]\n    (set! *cljs-ns* name)\n    (require 'cljs.core)\n    (doseq [nsym (concat (vals requires-macros) (vals uses-macros))]\n      (clojure.core/require nsym))\n    (swap! namespaces #(-> %\n                           (assoc-in [name :name] name)\n                           (assoc-in [name :excludes] excludes)\n                           (assoc-in [name :uses] uses)\n                           (assoc-in [name :requires] requires)\n                           (assoc-in [name :uses-macros] uses-macros)\n                           (assoc-in [name :requires-macros]\n                                     (into {} (map (fn [[alias nsym]]\n                                                     [alias (find-ns nsym)])\n                                                   requires-macros)))))\n    {:env env :op :ns :name name :uses uses :requires requires\n     :uses-macros uses-macros :requires-macros requires-macros :excludes excludes}))",
                                                :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                :lines [798 840],
                                                :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/compiler.clj#L798-L840"},
                                       :full-name-encode "special_ns",
                                       :clj-symbol "clojure.core/ns",
                                       :history [["+" "0.0-927"]]},
                         "cljs.core/extend-protocol" {:ns "cljs.core",
                                                      :name "extend-protocol",
                                                      :signature ["[p & specs]"],
                                                      :history [["+"
                                                                 "0.0-927"]],
                                                      :type "macro",
                                                      :full-name-encode "cljs.core_extend-protocol",
                                                      :source {:code "(defmacro extend-protocol \n  [p & specs]\n  (emit-extend-protocol p specs))",
                                                               :filename "clojure/src/clj/clojure/core_deftype.clj",
                                                               :lines [754
                                                                       792],
                                                               :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core_deftype.clj#L754-L792"},
                                                      :full-name "cljs.core/extend-protocol",
                                                      :clj-symbol "clojure.core/extend-protocol",
                                                      :docstring "Useful when you want to provide several implementations of the same\nprotocol all at once. Takes a single protocol and the implementation\nof that protocol for one or more types. Expands into calls to\nextend-type:\n\n(extend-protocol Protocol\n  AType\n    (foo [x] ...)\n    (bar [x y] ...)\n  BType\n    (foo [x] ...)\n    (bar [x y] ...)\n  AClass\n    (foo [x] ...)\n    (bar [x y] ...)\n  nil\n    (foo [x] ...)\n    (bar [x y] ...))\n\nexpands into:\n\n(do\n (clojure.core/extend-type AType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type BType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type AClass Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type nil Protocol \n   (foo [x] ...) \n   (bar [x y] ...)))"},
                         "cljs.reader/read" {:ns "cljs.reader",
                                             :name "read",
                                             :signature ["[reader eof-is-error sentinel is-recursive]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.reader_read",
                                             :source {:code "(defn read\n  [reader eof-is-error sentinel is-recursive]\n  (let [ch (read-char reader)]\n    (cond\n     (nil? ch) (if eof-is-error (reader-error reader \"EOF\") sentinel)\n     (whitespace? ch) (recur reader eof-is-error sentinel is-recursive)\n     (comment-prefix? ch) (recur (read-comment reader ch) eof-is-error sentinel is-recursive)\n     :else (let [res\n                 (cond\n                  (macros ch) ((macros ch) reader ch)\n                  (number-literal? reader ch) (read-number reader ch)\n                  :else (read-symbol reader ch))]\n     (if (= res reader)\n       (recur reader eof-is-error sentinel is-recursive)\n       res)))))",
                                                      :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                      :lines [338 354],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L338-L354"},
                                             :full-name "cljs.reader/read",
                                             :clj-symbol "clojure.core/read",
                                             :docstring "Reads the first object from a PushbackReader. Returns the object read.\nIf EOF, throws if eof-is-error is true. Otherwise returns sentinel."},
                         "cljs.core/EmptyList" {:full-name "cljs.core/EmptyList",
                                                :ns "cljs.core",
                                                :name "EmptyList",
                                                :type "type",
                                                :signature ["[meta]"],
                                                :source {:code "(deftype EmptyList [meta]\n  IWithMeta\n  (-with-meta [coll meta] (EmptyList. meta))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] nil)\n  (-rest [coll] nil)\n\n  IStack\n  (-peek [coll] nil)\n  (-pop [coll] #_(throw (js/Error. \"Can't pop empty list\")))\n\n  ICollection\n  (-conj [coll o] (List. meta o nil 1))\n\n  IEmptyableCollection\n  (-empty [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] nil)\n\n  ICounted\n  (-count [coll] 0))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1113
                                                                 1145],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1113-L1145"},
                                                :full-name-encode "cljs.core_EmptyList",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "clojure.walk/postwalk" {:ns "clojure.walk",
                                                  :name "postwalk",
                                                  :signature ["[f form]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.walk_postwalk",
                                                  :source {:code "(defn postwalk\n  [f form]\n  (walk (partial postwalk f) f form))",
                                                           :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                           :lines [50
                                                                   56],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/walk.cljs#L50-L56"},
                                                  :full-name "clojure.walk/postwalk",
                                                  :clj-symbol "clojure.walk/postwalk",
                                                  :docstring "Performs a depth-first, post-order traversal of form.  Calls f on\neach sub-form, uses f's return value in place of the original.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
                         "clojure.zip/edit" {:ns "clojure.zip",
                                             :name "edit",
                                             :signature ["[loc f & args]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_edit",
                                             :source {:code "(defn edit\n  [loc f & args]\n    (replace loc (apply f (node loc) args)))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [189 192],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L189-L192"},
                                             :full-name "clojure.zip/edit",
                                             :clj-symbol "clojure.zip/edit",
                                             :docstring "Replaces the node at this loc with the value of (f node args)"},
                         "cljs.core/re-seq" {:ns "cljs.core",
                                             :name "re-seq",
                                             :signature ["[re s]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_re-seq",
                                             :source {:code "(defn re-seq\n  [re s]\n  (let [match-data (re-find re s)\n        match-idx (.search s re)\n        match-str (if (coll? match-data) (first match-data) match-data)\n        post-match (subs s (+ match-idx (count match-str)))]\n    (when match-data (lazy-seq (cons match-data (re-seq re post-match))))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2785
                                                              2792],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2785-L2792"},
                                             :full-name "cljs.core/re-seq",
                                             :clj-symbol "clojure.core/re-seq",
                                             :docstring "Returns a lazy sequence of successive matches of re in s."},
                         "cljs.reader/read-list" {:full-name "cljs.reader/read-list",
                                                  :ns "cljs.reader",
                                                  :name "read-list",
                                                  :type "function",
                                                  :signature ["[rdr _]"],
                                                  :source {:code "(defn read-list\n  [rdr _]\n  (apply list (read-delimited-list \")\" rdr true)))",
                                                           :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                           :lines [203
                                                                   205],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L203-L205"},
                                                  :full-name-encode "cljs.reader_read-list",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/Atom" {:full-name "cljs.core/Atom",
                                           :ns "cljs.core",
                                           :name "Atom",
                                           :type "type",
                                           :signature ["[state meta validator watches]"],
                                           :source {:code "(deftype Atom [state meta validator watches]\n  IEquiv\n  (-equiv [o other] (identical? o other))\n\n  IDeref\n  (-deref [_] state)\n\n  IMeta\n  (-meta [_] meta)\n\n  IPrintable\n  (-pr-seq [a opts]\n    (concat  [\"#<Atom: \"] (-pr-seq state opts) \">\"))\n\n  IWatchable\n  (-notify-watches [this oldval newval]\n    (doseq [[key f] watches]\n      (f key this oldval newval)))\n  (-add-watch [this key f]\n    (set! (.-watches this) (assoc watches key f)))\n  (-remove-watch [this key]\n    (set! (.-watches this) (dissoc watches key)))\n\n  IHash\n  (-hash [this] (goog.getUid this)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2968 2992],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2968-L2992"},
                                           :full-name-encode "cljs.core_Atom",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/IMap" {:ns "cljs.core",
                                           :name "IMap",
                                           :type "protocol",
                                           :full-name-encode "cljs.core_IMap",
                                           :source {:code "(defprotocol IMap\n  #_(-assoc-ex [coll k v])\n  (-dissoc [coll k]))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [120 122],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L120-L122"},
                                           :methods [{:name "-dissoc",
                                                      :signature ["[coll k]"],
                                                      :docstring nil}],
                                           :full-name "cljs.core/IMap",
                                           :history [["+" "0.0-927"]]},
                         "cljs.reader/read-vector" {:full-name "cljs.reader/read-vector",
                                                    :ns "cljs.reader",
                                                    :name "read-vector",
                                                    :type "function",
                                                    :signature ["[rdr _]"],
                                                    :source {:code "(defn read-vector\n  [rdr _]\n  (read-delimited-list \"]\" rdr true))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [209
                                                                     211],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L209-L211"},
                                                    :full-name-encode "cljs.reader_read-vector",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "clojure.set/join" {:ns "clojure.set",
                                             :name "join",
                                             :signature ["[xrel yrel]"
                                                         "[xrel yrel km]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.set_join",
                                             :source {:code "(defn join\n  ([xrel yrel] ;natural join\n   (if (and (seq xrel) (seq yrel))\n     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n           [r s] (if (<= (count xrel) (count yrel))\n                   [xrel yrel]\n                   [yrel xrel])\n           idx (index r ks)]\n       (reduce (fn [ret x]\n                 (let [found (idx (select-keys x ks))]\n                   (if found\n                     (reduce #(conj %1 (merge %2 x)) ret found)\n                     ret)))\n               #{} s))\n     #{}))\n  ([xrel yrel km] ;arbitrary key mapping\n   (let [[r s k] (if (<= (count xrel) (count yrel))\n                   [xrel yrel (map-invert km)]\n                   [yrel xrel km])\n         idx (index r (vals k))]\n     (reduce (fn [ret x]\n               (let [found (idx (rename-keys (select-keys x (keys k)) k))]\n                 (if found\n                   (reduce #(conj %1 (merge %2 x)) ret found)\n                   ret)))\n             #{} s))))",
                                                      :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                      :lines [102 130],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/set.cljs#L102-L130"},
                                             :full-name "clojure.set/join",
                                             :clj-symbol "clojure.set/join",
                                             :docstring "When passed 2 rels, returns the rel corresponding to the natural\njoin. When passed an additional keymap, joins on the corresponding\nkeys."},
                         "cljs.core/HashMap" {:full-name "cljs.core/HashMap",
                                              :ns "cljs.core",
                                              :name "HashMap",
                                              :type "type",
                                              :signature ["[meta count hashobj]"],
                                              :source {:code "(deftype HashMap [meta count hashobj]\n  IWithMeta\n  (-with-meta [coll meta] (HashMap. meta count hashobj))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.HashMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? count)\n      (let [hashes (js-keys hashobj)]\n        (mapcat #(map vec (partition 2 (aget hashobj %)))\n                hashes))))\n\n  ICounted\n  (-count [coll] count)\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        (aget bucket (inc i))\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [h (hash k)\n          bucket (aget hashobj h)]\n      (if bucket\n        (let [new-bucket (aclone bucket)\n              new-hashobj (goog.object/clone hashobj)]\n          (aset new-hashobj h new-bucket)\n          (if-let [i (scan-array 2 k new-bucket)]\n            (do                         ; found key, replace\n              (aset new-bucket (inc i) v)\n              (HashMap. meta count new-hashobj))\n            (do                         ; did not find key, append\n              (.push new-bucket k v)\n              (HashMap. meta (inc count) new-hashobj))))\n        (let [new-hashobj (goog.object/clone hashobj)] ; did not find bucket\n          (aset new-hashobj h (array k v))\n          (HashMap. meta (inc count) new-hashobj)))))\n  (-contains-key? [coll k]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        true\n        false)))\n\n  IMap\n  (-dissoc [coll k]\n    (let [h (hash k)\n          bucket (aget hashobj h)\n          i (when bucket (scan-array 2 k bucket))]\n      (if (not i)\n        coll ; key not found, return coll unchanged\n        (let [new-hashobj (goog.object/clone hashobj)]\n          (if (> 3 (.-length bucket))\n            (js-delete new-hashobj h)\n            (let [new-bucket (aclone bucket)]\n              (.splice new-bucket i 2)\n              (aset new-hashobj h new-bucket)))\n          (HashMap. meta (dec count) new-hashobj))))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2270
                                                               2351],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2270-L2351"},
                                              :full-name-encode "cljs.core_HashMap",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.reader/int-pattern" {:full-name "cljs.reader/int-pattern",
                                                    :ns "cljs.reader",
                                                    :name "int-pattern",
                                                    :type "var",
                                                    :source {:code "(def int-pattern (re-pattern \"([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?\"))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [95
                                                                     95],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L95-L95"},
                                                    :full-name-encode "cljs.reader_int-pattern",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "cljs.core/swap!" {:ns "cljs.core",
                                            :name "swap!",
                                            :signature ["[a f]"
                                                        "[a f x]"
                                                        "[a f x y]"
                                                        "[a f x y z]"
                                                        "[a f x y z & more]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_swap_BANG_",
                                            :source {:code "(defn swap!\n  ([a f]\n     (reset! a (f (.-state a))))\n  ([a f x]\n     (reset! a (f (.-state a) x)))\n  ([a f x y]\n     (reset! a (f (.-state a) x y)))\n  ([a f x y z]\n     (reset! a (f (.-state a) x y z)))\n  ([a f x y z & more]\n     (reset! a (apply f (.-state a) x y z more))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [3022
                                                             3036],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3022-L3036"},
                                            :full-name "cljs.core/swap!",
                                            :clj-symbol "clojure.core/swap!",
                                            :docstring "Atomically swaps the value of atom to be:\n(apply f current-value-of-atom args). Note that f may be called\nmultiple times, and thus should be free of side effects.  Returns\nthe value that was swapped in."},
                         "cljs.core/dec" {:ns "cljs.core",
                                          :name "dec",
                                          :signature ["[x]"],
                                          :shadowed-sources ({:code "(defmacro dec [x]\n  `(- ~x 1))",
                                                              :filename "clojurescript/src/clj/cljs/core.clj",
                                                              :lines [103
                                                                      104],
                                                              :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L103-L104"}),
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_dec",
                                          :source {:code "(defn dec\n  [x] (- x 1))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [849 851],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L849-L851"},
                                          :full-name "cljs.core/dec",
                                          :clj-symbol "clojure.core/dec",
                                          :docstring "Returns a number one less than num."},
                         "clojure.browser.dom/remove-children" {:full-name "clojure.browser.dom/remove-children",
                                                                :ns "clojure.browser.dom",
                                                                :name "remove-children",
                                                                :docstring "Remove all children from the element with the passed id.",
                                                                :type "function",
                                                                :signature ["[id]"],
                                                                :source {:code "(defn remove-children\n  [id]\n  (let [parent (gdom/getElement (name id))]\n    (do (gdom/removeChildren parent))))",
                                                                         :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                         :lines [90
                                                                                 94],
                                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/dom.cljs#L90-L94"},
                                                                :full-name-encode "clojure.browser.dom_remove-children",
                                                                :history [["+"
                                                                           "0.0-927"]]},
                         "cljs.core/get-validator" {:ns "cljs.core",
                                                    :name "get-validator",
                                                    :signature ["[iref]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_get-validator",
                                                    :source {:code "(defn get-validator\n  [iref]\n  (.-validator iref))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [3064
                                                                     3067],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3064-L3067"},
                                                    :full-name "cljs.core/get-validator",
                                                    :clj-symbol "clojure.core/get-validator",
                                                    :docstring "Gets the validator-fn for a var/ref/agent/atom."},
                         "cljs.core/coll?" {:ns "cljs.core",
                                            :name "coll?",
                                            :signature ["[x]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_coll_QMARK_",
                                            :source {:code "(defn coll?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ICollection x)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [551 556],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L551-L556"},
                                            :full-name "cljs.core/coll?",
                                            :clj-symbol "clojure.core/coll?",
                                            :docstring "Returns true if x satisfies ICollection"},
                         "cljs.core/bit-or" {:ns "cljs.core",
                                             :name "bit-or",
                                             :signature ["[x y]"],
                                             :shadowed-sources ({:code "(defmacro bit-or\n  ([x y] (list 'js* \"(~{} | ~{})\" x y))\n  ([x y & more] `(bit-or (bit-or ~x ~y) ~@more)))",
                                                                 :filename "clojurescript/src/clj/cljs/core.clj",
                                                                 :lines [138
                                                                         140],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L138-L140"}),
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_bit-or",
                                             :source {:code "(defn bit-or\n  [x y] (js* \"(~{x} | ~{y})\"))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [906 908],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L906-L908"},
                                             :full-name "cljs.core/bit-or",
                                             :clj-symbol "clojure.core/bit-or",
                                             :docstring "Bitwise or"},
                         "cljs.core/nfirst" {:ns "cljs.core",
                                             :name "nfirst",
                                             :signature ["[coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_nfirst",
                                             :source {:code "(defn nfirst\n  [coll]\n  (next (first coll)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [405 408],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L405-L408"},
                                             :full-name "cljs.core/nfirst",
                                             :clj-symbol "clojure.core/nfirst",
                                             :docstring "Same as (next (first x))"},
                         "cljs.core/keep" {:ns "cljs.core",
                                           :name "keep",
                                           :signature ["[f coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_keep",
                                           :source {:code "(defn keep\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (let [x (f (first s))]\n        (if (nil? x)\n          (keep f (rest s))\n          (cons x (keep f (rest s)))))))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1535 1545],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1535-L1545"},
                                           :full-name "cljs.core/keep",
                                           :clj-symbol "clojure.core/keep",
                                           :docstring "Returns a lazy sequence of the non-nil results of (f item). Note,\nthis means false return values will be included.  f must be free of\nside-effects."},
                         "cljs.core/take" {:ns "cljs.core",
                                           :name "take",
                                           :signature ["[n coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_take",
                                           :source {:code "(defn take\n  [n coll]\n  (lazy-seq\n   (when (pos? n)\n     (when-let [s (seq coll)]\n      (cons (first s) (take (dec n) (rest s)))))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1669 1676],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1669-L1676"},
                                           :full-name "cljs.core/take",
                                           :clj-symbol "clojure.core/take",
                                           :docstring "Returns a lazy sequence of the first n items in coll, or all items if\nthere are fewer than n."},
                         "cljs.core/cond" {:ns "cljs.core",
                                           :name "cond",
                                           :signature ["[& clauses]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_cond",
                                           :source {:code "(defmacro cond\n  [& clauses]\n    (when clauses\n      (list 'if (first clauses)\n            (if (next clauses)\n                (second clauses)\n                (throw (IllegalArgumentException.\n                         \"cond requires an even number of forms\")))\n            (cons 'clojure.core/cond (next (next clauses))))))",
                                                    :filename "clojure/src/clj/clojure/core.clj",
                                                    :lines [534 547],
                                                    :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L534-L547"},
                                           :full-name "cljs.core/cond",
                                           :clj-symbol "clojure.core/cond",
                                           :docstring "Takes a set of test/expr pairs. It evaluates each test one at a\ntime.  If a test returns logical true, cond evaluates and returns\nthe value of the corresponding expr and doesn't evaluate any of the\nother tests or exprs. (cond) returns nil."},
                         "cljs.core/bit-and" {:ns "cljs.core",
                                              :name "bit-and",
                                              :signature ["[x y]"],
                                              :shadowed-sources ({:code "(defmacro bit-and\n  ([x y] (list 'js* \"(~{} & ~{})\" x y))\n  ([x y & more] `(bit-and (bit-and ~x ~y) ~@more)))",
                                                                  :filename "clojurescript/src/clj/cljs/core.clj",
                                                                  :lines [134
                                                                          136],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L134-L136"}),
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_bit-and",
                                              :source {:code "(defn bit-and\n  [x y] (js* \"(~{x} & ~{y})\"))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [902
                                                               904],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L902-L904"},
                                              :full-name "cljs.core/bit-and",
                                              :clj-symbol "clojure.core/bit-and",
                                              :docstring "Bitwise and"},
                         "clojure.browser.event/unique-event-id" {:full-name "clojure.browser.event/unique-event-id",
                                                                  :ns "clojure.browser.event",
                                                                  :name "unique-event-id",
                                                                  :type "function",
                                                                  :signature ["[event-type]"],
                                                                  :source {:code "(defn unique-event-id [event-type])",
                                                                           :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                           :lines [92
                                                                                   92],
                                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/event.cljs#L92-L92"},
                                                                  :full-name-encode "clojure.browser.event_unique-event-id",
                                                                  :history [["+"
                                                                             "0.0-927"]]},
                         "clojure.set/project" {:ns "clojure.set",
                                                :name "project",
                                                :signature ["[xrel ks]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.set_project",
                                                :source {:code "(defn project\n  [xrel ks]\n    (set (map #(select-keys % ks) xrel)))",
                                                         :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                         :lines [67
                                                                 70],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/set.cljs#L67-L70"},
                                                :full-name "clojure.set/project",
                                                :clj-symbol "clojure.set/project",
                                                :docstring "Returns a rel of the elements of xrel with only the keys in ks"},
                         "special/js*" {:full-name "special/js*",
                                        :ns "special",
                                        :name "js*",
                                        :type "special form",
                                        :source {:code "(defmethod parse 'js*\n  [op env [_ form & args] _]\n  (assert (string? form))\n  (if args\n    (disallowing-recur\n     (let [seg (fn seg [^String s]\n                 (let [idx (.indexOf s \"~{\")]\n                   (if (= -1 idx)\n                     (list s)\n                     (let [end (.indexOf s \"}\" idx)]\n                       (cons (subs s 0 idx) (seg (subs s (inc end))))))))\n           enve (assoc env :context :expr)\n           argexprs (vec (map #(analyze enve %) args))]\n       {:env env :op :js :segs (seg form) :args argexprs :children argexprs}))\n    (let [interp (fn interp [^String s]\n                   (let [idx (.indexOf s \"~{\")]\n                     (if (= -1 idx)\n                       (list s)\n                       (let [end (.indexOf s \"}\" idx)\n                             inner (:name (resolve-existing-var env (symbol (subs s (+ 2 idx) end))))]\n                         (cons (subs s 0 idx) (cons inner (interp (subs s (inc end)))))))))]\n      {:env env :op :js :code (apply str (interp form))})))",
                                                 :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                 :lines [951 972],
                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/compiler.clj#L951-L972"},
                                        :full-name-encode "special_js_STAR_",
                                        :history [["+" "0.0-927"]]},
                         "clojure.string/trim-newline" {:ns "clojure.string",
                                                        :name "trim-newline",
                                                        :signature ["[s]"],
                                                        :history [["+"
                                                                   "0.0-927"]],
                                                        :type "function",
                                                        :full-name-encode "clojure.string_trim-newline",
                                                        :source {:code "(defn trim-newline\n  [s]\n  (loop [index (.-length s)]\n    (if (zero? index)\n      \"\"\n      (let [ch (get s (dec index))]\n        (if (or (= ch \\newline) (= ch \\return))\n          (recur (dec index))\n          (.substring s 0 index))))))",
                                                                 :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                                 :lines [121
                                                                         131],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/string.cljs#L121-L131"},
                                                        :full-name "clojure.string/trim-newline",
                                                        :clj-symbol "clojure.string/trim-newline",
                                                        :docstring "Removes all trailing newline \\n or return \\r characters from\nstring.  Similar to Perl's chomp."},
                         "specialrepl/in-ns" {:full-name "specialrepl/in-ns",
                                              :ns "specialrepl",
                                              :name "in-ns",
                                              :type "special form (repl)",
                                              :source {:code "(defn repl\n  \"Note - repl will reload core.cljs every time, even if supplied old repl-env\"\n  [repl-env & {:keys [verbose warn-on-undeclared]}]\n  (prn \"Type: \" :cljs/quit \" to quit\")\n  (binding [comp/*cljs-ns* 'cljs.user\n            *cljs-verbose* verbose\n            comp/*cljs-warn-on-undeclared* warn-on-undeclared]\n    (let [env {:context :statement :locals {}}]\n      (-setup repl-env)\n      (loop []\n        (print (str \"ClojureScript:\" comp/*cljs-ns* \"> \"))\n        (flush)\n        (let [{:keys [status form]} (read-next-form)]\n          (cond\n           (= form :cljs/quit) :quit\n           \n           (= status :error) (recur)\n           \n           (and (seq? form) (= (first form) 'in-ns))\n           (do (set! comp/*cljs-ns* (second (second form))) (newline) (recur))\n           \n           (and (seq? form) ('#{load-file clojure.core/load-file} (first form)))\n           (do (load-file repl-env (second form)) (newline) (recur))\n           \n           (and (seq? form) ('#{load-namespace} (first form)))\n           (do (load-namespace repl-env (second form)) (newline) (recur))\n           \n           :else\n           (do (eval-and-print repl-env env form) (recur)))))\n      (-tear-down repl-env))))",
                                                       :filename "clojurescript/src/clj/cljs/repl.clj",
                                                       :lines [132
                                                               161],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/repl.clj#L132-L161"},
                                              :full-name-encode "specialrepl_in-ns",
                                              :clj-symbol "clojure.core/in-ns",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "special/let*" {:full-name "special/let*",
                                         :ns "special",
                                         :name "let*",
                                         :type "special form",
                                         :source {:code "(defmethod parse 'let*\n  [op encl-env form _]\n  (analyze-let encl-env form false))",
                                                  :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                  :lines [750 752],
                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/compiler.clj#L750-L752"},
                                         :full-name-encode "special_let_STAR_",
                                         :history [["+" "0.0-927"]]},
                         "special/throw" {:full-name "special/throw",
                                          :ns "special",
                                          :name "throw",
                                          :type "special form",
                                          :source {:code "(defmethod parse 'throw\n  [op env [_ throw :as form] name]\n  (let [throw-expr (disallowing-recur (analyze (assoc env :context :expr) throw))]\n    {:env env :op :throw :form form\n     :throw throw-expr\n     :children [throw-expr]}))",
                                                   :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                   :lines [612 617],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/compiler.clj#L612-L617"},
                                          :full-name-encode "special_throw",
                                          :clj-symbol "clojure.core/throw",
                                          :history [["+" "0.0-927"]]},
                         "clojure.zip/insert-left" {:ns "clojure.zip",
                                                    :name "insert-left",
                                                    :signature ["[loc item]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "clojure.zip_insert-left",
                                                    :source {:code "(defn insert-left\n  [loc item]\n    (let [[node {l :l :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :l (conj l item) :changed? true)] (meta loc)))))",
                                                             :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                             :lines [165
                                                                     172],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L165-L172"},
                                                    :full-name "clojure.zip/insert-left",
                                                    :clj-symbol "clojure.zip/insert-left",
                                                    :docstring "Inserts the item as the left sibling of the node at this loc,\nwithout moving"},
                         "cljs.core/true?" {:ns "cljs.core",
                                            :name "true?",
                                            :signature ["[x]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_true_QMARK_",
                                            :source {:code "(defn true?\n  [x] (js* \"~{x} === true\"))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [608 610],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L608-L610"},
                                            :full-name "cljs.core/true?",
                                            :clj-symbol "clojure.core/true?",
                                            :docstring "Returns true if x is the value true, false otherwise."},
                         "clojure.browser.net/xpc-connection" {:full-name "clojure.browser.net/xpc-connection",
                                                               :ns "clojure.browser.net",
                                                               :name "xpc-connection",
                                                               :docstring "When passed with a config hash-map, returns a parent\nCrossPageChannel object. Keys in the config hash map are downcased\nversions of the goog.net.xpc.CfgFields enum keys,\ne.g. goog.net.xpc.CfgFields.PEER_URI becomes :peer_uri in the config\nhash.\n\nWhen passed with no args, creates a child CrossPageChannel object,\nand the config is automatically taken from the URL param 'xpc', as\nper the CrossPageChannel API.",
                                                               :type "function",
                                                               :signature ["[]"
                                                                           "[config]"],
                                                               :source {:code "(defn xpc-connection\n  ([]\n     (when-let [config (.getParameterValue\n                        (goog.Uri. (.-href (.-location js/window)))\n                        \"xpc\")]\n       (goog.net.xpc.CrossPageChannel. (gjson/parse config))))\n  ([config]\n     (goog.net.xpc.CrossPageChannel.\n      (.-strobj (reduce (fn [sum [k v]]\n                          (if-let [field (get xpc-config-fields k)]\n                            (assoc sum field v)\n                            sum))\n                       {}\n                       config)))))",
                                                                        :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                        :lines [118
                                                                                140],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/net.cljs#L118-L140"},
                                                               :full-name-encode "clojure.browser.net_xpc-connection",
                                                               :history [["+"
                                                                          "0.0-927"]]},
                         "cljs.core/not" {:ns "cljs.core",
                                          :name "not",
                                          :signature ["[x]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_not",
                                          :source {:code "(defn not\n  [x] (if x false true))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [438 440],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L438-L440"},
                                          :full-name "cljs.core/not",
                                          :clj-symbol "clojure.core/not",
                                          :docstring "Returns true if x is logical false, false otherwise."},
                         "cljs.core/js-obj" {:full-name "cljs.core/js-obj",
                                             :ns "cljs.core",
                                             :name "js-obj",
                                             :type "function",
                                             :signature ["[]"],
                                             :source {:code "(defn js-obj []\n  (js* \"{}\"))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [589 590],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L589-L590"},
                                             :full-name-encode "cljs.core_js-obj",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/complement" {:ns "cljs.core",
                                                 :name "complement",
                                                 :signature ["[f]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_complement",
                                                 :source {:code "(defn complement\n  [f] \n  (fn \n    ([] (not (f)))\n    ([x] (not (f x)))\n    ([x y] (not (f x y)))\n    ([x y & zs] (not (apply f x y zs)))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [1443
                                                                  1451],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1443-L1451"},
                                                 :full-name "cljs.core/complement",
                                                 :clj-symbol "clojure.core/complement",
                                                 :docstring "Takes a fn f and returns a fn that takes the same arguments as f,\nhas the same effects, if any, and returns the opposite truth value."},
                         "cljs.core/spread" {:full-name "cljs.core/spread",
                                             :ns "cljs.core",
                                             :name "spread",
                                             :type "function",
                                             :signature ["[arglist]"],
                                             :source {:code "(defn spread\n  [arglist]\n  (cond\n   (nil? arglist) nil\n   (nil? (next arglist)) (seq (first arglist))\n   :else (cons (first arglist)\n               (spread (next arglist)))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1298
                                                              1304],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1298-L1304"},
                                             :full-name-encode "cljs.core_spread",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/keyword" {:ns "cljs.core",
                                              :name "keyword",
                                              :signature ["[name]"
                                                          "[ns name]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_keyword",
                                              :source {:code "(defn keyword\n  ([name] (cond (keyword? name) name\n                (symbol? name) (str* \"\\uFDD0\" \"'\" (subs name 2))\n                :else (str* \"\\uFDD0\" \"'\" name)))\n  ([ns name] (keyword (str* ns \"/\" name))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1036
                                                               1042],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1036-L1042"},
                                              :full-name "cljs.core/keyword",
                                              :clj-symbol "clojure.core/keyword",
                                              :docstring "Returns a Keyword with the given namespace and name.  Do not use :\nin the keyword strings, it will be added automatically."},
                         "cljs.core/sort" {:ns "cljs.core",
                                           :name "sort",
                                           :signature ["[coll]"
                                                       "[comp coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_sort",
                                           :source {:code "(defn sort\n  ([coll]\n   (sort compare coll))\n  ([comp coll]\n   (if (seq coll)\n     (let [a (to-array coll)]\n       ;; matching Clojure's stable sort, though docs don't promise it\n       (garray/stableSort a (fn->comparator comp))\n       (seq a))\n     ())))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [711 723],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L711-L723"},
                                           :full-name "cljs.core/sort",
                                           :clj-symbol "clojure.core/sort",
                                           :docstring "Returns a sorted sequence of the items in coll. Comp can be\nboolean-valued comparison funcion, or a -/0/+ valued comparator.\nComp defaults to compare."},
                         "clojure.string/trim" {:ns "clojure.string",
                                                :name "trim",
                                                :signature ["[s]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.string_trim",
                                                :source {:code "(defn trim\n    [s]\n    (gstring/trim s))",
                                                         :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                         :lines [106
                                                                 109],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/string.cljs#L106-L109"},
                                                :full-name "clojure.string/trim",
                                                :clj-symbol "clojure.string/trim",
                                                :docstring "Removes whitespace from both ends of string."},
                         "cljs.core/meta" {:ns "cljs.core",
                                           :name "meta",
                                           :signature ["[o]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_meta",
                                           :source {:code "(defn meta\n  [o]\n  (when (satisfies? IMeta o)\n    (-meta o)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [512 516],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L512-L516"},
                                           :full-name "cljs.core/meta",
                                           :clj-symbol "clojure.core/meta",
                                           :docstring "Returns the metadata of obj, returns nil if there is no metadata."},
                         "cljs.core/time" {:ns "cljs.core",
                                           :name "time",
                                           :signature ["[expr]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_time",
                                           :source {:code "(defmacro time\n  [expr]\n  `(let [start# (.getTime (js/Date.) ())\n         ret# ~expr]\n     (prn (str \"Elapsed time: \" (- (.getTime (js/Date.) ()) start#) \" msecs\"))\n     ret#))",
                                                    :filename "clojurescript/src/clj/cljs/core.clj",
                                                    :lines [709 715],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L709-L715"},
                                           :full-name "cljs.core/time",
                                           :clj-symbol "clojure.core/time",
                                           :docstring "Evaluates expr and prints the time it took. Returns the value of expr."},
                         "cljs.core/boolean" {:full-name "cljs.core/boolean",
                                              :ns "cljs.core",
                                              :name "boolean",
                                              :type "function",
                                              :signature ["[x]"],
                                              :source {:code "(defn boolean [x]\n  (if x true false))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [625
                                                               626],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L625-L626"},
                                              :full-name-encode "cljs.core_boolean",
                                              :clj-symbol "clojure.core/boolean",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.reader/read-token" {:full-name "cljs.reader/read-token",
                                                   :ns "cljs.reader",
                                                   :name "read-token",
                                                   :type "function",
                                                   :signature ["[rdr initch]"],
                                                   :source {:code "(defn read-token\n  [rdr initch]\n  (loop [sb (gstring/StringBuffer. initch)\n         ch (read-char rdr)]\n    (if (or (nil? ch)\n            (whitespace? ch)\n            (macro-terminating? ch))\n      (do (unread rdr ch) (. sb (toString)))\n      (recur (do (.append sb ch) sb) (read-char rdr)))))",
                                                            :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                            :lines [76
                                                                    84],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L76-L84"},
                                                   :full-name-encode "cljs.reader_read-token",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "cljs.core/update-in" {:ns "cljs.core",
                                                :name "update-in",
                                                :signature ["[m [k & ks] f & args]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_update-in",
                                                :source {:code "(defn update-in\n  ([m [k & ks] f & args]\n   (if ks\n     (assoc m k (apply update-in (get m k) ks f args))\n     (assoc m k (apply f (get m k) args)))))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1881
                                                                 1890],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1881-L1890"},
                                                :full-name "cljs.core/update-in",
                                                :clj-symbol "clojure.core/update-in",
                                                :docstring "'Updates' a value in a nested associative structure, where ks is a\nsequence of keys and f is a function that will take the old value\nand any supplied args and return the new value, and returns a new\nnested structure.  If any levels do not exist, hash-maps will be\ncreated."},
                         "cljs.core/map-indexed" {:ns "cljs.core",
                                                  :name "map-indexed",
                                                  :signature ["[f coll]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_map-indexed",
                                                  :source {:code "(defn map-indexed\n  [f coll]\n  (let [mapi (fn mpi [idx coll]\n               (lazy-seq\n                (when-let [s (seq coll)]\n                  (cons (f idx (first s))\n                        (mpi (inc idx) (rest s))))))]\n    (mapi 0 coll)))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [1522
                                                                   1533],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1522-L1533"},
                                                  :full-name "cljs.core/map-indexed",
                                                  :clj-symbol "clojure.core/map-indexed",
                                                  :docstring "Returns a lazy sequence consisting of the result of applying f to 0\nand the first item of coll, followed by applying f to 1 and the second\nitem in coll, etc, until coll is exhausted. Thus function f should\naccept 2 arguments, index and item."},
                         "cljs.core/IStack" {:ns "cljs.core",
                                             :name "IStack",
                                             :type "protocol",
                                             :full-name-encode "cljs.core_IStack",
                                             :source {:code "(defprotocol IStack\n  (-peek [coll])\n  (-pop [coll]))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [127 129],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L127-L129"},
                                             :methods [{:name "-peek",
                                                        :signature ["[coll]"],
                                                        :docstring nil}
                                                       {:name "-pop",
                                                        :signature ["[coll]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/IStack",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/IIndexed" {:ns "cljs.core",
                                               :name "IIndexed",
                                               :type "protocol",
                                               :full-name-encode "cljs.core_IIndexed",
                                               :source {:code "(defprotocol IIndexed\n  (-nth [coll n] [coll n not-found]))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [105
                                                                106],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L105-L106"},
                                               :methods [{:name "-nth",
                                                          :signature ["[coll n]"
                                                                      "[coll n not-found]"],
                                                          :docstring nil}],
                                               :full-name "cljs.core/IIndexed",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "clojure.browser.repl/repl-print" {:full-name "clojure.browser.repl/repl-print",
                                                            :ns "clojure.browser.repl",
                                                            :name "repl-print",
                                                            :type "function",
                                                            :signature ["[data]"],
                                                            :source {:code "(defn repl-print [data]\n  (if-let [conn @xpc-connection]\n    (net/transmit conn :print (pr-str data))))",
                                                                     :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                     :lines [23
                                                                             25],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/repl.cljs#L23-L25"},
                                                            :full-name-encode "clojure.browser.repl_repl-print",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "clojure.browser.net/xpc-config-fields" {:full-name "clojure.browser.net/xpc-config-fields",
                                                                  :ns "clojure.browser.net",
                                                                  :name "xpc-config-fields",
                                                                  :type "var",
                                                                  :source {:code "(def xpc-config-fields\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (. k (toLowerCase)))\n            v])\n         (js->clj goog.net.xpc.CfgFields))))",
                                                                           :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                           :lines [75
                                                                                   81],
                                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/net.cljs#L75-L81"},
                                                                  :full-name-encode "clojure.browser.net_xpc-config-fields",
                                                                  :history [["+"
                                                                             "0.0-927"]]},
                         "cljs.core/nnext" {:ns "cljs.core",
                                            :name "nnext",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_nnext",
                                            :source {:code "(defn nnext\n  [coll]\n  (next (next coll)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [415 418],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L415-L418"},
                                            :full-name "cljs.core/nnext",
                                            :clj-symbol "clojure.core/nnext",
                                            :docstring "Same as (next (next x))"},
                         "cljs.core/*print-meta*" {:full-name "cljs.core/*print-meta*",
                                                   :ns "cljs.core",
                                                   :name "*print-meta*",
                                                   :type "var",
                                                   :source {:code "(def *print-meta* false)",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [2858
                                                                    2858],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2858-L2858"},
                                                   :full-name-encode "cljs.core__STAR_print-meta_STAR_",
                                                   :clj-symbol "clojure.core/*print-meta*",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "cljs.reader/read-dispatch" {:full-name "cljs.reader/read-dispatch",
                                                      :ns "cljs.reader",
                                                      :name "read-dispatch",
                                                      :type "function",
                                                      :signature ["[rdr _]"],
                                                      :source {:code "(defn read-dispatch\n  [rdr _]\n  (let [ch (read-char rdr)\n        dm (get dispatch-macros ch)]\n    (if dm\n      (dm rdr _)\n      (reader-error rdr \"No dispatch macro for \" ch))))",
                                                               :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                               :lines [191
                                                                       197],
                                                               :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L191-L197"},
                                                      :full-name-encode "cljs.reader_read-dispatch",
                                                      :history [["+"
                                                                 "0.0-927"]]},
                         "cljs.core/distinct" {:ns "cljs.core",
                                               :name "distinct",
                                               :signature ["[coll]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_distinct",
                                               :source {:code "(defn distinct\n  [coll]\n  (let [step (fn step [xs seen]\n               (lazy-seq\n                ((fn [[f :as xs] seen]\n                   (when-let [s (seq xs)]\n                     (if (contains? seen f)\n                       (recur (rest s) seen)\n                       (cons f (step (rest s) (conj seen f))))))\n                 xs seen)))]\n    (step coll #{})))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [2499
                                                                2510],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2499-L2510"},
                                               :full-name "cljs.core/distinct",
                                               :clj-symbol "clojure.core/distinct",
                                               :docstring "Returns a lazy sequence of the elements of coll with duplicates removed"},
                         "cljs.reader/wrapping-reader" {:full-name "cljs.reader/wrapping-reader",
                                                        :ns "cljs.reader",
                                                        :name "wrapping-reader",
                                                        :type "function",
                                                        :signature ["[sym]"],
                                                        :source {:code "(defn wrapping-reader\n  [sym]\n  (fn [rdr _]\n    (list sym (read rdr true nil true))))",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [277
                                                                         280],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L277-L280"},
                                                        :full-name-encode "cljs.reader_wrapping-reader",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/prn" {:ns "cljs.core",
                                          :name "prn",
                                          :signature ["[& objs]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_prn",
                                          :source {:code "(defn prn\n  [& objs]\n  (pr-with-opts objs (pr-opts))\n  (newline (pr-opts)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [2893 2897],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2893-L2897"},
                                          :full-name "cljs.core/prn",
                                          :clj-symbol "clojure.core/prn",
                                          :docstring "Same as pr followed by (newline)."},
                         "clojure.zip/leftmost" {:ns "clojure.zip",
                                                 :name "leftmost",
                                                 :signature ["[loc]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.zip_leftmost",
                                                 :source {:code "(defn leftmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path (seq l))\n        (with-meta [(first l) (assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))\n        loc)))",
                                                          :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                          :lines [157
                                                                  163],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L157-L163"},
                                                 :full-name "clojure.zip/leftmost",
                                                 :clj-symbol "clojure.zip/leftmost",
                                                 :docstring "Returns the loc of the leftmost sibling of the node at this loc, or self"},
                         "cljs.core/>=" {:ns "cljs.core",
                                         :name ">=",
                                         :signature ["[x]"
                                                     "[x y]"
                                                     "[x y & more]"],
                                         :shadowed-sources ({:code "(defmacro >=\n  ([x] true)\n  ([x y] (list 'js* \"(~{} >= ~{})\" x y))\n  ([x y & more] `(and (>= ~x ~y) (>= ~y ~@more))))",
                                                             :filename "clojurescript/src/clj/cljs/core.clj",
                                                             :lines [93
                                                                     96],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L93-L96"}),
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core__GT__EQ_",
                                         :source {:code "(defn >=\n  ([x] true)\n  ([x y] (js* \"(~{x} >= ~{y})\"))\n  ([x y & more]\n   (if (>= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (>= y (first more)))\n     false)))",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [837 847],
                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L837-L847"},
                                         :full-name "cljs.core/>=",
                                         :clj-symbol "clojure.core/>=",
                                         :docstring "Returns non-nil if nums are in monotonically non-increasing order,\notherwise false."},
                         "cljs.reader/macros" {:full-name "cljs.reader/macros",
                                               :ns "cljs.reader",
                                               :name "macros",
                                               :type "var",
                                               :source {:code "(def macros\n     { \\\" read-string\n       \\: read-keyword\n       \\; not-implemented ;; never hit this\n       \\' (wrapping-reader 'quote)\n       \\@ (wrapping-reader 'deref)\n       \\^ read-meta\n       \\` not-implemented\n       \\~ not-implemented\n       \\( read-list\n       \\) read-unmatched-delimiter\n       \\[ read-vector\n       \\] read-unmatched-delimiter\n       \\{ read-map\n       \\} read-unmatched-delimiter\n       \\\\ read-char\n       \\% not-implemented\n       \\# read-dispatch\n       })",
                                                        :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                        :lines [310
                                                                328],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L310-L328"},
                                               :full-name-encode "cljs.reader_macros",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/doseq" {:ns "cljs.core",
                                            :name "doseq",
                                            :signature ["[seq-exprs & body]"],
                                            :history [["+" "0.0-927"]],
                                            :type "macro",
                                            :full-name-encode "cljs.core_doseq",
                                            :source {:code "(defmacro doseq\n  [seq-exprs & body]\n  (assert-args doseq\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [step (fn step [recform exprs]\n               (if-not exprs\n                 [true `(do ~@body)]\n                 (let [k (first exprs)\n                       v (second exprs)\n                       \n                       seqsym (when-not (keyword? k) (gensym))\n                       recform (if (keyword? k) recform `(recur (first ~seqsym) ~seqsym))\n                       steppair (step recform (nnext exprs))\n                       needrec (steppair 0)\n                       subform (steppair 1)]\n                   (cond\n                     (= k :let) [needrec `(let ~v ~subform)]\n                     (= k :while) [false `(when ~v\n                                            ~subform\n                                            ~@(when needrec [recform]))]\n                     (= k :when) [false `(if ~v\n                                           (do\n                                             ~subform\n                                             ~@(when needrec [recform]))\n                                           ~recform)]\n                     :else [true `(let [~seqsym (seq ~v)]\n                                    (when ~seqsym\n                                      (loop [~k (first ~seqsym) ~seqsym ~seqsym]\n                                       ~subform\n                                       (when-let [~seqsym (next ~seqsym)]\n                                        ~@(when needrec [recform])))))]))))]\n    (nth (step nil (seq seq-exprs)) 1)))",
                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                     :lines [571 606],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L571-L606"},
                                            :full-name "cljs.core/doseq",
                                            :clj-symbol "clojure.core/doseq",
                                            :docstring "Repeatedly executes body (presumably for side-effects) with\nbindings and filtering as provided by \"for\".  Does not retain\nthe head of the sequence. Returns nil."},
                         "cljs.core/*" {:ns "cljs.core",
                                        :name "*",
                                        :signature ["[]"
                                                    "[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :shadowed-sources ({:code "(defmacro *\n  ([] 1)\n  ([x] x)\n  ([x y] (list 'js* \"(~{} * ~{})\" x y))\n  ([x y & more] `(* (* ~x ~y) ~@more)))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [66
                                                                    70],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L66-L70"}),
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core__STAR_",
                                        :source {:code "(defn *\n  ([] 1)\n  ([x] x)\n  ([x y] (js* \"(~{x} * ~{y})\"))\n  ([x y & more] (reduce * (* x y) more)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [787 792],
                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L787-L792"},
                                        :full-name "cljs.core/*",
                                        :clj-symbol "clojure.core/*",
                                        :docstring "Returns the product of nums. (*) returns 1."},
                         "cljs.core/into" {:ns "cljs.core",
                                           :name "into",
                                           :signature ["[to from]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_into",
                                           :source {:code "(defn into\n  [to from]\n  (reduce -conj to from))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1825 1829],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1825-L1829"},
                                           :full-name "cljs.core/into",
                                           :clj-symbol "clojure.core/into",
                                           :docstring "Returns a new coll consisting of to-coll with all of the items of\nfrom-coll conjoined."},
                         "cljs.core/defmethod" {:ns "cljs.core",
                                                :name "defmethod",
                                                :signature ["[multifn dispatch-val & fn-tail]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "macro",
                                                :full-name-encode "cljs.core_defmethod",
                                                :source {:code "(defmacro defmethod\n  [multifn dispatch-val & fn-tail]\n  `(-add-method ~(with-meta multifn {:tag 'cljs.core.MultiFn}) ~dispatch-val (fn ~@fn-tail)))",
                                                         :filename "clojurescript/src/clj/cljs/core.clj",
                                                         :lines [704
                                                                 707],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L704-L707"},
                                                :full-name "cljs.core/defmethod",
                                                :clj-symbol "clojure.core/defmethod",
                                                :docstring "Creates and installs a new method of multimethod associated with dispatch-value. "},
                         "cljs.core/rest" {:ns "cljs.core",
                                           :name "rest",
                                           :signature ["[coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_rest",
                                           :source {:code "(defn rest\n  [coll]\n  (-rest (seq coll)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [382 386],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L382-L386"},
                                           :full-name "cljs.core/rest",
                                           :clj-symbol "clojure.core/rest",
                                           :docstring "Returns a possibly empty seq of the items after the first. Calls seq on its\nargument."},
                         "cljs.core/dotimes" {:ns "cljs.core",
                                              :name "dotimes",
                                              :signature ["[bindings & body]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "macro",
                                              :full-name-encode "cljs.core_dotimes",
                                              :source {:code "(defmacro dotimes\n  [bindings & body]\n  (let [i (first bindings)\n        n (second bindings)]\n    `(let [n# ~n]\n       (loop [~i 0]\n         (when (< ~i n#)\n           ~@body\n           (recur (inc ~i)))))))",
                                                       :filename "clojurescript/src/clj/cljs/core.clj",
                                                       :lines [634
                                                               646],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L634-L646"},
                                              :full-name "cljs.core/dotimes",
                                              :clj-symbol "clojure.core/dotimes",
                                              :docstring "bindings => name n\n\nRepeatedly executes body (presumably for side-effects) with name\nbound to integers from 0 through n-1."},
                         "clojure.zip/lefts" {:ns "clojure.zip",
                                              :name "lefts",
                                              :signature ["[loc]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.zip_lefts",
                                              :source {:code "(defn lefts\n  [loc]\n    (seq (:l (loc 1))))",
                                                       :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                       :lines [87 90],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L87-L90"},
                                              :full-name "clojure.zip/lefts",
                                              :clj-symbol "clojure.zip/lefts",
                                              :docstring "Returns a seq of the left siblings of this loc"},
                         "clojure.browser.dom/ensure-element" {:full-name "clojure.browser.dom/ensure-element",
                                                               :ns "clojure.browser.dom",
                                                               :name "ensure-element",
                                                               :docstring "Coerce the argument to a dom element if possible.",
                                                               :type "function",
                                                               :signature ["[e]"],
                                                               :source {:code "(defn ensure-element\n  [e]\n  (cond (keyword? e) (get-element e)\n        (string? e) (html->dom e)\n        :else e))",
                                                                        :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                        :lines [105
                                                                                110],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/dom.cljs#L105-L110"},
                                                               :full-name-encode "clojure.browser.dom_ensure-element",
                                                               :history [["+"
                                                                          "0.0-927"]]},
                         "cljs.core/defmacro" {:ns "cljs.core",
                                               :name "defmacro",
                                               :signature ["[name doc-string? attr-map? [params*] body]"
                                                           "[name doc-string? attr-map? ([params*] body) + attr-map?]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "macro",
                                               :full-name-encode "cljs.core_defmacro",
                                               :source {:code "(def\n\n ^{:doc \"Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.\"\n   :arglists '([name doc-string? attr-map? [params*] body]\n                 [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :added \"1.0\"}\n defmacro (fn [&form &env \n                name & args]\n             (let [prefix (loop [p (list name) args args]\n                            (let [f (first args)]\n                              (if (string? f)\n                                (recur (cons f p) (next args))\n                                (if (map? f)\n                                  (recur (cons f p) (next args))\n                                  p))))\n                   fdecl (loop [fd args]\n                           (if (string? (first fd))\n                             (recur (next fd))\n                             (if (map? (first fd))\n                               (recur (next fd))\n                               fd)))\n                   fdecl (if (vector? (first fdecl))\n                           (list fdecl)\n                           fdecl)\n                   add-implicit-args (fn [fd]\n                             (let [args (first fd)]\n                               (cons (vec (cons '&form (cons '&env args))) (next fd))))\n                   add-args (fn [acc ds]\n                              (if (nil? ds)\n                                acc\n                                (let [d (first ds)]\n                                  (if (map? d)\n                                    (conj acc d)\n                                    (recur (conj acc (add-implicit-args d)) (next ds))))))\n                   fdecl (seq (add-args [] fdecl))\n                   decl (loop [p prefix d fdecl]\n                          (if p\n                            (recur (next p) (cons (first p) d))\n                            d))]\n               (list 'do\n                     (cons `defn decl)\n                     (list '. (list 'var name) '(setMacro))\n                     (list 'var name)))))",
                                                        :filename "clojure/src/clj/clojure/core.clj",
                                                        :lines [405
                                                                449],
                                                        :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L405-L449"},
                                               :full-name "cljs.core/defmacro",
                                               :clj-symbol "clojure.core/defmacro",
                                               :docstring "Like defn, but the resulting function name is declared as a\nmacro and will be used as a macro by the compiler when it is\ncalled."},
                         "cljs.core/remove" {:ns "cljs.core",
                                             :name "remove",
                                             :signature ["[pred coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_remove",
                                             :source {:code "(defn remove\n  [pred coll]\n  (filter (complement pred) coll))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1796
                                                              1800],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1796-L1800"},
                                             :full-name "cljs.core/remove",
                                             :clj-symbol "clojure.core/remove",
                                             :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns false. pred must be free of side-effects."},
                         "cljs.core/if-not" {:ns "cljs.core",
                                             :name "if-not",
                                             :signature ["[test then]"
                                                         "[test then else]"],
                                             :history [["+" "0.0-927"]],
                                             :type "macro",
                                             :full-name-encode "cljs.core_if-not",
                                             :source {:code "(defmacro if-not\n  ([test then] `(if-not ~test ~then nil))\n  ([test then else]\n   `(if (not ~test) ~then ~else)))",
                                                      :filename "clojure/src/clj/clojure/core.clj",
                                                      :lines [702 708],
                                                      :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L702-L708"},
                                             :full-name "cljs.core/if-not",
                                             :clj-symbol "clojure.core/if-not",
                                             :docstring "Evaluates test. If logical false, evaluates and returns then expr, \notherwise else expr, if supplied, else nil."},
                         "clojure.zip/path" {:ns "clojure.zip",
                                             :name "path",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_path",
                                             :source {:code "(defn path\n  [loc]\n    (:pnodes (loc 1)))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [82 85],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L82-L85"},
                                             :full-name "clojure.zip/path",
                                             :clj-symbol "clojure.zip/path",
                                             :docstring "Returns a seq of nodes leading to this loc"},
                         "cljs.core/mapcat" {:ns "cljs.core",
                                             :name "mapcat",
                                             :signature ["[f coll]"
                                                         "[f coll & colls]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_mapcat",
                                             :source {:code "(defn mapcat\n  ([f coll]\n    (flatten1 (map f coll)))\n  ([f coll & colls]\n    (flatten1 (apply map f coll colls))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1777
                                                              1783],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1777-L1783"},
                                             :full-name "cljs.core/mapcat",
                                             :clj-symbol "clojure.core/mapcat",
                                             :docstring "Returns the result of applying concat to the result of applying map\nto f and colls.  Thus function f should return a collection."},
                         "cljs.core/IWatchable" {:ns "cljs.core",
                                                 :name "IWatchable",
                                                 :type "protocol",
                                                 :full-name-encode "cljs.core_IWatchable",
                                                 :source {:code "(defprotocol IWatchable\n  (-notify-watches [this oldval newval])\n  (-add-watch [this key f])\n  (-remove-watch [this key]))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [170
                                                                  173],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L170-L173"},
                                                 :methods [{:name "-notify-watches",
                                                            :signature ["[this oldval newval]"],
                                                            :docstring nil}
                                                           {:name "-add-watch",
                                                            :signature ["[this key f]"],
                                                            :docstring nil}
                                                           {:name "-remove-watch",
                                                            :signature ["[this key]"],
                                                            :docstring nil}],
                                                 :full-name "cljs.core/IWatchable",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "clojure.zip/rightmost" {:ns "clojure.zip",
                                                  :name "rightmost",
                                                  :signature ["[loc]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.zip_rightmost",
                                                  :source {:code "(defn rightmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path r)\n        (with-meta [(last r) (assoc path :l (apply conj l node (butlast r)) :r nil)] (meta loc))\n        loc)))",
                                                           :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                           :lines [142
                                                                   148],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L142-L148"},
                                                  :full-name "clojure.zip/rightmost",
                                                  :clj-symbol "clojure.zip/rightmost",
                                                  :docstring "Returns the loc of the rightmost sibling of the node at this loc, or self"},
                         "cljs.core/->" {:ns "cljs.core",
                                         :name "->",
                                         :signature ["[x]"
                                                     "[x form]"
                                                     "[x form & more]"],
                                         :history [["+" "0.0-927"]],
                                         :type "macro",
                                         :full-name-encode "cljs.core_-_GT_",
                                         :source {:code "(defmacro ->\n  ([x] x)\n  ([x form] (if (seq? form)\n              (with-meta `(~(first form) ~x ~@(next form)) (meta form))\n              (list form x)))\n  ([x form & more] `(-> (-> ~x ~form) ~@more)))",
                                                  :filename "clojure/src/clj/clojure/core.clj",
                                                  :lines [1528 1538],
                                                  :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L1528-L1538"},
                                         :full-name "cljs.core/->",
                                         :clj-symbol "clojure.core/->",
                                         :docstring "Threads the expr through the forms. Inserts x as the\nsecond item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nsecond item in second form, etc."},
                         "cljs.core/remove-all-methods" {:ns "cljs.core",
                                                         :name "remove-all-methods",
                                                         :signature ["[multifn]"],
                                                         :history [["+"
                                                                    "0.0-927"]],
                                                         :type "function",
                                                         :full-name-encode "cljs.core_remove-all-methods",
                                                         :source {:code "(defn remove-all-methods\n [multifn]\n (-reset multifn))",
                                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                  :lines [3478
                                                                          3481],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3478-L3481"},
                                                         :full-name "cljs.core/remove-all-methods",
                                                         :clj-symbol "clojure.core/remove-all-methods",
                                                         :docstring "Removes all of the methods of multimethod."},
                         "clojure.string/replace-first" {:ns "clojure.string",
                                                         :name "replace-first",
                                                         :signature ["[s match replacement]"],
                                                         :history [["+"
                                                                    "0.0-927"]],
                                                         :type "function",
                                                         :full-name-encode "clojure.string_replace-first",
                                                         :source {:code "(defn replace-first\n  [s match replacement]\n  (.replace s match replacement))",
                                                                  :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                                  :lines [36
                                                                          43],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/string.cljs#L36-L43"},
                                                         :full-name "clojure.string/replace-first",
                                                         :clj-symbol "clojure.string/replace-first",
                                                         :docstring "Replaces the first instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
                         "clojure.browser.dom/get-value" {:full-name "clojure.browser.dom/get-value",
                                                          :ns "clojure.browser.dom",
                                                          :name "get-value",
                                                          :docstring "Get the value of an element.",
                                                          :type "function",
                                                          :signature ["[e]"],
                                                          :source {:code "(defn get-value\n  [e]\n  (.-value (ensure-element e)))",
                                                                   :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                   :lines [129
                                                                           132],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/dom.cljs#L129-L132"},
                                                          :full-name-encode "clojure.browser.dom_get-value",
                                                          :history [["+"
                                                                     "0.0-927"]]},
                         "cljs.nodejs/process" {:full-name "cljs.nodejs/process",
                                                :ns "cljs.nodejs",
                                                :name "process",
                                                :type "var",
                                                :source {:code "(def process (js* \"process\"))",
                                                         :filename "clojurescript/src/cljs/cljs/nodejs.cljs",
                                                         :lines [8 8],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/nodejs.cljs#L8-L8"},
                                                :full-name-encode "cljs.nodejs_process",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/not=" {:ns "cljs.core",
                                           :name "not=",
                                           :signature ["[x]"
                                                       "[x y]"
                                                       "[x y & more]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_not_EQ_",
                                           :source {:code "(defn not=\n  ([x] false)\n  ([x y] (not (= x y)))\n  ([x y & more]\n   (not (apply = x y more))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1392 1397],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1392-L1397"},
                                           :full-name "cljs.core/not=",
                                           :clj-symbol "clojure.core/not=",
                                           :docstring "Same as (not (= obj1 obj2))"},
                         "cljs.core/js-keys" {:full-name "cljs.core/js-keys",
                                              :ns "cljs.core",
                                              :name "js-keys",
                                              :type "function",
                                              :signature ["[obj]"],
                                              :source {:code "(defn js-keys [obj]\n  (let [keys (array)]\n    (goog.object/forEach obj (fn [val key obj] (.push keys key)))\n    keys))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [592
                                                               595],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L592-L595"},
                                              :full-name-encode "cljs.core_js-keys",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "clojure.zip/seq-zip" {:ns "clojure.zip",
                                                :name "seq-zip",
                                                :signature ["[root]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.zip_seq-zip",
                                                :source {:code "(defn seq-zip\n  [root]\n    (zipper seq?\n            identity\n            (fn [node children] (with-meta children (meta node)))\n            root))",
                                                         :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                         :lines [34
                                                                 40],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L34-L40"},
                                                :full-name "clojure.zip/seq-zip",
                                                :clj-symbol "clojure.zip/seq-zip",
                                                :docstring "Returns a zipper for nested sequences, given a root sequence"},
                         "cljs.core/IVector" {:ns "cljs.core",
                                              :name "IVector",
                                              :type "protocol",
                                              :full-name-encode "cljs.core_IVector",
                                              :source {:code "(defprotocol IVector\n  (-assoc-n [coll n val]))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [131
                                                               132],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L131-L132"},
                                              :methods [{:name "-assoc-n",
                                                         :signature ["[coll n val]"],
                                                         :docstring nil}],
                                              :full-name "cljs.core/IVector",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/empty" {:ns "cljs.core",
                                            :name "empty",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_empty",
                                            :source {:code "(defn empty\n  [coll]\n  (-empty coll))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [453 456],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L453-L456"},
                                            :full-name "cljs.core/empty",
                                            :clj-symbol "clojure.core/empty",
                                            :docstring "Returns an empty collection of the same category as coll, or nil"},
                         "cljs.core/re-matches" {:ns "cljs.core",
                                                 :name "re-matches",
                                                 :signature ["[re s]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_re-matches",
                                                 :source {:code "(defn re-matches\n  [re s]\n  (let [matches (.exec re s)]\n    (when (= (first matches) s)\n      (if (= (count matches) 1)\n        (first matches)\n        (vec matches)))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2764
                                                                  2771],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2764-L2771"},
                                                 :full-name "cljs.core/re-matches",
                                                 :clj-symbol "clojure.core/re-matches",
                                                 :docstring "Returns the result of (re-find re s) if re fully matches s."},
                         "clojure.browser.dom/DOMBuilder" {:ns "clojure.browser.dom",
                                                           :name "DOMBuilder",
                                                           :type "protocol",
                                                           :full-name-encode "clojure.browser.dom_DOMBuilder",
                                                           :source {:code "(defprotocol DOMBuilder\n  (-element [this] [this attrs-or-children] [this attrs children]))",
                                                                    :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                    :lines [16
                                                                            17],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/dom.cljs#L16-L17"},
                                                           :methods [{:name "-element",
                                                                      :signature ["[this]"
                                                                                  "[this attrs-or-children]"
                                                                                  "[this attrs children]"],
                                                                      :docstring nil}],
                                                           :full-name "clojure.browser.dom/DOMBuilder",
                                                           :history [["+"
                                                                      "0.0-927"]]},
                         "cljs.core/fixture1" {:full-name "cljs.core/fixture1",
                                               :ns "cljs.core",
                                               :name "fixture1",
                                               :type "var",
                                               :source {:code "(def fixture1 1)",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [3130
                                                                3130],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3130-L3130"},
                                               :full-name-encode "cljs.core_fixture1",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/extend-type" {:full-name "cljs.core/extend-type",
                                                  :ns "cljs.core",
                                                  :name "extend-type",
                                                  :type "macro",
                                                  :signature ["[tsym & impls]"],
                                                  :source {:code "(defmacro extend-type [tsym & impls]\n  (let [resolve #(let [ret (:name (cljs.compiler/resolve-var (dissoc &env :locals) %))]\n                   (assert ret (str \"Can't resolve: \" %))\n                   ret)\n        impl-map (loop [ret {} s impls]\n                   (if (seq s)\n                     (recur (assoc ret (first s) (take-while seq? (next s)))\n                            (drop-while seq? (next s)))\n                     ret))]\n    (if (base-type tsym)\n      (let [t (base-type tsym)\n            assign-impls (fn [[p sigs]]\n                           (let [psym (resolve p)\n\t\t\t\t pfn-prefix (subs (str psym) 0 (clojure.core/inc (.lastIndexOf (str psym) \".\")))]\n                             (cons `(aset ~psym ~t true)\n                                   (map (fn [[f & meths]]\n                                          `(aset ~(symbol (str pfn-prefix f)) ~t (fn* ~@meths)))\n                                        sigs))))]\n        `(do ~@(mapcat assign-impls impl-map)))\n      (let [t (resolve tsym)\n            prototype-prefix (str t \".prototype.\")\n            assign-impls (fn [[p sigs]]\n                           (let [psym (resolve p)\n\t\t\t\t pprefix (protocol-prefix psym)]\n\t\t\t     (if (= p 'Object)\n\t\t\t       (let [adapt-params (fn [[sig & body]]\n\t\t\t\t\t\t    (let [[tname & args] sig]\n\t\t\t\t\t\t      (list (with-meta (vec args) (meta sig))\n\t\t\t\t\t\t\t    (list* 'this-as tname body))))]\n\t\t\t\t (map (fn [[f & meths]]\n\t\t\t\t\t`(set! ~(symbol (str prototype-prefix f)) (fn* ~@(map adapt-params meths))))\n\t\t\t\t      sigs))\n\t\t\t       (cons `(set! ~(symbol (str prototype-prefix pprefix)) true)\n\t\t\t\t     (map (fn [[f & meths]]\n\t\t\t\t\t    `(set! ~(symbol (str prototype-prefix pprefix f)) (fn* ~@meths)))\n\t\t\t\t\t  sigs)))))]\n        `(do ~@(mapcat assign-impls impl-map))))))",
                                                           :filename "clojurescript/src/clj/cljs/core.clj",
                                                           :lines [198
                                                                   234],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L198-L234"},
                                                  :full-name-encode "cljs.core_extend-type",
                                                  :clj-symbol "clojure.core/extend-type",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/ISeqable" {:ns "cljs.core",
                                               :name "ISeqable",
                                               :type "protocol",
                                               :full-name-encode "cljs.core_ISeqable",
                                               :source {:code "(defprotocol ISeqable\n  (-seq [o]))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [155
                                                                156],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L155-L156"},
                                               :methods [{:name "-seq",
                                                          :signature ["[o]"],
                                                          :docstring nil}],
                                               :full-name "cljs.core/ISeqable",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/assoc" {:ns "cljs.core",
                                            :name "assoc",
                                            :signature ["[coll k v]"
                                                        "[coll k v & kvs]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_assoc",
                                            :source {:code "(defn assoc\n  ([coll k v]\n     (-assoc coll k v))\n  ([coll k v & kvs]\n     (let [ret (assoc coll k v)]\n       (if kvs\n         (recur ret (first kvs) (second kvs) (nnext kvs))\n         ret))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [481 492],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L481-L492"},
                                            :full-name "cljs.core/assoc",
                                            :clj-symbol "clojure.core/assoc",
                                            :docstring "assoc[iate]. When applied to a map, returns a new map of the\nsame (hashed/sorted) type, that contains the mapping of key(s) to\nval(s). When applied to a vector, returns a new vector that\ncontains val at index."},
                         "clojure.browser.repl/xpc-connection" {:full-name "clojure.browser.repl/xpc-connection",
                                                                :ns "clojure.browser.repl",
                                                                :name "xpc-connection",
                                                                :type "var",
                                                                :source {:code "(def xpc-connection (atom nil))",
                                                                         :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                         :lines [21
                                                                                 21],
                                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/repl.cljs#L21-L21"},
                                                                :full-name-encode "clojure.browser.repl_xpc-connection",
                                                                :history [["+"
                                                                           "0.0-927"]]},
                         "cljs.core/IDerefWithTimeout" {:ns "cljs.core",
                                                        :name "IDerefWithTimeout",
                                                        :type "protocol",
                                                        :full-name-encode "cljs.core_IDerefWithTimeout",
                                                        :source {:code "(defprotocol IDerefWithTimeout\n  (-deref-with-timeout [o msec timeout-val]))",
                                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                 :lines [137
                                                                         138],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L137-L138"},
                                                        :methods [{:name "-deref-with-timeout",
                                                                   :signature ["[o msec timeout-val]"],
                                                                   :docstring nil}],
                                                        :full-name "cljs.core/IDerefWithTimeout",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "clojure.browser.repl/start-evaluator" {:full-name "clojure.browser.repl/start-evaluator",
                                                                 :ns "clojure.browser.repl",
                                                                 :name "start-evaluator",
                                                                 :docstring "Start the REPL server connection.",
                                                                 :type "function",
                                                                 :signature ["[url]"],
                                                                 :source {:code "(defn start-evaluator\n  [url]\n  (if-let [repl-connection (net/xpc-connection)]\n    (let [connection (net/xhr-connection)]\n      (event/listen connection\n                    :success\n                    (fn [e]\n                      (net/transmit\n                       repl-connection\n                       :evaluate-javascript\n                       (.getResponseText e/currentTarget\n                                         ()))))\n\n      (net/register-service repl-connection\n                            :send-result\n                            (fn [data]\n                              (send-result connection url (wrap-message :result data))))\n\n      (net/register-service repl-connection\n                            :print\n                            (fn [data]\n                              (send-print url (wrap-message :print data))))\n      \n      (net/connect repl-connection\n                   (constantly nil))\n\n      (js/setTimeout #(send-result connection url (wrap-message :ready \"ready\")) 50))\n    (js/alert \"No 'xpc' param provided to child iframe.\")))",
                                                                          :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                          :lines [60
                                                                                  88],
                                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/repl.cljs#L60-L88"},
                                                                 :full-name-encode "clojure.browser.repl_start-evaluator",
                                                                 :history [["+"
                                                                            "0.0-927"]]},
                         "clojure.browser.event/unlisten" {:full-name "clojure.browser.event/unlisten",
                                                           :ns "clojure.browser.event",
                                                           :name "unlisten",
                                                           :type "function",
                                                           :signature ["[src type fn]"
                                                                       "[src type fn capture?]"],
                                                           :source {:code "(defn unlisten\n  ([src type fn]\n     (unlisten src type fn false))\n  ([src type fn capture?]\n     (goog.events/unlisten src\n                           (get (event-types src) type type)\n                           fn\n                           capture?)))",
                                                                    :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                    :lines [62
                                                                            69],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/event.cljs#L62-L69"},
                                                           :full-name-encode "clojure.browser.event_unlisten",
                                                           :history [["+"
                                                                      "0.0-927"]]},
                         "cljs.core/fnil" {:ns "cljs.core",
                                           :name "fnil",
                                           :signature ["[f x]"
                                                       "[f x y]"
                                                       "[f x y z]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_fnil",
                                           :source {:code "(defn fnil\n  ([f x]\n   (fn\n     ([a] (f (if (nil? a) x a)))\n     ([a b] (f (if (nil? a) x a) b))\n     ([a b c] (f (if (nil? a) x a) b c))\n     ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n  ([f x y]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n  ([f x y z]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1499 1520],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1499-L1520"},
                                           :full-name "cljs.core/fnil",
                                           :clj-symbol "clojure.core/fnil",
                                           :docstring "Takes a function f, and returns a function that calls f, replacing\na nil first argument to f with the supplied value x. Higher arity\nversions can replace arguments in the second and third\npositions (y, z). Note that the function f can take any number of\narguments, not just the one(s) being nil-patched."},
                         "cljs.core/this-as" {:full-name "cljs.core/this-as",
                                              :ns "cljs.core",
                                              :name "this-as",
                                              :docstring "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided.",
                                              :type "macro",
                                              :signature ["[name & body]"],
                                              :source {:code "(defmacro this-as\n  [name & body]\n  `(let [~name (~'js* \"this\")]\n     ~@body))",
                                                       :filename "clojurescript/src/clj/cljs/core.clj",
                                                       :lines [192
                                                               196],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L192-L196"},
                                              :full-name-encode "cljs.core_this-as",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/PersistentQueueSeq" {:full-name "cljs.core/PersistentQueueSeq",
                                                         :ns "cljs.core",
                                                         :name "PersistentQueueSeq",
                                                         :type "type",
                                                         :signature ["[meta front rear]"],
                                                         :source {:code "(deftype PersistentQueueSeq [meta front rear]\n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueueSeq. meta front rear))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (-first front))\n  (-rest  [coll]\n    (if-let [f1 (next front)]\n      (PersistentQueueSeq. meta f1 rear)\n      (if (nil? rear)\n        (-empty coll)\n        (PersistentQueueSeq. meta rear nil))))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] coll))",
                                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                  :lines [2070
                                                                          2100],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2070-L2100"},
                                                         :full-name-encode "cljs.core_PersistentQueueSeq",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "cljs.core/counted?" {:ns "cljs.core",
                                               :name "counted?",
                                               :signature ["[x]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_counted_QMARK_",
                                               :source {:code "(defn counted?\n  [x] (satisfies? ICounted x))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [573
                                                                575],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L573-L575"},
                                               :full-name "cljs.core/counted?",
                                               :clj-symbol "clojure.core/counted?",
                                               :docstring "Returns true if coll implements count in constant time"},
                         "clojure.string/trimr" {:ns "clojure.string",
                                                 :name "trimr",
                                                 :signature ["[s]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.string_trimr",
                                                 :source {:code "(defn trimr\n    [s]\n    (gstring/trimRight s))",
                                                          :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                          :lines [116
                                                                  119],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/string.cljs#L116-L119"},
                                                 :full-name "clojure.string/trimr",
                                                 :clj-symbol "clojure.string/trimr",
                                                 :docstring "Removes whitespace from the right side of string."},
                         "cljs.core/force" {:ns "cljs.core",
                                            :name "force",
                                            :signature ["[x]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_force",
                                            :source {:code "(defn force\n  [x]\n  (if (delay? x)\n    (deref x)\n    x))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [3159
                                                             3164],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3159-L3164"},
                                            :full-name "cljs.core/force",
                                            :clj-symbol "clojure.core/force",
                                            :docstring "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"},
                         "cljs.core/compare-and-set!" {:ns "cljs.core",
                                                       :name "compare-and-set!",
                                                       :signature ["[a oldval newval]"],
                                                       :history [["+"
                                                                  "0.0-927"]],
                                                       :type "function",
                                                       :full-name-encode "cljs.core_compare-and-set_BANG_",
                                                       :source {:code "(defn compare-and-set!\n  [a oldval newval]\n  (if (= a.state oldval)\n    (do (reset! a newval) true)\n    false))",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [3038
                                                                        3045],
                                                                :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3038-L3045"},
                                                       :full-name "cljs.core/compare-and-set!",
                                                       :clj-symbol "clojure.core/compare-and-set!",
                                                       :docstring "Atomically sets the value of atom to newval if and only if the\ncurrent value of the atom is identical to oldval. Returns true if\nset happened, else false."},
                         "cljs.core/set?" {:ns "cljs.core",
                                           :name "set?",
                                           :signature ["[x]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_set_QMARK_",
                                           :source {:code "(defn set?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ISet x)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [558 563],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L558-L563"},
                                           :full-name "cljs.core/set?",
                                           :clj-symbol "clojure.core/set?",
                                           :docstring "Returns true if x satisfies ISet"},
                         "clojure.string/escape" {:ns "clojure.string",
                                                  :name "escape",
                                                  :signature ["[s cmap]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.string_escape",
                                                  :source {:code "(defn escape\n  [s cmap]\n  (let [buffer (gstring/StringBuffer.)\n        length (.-length s)]\n    (loop [index 0]\n      (if (= length index)\n        (. buffer (toString))\n        (let [ch (.charAt s index)]\n          (if-let [replacement (get cmap ch)]\n            (.append buffer (str replacement))\n            (.append buffer ch))\n          (recur (inc index)))))))",
                                                           :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                           :lines [144
                                                                   160],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/string.cljs#L144-L160"},
                                                  :full-name "clojure.string/escape",
                                                  :clj-symbol "clojure.string/escape",
                                                  :docstring "Return a new string, using cmap to escape each character ch\nfrom s as follows:\n\nIf (cmap ch) is nil, append ch to the new string.\nIf (cmap ch) is non-nil, append (str (cmap ch)) instead."},
                         "cljs.core/remove-watch" {:ns "cljs.core",
                                                   :name "remove-watch",
                                                   :signature ["[iref key]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.core_remove-watch",
                                                   :source {:code "(defn remove-watch\n  [iref key]\n  (-remove-watch iref key))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [3107
                                                                    3112],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3107-L3112"},
                                                   :full-name "cljs.core/remove-watch",
                                                   :clj-symbol "clojure.core/remove-watch",
                                                   :docstring "Alpha - subject to change.\n\nRemoves a watch (set by add-watch) from a reference"},
                         "cljs.core/IMultiFn" {:ns "cljs.core",
                                               :name "IMultiFn",
                                               :type "protocol",
                                               :full-name-encode "cljs.core_IMultiFn",
                                               :source {:code "(defprotocol IMultiFn\n  (-reset [mf])\n  (-add-method [mf dispatch-val method])\n  (-remove-method [mf dispatch-val])\n  (-prefer-method [mf dispatch-val dispatch-val-y])\n  (-get-method [mf dispatch-val])\n  (-methods [mf])\n  (-prefers [mf])\n  (-invoke [mf args]))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [3408
                                                                3416],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3408-L3416"},
                                               :methods [{:name "-reset",
                                                          :signature ["[mf]"],
                                                          :docstring nil}
                                                         {:name "-add-method",
                                                          :signature ["[mf dispatch-val method]"],
                                                          :docstring nil}
                                                         {:name "-remove-method",
                                                          :signature ["[mf dispatch-val]"],
                                                          :docstring nil}
                                                         {:name "-prefer-method",
                                                          :signature ["[mf dispatch-val dispatch-val-y]"],
                                                          :docstring nil}
                                                         {:name "-get-method",
                                                          :signature ["[mf dispatch-val]"],
                                                          :docstring nil}
                                                         {:name "-methods",
                                                          :signature ["[mf]"],
                                                          :docstring nil}
                                                         {:name "-prefers",
                                                          :signature ["[mf]"],
                                                          :docstring nil}
                                                         {:name "-invoke",
                                                          :signature ["[mf args]"],
                                                          :docstring nil}],
                                               :full-name "cljs.core/IMultiFn",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "clojure.zip/end?" {:ns "clojure.zip",
                                             :name "end?",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_end_QMARK_",
                                             :source {:code "(defn end?\n  [loc]\n    (= :end (loc 1)))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [232 235],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L232-L235"},
                                             :full-name "clojure.zip/end?",
                                             :clj-symbol "clojure.zip/end?",
                                             :docstring "Returns true if loc represents the end of a depth-first walk"},
                         "clojure.set/superset?" {:ns "clojure.set",
                                                  :name "superset?",
                                                  :signature ["[set1 set2]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.set_superset_QMARK_",
                                                  :source {:code "(defn superset? \n  [set1 set2]\n  (and (>= (count set1) (count set2))\n       (every? #(contains? set1 %) set2)))",
                                                           :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                           :lines [138
                                                                   142],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/set.cljs#L138-L142"},
                                                  :full-name "clojure.set/superset?",
                                                  :clj-symbol "clojure.set/superset?",
                                                  :docstring "Is set1 a superset of set2?"},
                         "clojure.browser.net/IConnection" {:ns "clojure.browser.net",
                                                            :name "IConnection",
                                                            :type "protocol",
                                                            :full-name-encode "clojure.browser.net_IConnection",
                                                            :source {:code "(defprotocol IConnection\n  (connect\n    [this]\n    [this opt1]\n    [this opt1 opt2]\n    [this opt1 opt2 opt3])\n  (transmit\n    [this opt]\n    [this opt opt2]\n    [this opt opt2 opt3]\n    [this opt opt2 opt3 opt4]\n    [this opt opt2 opt3 opt4 opt5])\n  (close [this]))",
                                                                     :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                     :lines [32
                                                                             44],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/net.cljs#L32-L44"},
                                                            :methods [{:name "connect",
                                                                       :signature ["[this]"
                                                                                   "[this opt1]"
                                                                                   "[this opt1 opt2]"
                                                                                   "[this opt1 opt2 opt3]"],
                                                                       :docstring nil}
                                                                      {:name "transmit",
                                                                       :signature ["[this opt]"
                                                                                   "[this opt opt2]"
                                                                                   "[this opt opt2 opt3]"
                                                                                   "[this opt opt2 opt3 opt4]"
                                                                                   "[this opt opt2 opt3 opt4 opt5]"],
                                                                       :docstring nil}
                                                                      {:name "close",
                                                                       :signature ["[this]"],
                                                                       :docstring nil}],
                                                            :full-name "clojure.browser.net/IConnection",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "cljs.core/let" {:ns "cljs.core",
                                          :name "let",
                                          :signature ["[bindings & body]"],
                                          :shadowed-sources ({:code "(def\n  ^{:macro true\n    :added \"1.0\"}\n  let (fn* let [&form &env & decl] (cons 'let* decl)))",
                                                              :filename "clojure/src/clj/clojure/core.clj",
                                                              :lines [32
                                                                      35],
                                                              :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L32-L35"}),
                                          :history [["+" "0.0-927"]],
                                          :type "macro",
                                          :full-name-encode "cljs.core_let",
                                          :source {:code "(defmacro let\n  [bindings & body]\n  (assert-args let\n     (vector? bindings) \"a vector for its binding\"\n     (even? (count bindings)) \"an even number of forms in binding vector\")\n  `(let* ~(destructure bindings) ~@body))",
                                                   :filename "clojure/src/clj/clojure/core.clj",
                                                   :lines [3953 3964],
                                                   :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L3953-L3964"},
                                          :full-name "cljs.core/let",
                                          :clj-symbol "clojure.core/let",
                                          :docstring "binding => binding-form init-expr\n\nEvaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein."},
                         "cljs.core/dorun" {:ns "cljs.core",
                                            :name "dorun",
                                            :signature ["[coll]"
                                                        "[n coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_dorun",
                                            :source {:code "(defn dorun\n  ([coll]\n   (when (seq coll)\n     (recur (next coll))))\n  ([n coll]\n   (when (and (seq coll) (pos? n))\n     (recur (dec n) (next coll)))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2735
                                                             2746],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2735-L2746"},
                                            :full-name "cljs.core/dorun",
                                            :clj-symbol "clojure.core/dorun",
                                            :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. dorun can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, does not retain the head and returns nil."},
                         "cljs.core/pr-str" {:ns "cljs.core",
                                             :name "pr-str",
                                             :signature ["[& objs]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_pr-str",
                                             :source {:code "(defn pr-str\n  [& objs]\n  (pr-str-with-opts objs (pr-opts)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2867
                                                              2870],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2867-L2870"},
                                             :full-name "cljs.core/pr-str",
                                             :clj-symbol "clojure.core/pr-str",
                                             :docstring "pr to a string, returning it. Fundamental entrypoint to IPrintable."},
                         "cljs.core/IPrintable" {:ns "cljs.core",
                                                 :name "IPrintable",
                                                 :type "protocol",
                                                 :full-name-encode "cljs.core_IPrintable",
                                                 :source {:code "(defprotocol IPrintable\n  (-pr-seq [o opts]))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [164
                                                                  165],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L164-L165"},
                                                 :methods [{:name "-pr-seq",
                                                            :signature ["[o opts]"],
                                                            :docstring nil}],
                                                 :full-name "cljs.core/IPrintable",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "cljs.core/defprotocol" {:full-name "cljs.core/defprotocol",
                                                  :ns "cljs.core",
                                                  :name "defprotocol",
                                                  :type "macro",
                                                  :signature ["[psym & doc+methods]"],
                                                  :source {:code "(defmacro defprotocol [psym & doc+methods]\n  (let [p (:name (cljs.compiler/resolve-var (dissoc &env :locals) psym))\n        ns-name (-> &env :ns :name)\n        fqn (fn [n] (symbol (str ns-name \".\" n)))\n        prefix (protocol-prefix p)\n        methods (if (string? (first doc+methods)) (next doc+methods) doc+methods)\n        expand-sig (fn [fname slot sig]\n                     `(~sig\n                       (if (and ~(first sig) (. ~(first sig) ~(symbol (str \"-\" slot)))) ;; Property access needed here.\n                         (. ~(first sig) ~slot ~@sig)\n                         ((or\n                           (aget ~(fqn fname) (goog.typeOf ~(first sig)))\n                           (aget ~(fqn fname) \"_\")\n                           (throw (missing-protocol\n                                    ~(str psym \".\" fname) ~(first sig))))\n                          ~@sig))))\n        method (fn [[fname & sigs]]\n                 (let [sigs (take-while vector? sigs)\n                       slot (symbol (str prefix (name fname)))]\n                   `(defn ~fname ~@(map #(expand-sig fname slot %) sigs))))]\n    `(do\n       (def ~psym (~'js* \"{}\"))\n       ~@(map method methods))))",
                                                           :filename "clojurescript/src/clj/cljs/core.clj",
                                                           :lines [364
                                                                   386],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L364-L386"},
                                                  :full-name-encode "cljs.core_defprotocol",
                                                  :clj-symbol "clojure.core/defprotocol",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/assert" {:ns "cljs.core",
                                             :name "assert",
                                             :signature ["[x]"
                                                         "[x message]"],
                                             :shadowed-sources ({:code "(defmacro assert\n  ([x]\n     (when *assert*\n       `(when-not ~x\n          (throw (new AssertionError (str \"Assert failed: \" (pr-str '~x)))))))\n  ([x message]\n     (when *assert*\n       `(when-not ~x\n          (throw (new AssertionError (str \"Assert failed: \" ~message \"\\n\" (pr-str '~x))))))))",
                                                                 :filename "clojure/src/clj/clojure/core.clj",
                                                                 :lines [4222
                                                                         4233],
                                                                 :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L4222-L4233"}),
                                             :history [["+" "0.0-927"]],
                                             :type "macro",
                                             :full-name-encode "cljs.core_assert",
                                             :source {:code "(defmacro assert\n  ([x]\n     (when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" (cljs.core/pr-str '~x)))))))\n  ([x message]\n     (when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" ~message \"\\n\" (cljs.core/pr-str '~x))))))))",
                                                      :filename "clojurescript/src/clj/cljs/core.clj",
                                                      :lines [500 512],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L500-L512"},
                                             :full-name "cljs.core/assert",
                                             :clj-symbol "clojure.core/assert",
                                             :docstring "Evaluates expr and throws an exception if it does not evaluate to\nlogical true."},
                         "cljs.core/declare" {:ns "cljs.core",
                                              :name "declare",
                                              :signature ["[& names]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "macro",
                                              :full-name-encode "cljs.core_declare",
                                              :source {:code "(defmacro declare\n  [& names] `(do ~@(map #(list 'def (vary-meta % assoc :declared true)) names)))",
                                                       :filename "clojure/src/clj/clojure/core.clj",
                                                       :lines [2665
                                                               2668],
                                                       :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L2665-L2668"},
                                              :full-name "cljs.core/declare",
                                              :clj-symbol "clojure.core/declare",
                                              :docstring "defs the supplied var names with no bindings, useful for making forward declarations."},
                         "cljs.core/fn?" {:full-name "cljs.core/fn?",
                                          :ns "cljs.core",
                                          :name "fn?",
                                          :type "function",
                                          :signature ["[f]"],
                                          :source {:code "(defn fn? [f]\n  (goog/isFunction f))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [644 645],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L644-L645"},
                                          :full-name-encode "cljs.core_fn_QMARK_",
                                          :clj-symbol "clojure.core/fn?",
                                          :history [["+" "0.0-927"]]},
                         "cljs.core/associative?" {:ns "cljs.core",
                                                   :name "associative?",
                                                   :signature ["[x]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.core_associative_QMARK_",
                                                   :source {:code "(defn associative?\n  [x] (satisfies? IAssociative x))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [565
                                                                    567],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L565-L567"},
                                                   :full-name "cljs.core/associative?",
                                                   :clj-symbol "clojure.core/associative?",
                                                   :docstring "Returns true if coll implements Associative"},
                         "cljs.core/list*" {:ns "cljs.core",
                                            :name "list*",
                                            :signature ["[args]"
                                                        "[a args]"
                                                        "[a b args]"
                                                        "[a b c args]"
                                                        "[a b c d & more]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_list_STAR_",
                                            :source {:code "(defn list*\n  ([args] (seq args))\n  ([a args] (cons a args))\n  ([a b args] (cons a (cons b args)))\n  ([a b c args] (cons a (cons b (cons c args))))\n  ([a b c d & more]\n     (cons a (cons b (cons c (cons d (spread more)))))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [1326
                                                             1334],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1326-L1334"},
                                            :full-name "cljs.core/list*",
                                            :clj-symbol "clojure.core/list*",
                                            :docstring "Creates a new list containing the items prepended to the rest, the\nlast of which will be treated as a sequence."},
                         "cljs.core/reduce" {:ns "cljs.core",
                                             :name "reduce",
                                             :signature ["[f coll]"
                                                         "[f val coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_reduce",
                                             :source {:code "(defn reduce\n  ([f coll]\n     (-reduce coll f))\n  ([f val coll]\n     (-reduce coll f val)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [735 748],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L735-L748"},
                                             :full-name "cljs.core/reduce",
                                             :clj-symbol "clojure.core/reduce",
                                             :docstring "f should be a function of 2 arguments. If val is not supplied,\nreturns the result of applying f to the first 2 items in coll, then\napplying f to that result and the 3rd item, etc. If coll contains no\nitems, f must accept no arguments as well, and reduce returns the\nresult of calling f with no arguments.  If coll has only 1 item, it\nis returned and f is not called.  If val is supplied, returns the\nresult of applying f to val and the first item in coll, then\napplying f to that result and the 2nd item, etc. If coll contains no\nitems, returns val and f is not called."},
                         "clojure.browser.event/has-listener" {:full-name "clojure.browser.event/has-listener",
                                                               :ns "clojure.browser.event",
                                                               :name "has-listener",
                                                               :type "function",
                                                               :signature ["[obj opt_type opt_capture]"],
                                                               :source {:code "(defn has-listener [obj opt_type opt_capture])",
                                                                        :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                        :lines [94
                                                                                94],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/event.cljs#L94-L94"},
                                                               :full-name-encode "clojure.browser.event_has-listener",
                                                               :history [["+"
                                                                          "0.0-927"]]},
                         "cljs.core/compare" {:ns "cljs.core",
                                              :name "compare",
                                              :signature ["[x y]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_compare",
                                              :source {:code "(defn compare\n  [x y] (garray/defaultCompare x y))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [690
                                                               694],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L690-L694"},
                                              :full-name "cljs.core/compare",
                                              :clj-symbol "clojure.core/compare",
                                              :docstring "Comparator. Returns a negative number, zero, or a positive number\nwhen x is logically 'less than', 'equal to', or 'greater than'\ny. Uses google.array.defaultCompare."},
                         "cljs.core/contains?" {:ns "cljs.core",
                                                :name "contains?",
                                                :signature ["[coll v]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_contains_QMARK_",
                                                :source {:code "(defn contains?\n  [coll v]\n  (if (identical? (-lookup coll v lookup-sentinel) lookup-sentinel)\n    false\n    true))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [653
                                                                 662],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L653-L662"},
                                                :full-name "cljs.core/contains?",
                                                :clj-symbol "clojure.core/contains?",
                                                :docstring "Returns true if key is present in the given collection, otherwise\nreturns false.  Note that for numerically indexed collections like\nvectors and arrays, this tests if the numeric key is within the\nrange of indexes. 'contains?' operates constant or logarithmic time;\nit will not perform a linear search for a value.  See also 'some'."},
                         "cljs.core/prefer-method" {:ns "cljs.core",
                                                    :name "prefer-method",
                                                    :signature ["[multifn dispatch-val-x dispatch-val-y]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_prefer-method",
                                                    :source {:code "(defn prefer-method\n  [multifn dispatch-val-x dispatch-val-y]\n  (-prefer-method multifn dispatch-val-x dispatch-val-y))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [3488
                                                                     3492],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3488-L3492"},
                                                    :full-name "cljs.core/prefer-method",
                                                    :clj-symbol "clojure.core/prefer-method",
                                                    :docstring "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\nwhen there is a conflict"},
                         "cljs.core/array-seq" {:full-name "cljs.core/array-seq",
                                                :ns "cljs.core",
                                                :name "array-seq",
                                                :type "function",
                                                :signature ["[array i]"],
                                                :source {:code "(defn array-seq [array i]\n  (prim-seq array i))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [335
                                                                 336],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L335-L336"},
                                                :full-name-encode "cljs.core_array-seq",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/PersistentQueue" {:full-name "cljs.core/PersistentQueue",
                                                      :ns "cljs.core",
                                                      :name "PersistentQueue",
                                                      :type "type",
                                                      :signature ["[meta count front rear]"],
                                                      :source {:code "(deftype PersistentQueue [meta count front rear]\n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueue. meta count front rear))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest [coll] (rest (seq coll)))\n\n  IStack\n  (-peek [coll] (-first front))\n  (-pop [coll]\n    (if front\n      (if-let [f1 (next front)]\n        (PersistentQueue. meta (dec count) f1 rear)\n        (PersistentQueue. meta (dec count) (seq rear) []))\n      coll))\n\n  ICollection\n  (-conj [coll o]\n    (if front\n      (PersistentQueue. meta (inc count) front (conj (or rear []) o))\n      (PersistentQueue. meta (inc count) (conj front o) [])))\n\n  IEmptyableCollection\n  (-empty [coll] cljs.core.PersistentQueue/EMPTY)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (let [rear (seq rear)]\n      (if (or front rear)\n        (PersistentQueueSeq. nil front (seq rear))\n        cljs.core.List/EMPTY)))\n\n  ICounted\n  (-count [coll] count))",
                                                               :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                               :lines [2102
                                                                       2146],
                                                               :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2102-L2146"},
                                                      :full-name-encode "cljs.core_PersistentQueue",
                                                      :history [["+"
                                                                 "0.0-927"]]},
                         "cljs.core/drop-last" {:ns "cljs.core",
                                                :name "drop-last",
                                                :signature ["[s]"
                                                            "[n s]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_drop-last",
                                                :source {:code "(defn drop-last\n  ([s] (drop-last 1 s))\n  ([n s] (map (fn [x _] x) s (drop n s))))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1688
                                                                 1691],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1688-L1691"},
                                                :full-name "cljs.core/drop-last",
                                                :clj-symbol "clojure.core/drop-last",
                                                :docstring "Return a lazy sequence of all but the last n (default 1) items in coll"},
                         "cljs.reader/read-string" {:ns "cljs.reader",
                                                    :name "read-string",
                                                    :signature ["[s]"],
                                                    :shadowed-sources ({:code "(defn read-string\n  [reader _]\n  (loop [buffer (gstring/StringBuffer.)\n         ch (read-char reader)]\n    (cond\n     (nil? ch) (reader-error reader \"EOF while reading string\")\n     (= \"\\\\\" ch) (recur (do (.append buffer (escape-char buffer reader)) buffer)\n                        (read-char reader))\n     (= \\\" ch) (. buffer (toString))\n     :default (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                                                        :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                        :lines [232
                                                                                241],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L232-L241"}),
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.reader_read-string",
                                                    :source {:code "(defn read-string\n  [s]\n  (let [r (push-back-reader s)]\n    (read r true nil false)))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [356
                                                                     360],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L356-L360"},
                                                    :full-name "cljs.reader/read-string",
                                                    :clj-symbol "clojure.core/read-string",
                                                    :docstring "Reads one object from the string s"},
                         "cljs.core/vector?" {:ns "cljs.core",
                                              :name "vector?",
                                              :signature ["[x]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_vector_QMARK_",
                                              :source {:code "(defn vector?\n  [x] (satisfies? IVector x))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [584
                                                               586],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L584-L586"},
                                              :full-name "cljs.core/vector?",
                                              :clj-symbol "clojure.core/vector?",
                                              :docstring "Return true if x satisfies IVector"},
                         "cljs.core/defmulti" {:ns "cljs.core",
                                               :name "defmulti",
                                               :signature ["[mm-name & options]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "macro",
                                               :full-name-encode "cljs.core_defmulti",
                                               :source {:code "(defmacro defmulti\n  [mm-name & options]\n  (let [docstring   (if (string? (first options))\n                      (first options)\n                      nil)\n        options     (if (string? (first options))\n                      (next options)\n                      options)\n        m           (if (map? (first options))\n                      (first options)\n                      {})\n        options     (if (map? (first options))\n                      (next options)\n                      options)\n        dispatch-fn (first options)\n        options     (next options)\n        m           (if docstring\n                      (assoc m :doc docstring)\n                      m)\n        m           (if (meta mm-name)\n                      (conj (meta mm-name) m)\n                      m)]\n    (when (= (count options) 1)\n      (throw \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\"))\n    (let [options   (apply hash-map options)\n          default   (get options :default :default)\n          ;; hierarchy (get options :hierarchy #'cljs.core.global-hierarchy)\n\t  ]\n      (check-valid-options options :default :hierarchy)\n      `(def ~(with-meta mm-name m)\n\t (let [method-table# (atom {})\n\t       prefer-table# (atom {})\n\t       method-cache# (atom {})\n\t       cached-hierarchy# (atom {})\n\t       hierarchy# (get ~options :hierarchy cljs.core/global-hierarchy)\n\t       ]\n\t   (cljs.core.MultiFn. ~(name mm-name) ~dispatch-fn ~default hierarchy#\n\t\t\t       method-table# prefer-table# method-cache# cached-hierarchy#))))))",
                                                        :filename "clojurescript/src/clj/cljs/core.clj",
                                                        :lines [658
                                                                702],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L658-L702"},
                                               :full-name "cljs.core/defmulti",
                                               :clj-symbol "clojure.core/defmulti",
                                               :docstring "Creates a new multimethod with the associated dispatch function.\nThe docstring and attribute-map are optional.\n\nOptions are key-value pairs and may be one of:\n  :default    the default dispatch value, defaults to :default\n  :hierarchy  the isa? hierarchy to use for dispatching\n              defaults to the global hierarchy"},
                         "clojure.browser.event/dispatch-event" {:full-name "clojure.browser.event/dispatch-event",
                                                                 :ns "clojure.browser.event",
                                                                 :name "dispatch-event",
                                                                 :type "function",
                                                                 :signature ["[src event]"],
                                                                 :source {:code "(defn dispatch-event\n  [src event]\n  (goog.events/dispatchEvent src event))",
                                                                          :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                          :lines [75
                                                                                  77],
                                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/event.cljs#L75-L77"},
                                                                 :full-name-encode "clojure.browser.event_dispatch-event",
                                                                 :history [["+"
                                                                            "0.0-927"]]},
                         "clojure.string/split-lines" {:ns "clojure.string",
                                                       :name "split-lines",
                                                       :signature ["[s]"],
                                                       :history [["+"
                                                                  "0.0-927"]],
                                                       :type "function",
                                                       :full-name-encode "clojure.string_split-lines",
                                                       :source {:code "(defn split-lines\n  [s]\n  (split s #\"\\n|\\r\\n\"))",
                                                                :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                                :lines [101
                                                                        104],
                                                                :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/string.cljs#L101-L104"},
                                                       :full-name "clojure.string/split-lines",
                                                       :clj-symbol "clojure.string/split-lines",
                                                       :docstring "Splits s on \n or \r\n."},
                         "cljs.core/areduce" {:ns "cljs.core",
                                              :name "areduce",
                                              :signature ["[a idx ret init expr]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "macro",
                                              :full-name-encode "cljs.core_areduce",
                                              :source {:code "(defmacro areduce\n  [a idx ret init expr]\n  `(let [a# ~a]\n     (loop  [~idx 0 ~ret ~init]\n       (if (< ~idx  (alength a#))\n         (recur (inc ~idx) ~expr)\n         ~ret))))",
                                                       :filename "clojurescript/src/clj/cljs/core.clj",
                                                       :lines [623
                                                               632],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L623-L632"},
                                              :full-name "cljs.core/areduce",
                                              :clj-symbol "clojure.core/areduce",
                                              :docstring "Reduces an expression across an array a, using an index named idx,\nand return value named ret, initialized to init, setting ret to the \nevaluation of expr at each step, returning ret."},
                         "cljs.core/disj" {:ns "cljs.core",
                                           :name "disj",
                                           :signature ["[coll]"
                                                       "[coll k]"
                                                       "[coll k & ks]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_disj",
                                           :source {:code "(defn disj\n  ([coll] coll)\n  ([coll k]\n     (-disjoin coll k))\n  ([coll k & ks]\n     (let [ret (disj coll k)]\n       (if ks\n         (recur ret (first ks) (next ks))\n         ret))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [531 541],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L531-L541"},
                                           :full-name "cljs.core/disj",
                                           :clj-symbol "clojure.core/disj",
                                           :docstring "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\ndoes not contain key(s)."},
                         "clojure.browser.net/event-types" {:full-name "clojure.browser.net/event-types",
                                                            :ns "clojure.browser.net",
                                                            :name "event-types",
                                                            :type "var",
                                                            :source {:code "(def event-types\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (. k (toLowerCase)))\n            v])\n         (merge\n          (js->clj goog.net.EventType)))))",
                                                                     :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                     :lines [23
                                                                             30],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/net.cljs#L23-L30"},
                                                            :full-name-encode "clojure.browser.net_event-types",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "clojure.string/lower-case" {:ns "clojure.string",
                                                      :name "lower-case",
                                                      :signature ["[s]"],
                                                      :history [["+"
                                                                 "0.0-927"]],
                                                      :type "function",
                                                      :full-name-encode "clojure.string_lower-case",
                                                      :source {:code "(defn lower-case\n  [s]\n  (. s (toLowerCase)))",
                                                               :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                               :lines [58
                                                                       61],
                                                               :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/string.cljs#L58-L61"},
                                                      :full-name "clojure.string/lower-case",
                                                      :clj-symbol "clojure.string/lower-case",
                                                      :docstring "Converts string to all lower-case."},
                         "cljs.core/*print-fn*" {:full-name "cljs.core/*print-fn*",
                                                 :ns "cljs.core",
                                                 :name "*print-fn*",
                                                 :docstring "Each runtime environment provides a diffenent way to print output.\nWhatever function *print-fn* is bound to will be passed any\nStrings which should be printed.",
                                                 :type "function",
                                                 :source {:code "(def\n  ^{:doc \"Each runtime environment provides a diffenent way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.\"}\n  *print-fn*\n  (fn [_]\n    (throw (js/Error. \"No *print-fn* fn set for evaluation environment\"))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [15
                                                                  21],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L15-L21"},
                                                 :full-name-encode "cljs.core__STAR_print-fn_STAR_",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "cljs.core/str" {:ns "cljs.core",
                                          :name "str",
                                          :signature ["[]"
                                                      "[x]"
                                                      "[x & ys]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_str",
                                          :source {:code "(defn str\n  ([] \"\")\n  ([x] (cond\n        (symbol? x) (. x (substring 2 (.-length x)))\n        (keyword? x) (str* \":\" (. x (substring 2 (.-length x))))\n        (nil? x) \"\"\n        :else (. x (toString))))\n  ([x & ys]\n     (apply str* x ys)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [1010 1021],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1010-L1021"},
                                          :full-name "cljs.core/str",
                                          :clj-symbol "clojure.core/str",
                                          :docstring "With no args, returns the empty string. With one arg x, returns\nx.toString().  (str nil) returns the empty string. With more than\none arg, returns the concatenation of the str values of the args."},
                         "cljs.core/ISequential" {:ns "cljs.core",
                                                  :name "ISequential",
                                                  :type "protocol",
                                                  :full-name-encode "cljs.core_ISequential",
                                                  :source {:code "(defprotocol ISequential\n  \"Marker interface indicating a persistent collection of sequential items\")",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [158
                                                                   159],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L158-L159"},
                                                  :full-name "cljs.core/ISequential",
                                                  :docstring "Marker interface indicating a persistent collection of sequential items",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/set" {:ns "cljs.core",
                                          :name "set",
                                          :signature ["[coll]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_set",
                                          :source {:code "(defn set\n  [coll]\n  (loop [in (seq coll)\n         out cljs.core.Set/EMPTY]\n    (if-not (empty? in)\n      (recur (rest in) (conj out (first in)))\n      out)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [2476 2483],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2476-L2483"},
                                          :full-name "cljs.core/set",
                                          :clj-symbol "clojure.core/set",
                                          :docstring "Returns a set of the distinct elements of coll."},
                         "special/def" {:full-name "special/def",
                                        :ns "special",
                                        :name "def",
                                        :type "special form",
                                        :source {:code "(defmethod parse 'def\n  [op env form name]\n  (let [pfn (fn ([_ sym] {:sym sym})\n              ([_ sym init] {:sym sym :init init})\n              ([_ sym doc init] {:sym sym :doc doc :init init}))\n        args (apply pfn form)\n        sym (:sym args)]\n    (assert (not (namespace sym)) \"Can't def ns-qualified name\")\n    (let [name (munge (:name (resolve-var (dissoc env :locals) sym)))\n          init-expr (when (contains? args :init) (disallowing-recur\n                                                  (analyze (assoc env :context :expr) (:init args) sym)))\n          export-as (when-let [export-val (-> sym meta :export)]\n                      (if (= true export-val) name export-val))\n          doc (or (:doc args) (-> sym meta :doc))]\n      (swap! namespaces update-in [(-> env :ns :name) :defs sym]\n             (fn [m]\n               (let [m (assoc (or m {}) :name name)]\n                 (if-let [line (:line env)]\n                   (-> m\n                       (assoc :file *cljs-file*)\n                       (assoc :line line))\n                   m))))\n      (merge {:env env :op :def :form form\n              :name name :doc doc :init init-expr}\n             (when init-expr {:children [init-expr]})\n             (when export-as {:export export-as})))))",
                                                 :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                 :lines [654 679],
                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/compiler.clj#L654-L679"},
                                        :full-name-encode "special_def",
                                        :clj-symbol "clojure.core/def",
                                        :history [["+" "0.0-927"]]},
                         "cljs.core/print" {:full-name "cljs.core/print",
                                            :ns "cljs.core",
                                            :name "print",
                                            :docstring "Prints the object(s) using string-print.\nprint and println produce output for human consumption.",
                                            :type "function",
                                            :source {:code "(def ^{:doc\n  \"Prints the object(s) using string-print.\n  print and println produce output for human consumption.\"}\n  print\n  (fn cljs-core-print [& objs]\n    (pr-with-opts objs (assoc (pr-opts) :readably false))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2880
                                                             2885],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2880-L2885"},
                                            :full-name-encode "cljs.core_print",
                                            :clj-symbol "clojure.core/print",
                                            :history [["+" "0.0-927"]]},
                         "clojure.string/blank?" {:ns "clojure.string",
                                                  :name "blank?",
                                                  :signature ["[s]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.string_blank_QMARK_",
                                                  :source {:code "(defn blank?\n  [s]\n  (let [s (str s)]\n    (if (or\n         (not s)\n         (= \"\" s)\n         (re-matches #\"\\s+\" s))\n      true\n      false)))",
                                                           :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                           :lines [133
                                                                   142],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/string.cljs#L133-L142"},
                                                  :full-name "clojure.string/blank?",
                                                  :clj-symbol "clojure.string/blank?",
                                                  :docstring "True is s is nil, empty, or contains only whitespace."},
                         "clojure.browser.dom/append" {:full-name "clojure.browser.dom/append",
                                                       :ns "clojure.browser.dom",
                                                       :name "append",
                                                       :type "function",
                                                       :signature ["[parent & children]"],
                                                       :source {:code "(defn append [parent & children]\n  (apply gdom/append parent children)\n  parent)",
                                                                :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                :lines [12
                                                                        14],
                                                                :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/dom.cljs#L12-L14"},
                                                       :full-name-encode "clojure.browser.dom_append",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.core/take-last" {:ns "cljs.core",
                                                :name "take-last",
                                                :signature ["[n coll]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_take-last",
                                                :source {:code "(defn take-last\n  [n coll]\n  (loop [s (seq coll), lead (seq (drop n coll))]\n    (if lead\n      (recur (next s) (next lead))\n      s)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1693
                                                                 1700],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1693-L1700"},
                                                :full-name "cljs.core/take-last",
                                                :clj-symbol "clojure.core/take-last",
                                                :docstring "Returns a seq of the last n items in coll.  Depending on the type\nof coll may be no better than linear time.  For vectors, see also subvec."},
                         "clojure.set/intersection" {:ns "clojure.set",
                                                     :name "intersection",
                                                     :signature ["[s1]"
                                                                 "[s1 s2]"
                                                                 "[s1 s2 & sets]"],
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "clojure.set_intersection",
                                                     :source {:code "(defn intersection\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s2) (count s1))\n       (recur s2 s1)\n       (reduce (fn [result item]\n                   (if (contains? s2 item)\n\t\t     result\n                     (disj result item)))\n\t       s1 s1)))\n  ([s1 s2 & sets] \n     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]\n       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))",
                                                              :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                              :lines [31
                                                                      44],
                                                              :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/set.cljs#L31-L44"},
                                                     :full-name "clojure.set/intersection",
                                                     :clj-symbol "clojure.set/intersection",
                                                     :docstring "Return a set that is the intersection of the input sets"},
                         "cljs.core/fnext" {:ns "cljs.core",
                                            :name "fnext",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_fnext",
                                            :source {:code "(defn fnext\n  [coll]\n  (first (next coll)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [410 413],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L410-L413"},
                                            :full-name "cljs.core/fnext",
                                            :clj-symbol "clojure.core/fnext",
                                            :docstring "Same as (first (next x))"},
                         "cljs.core/apply" {:ns "cljs.core",
                                            :name "apply",
                                            :signature ["[f args]"
                                                        "[f x args]"
                                                        "[f x y args]"
                                                        "[f x y z args]"
                                                        "[f a b c d & args]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_apply",
                                            :source {:code "(defn apply\n  ([f args]\n     (let [fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count args (inc fixed-arity))\n                 fixed-arity)\n           (.apply f f (to-array args))\n           (.cljs$lang$applyTo f args))\n         (.apply f f (to-array args)))))\n  ([f x args]\n     (let [arglist (list* x args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count arglist fixed-arity)\n                 fixed-arity)\n           (.apply f f (to-array arglist))\n           (.cljs$lang$applyTo f arglist))\n         (.apply f f (to-array arglist)))))\n  ([f x y args]\n     (let [arglist (list* x y args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count arglist fixed-arity)\n                 fixed-arity)\n           (.apply f f (to-array arglist))\n           (.cljs$lang$applyTo f arglist))\n         (.apply f f (to-array arglist)))))\n  ([f x y z args]\n     (let [arglist (list* x y z args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count arglist fixed-arity)\n                 fixed-arity)\n           (.apply f f (to-array arglist))\n           (.cljs$lang$applyTo f arglist))\n         (.apply f f (to-array arglist)))))\n  ([f a b c d & args]\n     (let [arglist (cons a (cons b (cons c (cons d (spread args)))))\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count arglist fixed-arity)\n                 fixed-arity)\n           (.apply f f (to-array arglist))\n           (.cljs$lang$applyTo f arglist))\n         (.apply f f (to-array arglist))))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [1338
                                                             1384],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1338-L1384"},
                                            :full-name "cljs.core/apply",
                                            :clj-symbol "clojure.core/apply",
                                            :docstring "Applies fn f to the argument list formed by prepending intervening arguments to args.\nFirst cut.  Not lazy.  Needs to use emitted toApply."},
                         "clojure.walk/prewalk" {:ns "clojure.walk",
                                                 :name "prewalk",
                                                 :signature ["[f form]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.walk_prewalk",
                                                 :source {:code "(defn prewalk\n  [f form]\n  (walk (partial prewalk f) identity (f form)))",
                                                          :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                          :lines [58
                                                                  62],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/walk.cljs#L58-L62"},
                                                 :full-name "clojure.walk/prewalk",
                                                 :clj-symbol "clojure.walk/prewalk",
                                                 :docstring "Like postwalk, but does pre-order traversal."},
                         "cljs.core/flatten" {:ns "cljs.core",
                                              :name "flatten",
                                              :signature ["[x]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_flatten",
                                              :source {:code "(defn flatten\n  [x]\n  (filter #(not (sequential? %))\n          (rest (tree-seq sequential? seq x))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1817
                                                               1823],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1817-L1823"},
                                              :full-name "cljs.core/flatten",
                                              :clj-symbol "clojure.core/flatten",
                                              :docstring "Takes any nested combination of sequential things (lists, vectors,\netc.) and returns their contents as a single, flat sequence.\n(flatten nil) returns nil."},
                         "cljs.core/get" {:ns "cljs.core",
                                          :name "get",
                                          :signature ["[o k]"
                                                      "[o k not-found]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_get",
                                          :source {:code "(defn get\n  ([o k]\n     (-lookup o k))\n  ([o k not-found]\n     (-lookup o k not-found)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [474 479],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L474-L479"},
                                          :full-name "cljs.core/get",
                                          :clj-symbol "clojure.core/get",
                                          :docstring "Returns the value mapped to key, not-found or nil if key not present."},
                         "cljs.core/.." {:ns "cljs.core",
                                         :name "..",
                                         :signature ["[x form]"
                                                     "[x form & more]"],
                                         :history [["+" "0.0-927"]],
                                         :type "macro",
                                         :full-name-encode "cljs.core__DOT__DOT_",
                                         :source {:code "(defmacro ..\n  ([x form] `(. ~x ~form))\n  ([x form & more] `(.. (. ~x ~form) ~@more)))",
                                                  :filename "clojure/src/clj/clojure/core.clj",
                                                  :lines [1510 1526],
                                                  :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L1510-L1526"},
                                         :full-name "cljs.core/..",
                                         :clj-symbol "clojure.core/..",
                                         :docstring "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\nExpands into a member access (.) of the first member on the first\nargument, followed by the next member on the result, etc. For\ninstance:\n\n(.. System (getProperties) (get \"os.name\"))\n\nexpands to:\n\n(. (. System (getProperties)) (get \"os.name\"))\n\nbut is easier to write, read, and understand."},
                         "cljs.core/Range" {:full-name "cljs.core/Range",
                                            :ns "cljs.core",
                                            :name "Range",
                                            :type "type",
                                            :signature ["[meta start end step]"],
                                            :source {:code "(deftype Range [meta start end step]\n  IWithMeta\n  (-with-meta [rng meta] (Range. meta start end step))\n\n  IMeta\n  (-meta [rng] meta)\n\n  ISeq\n  (-first [rng] start)\n\n  (-rest [rng]\n    (if (-seq rng)\n      (Range. meta (+ start step) end step)\n      (list)))\n\n  ICollection\n  (-conj [rng o] (cons o rng))\n\n  IEmptyableCollection\n  (-empty [rng] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [rng other] (equiv-sequential rng other))\n\n  IHash\n  (-hash [rng] (hash-coll rng))\n\n  ICounted\n  (-count [rng]\n    (if-not (-seq rng)\n      0\n      (js/Math.ceil (/ (- end start) step))))\n\n  IIndexed\n  (-nth [rng n]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (= step 0))\n        start\n        (throw (js/Error. \"Index out of bounds\")))))\n  (-nth [rng n not-found]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (= step 0))\n        start\n        not-found)))\n\n  ISeqable\n  (-seq [rng]\n    (let [comp (if (pos? step) < >)]\n      (when (comp start end)\n        rng)))\n\n  IReduce\n  (-reduce [rng f] (ci-reduce rng f))\n  (-reduce [rng f s] (ci-reduce rng f s)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2585
                                                             2641],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2585-L2641"},
                                            :full-name-encode "cljs.core_Range",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/zero?" {:ns "cljs.core",
                                            :name "zero?",
                                            :signature ["[n]"],
                                            :shadowed-sources ({:code "(defmacro zero? [x]\n  `(== ~x 0))",
                                                                :filename "clojurescript/src/clj/cljs/core.clj",
                                                                :lines [109
                                                                        110],
                                                                :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L109-L110"}),
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_zero_QMARK_",
                                            :source {:code "(defn zero? [n]\n  (== 0 n))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [963 964],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L963-L964"},
                                            :full-name "cljs.core/zero?",
                                            :clj-symbol "clojure.core/zero?"},
                         "cljs.core/identity" {:full-name "cljs.core/identity",
                                               :ns "cljs.core",
                                               :name "identity",
                                               :type "function",
                                               :signature ["[x]"],
                                               :source {:code "(defn identity [x] x)",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [1441
                                                                1441],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1441-L1441"},
                                               :full-name-encode "cljs.core_identity",
                                               :clj-symbol "clojure.core/identity",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/first" {:ns "cljs.core",
                                            :name "first",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_first",
                                            :source {:code "(defn first\n  [coll]\n  (when-let [s (seq coll)]\n    (-first s)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [375 380],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L375-L380"},
                                            :full-name "cljs.core/first",
                                            :clj-symbol "clojure.core/first",
                                            :docstring "Returns the first item in the collection. Calls seq on its\nargument. If coll is nil, returns nil."},
                         "cljs.reader/ratio-pattern" {:full-name "cljs.reader/ratio-pattern",
                                                      :ns "cljs.reader",
                                                      :name "ratio-pattern",
                                                      :type "var",
                                                      :source {:code "(def ratio-pattern (re-pattern \"([-+]?[0-9]+)/([0-9]+)\"))",
                                                               :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                               :lines [96
                                                                       96],
                                                               :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L96-L96"},
                                                      :full-name-encode "cljs.reader_ratio-pattern",
                                                      :history [["+"
                                                                 "0.0-927"]]},
                         "cljs.core/>" {:ns "cljs.core",
                                        :name ">",
                                        :signature ["[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :shadowed-sources ({:code "(defmacro >\n  ([x] true)\n  ([x y] (list 'js* \"(~{} > ~{})\" x y))\n  ([x y & more] `(and (> ~x ~y) (> ~y ~@more))))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [88
                                                                    91],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L88-L91"}),
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core__GT_",
                                        :source {:code "(defn >\n  ([x] true)\n  ([x y] (js* \"(~{x} > ~{y})\"))\n  ([x y & more]\n   (if (> x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (> y (first more)))\n     false)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [825 835],
                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L825-L835"},
                                        :full-name "cljs.core/>",
                                        :clj-symbol "clojure.core/>",
                                        :docstring "Returns non-nil if nums are in monotonically decreasing order,\notherwise false."},
                         "cljs.core/juxt" {:ns "cljs.core",
                                           :name "juxt",
                                           :signature ["[f]"
                                                       "[f g]"
                                                       "[f g h]"
                                                       "[f g h & fs]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_juxt",
                                           :source {:code "(defn juxt\n  ([f]\n     (fn\n       ([] (vector (f)))\n       ([x] (vector (f x)))\n       ([x y] (vector (f x y)))\n       ([x y z] (vector (f x y z)))\n       ([x y z & args] (vector (apply f x y z args)))))\n  ([f g]\n     (fn\n       ([] (vector (f) (g)))\n       ([x] (vector (f x) (g x)))\n       ([x y] (vector (f x y) (g x y)))\n       ([x y z] (vector (f x y z) (g x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (vector (f) (g) (h)))\n       ([x] (vector (f x) (g x) (h x)))\n       ([x y] (vector (f x y) (g x y) (h x y)))\n       ([x y z] (vector (f x y z) (g x y z) (h x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args) (apply h x y z args)))))\n  ([f g h & fs]\n     (let [fs (list* f g h fs)]\n       (fn\n         ([] (reduce #(conj %1 (%2)) [] fs))\n         ([x] (reduce #(conj %1 (%2 x)) [] fs))\n         ([x y] (reduce #(conj %1 (%2 x y)) [] fs))\n         ([x y z] (reduce #(conj %1 (%2 x y z)) [] fs))\n         ([x y z & args] (reduce #(conj %1 (apply %2 x y z args)) [] fs))))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2699 2733],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2699-L2733"},
                                           :full-name "cljs.core/juxt",
                                           :clj-symbol "clojure.core/juxt",
                                           :docstring "Takes a set of functions and returns a fn that is the juxtaposition\nof those fns.  The returned fn takes a variable number of args, and\nreturns a vector containing the result of applying each fn to the\nargs (left-to-right).\n((juxt a b c) x) => [(a x) (b x) (c x)]"},
                         "cljs.core/max" {:ns "cljs.core",
                                          :name "max",
                                          :signature ["[x]"
                                                      "[x y]"
                                                      "[x y & more]"],
                                          :shadowed-sources ({:code "(defmacro max\n  ([x] x)\n  ([x y] (list 'js* \"((~{} > ~{}) ? ~{} : ~{})\" x y x y))\n  ([x y & more] `(max (max ~x ~y) ~@more)))",
                                                              :filename "clojurescript/src/clj/cljs/core.clj",
                                                              :lines [118
                                                                      121],
                                                              :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L118-L121"}),
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_max",
                                          :source {:code "(defn max\n  ([x] x)\n  ([x y] (js* \"((~{x} > ~{y}) ? x : y)\"))\n  ([x y & more]\n   (reduce max (max x y) more)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [853 858],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L853-L858"},
                                          :full-name "cljs.core/max",
                                          :clj-symbol "clojure.core/max",
                                          :docstring "Returns the greatest of the nums."},
                         "cljs.core/*3" {:full-name "cljs.core/*3",
                                         :ns "cljs.core",
                                         :name "*3",
                                         :docstring "bound in a repl thread to the third most recent value printed",
                                         :type "var",
                                         :source {:code "(def\n  ^{:doc \"bound in a repl thread to the third most recent value printed\"}\n  *3)",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [31 33],
                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L31-L33"},
                                         :full-name-encode "cljs.core__STAR_3",
                                         :clj-symbol "clojure.core/*3",
                                         :history [["+" "0.0-927"]]},
                         "cljs.core/number?" {:full-name "cljs.core/number?",
                                              :ns "cljs.core",
                                              :name "number?",
                                              :type "function",
                                              :signature ["[n]"],
                                              :source {:code "(defn number? [n]\n  (goog/isNumber n))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [641
                                                               642],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L641-L642"},
                                              :full-name-encode "cljs.core_number_QMARK_",
                                              :clj-symbol "clojure.core/number?",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/array" {:full-name "cljs.core/array",
                                            :ns "cljs.core",
                                            :name "array",
                                            :docstring "Creates a new javascript array.\n@param {...*} var_args",
                                            :type "function",
                                            :signature ["[var-args]"],
                                            :source {:code "(defn array\n  [var-args]            ;; [& items]\n  (js* \"Array.prototype.slice.call(arguments)\"))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [71 75],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L71-L75"},
                                            :full-name-encode "cljs.core_array",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/nthnext" {:ns "cljs.core",
                                              :name "nthnext",
                                              :signature ["[coll n]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_nthnext",
                                              :source {:code "(defn nthnext\n  [coll n]\n  (loop [n n xs (seq coll)]\n    (if (and xs (pos? n))\n      (recur (dec n) (next xs))\n      xs)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [974
                                                               980],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L974-L980"},
                                              :full-name "cljs.core/nthnext",
                                              :clj-symbol "clojure.core/nthnext",
                                              :docstring "Returns the nth next of coll, (seq coll) when n is 0."},
                         "cljs.core/re-pattern" {:ns "cljs.core",
                                                 :name "re-pattern",
                                                 :signature ["[s]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_re-pattern",
                                                 :source {:code "(defn re-pattern\n  [s]\n  (js/RegExp. s))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2794
                                                                  2797],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2794-L2797"},
                                                 :full-name "cljs.core/re-pattern",
                                                 :clj-symbol "clojure.core/re-pattern",
                                                 :docstring "Returns an instance of RegExp which has compiled the provided string."},
                         "cljs.core/missing-protocol" {:full-name "cljs.core/missing-protocol",
                                                       :ns "cljs.core",
                                                       :name "missing-protocol",
                                                       :type "function",
                                                       :signature ["[proto obj]"],
                                                       :source {:code "(defn missing-protocol [proto obj]\n  (js/Error (js* \"~{}+~{}+~{}+~{}+~{}+~{}\"\n                 \"No protocol method \" proto\n                 \" defined for type \" (goog/typeOf obj) \": \" obj)))",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [58
                                                                        61],
                                                                :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L58-L61"},
                                                       :full-name-encode "cljs.core_missing-protocol",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "clojure.browser.dom/set-text" {:full-name "clojure.browser.dom/set-text",
                                                         :ns "clojure.browser.dom",
                                                         :name "set-text",
                                                         :docstring "Set the text content for the passed element returning the\nelement. If a keyword is passed in the place of e, the element with\nthat id will be used and returned.",
                                                         :type "function",
                                                         :signature ["[e s]"],
                                                         :source {:code "(defn set-text\n  [e s]\n  (gdom/setTextContent (ensure-element e) s))",
                                                                  :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                  :lines [122
                                                                          127],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/dom.cljs#L122-L127"},
                                                         :full-name-encode "clojure.browser.dom_set-text",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "clojure.zip/up" {:ns "clojure.zip",
                                           :name "up",
                                           :signature ["[loc]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.zip_up",
                                           :source {:code "(defn up\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes r :r, changed? :changed?, :as path}] loc]\n      (when pnodes\n        (let [pnode (peek pnodes)]\n          (with-meta (if changed?\n                       [(make-node loc pnode (concat l (cons node r))) \n                        (and ppath (assoc ppath :changed? true))]\n                       [pnode ppath])\n                     (meta loc))))))",
                                                    :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                    :lines [111 122],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L111-L122"},
                                           :full-name "clojure.zip/up",
                                           :clj-symbol "clojure.zip/up",
                                           :docstring "Returns the loc of the parent of the node at this loc, or nil if at\nthe top"},
                         "cljs.core/IWithMeta" {:ns "cljs.core",
                                                :name "IWithMeta",
                                                :type "protocol",
                                                :full-name-encode "cljs.core_IWithMeta",
                                                :source {:code "(defprotocol IWithMeta\n  (-with-meta [o meta]))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [143
                                                                 144],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L143-L144"},
                                                :methods [{:name "-with-meta",
                                                           :signature ["[o meta]"],
                                                           :docstring nil}],
                                                :full-name "cljs.core/IWithMeta",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/bit-and-not" {:ns "cljs.core",
                                                  :name "bit-and-not",
                                                  :signature ["[x y]"],
                                                  :shadowed-sources ({:code "(defmacro bit-and-not\n  ([x y] (list 'js* \"(~{} & ~~{})\" x y))\n  ([x y & more] `(bit-and-not (bit-and-not ~x ~y) ~@more)))",
                                                                      :filename "clojurescript/src/clj/cljs/core.clj",
                                                                      :lines [146
                                                                              148],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L146-L148"}),
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_bit-and-not",
                                                  :source {:code "(defn bit-and-not\n  [x y] (js* \"(~{x} & ~~{y})\"))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [910
                                                                   912],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L910-L912"},
                                                  :full-name "cljs.core/bit-and-not",
                                                  :clj-symbol "clojure.core/bit-and-not",
                                                  :docstring "Bitwise and"},
                         "clojure.string/triml" {:ns "clojure.string",
                                                 :name "triml",
                                                 :signature ["[s]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.string_triml",
                                                 :source {:code "(defn triml\n    [s]\n    (gstring/trimLeft s))",
                                                          :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                          :lines [111
                                                                  114],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/string.cljs#L111-L114"},
                                                 :full-name "clojure.string/triml",
                                                 :clj-symbol "clojure.string/triml",
                                                 :docstring "Removes whitespace from the left side of string."},
                         "clojure.string/split" {:ns "clojure.string",
                                                 :name "split",
                                                 :signature ["[s re]"
                                                             "[s re limit]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.string_split",
                                                 :source {:code "(defn split\n  ([s re]\n     (vec (.split (str s) re)))\n  ([s re limit]\n     (if (< limit 1)\n       (vec (.split (str s) re))\n       (loop [s s\n              limit limit\n              parts []]\n         (if (= limit 1)\n           (conj parts s)\n           (if-let [m (re-find re s)]\n             (let [index (.indexOf s m)]\n               (recur (.substring s (+ index (count m)))\n                      (dec limit)\n                      (conj parts (.substring s 0 index))))\n             (conj parts s)))))))",
                                                          :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                          :lines [81
                                                                  99],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/string.cljs#L81-L99"},
                                                 :full-name "clojure.string/split",
                                                 :clj-symbol "clojure.string/split",
                                                 :docstring "Splits string on a regular expression. Optional argument limit is\nthe maximum number of splits. Not lazy. Returns vector of the splits."},
                         "cljs.core/hash-map" {:ns "cljs.core",
                                               :name "hash-map",
                                               :signature ["[& keyvals]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_hash-map",
                                               :source {:code "(defn hash-map\n  [& keyvals]\n  (loop [in (seq keyvals), out cljs.core.HashMap/EMPTY]\n    (if in\n      (recur (nnext in) (assoc out (first in) (second in)))\n      out)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [2367
                                                                2374],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2367-L2374"},
                                               :full-name "cljs.core/hash-map",
                                               :clj-symbol "clojure.core/hash-map",
                                               :docstring "keyval => key val\nReturns a new hash map with supplied mappings."},
                         "cljs.core/rem" {:ns "cljs.core",
                                          :name "rem",
                                          :signature ["[n d]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_rem",
                                          :source {:code "(defn rem\n  [n d]\n  (let [q (quot n d)]\n    (js* \"(~{n} - (~{d} * ~{q}))\")))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [883 887],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L883-L887"},
                                          :full-name "cljs.core/rem",
                                          :clj-symbol "clojure.core/rem",
                                          :docstring "remainder of dividing numerator by denominator."},
                         "cljs.core/IRecord" {:ns "cljs.core",
                                              :name "IRecord",
                                              :type "protocol",
                                              :full-name-encode "cljs.core_IRecord",
                                              :source {:code "(defprotocol IRecord\n  \"Marker interface indicating a record object\")",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [161
                                                               162],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L161-L162"},
                                              :full-name "cljs.core/IRecord",
                                              :docstring "Marker interface indicating a record object",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/constantly" {:ns "cljs.core",
                                                 :name "constantly",
                                                 :signature ["[x]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_constantly",
                                                 :source {:code "(defn constantly\n  [x] (fn [& args] x))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [1453
                                                                  1455],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1453-L1455"},
                                                 :full-name "cljs.core/constantly",
                                                 :clj-symbol "clojure.core/constantly",
                                                 :docstring "Returns a function that takes any number of arguments and returns x."},
                         "clojure.browser.dom/get-element" {:full-name "clojure.browser.dom/get-element",
                                                            :ns "clojure.browser.dom",
                                                            :name "get-element",
                                                            :type "function",
                                                            :signature ["[id]"],
                                                            :source {:code "(defn get-element [id]\n  (gdom/getElement (name id)))",
                                                                     :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                     :lines [96
                                                                             97],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/dom.cljs#L96-L97"},
                                                            :full-name-encode "clojure.browser.dom_get-element",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "cljs.core/and" {:ns "cljs.core",
                                          :name "and",
                                          :signature ["[]"
                                                      "[x]"
                                                      "[x & next]"],
                                          :history [["+" "0.0-927"]],
                                          :type "macro",
                                          :full-name-encode "cljs.core_and",
                                          :source {:code "(defmacro and\n  ([] true)\n  ([x] x)\n  ([x & next]\n   `(let [and# ~x]\n      (if and# (and ~@next) and#))))",
                                                   :filename "clojure/src/clj/clojure/core.clj",
                                                   :lines [777 787],
                                                   :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L777-L787"},
                                          :full-name "cljs.core/and",
                                          :clj-symbol "clojure.core/and",
                                          :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns logical false (nil or false), and returns that value and\ndoesn't evaluate any of the other expressions, otherwise it returns\nthe value of the last expr. (and) returns true."},
                         "clojure.browser.repl/wrap-message" {:full-name "clojure.browser.repl/wrap-message",
                                                              :ns "clojure.browser.repl",
                                                              :name "wrap-message",
                                                              :type "function",
                                                              :signature ["[t data]"],
                                                              :source {:code "(defn wrap-message [t data]\n  (pr-str {:type t :content data :order (swap! order inc)}))",
                                                                       :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                       :lines [57
                                                                               58],
                                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/repl.cljs#L57-L58"},
                                                              :full-name-encode "clojure.browser.repl_wrap-message",
                                                              :history [["+"
                                                                         "0.0-927"]]},
                         "clojure.browser.event/unlisten-by-key" {:full-name "clojure.browser.event/unlisten-by-key",
                                                                  :ns "clojure.browser.event",
                                                                  :name "unlisten-by-key",
                                                                  :type "function",
                                                                  :signature ["[key]"],
                                                                  :source {:code "(defn unlisten-by-key\n  [key]\n  (goog.events/unlistenByKey key))",
                                                                           :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                           :lines [71
                                                                                   73],
                                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/event.cljs#L71-L73"},
                                                                  :full-name-encode "clojure.browser.event_unlisten-by-key",
                                                                  :history [["+"
                                                                             "0.0-927"]]},
                         "cljs.core/try" {:ns "cljs.core",
                                          :name "try",
                                          :signature ["[& forms]"],
                                          :history [["+" "0.0-927"]],
                                          :type "macro",
                                          :full-name-encode "cljs.core_try",
                                          :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (list? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                                   :filename "clojurescript/src/clj/cljs/core.clj",
                                                   :lines [470 498],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L470-L498"},
                                          :full-name "cljs.core/try",
                                          :clj-symbol "clojure.core/try",
                                          :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions."},
                         "cljs.core/iterate" {:ns "cljs.core",
                                              :name "iterate",
                                              :signature ["[f x]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_iterate",
                                              :source {:code "(defn iterate\n  [f x] (cons x (lazy-seq (iterate f (f x)))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1740
                                                               1743],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1740-L1743"},
                                              :full-name "cljs.core/iterate",
                                              :clj-symbol "clojure.core/iterate",
                                              :docstring "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"},
                         "cljs.core/lazy-seq" {:full-name "cljs.core/lazy-seq",
                                               :ns "cljs.core",
                                               :name "lazy-seq",
                                               :type "macro",
                                               :signature ["[& body]"],
                                               :source {:code "(defmacro lazy-seq [& body]\n  `(new cljs.core.LazySeq nil false (fn [] ~@body)))",
                                                        :filename "clojurescript/src/clj/cljs/core.clj",
                                                        :lines [400
                                                                401],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L400-L401"},
                                               :full-name-encode "cljs.core_lazy-seq",
                                               :clj-symbol "clojure.core/lazy-seq",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "specialrepl/load-file" {:full-name "specialrepl/load-file",
                                                  :ns "specialrepl",
                                                  :name "load-file",
                                                  :type "special form (repl)",
                                                  :source {:code "(defn repl\n  \"Note - repl will reload core.cljs every time, even if supplied old repl-env\"\n  [repl-env & {:keys [verbose warn-on-undeclared]}]\n  (prn \"Type: \" :cljs/quit \" to quit\")\n  (binding [comp/*cljs-ns* 'cljs.user\n            *cljs-verbose* verbose\n            comp/*cljs-warn-on-undeclared* warn-on-undeclared]\n    (let [env {:context :statement :locals {}}]\n      (-setup repl-env)\n      (loop []\n        (print (str \"ClojureScript:\" comp/*cljs-ns* \"> \"))\n        (flush)\n        (let [{:keys [status form]} (read-next-form)]\n          (cond\n           (= form :cljs/quit) :quit\n           \n           (= status :error) (recur)\n           \n           (and (seq? form) (= (first form) 'in-ns))\n           (do (set! comp/*cljs-ns* (second (second form))) (newline) (recur))\n           \n           (and (seq? form) ('#{load-file clojure.core/load-file} (first form)))\n           (do (load-file repl-env (second form)) (newline) (recur))\n           \n           (and (seq? form) ('#{load-namespace} (first form)))\n           (do (load-namespace repl-env (second form)) (newline) (recur))\n           \n           :else\n           (do (eval-and-print repl-env env form) (recur)))))\n      (-tear-down repl-env))))",
                                                           :filename "clojurescript/src/clj/cljs/repl.clj",
                                                           :lines [132
                                                                   161],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/repl.clj#L132-L161"},
                                                  :full-name-encode "specialrepl_load-file",
                                                  :clj-symbol "clojure.core/load-file",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/IndexedSeq" {:full-name "cljs.core/IndexedSeq",
                                                 :ns "cljs.core",
                                                 :name "IndexedSeq",
                                                 :type "type",
                                                 :signature ["[a i]"],
                                                 :source {:code "(deftype IndexedSeq [a i]\n  ISeqable\n  (-seq [this] this)\n  ISeq\n  (-first [_] (aget a i))\n  (-rest [_] (if (< (inc i) (.-length a))\n               (IndexedSeq. a (inc i))\n               (list)))\n\n  ICounted\n  (-count [_] (- (.-length a) i))\n\n  IIndexed\n  (-nth [coll n]\n    (let [i (+ n i)]\n      (when (< i (.-length a))\n        (aget a i))))\n  (-nth [coll n not-found]\n    (let [i (+ n i)]\n      (if (< i (.-length a))\n        (aget a i)\n        not-found)))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IReduce\n  (-reduce [coll f]\n    (ci-reduce coll f (aget a i) (inc i)))\n  (-reduce [coll f start]\n    (ci-reduce coll f start i))\n\n  IHash\n  (-hash [coll] (hash-coll coll)))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [292
                                                                  329],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L292-L329"},
                                                 :full-name-encode "cljs.core_IndexedSeq",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "cljs.core/next" {:ns "cljs.core",
                                           :name "next",
                                           :signature ["[coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_next",
                                           :source {:code "(defn next\n  [coll]\n  (when coll\n    (seq (rest coll))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [388 393],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L388-L393"},
                                           :full-name "cljs.core/next",
                                           :clj-symbol "clojure.core/next",
                                           :docstring "Returns a seq of the items after the first. Calls seq on its\nargument.  If there are no more items, returns nil"},
                         "cljs.core/*print-readably*" {:full-name "cljs.core/*print-readably*",
                                                       :ns "cljs.core",
                                                       :name "*print-readably*",
                                                       :type "var",
                                                       :source {:code "(def *print-readably* true)",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [2857
                                                                        2857],
                                                                :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2857-L2857"},
                                                       :full-name-encode "cljs.core__STAR_print-readably_STAR_",
                                                       :clj-symbol "clojure.core/*print-readably*",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.core/last" {:ns "cljs.core",
                                           :name "last",
                                           :signature ["[s]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_last",
                                           :source {:code "(defn last\n  [s]\n  (if (next s)\n    (recur (next s))\n    (first s)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [420 425],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L420-L425"},
                                           :full-name "cljs.core/last",
                                           :clj-symbol "clojure.core/last",
                                           :docstring "Return the last item in coll, in linear time"},
                         "cljs.core/bit-shift-left" {:ns "cljs.core",
                                                     :name "bit-shift-left",
                                                     :signature ["[x n]"],
                                                     :shadowed-sources ({:code "(defmacro bit-shift-left [x n]\n  (list 'js* \"(~{} << ~{})\" x n))",
                                                                         :filename "clojurescript/src/clj/cljs/core.clj",
                                                                         :lines [159
                                                                                 160],
                                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L159-L160"}),
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.core_bit-shift-left",
                                                     :source {:code "(defn bit-shift-left\n  [x n] (js* \"(~{x} << ~{n})\"))",
                                                              :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                              :lines [939
                                                                      941],
                                                              :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L939-L941"},
                                                     :full-name "cljs.core/bit-shift-left",
                                                     :clj-symbol "clojure.core/bit-shift-left",
                                                     :docstring "Bitwise shift left"},
                         "clojure.string/reverse" {:ns "clojure.string",
                                                   :name "reverse",
                                                   :signature ["[s]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.string_reverse",
                                                   :source {:code "(defn reverse\n  [s]\n  (.. s (split \"\") (reverse) (join \"\")))",
                                                            :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                            :lines [18
                                                                    21],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/string.cljs#L18-L21"},
                                                   :full-name "clojure.string/reverse",
                                                   :clj-symbol "clojure.string/reverse",
                                                   :docstring "Returns s with its characters reversed."},
                         "cljs.core/min" {:ns "cljs.core",
                                          :name "min",
                                          :signature ["[x]"
                                                      "[x y]"
                                                      "[x y & more]"],
                                          :shadowed-sources ({:code "(defmacro min\n  ([x] x)\n  ([x y] (list 'js* \"((~{} < ~{}) ? ~{} : ~{})\" x y x y))\n  ([x y & more] `(min (min ~x ~y) ~@more)))",
                                                              :filename "clojurescript/src/clj/cljs/core.clj",
                                                              :lines [123
                                                                      126],
                                                              :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L123-L126"}),
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_min",
                                          :source {:code "(defn min\n  ([x] x)\n  ([x y] (js* \"((~{x} < ~{y}) ? x : y)\"))\n  ([x y & more]\n   (reduce min (min x y) more)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [860 865],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L860-L865"},
                                          :full-name "cljs.core/min",
                                          :clj-symbol "clojure.core/min",
                                          :docstring "Returns the least of the nums."},
                         "cljs.reader/escape-char" {:full-name "cljs.reader/escape-char",
                                                    :ns "cljs.reader",
                                                    :name "escape-char",
                                                    :type "function",
                                                    :signature ["[buffer reader]"],
                                                    :source {:code "(defn escape-char\n  [buffer reader]\n  (let [ch (read-char reader)\n        mapresult (get escape-char-map ch)]\n    (if mapresult\n      mapresult\n      (if (or (= \\u ch) (numeric? ch))\n        (read-unicode-char reader ch)\n        (reader-error reader \"Unsupported escape charater: \\\\\" ch)))))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [149
                                                                     157],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L149-L157"},
                                                    :full-name-encode "cljs.reader_escape-char",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "cljs.reader/read-map" {:full-name "cljs.reader/read-map",
                                                 :ns "cljs.reader",
                                                 :name "read-map",
                                                 :type "function",
                                                 :signature ["[rdr _]"],
                                                 :source {:code "(defn read-map\n  [rdr _]\n  (let [l (read-delimited-list \"}\" rdr true)]\n    (when (odd? (count l))\n      (reader-error rdr \"Map literal must contain an even number of forms\"))\n    (apply hash-map l)))",
                                                          :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                          :lines [213
                                                                  218],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L213-L218"},
                                                 :full-name-encode "cljs.reader_read-map",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "cljs.core/seq" {:ns "cljs.core",
                                          :name "seq",
                                          :signature ["[coll]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_seq",
                                          :source {:code "(defn seq\n  [coll]\n  (when coll\n    (-seq coll)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [367 373],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L367-L373"},
                                          :full-name "cljs.core/seq",
                                          :clj-symbol "clojure.core/seq",
                                          :docstring "Returns a seq on the collection. If the collection is\nempty, returns nil.  (seq nil) returns nil. seq also works on\nStrings."},
                         "cljs.core/not-empty" {:ns "cljs.core",
                                                :name "not-empty",
                                                :signature ["[coll]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_not-empty",
                                                :source {:code "(defn not-empty\n  [coll] (when (seq coll) coll))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1399
                                                                 1401],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1399-L1401"},
                                                :full-name "cljs.core/not-empty",
                                                :clj-symbol "clojure.core/not-empty",
                                                :docstring "If coll is empty, returns nil, else coll"},
                         "cljs.core/println" {:ns "cljs.core",
                                              :name "println",
                                              :signature ["[& objs]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_println",
                                              :source {:code "(defn println\n  [& objs]\n  (pr-with-opts objs (assoc (pr-opts) :readably false))\n  (newline (pr-opts)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2887
                                                               2891],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2887-L2891"},
                                              :full-name "cljs.core/println",
                                              :clj-symbol "clojure.core/println",
                                              :docstring "Same as print followed by (newline)"},
                         "clojure.browser.repl/connect" {:full-name "clojure.browser.repl/connect",
                                                         :ns "clojure.browser.repl",
                                                         :name "connect",
                                                         :docstring "Connects to a REPL server from an HTML document. After the\nconnection is made, the REPL will evaluate forms in the context of\nthe document that called this function.",
                                                         :type "function",
                                                         :signature ["[repl-server-url]"],
                                                         :source {:code "(defn connect\n  [repl-server-url]\n  (let [repl-connection (net/xpc-connection\n                         {:peer_uri repl-server-url})]\n    (swap! xpc-connection (constantly repl-connection))\n    (net/register-service repl-connection\n                          :evaluate-javascript\n                          (fn [js]\n                            (net/transmit\n                             repl-connection\n                             :send-result\n                             (evaluate-javascript repl-connection js))))\n    (net/connect repl-connection\n                 (constantly nil)\n                 (fn [iframe]\n                   (set! iframe.style.display\n                         \"none\")))))",
                                                                  :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                  :lines [90
                                                                          109],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/repl.cljs#L90-L109"},
                                                         :full-name-encode "clojure.browser.repl_connect",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "clojure.browser.dom/insert-at" {:full-name "clojure.browser.dom/insert-at",
                                                          :ns "clojure.browser.dom",
                                                          :name "insert-at",
                                                          :type "function",
                                                          :signature ["[parent child index]"],
                                                          :source {:code "(defn insert-at [parent child index]\n  (gdom/insertChildAt parent child index))",
                                                                   :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                   :lines [102
                                                                           103],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/dom.cljs#L102-L103"},
                                                          :full-name-encode "clojure.browser.dom_insert-at",
                                                          :history [["+"
                                                                     "0.0-927"]]},
                         "cljs.core/quot" {:ns "cljs.core",
                                           :name "quot",
                                           :signature ["[n d]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_quot",
                                           :source {:code "(defn quot\n  [n d]\n  (let [rem (mod n d)]\n    (fix (js* \"((~{n} - ~{rem}) / ~{d})\"))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [877 881],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L877-L881"},
                                           :full-name "cljs.core/quot",
                                           :clj-symbol "clojure.core/quot",
                                           :docstring "quot[ient] of dividing numerator by denominator."},
                         "clojure.browser.event/get-listener" {:full-name "clojure.browser.event/get-listener",
                                                               :ns "clojure.browser.event",
                                                               :name "get-listener",
                                                               :type "function",
                                                               :signature ["[src type listener opt_capt opt_handler]"],
                                                               :source {:code "(defn get-listener [src type listener opt_capt opt_handler])",
                                                                        :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                        :lines [89
                                                                                89],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/event.cljs#L89-L89"},
                                                               :full-name-encode "clojure.browser.event_get-listener",
                                                               :history [["+"
                                                                          "0.0-927"]]},
                         "cljs.core/filter" {:ns "cljs.core",
                                             :name "filter",
                                             :signature ["[pred coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_filter",
                                             :source {:code "(defn filter\n  ([pred coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (let [f (first s) r (rest s)]\n        (if (pred f)\n          (cons f (filter pred r))\n          (filter pred r)))))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1785
                                                              1794],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1785-L1794"},
                                             :full-name "cljs.core/filter",
                                             :clj-symbol "clojure.core/filter",
                                             :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns true. pred must be free of side-effects."},
                         "clojure.zip/branch?" {:ns "clojure.zip",
                                                :name "branch?",
                                                :signature ["[loc]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.zip_branch_QMARK_",
                                                :source {:code "(defn branch?\n  [loc]\n    ((:zip/branch? (meta loc)) (node loc)))",
                                                         :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                         :lines [64
                                                                 67],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L64-L67"},
                                                :full-name "clojure.zip/branch?",
                                                :clj-symbol "clojure.zip/branch?",
                                                :docstring "Returns true if the node at loc is a branch"},
                         "special/if" {:full-name "special/if",
                                       :ns "special",
                                       :name "if",
                                       :type "special form",
                                       :source {:code "(defmethod parse 'if\n  [op env [_ test then else :as form] name]\n  (let [test-expr (disallowing-recur (analyze (assoc env :context :expr) test))\n        then-expr (analyze env then)\n        else-expr (analyze env else)]\n    {:env env :op :if :form form\n     :test test-expr :then then-expr :else else-expr\n     :children [test-expr then-expr else-expr]}))",
                                                :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                :lines [603 610],
                                                :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/compiler.clj#L603-L610"},
                                       :full-name-encode "special_if",
                                       :clj-symbol "clojure.core/if",
                                       :history [["+" "0.0-927"]]},
                         "cljs.core/ObjMap" {:full-name "cljs.core/ObjMap",
                                             :ns "cljs.core",
                                             :name "ObjMap",
                                             :type "type",
                                             :signature ["[meta keys strobj]"],
                                             :source {:code "(deftype ObjMap [meta keys strobj]\n  IWithMeta\n  (-with-meta [coll meta] (ObjMap. meta keys strobj))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.ObjMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? (.-length keys))\n      (map #(vector % (aget strobj %)) keys)))\n\n  ICounted\n  (-count [coll] (.-length keys))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (obj-map-contains-key? k strobj (aget strobj k) not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (goog/isString k)\n      (let [new-strobj (goog.object/clone strobj)\n            overwrite? (.hasOwnProperty new-strobj k)]\n        (aset new-strobj k v)\n        (if overwrite?\n          (ObjMap. meta keys new-strobj)     ; overwrite\n          (let [new-keys (aclone keys)] ; append\n            (.push new-keys k)\n            (ObjMap. meta new-keys new-strobj))))\n      ; non-string key. game over.\n      (with-meta (into (hash-map k v) (seq coll)) meta)))\n  (-contains-key? [coll k]\n    (obj-map-contains-key? k strobj))\n\n  IMap\n  (-dissoc [coll k]\n    (if (and (goog/isString k) (.hasOwnProperty strobj k))\n      (let [new-keys (aclone keys)\n            new-strobj (goog.object/clone strobj)]\n        (.splice new-keys (scan-array 1 k new-keys) 1)\n        (js-delete new-strobj k)\n        (ObjMap. meta new-keys new-strobj))\n      coll)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2193
                                                              2254],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2193-L2254"},
                                             :full-name-encode "cljs.core_ObjMap",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/zipmap" {:ns "cljs.core",
                                             :name "zipmap",
                                             :signature ["[keys vals]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_zipmap",
                                             :source {:code "(defn zipmap\n  [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2540
                                                              2550],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2540-L2550"},
                                             :full-name "cljs.core/zipmap",
                                             :clj-symbol "clojure.core/zipmap",
                                             :docstring "Returns a map with the keys mapped to the corresponding vals."},
                         "cljs.core/hash-combine" {:full-name "cljs.core/hash-combine",
                                                   :ns "cljs.core",
                                                   :name "hash-combine",
                                                   :type "function",
                                                   :signature ["[seed hash]"],
                                                   :source {:code "(defn hash-combine [seed hash]\n  ; a la boost\n  (bit-xor seed (+ hash 0x9e3779b9\n                   (bit-shift-left seed 6)\n                   (bit-shift-right seed 2))))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [1058
                                                                    1062],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1058-L1062"},
                                                   :full-name-encode "cljs.core_hash-combine",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "cljs.core/max-key" {:ns "cljs.core",
                                              :name "max-key",
                                              :signature ["[k x]"
                                                          "[k x y]"
                                                          "[k x y & more]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_max-key",
                                              :source {:code "(defn max-key\n  ([k x] x)\n  ([k x y] (if (> (k x) (k y)) x y))\n  ([k x y & more]\n   (reduce #(max-key k %1 %2) (max-key k x y) more)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2552
                                                               2557],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2552-L2557"},
                                              :full-name "cljs.core/max-key",
                                              :clj-symbol "clojure.core/max-key",
                                              :docstring "Returns the x for which (k x), a number, is greatest."},
                         "clojure.zip/insert-child" {:ns "clojure.zip",
                                                     :name "insert-child",
                                                     :signature ["[loc item]"],
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "clojure.zip_insert-child",
                                                     :source {:code "(defn insert-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (cons item (children loc)))))",
                                                              :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                              :lines [194
                                                                      198],
                                                              :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L194-L198"},
                                                     :full-name "clojure.zip/insert-child",
                                                     :clj-symbol "clojure.zip/insert-child",
                                                     :docstring "Inserts the item as the leftmost child of the node at this loc,\nwithout moving"},
                         "cljs.core/defrecord" {:full-name "cljs.core/defrecord",
                                                :ns "cljs.core",
                                                :name "defrecord",
                                                :type "macro",
                                                :signature ["[rsym fields & impls]"],
                                                :source {:code "(defmacro defrecord [rsym fields & impls]\n  (let [r (:name (cljs.compiler/resolve-var (dissoc &env :locals) rsym))]\n    `(let []\n       ~(emit-defrecord rsym r fields impls)\n       ~(build-positional-factory rsym r fields)\n       ~(build-map-factory rsym r fields))))",
                                                         :filename "clojurescript/src/clj/cljs/core.clj",
                                                         :lines [357
                                                                 362],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L357-L362"},
                                                :full-name-encode "cljs.core_defrecord",
                                                :clj-symbol "clojure.core/defrecord",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/butlast" {:full-name "cljs.core/butlast",
                                              :ns "cljs.core",
                                              :name "butlast",
                                              :type "function",
                                              :signature ["[s]"],
                                              :source {:code "(defn butlast [s]\n  (loop [ret [] s s]\n    (if (next s)\n      (recur (conj ret (first s)) (next s))\n      (seq ret))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2513
                                                               2517],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2513-L2517"},
                                              :full-name-encode "cljs.core_butlast",
                                              :clj-symbol "clojure.core/butlast",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/hash" {:full-name "cljs.core/hash",
                                           :ns "cljs.core",
                                           :name "hash",
                                           :type "function",
                                           :signature ["[o]"],
                                           :source {:code "(defn hash [o]\n  (-hash o))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [543 544],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L543-L544"},
                                           :full-name-encode "cljs.core_hash",
                                           :clj-symbol "clojure.core/hash",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/bit-set" {:ns "cljs.core",
                                              :name "bit-set",
                                              :signature ["[x n]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_bit-set",
                                              :source {:code "(defn bit-set\n  [x n]\n  (js* \"(~{x} | (1 << ~{n}))\"))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [928
                                                               931],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L928-L931"},
                                              :full-name "cljs.core/bit-set",
                                              :clj-symbol "clojure.core/bit-set",
                                              :docstring "Set bit at index n"},
                         "cljs.core/concat" {:ns "cljs.core",
                                             :name "concat",
                                             :signature ["[]"
                                                         "[x]"
                                                         "[x y]"
                                                         "[x y & zs]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_concat",
                                             :source {:code "(defn concat\n  ([] (lazy-seq nil))\n  ([x] (lazy-seq x))\n  ([x y]\n    (lazy-seq\n      (let [s (seq x)]\n        (if s\n          (cons (first s) (concat (rest s) y))\n          y))))\n  ([x y & zs]\n     (let [cat (fn cat [xys zs]\n                 (lazy-seq\n                   (let [xys (seq xys)]\n                     (if xys\n                       (cons (first xys) (cat (rest xys) zs))\n                       (when zs\n                         (cat (first zs) (next zs)))))))]\n       (cat (concat x y) zs))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1306
                                                              1324],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1306-L1324"},
                                             :full-name "cljs.core/concat",
                                             :clj-symbol "clojure.core/concat",
                                             :docstring "Returns a lazy seq representing the concatenation of the elements in the supplied colls."},
                         "cljs.core/conj" {:ns "cljs.core",
                                           :name "conj",
                                           :signature ["[coll x]"
                                                       "[coll x & xs]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_conj",
                                           :source {:code "(defn conj\n  ([coll x]\n     (-conj coll x))\n  ([coll x & xs]\n     (if xs\n       (recur (conj coll x) (first xs) (next xs))\n       (conj coll x))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [442 451],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L442-L451"},
                                           :full-name "cljs.core/conj",
                                           :clj-symbol "clojure.core/conj",
                                           :docstring "conj[oin]. Returns a new collection with the xs\n'added'. (conj nil item) returns (item).  The 'addition' may\nhappen at different 'places' depending on the concrete type."},
                         "clojure.set/difference" {:ns "clojure.set",
                                                   :name "difference",
                                                   :signature ["[s1]"
                                                               "[s1 s2]"
                                                               "[s1 s2 & sets]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.set_difference",
                                                   :source {:code "(defn difference\n  ([s1] s1)\n  ([s1 s2] \n     (if (< (count s1) (count s2))\n       (reduce (fn [result item] \n                   (if (contains? s2 item) \n                     (disj result item) \n                     result))\n               s1 s1)\n       (reduce disj s1 s2)))\n  ([s1 s2 & sets] \n     (reduce difference s1 (conj sets s2))))",
                                                            :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                            :lines [46
                                                                    58],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/set.cljs#L46-L58"},
                                                   :full-name "clojure.set/difference",
                                                   :clj-symbol "clojure.set/difference",
                                                   :docstring "Return a set that is the first set without elements of the remaining sets"},
                         "cljs.core/when-first" {:ns "cljs.core",
                                                 :name "when-first",
                                                 :signature ["[bindings & body]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "macro",
                                                 :full-name-encode "cljs.core_when-first",
                                                 :source {:code "(defmacro when-first\n  [bindings & body]\n  (assert-args when-first\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n  (let [[x xs] bindings]\n    `(when (seq ~xs)\n       (let [~x (first ~xs)]\n         ~@body))))",
                                                          :filename "clojure/src/clj/clojure/core.clj",
                                                          :lines [4050
                                                                  4062],
                                                          :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L4050-L4062"},
                                                 :full-name "cljs.core/when-first",
                                                 :clj-symbol "clojure.core/when-first",
                                                 :docstring "bindings => x xs\n\nSame as (when (seq xs) (let [x (first xs)] body))"},
                         "cljs.core/distinct?" {:ns "cljs.core",
                                                :name "distinct?",
                                                :signature ["[x]"
                                                            "[x y]"
                                                            "[x y & more]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_distinct_QMARK_",
                                                :source {:code "(defn distinct?\n  ([x] true)\n  ([x y] (not (= x y)))\n  ([x y & more]\n     (if (not (= x y))\n     (loop [s #{x y} xs more]\n       (let [x (first xs)\n             etc (next xs)]\n         (if xs\n           (if (contains? s x)\n             false\n             (recur (conj s x) etc))\n           true)))\n     false)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [672
                                                                 686],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L672-L686"},
                                                :full-name "cljs.core/distinct?",
                                                :clj-symbol "clojure.core/distinct?",
                                                :docstring "Returns true if no two of the arguments are ="},
                         "cljs.core/pos?" {:ns "cljs.core",
                                           :name "pos?",
                                           :signature ["[n]"],
                                           :shadowed-sources ({:code "(defmacro pos? [x]\n  `(> ~x 0))",
                                                               :filename "clojurescript/src/clj/cljs/core.clj",
                                                               :lines [112
                                                                       113],
                                                               :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L112-L113"}),
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_pos_QMARK_",
                                           :source {:code "(defn pos?\n  [n] (< 0 n))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [959 961],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L959-L961"},
                                           :full-name "cljs.core/pos?",
                                           :clj-symbol "clojure.core/pos?",
                                           :docstring "Returns true if num is greater than zero, else false"},
                         "cljs.core/IHash" {:ns "cljs.core",
                                            :name "IHash",
                                            :type "protocol",
                                            :full-name-encode "cljs.core_IHash",
                                            :source {:code "(defprotocol IHash\n  (-hash [o]))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [152 153],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L152-L153"},
                                            :methods [{:name "-hash",
                                                       :signature ["[o]"],
                                                       :docstring nil}],
                                            :full-name "cljs.core/IHash",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/is_proto_" {:full-name "cljs.core/is_proto_",
                                                :ns "cljs.core",
                                                :name "is_proto_",
                                                :type "function",
                                                :signature ["[x]"],
                                                :source {:code "(defn is_proto_\n  [x]\n  (js* \"(~{x}).constructor.prototype === ~{x}\"))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [48
                                                                 50],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L48-L50"},
                                                :full-name-encode "cljs.core_is_proto_",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/keep-indexed" {:ns "cljs.core",
                                                   :name "keep-indexed",
                                                   :signature ["[f coll]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.core_keep-indexed",
                                                   :source {:code "(defn keep-indexed\n  ([f coll]\n     (let [keepi (fn kpi [idx coll]\n                   (lazy-seq\n                    (when-let [s (seq coll)]\n                      (let [x (f idx (first s))]\n                        (if (nil? x)\n                          (kpi (inc idx) (rest s))\n                          (cons x (kpi (inc idx) (rest s))))))))]\n       (keepi 0 coll))))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [1547
                                                                    1559],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1547-L1559"},
                                                   :full-name "cljs.core/keep-indexed",
                                                   :clj-symbol "clojure.core/keep-indexed",
                                                   :docstring "Returns a lazy sequence of the non-nil results of (f index item). Note,\nthis means false return values will be included.  f must be free of\nside-effects."},
                         "cljs.core/bit-shift-right" {:ns "cljs.core",
                                                      :name "bit-shift-right",
                                                      :signature ["[x n]"],
                                                      :shadowed-sources ({:code "(defmacro bit-shift-right [x n]\n  (list 'js* \"(~{} >> ~{})\" x n))",
                                                                          :filename "clojurescript/src/clj/cljs/core.clj",
                                                                          :lines [162
                                                                                  163],
                                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L162-L163"}),
                                                      :history [["+"
                                                                 "0.0-927"]],
                                                      :type "function",
                                                      :full-name-encode "cljs.core_bit-shift-right",
                                                      :source {:code "(defn bit-shift-right\n  [x n] (js* \"(~{x} >> ~{n})\"))",
                                                               :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                               :lines [943
                                                                       945],
                                                               :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L943-L945"},
                                                      :full-name "cljs.core/bit-shift-right",
                                                      :clj-symbol "clojure.core/bit-shift-right",
                                                      :docstring "Bitwise shift right"},
                         "clojure.zip/insert-right" {:ns "clojure.zip",
                                                     :name "insert-right",
                                                     :signature ["[loc item]"],
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "clojure.zip_insert-right",
                                                     :source {:code "(defn insert-right\n  [loc item]\n    (let [[node {r :r :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :r (cons item r) :changed? true)] (meta loc)))))",
                                                              :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                              :lines [174
                                                                      181],
                                                              :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L174-L181"},
                                                     :full-name "clojure.zip/insert-right",
                                                     :clj-symbol "clojure.zip/insert-right",
                                                     :docstring "Inserts the item as the right sibling of the node at this loc,\nwithout moving"},
                         "cljs.core/make-hierarchy" {:ns "cljs.core",
                                                     :name "make-hierarchy",
                                                     :signature ["[]"],
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.core_make-hierarchy",
                                                     :source {:code "(defn make-hierarchy\n  [] {:parents {} :descendants {} :ancestors {}})",
                                                              :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                              :lines [3248
                                                                      3250],
                                                              :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3248-L3250"},
                                                     :full-name "cljs.core/make-hierarchy",
                                                     :clj-symbol "clojure.core/make-hierarchy",
                                                     :docstring "Creates a hierarchy object for use with derive, isa? etc."},
                         "cljs.core/repeat" {:ns "cljs.core",
                                             :name "repeat",
                                             :signature ["[x]"
                                                         "[n x]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_repeat",
                                             :source {:code "(defn repeat\n  ([x] (lazy-seq (cons x (repeat x))))\n  ([n x] (take n (repeat x))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1724
                                                              1727],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1724-L1727"},
                                             :full-name "cljs.core/repeat",
                                             :clj-symbol "clojure.core/repeat",
                                             :docstring "Returns a lazy (infinite!, or length n if supplied) sequence of xs."},
                         "cljs.core/MultiFn" {:full-name "cljs.core/MultiFn",
                                              :ns "cljs.core",
                                              :name "MultiFn",
                                              :type "type",
                                              :signature ["[name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]"],
                                              :source {:code "(deftype MultiFn [name dispatch-fn default-dispatch-val hierarchy\n                  method-table prefer-table method-cache cached-hierarchy]\n  IMultiFn\n  (-reset [mf]\n    (swap! method-table (fn [mf] {}))\n    (swap! method-cache (fn [mf] {}))\n    (swap! prefer-table (fn [mf] {}))\n    (swap! cached-hierarchy (fn [mf] nil))\n    mf)\n\n  (-add-method [mf dispatch-val method]\n    (swap! method-table assoc dispatch-val method)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-remove-method [mf dispatch-val]\n    (swap! method-table dissoc dispatch-val)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-get-method [mf dispatch-val]\n    (when-not (= @cached-hierarchy @hierarchy)\n      (reset-cache method-cache method-table cached-hierarchy hierarchy))\n    (if-let [target-fn (@method-cache dispatch-val)]\n      target-fn\n      (if-let [target-fn (find-and-cache-best-method name dispatch-val hierarchy method-table\n                                                     prefer-table method-cache cached-hierarchy)]\n        target-fn\n        (@method-table default-dispatch-val))))\n\n  (-prefer-method [mf dispatch-val-x dispatch-val-y]\n    (when (prefers* dispatch-val-x dispatch-val-y prefer-table)\n      (throw (js/Error. (str \"Preference conflict in multimethod '\" name \"': \" dispatch-val-y\n                   \" is already preferred to \" dispatch-val-x))))\n    (swap! prefer-table\n           (fn [old]\n             (assoc old dispatch-val-x\n                    (conj (get old dispatch-val-x #{})\n                          dispatch-val-y))))\n    (reset-cache method-cache method-table cached-hierarchy hierarchy))\n\n  (-methods [mf] @method-table)\n  (-prefers [mf] @prefer-table)\n\n  (-invoke [mf args] (do-invoke mf dispatch-fn args))\n\n  IHash\n  (-hash [this] (goog.getUid this)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [3426
                                                               3473],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3426-L3473"},
                                              :full-name-encode "cljs.core_MultiFn",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/not-any?" {:ns "cljs.core",
                                               :name "not-any?",
                                               :signature ["[pred coll]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_not-any_QMARK_",
                                               :source {:code "(defn not-any?\n  [pred coll] (not (some pred coll)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [1426
                                                                1429],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1426-L1429"},
                                               :full-name "cljs.core/not-any?",
                                               :clj-symbol "clojure.core/not-any?",
                                               :docstring "Returns false if (pred x) is logical true for any x in coll,\nelse true."},
                         "cljs.reader/read-regex" {:full-name "cljs.reader/read-regex",
                                                   :ns "cljs.reader",
                                                   :name "read-regex",
                                                   :type "function",
                                                   :signature ["[rdr ch]"],
                                                   :source {:code "(defn read-regex\n  [rdr ch]\n  (-> (read-string rdr ch) re-pattern))",
                                                            :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                            :lines [301
                                                                    303],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L301-L303"},
                                                   :full-name-encode "cljs.reader_read-regex",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "clojure.zip/next" {:ns "clojure.zip",
                                             :name "next",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_next",
                                             :source {:code "(defn next\n  [loc]\n    (if (= :end (loc 1))\n      loc\n      (or \n       (and (branch? loc) (down loc))\n       (right loc)\n       (loop [p loc]\n         (if (up p)\n           (or (right (up p)) (recur (up p)))\n           [(node p) :end])))))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [206 219],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L206-L219"},
                                             :full-name "clojure.zip/next",
                                             :clj-symbol "clojure.zip/next",
                                             :docstring "Moves to the next loc in the hierarchy, depth-first. When reaching\nthe end, returns a distinguished loc detectable via end?. If already\nat the end, stays there."},
                         "cljs.core/aget" {:ns "cljs.core",
                                           :name "aget",
                                           :signature ["[array i]"],
                                           :shadowed-sources ({:code "(defmacro aget [a i]\n  (list 'js* \"(~{}[~{}])\" a i))",
                                                               :filename "clojurescript/src/clj/cljs/core.clj",
                                                               :lines [48
                                                                       49],
                                                               :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L48-L49"}),
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_aget",
                                           :source {:code "(defn aget\n  [array i]\n  (js* \"~{array}[~{i}]\"))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [77 80],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L77-L80"},
                                           :full-name "cljs.core/aget",
                                           :clj-symbol "clojure.core/aget",
                                           :docstring "Returns the value at the index."},
                         "cljs.core/if-let" {:ns "cljs.core",
                                             :name "if-let",
                                             :signature ["[bindings then]"
                                                         "[bindings then else & oldform]"],
                                             :history [["+" "0.0-927"]],
                                             :type "macro",
                                             :full-name-encode "cljs.core_if-let",
                                             :source {:code "(defmacro if-let\n  ([bindings then]\n   `(if-let ~bindings ~then nil))\n  ([bindings then else & oldform]\n   (assert-args if-let\n     (and (vector? bindings) (nil? oldform)) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if temp#\n          (let [~form temp#]\n            ~then)\n          ~else)))))",
                                                      :filename "clojure/src/clj/clojure/core.clj",
                                                      :lines [1666
                                                              1683],
                                                      :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L1666-L1683"},
                                             :full-name "cljs.core/if-let",
                                             :clj-symbol "clojure.core/if-let",
                                             :docstring "bindings => binding-form test\n\nIf test is true, evaluates then with binding-form bound to the value of \ntest, if not, yields else"},
                         "cljs.core//" {:ns "cljs.core",
                                        :name "/",
                                        :signature ["[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :shadowed-sources ({:code "(defmacro /\n  ([] 1)\n  ([x] `(/ 1 x))\n  ([x y] (list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [72
                                                                    76],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L72-L76"}),
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core__SLASH_",
                                        :source {:code "(defn /\n  ([x] (js* \"(1 / ~{x})\"))\n  ([x y] (js* \"(~{x} / ~{y})\"))\n  ([x y & more] (reduce / (/ x y) more)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [794 799],
                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L794-L799"},
                                        :full-name "cljs.core//",
                                        :clj-symbol "clojure.core//",
                                        :docstring "If no denominators are supplied, returns 1/numerator,\nelse returns numerator divided by all of the denominators."},
                         "cljs.core/min-key" {:ns "cljs.core",
                                              :name "min-key",
                                              :signature ["[k x]"
                                                          "[k x y]"
                                                          "[k x y & more]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_min-key",
                                              :source {:code "(defn min-key\n  ([k x] x)\n  ([k x y] (if (< (k x) (k y)) x y))\n  ([k x y & more]\n     (reduce #(min-key k %1 %2) (min-key k x y) more)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2559
                                                               2564],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2559-L2564"},
                                              :full-name "cljs.core/min-key",
                                              :clj-symbol "clojure.core/min-key",
                                              :docstring "Returns the x for which (k x), a number, is least."},
                         "clojure.zip/root" {:ns "clojure.zip",
                                             :name "root",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_root",
                                             :source {:code "(defn root\n  [loc]\n    (if (= :end (loc 1))\n      (node loc)\n      (let [p (up loc)]\n        (if p\n          (recur p)\n          (node loc)))))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [124 133],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L124-L133"},
                                             :full-name "clojure.zip/root",
                                             :clj-symbol "clojure.zip/root",
                                             :docstring "zips all the way up and returns the root node, reflecting any\nchanges."},
                         "cljs.core/drop-while" {:ns "cljs.core",
                                                 :name "drop-while",
                                                 :signature ["[pred coll]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_drop-while",
                                                 :source {:code "(defn drop-while\n  [pred coll]\n  (let [step (fn [pred coll]\n               (let [s (seq coll)]\n                 (if (and s (pred (first s)))\n                   (recur pred (rest s))\n                   s)))]\n    (lazy-seq (step pred coll))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [1702
                                                                  1711],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1702-L1711"},
                                                 :full-name "cljs.core/drop-while",
                                                 :clj-symbol "clojure.core/drop-while",
                                                 :docstring "Returns a lazy sequence of the items in coll starting from the first\nitem for which (pred item) returns nil."},
                         "clojure.browser.repl/evaluate-javascript" {:full-name "clojure.browser.repl/evaluate-javascript",
                                                                     :ns "clojure.browser.repl",
                                                                     :name "evaluate-javascript",
                                                                     :docstring "Process a single block of JavaScript received from the server",
                                                                     :type "function",
                                                                     :signature ["[conn block]"],
                                                                     :source {:code "(defn evaluate-javascript\n  [conn block]\n  (let [result (try {:status :success :value (str (js* \"eval(~{block})\"))}\n                    (catch js/Error e\n                      {:status :exception :value (pr-str e)\n                       :stacktrace (if (.hasOwnProperty e \"stack\")\n                                     (.-stack e)\n                                     \"No stacktrace available.\")}))]\n    (pr-str result)))",
                                                                              :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                              :lines [27
                                                                                      36],
                                                                              :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/repl.cljs#L27-L36"},
                                                                     :full-name-encode "clojure.browser.repl_evaluate-javascript",
                                                                     :history [["+"
                                                                                "0.0-927"]]},
                         "cljs.core/set-validator!" {:ns "cljs.core",
                                                     :name "set-validator!",
                                                     :signature ["[iref val]"],
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.core_set-validator_BANG_",
                                                     :source {:code "(defn set-validator!\n  [iref val]\n  (set! (.-validator iref) val))",
                                                              :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                              :lines [3054
                                                                      3062],
                                                              :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3054-L3062"},
                                                     :full-name "cljs.core/set-validator!",
                                                     :clj-symbol "clojure.core/set-validator!",
                                                     :docstring "Sets the validator-fn for an atom. validator-fn must be nil or a\nside-effect-free fn of one argument, which will be passed the intended\nnew state on any state change. If the new state is unacceptable, the\nvalidator-fn should return false or throw an Error. If the current state\nis not acceptable to the new validator, an Error will be thrown and the\nvalidator will not be changed."},
                         "cljs.core/<" {:ns "cljs.core",
                                        :name "<",
                                        :signature ["[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :shadowed-sources ({:code "(defmacro <\n  ([x] true)\n  ([x y] (list 'js* \"(~{} < ~{})\" x y))\n  ([x y & more] `(and (< ~x ~y) (< ~y ~@more))))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [78
                                                                    81],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L78-L81"}),
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core__LT_",
                                        :source {:code "(defn <\n  ([x] true)\n  ([x y] (js* \"(~{x} < ~{y})\"))\n  ([x y & more]\n     (if (< x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (< y (first more)))\n       false)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [801 811],
                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L801-L811"},
                                        :full-name "cljs.core/<",
                                        :clj-symbol "clojure.core/<",
                                        :docstring "Returns non-nil if nums are in monotonically increasing order,\notherwise false."},
                         "cljs.core/fn" {:ns "cljs.core",
                                         :name "fn",
                                         :signature ["[& sigs]"],
                                         :shadowed-sources ({:code "(def\n ^{:macro true\n   :added \"1.0\"}\n fn (fn* fn [&form &env & decl] \n         (.withMeta ^clojure.lang.IObj (cons 'fn* decl) \n                    (.meta ^clojure.lang.IMeta &form))))",
                                                             :filename "clojure/src/clj/clojure/core.clj",
                                                             :lines [42
                                                                     47],
                                                             :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L42-L47"}),
                                         :history [["+" "0.0-927"]],
                                         :type "macro",
                                         :full-name-encode "cljs.core_fn",
                                         :source {:code "(defmacro fn\n  [& sigs]\n    (let [name (if (symbol? (first sigs)) (first sigs) nil)\n          sigs (if name (next sigs) sigs)\n          sigs (if (vector? (first sigs)) (list sigs) sigs)\n          psig (fn* [sig]\n                 (let [[params & body] sig\n                       conds (when (and (next body) (map? (first body))) \n                                           (first body))\n                       body (if conds (next body) body)\n                       conds (or conds (meta params))\n                       pre (:pre conds)\n                       post (:post conds)                       \n                       body (if post\n                              `((let [~'% ~(if (< 1 (count body)) \n                                            `(do ~@body) \n                                            (first body))]\n                                 ~@(map (fn* [c] `(assert ~c)) post)\n                                 ~'%))\n                              body)\n                       body (if pre\n                              (concat (map (fn* [c] `(assert ~c)) pre) \n                                      body)\n                              body)]\n                   (maybe-destructured params body)))\n          new-sigs (map psig sigs)]\n      (with-meta\n        (if name\n          (list* 'fn* name new-sigs)\n          (cons 'fn* new-sigs))\n        (meta &form))))",
                                                  :filename "clojure/src/clj/clojure/core.clj",
                                                  :lines [3985 4023],
                                                  :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L3985-L4023"},
                                         :full-name "cljs.core/fn",
                                         :clj-symbol "clojure.core/fn",
                                         :docstring "params => positional-params* , or positional-params* & next-param\npositional-param => binding-form\nnext-param => binding-form\nname => symbol\n\nDefines a function"},
                         "cljs.core/split-with" {:ns "cljs.core",
                                                 :name "split-with",
                                                 :signature ["[pred coll]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_split-with",
                                                 :source {:code "(defn split-with\n  [pred coll]\n  [(take-while pred coll) (drop-while pred coll)])",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2659
                                                                  2662],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2659-L2662"},
                                                 :full-name "cljs.core/split-with",
                                                 :clj-symbol "clojure.core/split-with",
                                                 :docstring "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"},
                         "cljs.core/IReduce" {:ns "cljs.core",
                                              :name "IReduce",
                                              :type "protocol",
                                              :full-name-encode "cljs.core_IReduce",
                                              :source {:code "(defprotocol IReduce\n  (-reduce [coll f] [coll f start]))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [146
                                                               147],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L146-L147"},
                                              :methods [{:name "-reduce",
                                                         :signature ["[coll f]"
                                                                     "[coll f start]"],
                                                         :docstring nil}],
                                              :full-name "cljs.core/IReduce",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.reader/symbol-pattern" {:full-name "cljs.reader/symbol-pattern",
                                                       :ns "cljs.reader",
                                                       :name "symbol-pattern",
                                                       :type "var",
                                                       :source {:code "(def symbol-pattern (re-pattern \"[:]?([^0-9/].*/)?([^0-9/][^/]*)\"))",
                                                                :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                :lines [98
                                                                        98],
                                                                :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L98-L98"},
                                                       :full-name-encode "cljs.reader_symbol-pattern",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.core/repeatedly" {:ns "cljs.core",
                                                 :name "repeatedly",
                                                 :signature ["[f]"
                                                             "[n f]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_repeatedly",
                                                 :source {:code "(defn repeatedly\n  ([f] (lazy-seq (cons (f) (repeatedly f))))\n  ([n f] (take n (repeatedly f))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [1733
                                                                  1738],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1733-L1738"},
                                                 :full-name "cljs.core/repeatedly",
                                                 :clj-symbol "clojure.core/repeatedly",
                                                 :docstring "Takes a function of no args, presumably with side effects, and\nreturns an infinite (or length n if supplied) lazy sequence of calls\nto it"},
                         "cljs.reader/read-delimited-list" {:full-name "cljs.reader/read-delimited-list",
                                                            :ns "cljs.reader",
                                                            :name "read-delimited-list",
                                                            :type "function",
                                                            :signature ["[delim rdr recursive?]"],
                                                            :source {:code "(defn read-delimited-list\n  [delim rdr recursive?]\n  (loop [a []]\n    (let [ch (read-past whitespace? rdr)]\n      (when-not ch (reader-error rdr \"EOF\"))\n      (if (= delim ch)\n        a\n        (if-let [macrofn (get macros ch)]\n          (let [mret (macrofn rdr ch)]\n            (recur (if (= mret rdr) a (conj a mret))))\n          (do\n            (unread rdr ch)\n            (let [o (read rdr true nil recursive?)]\n              (recur (if (= o rdr) a (conj a o))))))))))",
                                                                     :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                     :lines [168
                                                                             181],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L168-L181"},
                                                            :full-name-encode "cljs.reader_read-delimited-list",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "cljs.core/undefined?" {:full-name "cljs.core/undefined?",
                                                 :ns "cljs.core",
                                                 :name "undefined?",
                                                 :type "function",
                                                 :signature ["[x]"],
                                                 :source {:code "(defn undefined? [x]\n  (js* \"(void 0 === ~{x})\"))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [612
                                                                  613],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L612-L613"},
                                                 :full-name-encode "cljs.core_undefined_QMARK_",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "clojure.zip/prev" {:ns "clojure.zip",
                                             :name "prev",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_prev",
                                             :source {:code "(defn prev\n  [loc]\n    (if-let [lloc (left loc)]\n      (loop [loc lloc]\n        (if-let [child (and (branch? loc) (down loc))]\n          (recur (rightmost child))\n          loc))\n      (up loc)))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [221 230],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L221-L230"},
                                             :full-name "clojure.zip/prev",
                                             :clj-symbol "clojure.zip/prev",
                                             :docstring "Moves to the previous loc in the hierarchy, depth-first. If already\nat the root, returns nil."},
                         "cljs.core/seq?" {:ns "cljs.core",
                                           :name "seq?",
                                           :signature ["[s]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_seq_QMARK_",
                                           :source {:code "(defn seq?\n  [s]\n  (if (nil? s)\n    false\n    (satisfies? ISeq s)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [618 623],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L618-L623"},
                                           :full-name "cljs.core/seq?",
                                           :clj-symbol "clojure.core/seq?",
                                           :docstring "Return true if s satisfies ISeq"},
                         "cljs.core/odd?" {:ns "cljs.core",
                                           :name "odd?",
                                           :signature ["[n]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_odd_QMARK_",
                                           :source {:code "(defn odd?\n  [n] (not (even? n)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1437 1439],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1437-L1439"},
                                           :full-name "cljs.core/odd?",
                                           :clj-symbol "clojure.core/odd?",
                                           :docstring "Returns true if n is odd, throws an exception if n is not an integer"},
                         "cljs.core/cons" {:ns "cljs.core",
                                           :name "cons",
                                           :signature ["[x seq]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_cons",
                                           :source {:code "(defn cons\n  [x seq]\n  (Cons. nil x seq))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1184 1187],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1184-L1187"},
                                           :full-name "cljs.core/cons",
                                           :clj-symbol "clojure.core/cons",
                                           :docstring "Returns a new seq where x is the first element and seq is the rest."},
                         "special/deftype*" {:full-name "special/deftype*",
                                             :ns "special",
                                             :name "deftype*",
                                             :type "special form",
                                             :source {:code "(defmethod parse 'deftype*\n  [_ env [_ tsym fields] _]\n  (let [t (munge (:name (resolve-var (dissoc env :locals) tsym)))]\n    (swap! namespaces update-in [(-> env :ns :name) :defs tsym]\n           (fn [m]\n             (let [m (assoc (or m {}) :name t)]\n               (if-let [line (:line env)]\n                 (-> m\n                     (assoc :file *cljs-file*)\n                     (assoc :line line))\n                 m))))\n    {:env env :op :deftype* :t t :fields fields}))",
                                                      :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                      :lines [842 853],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/compiler.clj#L842-L853"},
                                             :full-name-encode "special_deftype_STAR_",
                                             :history [["+" "0.0-927"]]},
                         "cljs.reader/read-set" {:full-name "cljs.reader/read-set",
                                                 :ns "cljs.reader",
                                                 :name "read-set",
                                                 :type "function",
                                                 :signature ["[rdr _]"],
                                                 :source {:code "(defn read-set\n  [rdr _]\n  (set (read-delimited-list \"}\" rdr true)))",
                                                          :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                          :lines [297
                                                                  299],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L297-L299"},
                                                 :full-name-encode "cljs.reader_read-set",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "cljs.core/descendants" {:ns "cljs.core",
                                                  :name "descendants",
                                                  :signature ["[tag]"
                                                              "[h tag]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_descendants",
                                                  :source {:code "(defn descendants\n  ([tag] (descendants @global-hierarchy tag))\n  ([h tag] (not-empty (get (:descendants h) tag))))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [3292
                                                                   3299],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3292-L3299"},
                                                  :full-name "cljs.core/descendants",
                                                  :clj-symbol "clojure.core/descendants",
                                                  :docstring "Returns the immediate and indirect children of tag, through a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy. Note: does not work on Java type inheritance\nrelationships."},
                         "special/new" {:full-name "special/new",
                                        :ns "special",
                                        :name "new",
                                        :type "special form",
                                        :source {:code "(defmethod parse 'new\n  [_ env [_ ctor & args] _]\n  (disallowing-recur\n   (let [enve (assoc env :context :expr)\n         ctorexpr (analyze enve ctor)\n         argexprs (vec (map #(analyze enve %) args))]\n     {:env env :op :new :ctor ctorexpr :args argexprs :children (conj argexprs ctorexpr)})))",
                                                 :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                 :lines [773 779],
                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/compiler.clj#L773-L779"},
                                        :full-name-encode "special_new",
                                        :clj-symbol "clojure.core/new",
                                        :history [["+" "0.0-927"]]},
                         "cljs.core/take-nth" {:ns "cljs.core",
                                               :name "take-nth",
                                               :signature ["[n coll]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_take-nth",
                                               :source {:code "(defn take-nth\n  [n coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (cons (first s) (take-nth n (drop n s))))))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [2652
                                                                2657],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2652-L2657"},
                                               :full-name "cljs.core/take-nth",
                                               :clj-symbol "clojure.core/take-nth",
                                               :docstring "Returns a lazy seq of every nth item in coll."},
                         "cljs.reader/throwing-reader" {:full-name "cljs.reader/throwing-reader",
                                                        :ns "cljs.reader",
                                                        :name "throwing-reader",
                                                        :type "function",
                                                        :signature ["[msg]"],
                                                        :source {:code "(defn throwing-reader\n  [msg]\n  (fn [rdr _]\n    (reader-error rdr msg)))",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [282
                                                                         285],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L282-L285"},
                                                        :full-name-encode "cljs.reader_throwing-reader",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/even?" {:ns "cljs.core",
                                            :name "even?",
                                            :signature ["[n]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_even_QMARK_",
                                            :source {:code "(defn even?\n   [n] (if (integer? n)\n        (zero? (bit-and n 1))\n        (throw (js/Error. (str \"Argument must be an integer: \" n)))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [1431
                                                             1435],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1431-L1435"},
                                            :full-name "cljs.core/even?",
                                            :clj-symbol "clojure.core/even?",
                                            :docstring "Returns true if n is even, throws an exception if n is not an integer"},
                         "special/fn*" {:full-name "special/fn*",
                                        :ns "special",
                                        :name "fn*",
                                        :type "special form",
                                        :source {:code "(defmethod parse 'fn*\n  [op env [_ & args] name]\n  (let [[name meths] (if (symbol? (first args))\n                       [(first args) (next args)]\n                       [name (seq args)])\n        ;;turn (fn [] ...) into (fn ([]...))\n        meths (if (vector? (first meths)) (list meths) meths)\n        mname (when name (munge name))\n        locals (:locals env)\n        locals (if name (assoc locals name {:name mname}) locals)\n        menv (if (> (count meths) 1) (assoc env :context :expr) env)\n        methods (map #(analyze-fn-method menv locals %) meths)\n        max-fixed-arity (apply max (map :max-fixed-arity methods))\n        variadic (boolean (some :variadic methods))]\n    ;;(assert (= 1 (count methods)) \"Arity overloading not yet supported\")\n    ;;todo - validate unique arities, at most one variadic, variadic takes max required args\n    {:env env :op :fn :name mname :methods methods :variadic variadic :recur-frames *recur-frames*\n     :jsdoc [(when variadic \"@param {...*} var_args\")]\n     :max-fixed-arity max-fixed-arity}))",
                                                 :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                 :lines [701 719],
                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/compiler.clj#L701-L719"},
                                        :full-name-encode "special_fn_STAR_",
                                        :history [["+" "0.0-927"]]},
                         "clojure.set/subset?" {:ns "clojure.set",
                                                :name "subset?",
                                                :signature ["[set1 set2]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.set_subset_QMARK_",
                                                :source {:code "(defn subset? \n  [set1 set2]\n  (and (<= (count set1) (count set2))\n       (every? #(contains? set2 %) set1)))",
                                                         :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                         :lines [132
                                                                 136],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/set.cljs#L132-L136"},
                                                :full-name "clojure.set/subset?",
                                                :clj-symbol "clojure.set/subset?",
                                                :docstring "Is set1 a subset of set2?"},
                         "cljs.core/flush" {:full-name "cljs.core/flush",
                                            :ns "cljs.core",
                                            :name "flush",
                                            :type "function",
                                            :signature ["[]"],
                                            :source {:code "(defn flush [] ;stub\n  nil)",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2811
                                                             2812],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2811-L2812"},
                                            :full-name-encode "cljs.core_flush",
                                            :clj-symbol "clojure.core/flush",
                                            :history [["+" "0.0-927"]]},
                         "cljs.reader/reader-error" {:full-name "cljs.reader/reader-error",
                                                     :ns "cljs.reader",
                                                     :name "reader-error",
                                                     :type "function",
                                                     :signature ["[rdr & msg]"],
                                                     :source {:code "(defn reader-error\n  [rdr & msg]\n  (throw (apply str msg)))",
                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                              :lines [69
                                                                      71],
                                                              :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L69-L71"},
                                                     :full-name-encode "cljs.reader_reader-error",
                                                     :history [["+"
                                                                "0.0-927"]]},
                         "clojure.walk/prewalk-replace" {:ns "clojure.walk",
                                                         :name "prewalk-replace",
                                                         :signature ["[smap form]"],
                                                         :history [["+"
                                                                    "0.0-927"]],
                                                         :type "function",
                                                         :full-name-encode "clojure.walk_prewalk-replace",
                                                         :source {:code "(defn prewalk-replace\n  [smap form]\n  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                                  :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                                  :lines [80
                                                                          86],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/walk.cljs#L80-L86"},
                                                         :full-name "clojure.walk/prewalk-replace",
                                                         :clj-symbol "clojure.walk/prewalk-replace",
                                                         :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the root of the tree first."},
                         "cljs.core/*1" {:full-name "cljs.core/*1",
                                         :ns "cljs.core",
                                         :name "*1",
                                         :docstring "bound in a repl thread to the most recent value printed",
                                         :type "var",
                                         :source {:code "(def\n  ^{:doc \"bound in a repl thread to the most recent value printed\"}\n  *1)",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [23 25],
                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L23-L25"},
                                         :full-name-encode "cljs.core__STAR_1",
                                         :clj-symbol "clojure.core/*1",
                                         :history [["+" "0.0-927"]]},
                         "cljs.reader/read-unicode-char" {:full-name "cljs.reader/read-unicode-char",
                                                          :ns "cljs.reader",
                                                          :name "read-unicode-char",
                                                          :type "function",
                                                          :signature ["[reader initch]"],
                                                          :source {:code "(defn read-unicode-char\n  [reader initch]\n  (reader-error reader \"Unicode characters not supported by reader (yet)\"))",
                                                                   :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                   :lines [145
                                                                           147],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L145-L147"},
                                                          :full-name-encode "cljs.reader_read-unicode-char",
                                                          :history [["+"
                                                                     "0.0-927"]]},
                         "cljs.core/dissoc" {:ns "cljs.core",
                                             :name "dissoc",
                                             :signature ["[coll]"
                                                         "[coll k]"
                                                         "[coll k & ks]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_dissoc",
                                             :source {:code "(defn dissoc\n  ([coll] coll)\n  ([coll k]\n     (-dissoc coll k))\n  ([coll k & ks]\n     (let [ret (dissoc coll k)]\n       (if ks\n         (recur ret (first ks) (next ks))\n         ret))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [494 504],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L494-L504"},
                                             :full-name "cljs.core/dissoc",
                                             :clj-symbol "clojure.core/dissoc",
                                             :docstring "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\nthat does not contain a mapping for key(s)."},
                         "cljs.core/ffirst" {:ns "cljs.core",
                                             :name "ffirst",
                                             :signature ["[coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_ffirst",
                                             :source {:code "(defn ffirst\n  [coll]\n  (first (first coll)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [400 403],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L400-L403"},
                                             :full-name "cljs.core/ffirst",
                                             :clj-symbol "clojure.core/ffirst",
                                             :docstring "Same as (first (first x))"},
                         "clojure.zip/replace" {:ns "clojure.zip",
                                                :name "replace",
                                                :signature ["[loc node]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.zip_replace",
                                                :source {:code "(defn replace\n  [loc node]\n    (let [[_ path] loc]\n      (with-meta [node (assoc path :changed? true)] (meta loc))))",
                                                         :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                         :lines [183
                                                                 187],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L183-L187"},
                                                :full-name "clojure.zip/replace",
                                                :clj-symbol "clojure.zip/replace",
                                                :docstring "Replaces the node at this loc, without moving"},
                         "cljs.core/vec" {:full-name "cljs.core/vec",
                                          :ns "cljs.core",
                                          :name "vec",
                                          :type "function",
                                          :signature ["[coll]"],
                                          :source {:code "(defn vec [coll]\n  (reduce conj cljs.core.Vector/EMPTY coll))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [1981 1982],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1981-L1982"},
                                          :full-name-encode "cljs.core_vec",
                                          :clj-symbol "clojure.core/vec",
                                          :history [["+" "0.0-927"]]},
                         "cljs.core/or" {:ns "cljs.core",
                                         :name "or",
                                         :signature ["[]"
                                                     "[x]"
                                                     "[x & next]"],
                                         :history [["+" "0.0-927"]],
                                         :type "macro",
                                         :full-name-encode "cljs.core_or",
                                         :source {:code "(defmacro or\n  ([] nil)\n  ([x] x)\n  ([x & next]\n      `(let [or# ~x]\n         (if or# or# (or ~@next)))))",
                                                  :filename "clojure/src/clj/clojure/core.clj",
                                                  :lines [789 799],
                                                  :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L789-L799"},
                                         :full-name "cljs.core/or",
                                         :clj-symbol "clojure.core/or",
                                         :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns a logical true value, or returns that value and doesn't\nevaluate any of the other expressions, otherwise it returns the\nvalue of the last expression. (or) returns nil."},
                         "cljs.core/mod" {:ns "cljs.core",
                                          :name "mod",
                                          :signature ["[n d]"],
                                          :shadowed-sources ({:code "(defmacro mod [num div]\n  (list 'js* \"(~{} % ~{})\" num div))",
                                                              :filename "clojurescript/src/clj/cljs/core.clj",
                                                              :lines [128
                                                                      129],
                                                              :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L128-L129"}),
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_mod",
                                          :source {:code "(defn mod\n  [n d]\n  (js* \"(~{n} % ~{d})\"))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [872 875],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L872-L875"},
                                          :full-name "cljs.core/mod",
                                          :clj-symbol "clojure.core/mod",
                                          :docstring "Modulus of num and div. Truncates toward negative infinity."},
                         "cljs.core/aset" {:ns "cljs.core",
                                           :name "aset",
                                           :signature ["[array i val]"],
                                           :shadowed-sources ({:code "(defmacro aset [a i v]\n  (list 'js* \"(~{}[~{}] = ~{})\" a i v))",
                                                               :filename "clojurescript/src/clj/cljs/core.clj",
                                                               :lines [51
                                                                       52],
                                                               :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L51-L52"}),
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_aset",
                                           :source {:code "(defn aset\n  [array i val]\n  (js* \"(~{array}[~{i}] = ~{val})\"))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [82 85],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L82-L85"},
                                           :full-name "cljs.core/aset",
                                           :clj-symbol "clojure.core/aset",
                                           :docstring "Sets the value at the index."},
                         "cljs.core/second" {:ns "cljs.core",
                                             :name "second",
                                             :signature ["[coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_second",
                                             :source {:code "(defn second\n  [coll]\n  (first (next coll)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [395 398],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L395-L398"},
                                             :full-name "cljs.core/second",
                                             :clj-symbol "clojure.core/second",
                                             :docstring "Same as (first (next x))"},
                         "clojure.set/rename" {:ns "clojure.set",
                                               :name "rename",
                                               :signature ["[xrel kmap]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.set_rename",
                                               :source {:code "(defn rename\n  [xrel kmap]\n    (set (map #(rename-keys % kmap) xrel)))",
                                                        :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                        :lines [83 86],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/set.cljs#L83-L86"},
                                               :full-name "clojure.set/rename",
                                               :clj-symbol "clojure.set/rename",
                                               :docstring "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap"},
                         "cljs.core/delay?" {:ns "cljs.core",
                                             :name "delay?",
                                             :signature ["[x]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_delay_QMARK_",
                                             :source {:code "(defn delay?\n  [x] (instance? cljs.core.Delay x))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [3155
                                                              3157],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3155-L3157"},
                                             :full-name "cljs.core/delay?",
                                             :clj-symbol "clojure.core/delay?",
                                             :docstring "returns true if x is a Delay created with delay"},
                         "clojure.zip/left" {:ns "clojure.zip",
                                             :name "left",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_left",
                                             :source {:code "(defn left\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (when (and path (seq l))\n        (with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))] (meta loc)))))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [150 155],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L150-L155"},
                                             :full-name "clojure.zip/left",
                                             :clj-symbol "clojure.zip/left",
                                             :docstring "Returns the loc of the left sibling of the node at this loc, or nil"},
                         "cljs.reader/not-implemented" {:full-name "cljs.reader/not-implemented",
                                                        :ns "cljs.reader",
                                                        :name "not-implemented",
                                                        :type "function",
                                                        :signature ["[rdr ch]"],
                                                        :source {:code "(defn not-implemented\n  [rdr ch]\n  (reader-error rdr \"Reader for \" ch \" not implemented yet\"))",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [187
                                                                         189],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L187-L189"},
                                                        :full-name-encode "cljs.reader_not-implemented",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/IAssociative" {:ns "cljs.core",
                                                   :name "IAssociative",
                                                   :type "protocol",
                                                   :full-name-encode "cljs.core_IAssociative",
                                                   :source {:code "(defprotocol IAssociative\n  (-contains-key? [coll k])\n  #_(-entry-at [coll k])\n  (-assoc [coll k v]))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [115
                                                                    118],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L115-L118"},
                                                   :methods [{:name "-contains-key?",
                                                              :signature ["[coll k]"],
                                                              :docstring nil}
                                                             {:name "-assoc",
                                                              :signature ["[coll k v]"],
                                                              :docstring nil}],
                                                   :full-name "cljs.core/IAssociative",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "cljs.core/group-by" {:ns "cljs.core",
                                               :name "group-by",
                                               :signature ["[f coll]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_group-by",
                                               :source {:code "(defn group-by\n  [f coll]\n  (reduce\n   (fn [ret x]\n     (let [k (f x)]\n       (assoc ret k (conj (get ret k []) x))))\n   {} coll))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [3237
                                                                3246],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3237-L3246"},
                                               :full-name "cljs.core/group-by",
                                               :clj-symbol "clojure.core/group-by",
                                               :docstring "Returns a map of the elements of coll keyed by the result of\nf on each element. The value at each key will be a vector of the\ncorresponding elements, in the order they appeared in coll."},
                         "cljs.core/symbol" {:ns "cljs.core",
                                             :name "symbol",
                                             :signature ["[name]"
                                                         "[ns name]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_symbol",
                                             :source {:code "(defn symbol\n  ([name] (cond (symbol? name) name\n                (keyword? name) (str* \"\\uFDD1\" \"'\" (subs name 2)))\n     :else (str* \"\\uFDD1\" \"'\" name))\n  ([ns name] (symbol (str* ns \"/\" name))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1029
                                                              1034],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1029-L1034"},
                                             :full-name "cljs.core/symbol",
                                             :clj-symbol "clojure.core/symbol",
                                             :docstring "Returns a Symbol with the given namespace and name."},
                         "cljs.core/Delay" {:full-name "cljs.core/Delay",
                                            :ns "cljs.core",
                                            :name "Delay",
                                            :type "type",
                                            :signature ["[f state]"],
                                            :source {:code "(deftype Delay [f state]\n\n  IDeref\n  (-deref [_]\n    (when-not @state\n      (swap! state f))\n    @state)\n\n  IPending\n  (-realized? [d]\n    (not (nil? @state))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [3135
                                                             3145],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3135-L3145"},
                                            :full-name-encode "cljs.core_Delay",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/methods" {:ns "cljs.core",
                                              :name "methods",
                                              :signature ["[multifn]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_methods",
                                              :source {:code "(defn methods\n  [multifn] (-methods multifn))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [3494
                                                               3496],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3494-L3496"},
                                              :full-name "cljs.core/methods",
                                              :clj-symbol "clojure.core/methods",
                                              :docstring "Given a multimethod, returns a map of dispatch values -> dispatch fns"},
                         "cljs.core/vector" {:full-name "cljs.core/vector",
                                             :ns "cljs.core",
                                             :name "vector",
                                             :type "function",
                                             :signature ["[& args]"],
                                             :source {:code "(defn vector [& args] (vec args))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1984
                                                              1984],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1984-L1984"},
                                             :full-name-encode "cljs.core_vector",
                                             :clj-symbol "clojure.core/vector",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/rand-int" {:ns "cljs.core",
                                               :name "rand-int",
                                               :signature ["[n]"],
                                               :shadowed-sources ({:code "(defn rand-int\n  [n] (fix (rand n)))",
                                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                   :lines [894
                                                                           896],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L894-L896"}),
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_rand-int",
                                               :source {:code "(defn rand-int\n  [n] (js* \"Math.floor(Math.random() * ~{n})\"))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [3226
                                                                3228],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3226-L3228"},
                                               :full-name "cljs.core/rand-int",
                                               :clj-symbol "clojure.core/rand-int",
                                               :docstring "Returns a random integer between 0 (inclusive) and n (exclusive)."},
                         "cljs.core/letfn" {:ns "cljs.core",
                                            :name "letfn",
                                            :signature ["[fnspecs & body]"],
                                            :history [["+" "0.0-927"]],
                                            :type "macro",
                                            :full-name-encode "cljs.core_letfn",
                                            :source {:code "(defmacro letfn \n  [fnspecs & body] \n  `(letfn* ~(vec (interleave (map first fnspecs) \n                             (map #(cons `fn %) fnspecs)))\n           ~@body))",
                                                     :filename "clojure/src/clj/clojure/core.clj",
                                                     :lines [5751
                                                             5762],
                                                     :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L5751-L5762"},
                                            :full-name "cljs.core/letfn",
                                            :clj-symbol "clojure.core/letfn",
                                            :docstring "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\nTakes a vector of function specs and a body, and generates a set of\nbindings of functions to their names. All of the names are available\nin all of the definitions of the functions, as well as the body."},
                         "cljs.reader/read-discard" {:full-name "cljs.reader/read-discard",
                                                     :ns "cljs.reader",
                                                     :name "read-discard",
                                                     :type "function",
                                                     :signature ["[rdr _]"],
                                                     :source {:code "(defn read-discard\n  [rdr _]\n  (read rdr true nil true)\n  rdr)",
                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                              :lines [305
                                                                      308],
                                                              :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L305-L308"},
                                                     :full-name-encode "cljs.reader_read-discard",
                                                     :history [["+"
                                                                "0.0-927"]]},
                         "cljs.core/inc" {:ns "cljs.core",
                                          :name "inc",
                                          :signature ["[x]"],
                                          :shadowed-sources ({:code "(defmacro inc [x]\n  `(+ ~x 1))",
                                                              :filename "clojurescript/src/clj/cljs/core.clj",
                                                              :lines [106
                                                                      107],
                                                              :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L106-L107"}),
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_inc",
                                          :source {:code "(defn inc\n  [x] (js* \"(~{x} + 1)\"))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [267 269],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L267-L269"},
                                          :full-name "cljs.core/inc",
                                          :clj-symbol "clojure.core/inc",
                                          :docstring "Returns a number one greater than num."},
                         "cljs.core/name" {:ns "cljs.core",
                                           :name "name",
                                           :signature ["[x]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_name",
                                           :source {:code "(defn name\n  [x]\n  (cond\n    (string? x) x\n    (or (keyword? x) (symbol? x))\n      (let [i (.lastIndexOf x \"/\")]\n        (if (< i 0)\n          (subs x 2)\n          (subs x (inc i))))\n    :else (throw (js/Error. (str \"Doesn't support name: \" x)))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2519 2529],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2519-L2529"},
                                           :full-name "cljs.core/name",
                                           :clj-symbol "clojure.core/name",
                                           :docstring "Returns the name String of a string, symbol or keyword."},
                         "cljs.core/cycle" {:ns "cljs.core",
                                            :name "cycle",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_cycle",
                                            :source {:code "(defn cycle\n  [coll] (lazy-seq \n          (when-let [s (seq coll)] \n            (concat s (cycle s)))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [1713
                                                             1717],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1713-L1717"},
                                            :full-name "cljs.core/cycle",
                                            :clj-symbol "clojure.core/cycle",
                                            :docstring "Returns a lazy (infinite!) sequence of repetitions of the items in coll."},
                         "cljs.core/map" {:ns "cljs.core",
                                          :name "map",
                                          :signature ["[f coll]"
                                                      "[f c1 c2]"
                                                      "[f c1 c2 c3]"
                                                      "[f c1 c2 c3 & colls]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_map",
                                          :source {:code "(defn map\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (cons (f (first s)) (map f (rest s))))))\n  ([f c1 c2]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2)]\n      (when (and s1 s2)\n        (cons (f (first s1) (first s2))\n              (map f (rest s1) (rest s2)))))))\n  ([f c1 c2 c3]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n      (when (and  s1 s2 s3)\n        (cons (f (first s1) (first s2) (first s3))\n              (map f (rest s1) (rest s2) (rest s3)))))))\n  ([f c1 c2 c3 & colls]\n   (let [step (fn step [cs]\n                 (lazy-seq\n                  (let [ss (map seq cs)]\n                    (when (every? identity ss)\n                      (cons (map first ss) (step (map rest ss)))))))]\n     (map #(apply f %) (step (conj colls c3 c2 c1))))))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [1639 1667],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1639-L1667"},
                                          :full-name "cljs.core/map",
                                          :clj-symbol "clojure.core/map",
                                          :docstring "Returns a lazy sequence consisting of the result of applying f to the\nset of first items of each coll, followed by applying f to the set\nof second items in each coll, until any one of the colls is\nexhausted.  Any remaining items in other colls are ignored. Function\nf should accept number-of-colls arguments."},
                         "cljs.core/amap" {:ns "cljs.core",
                                           :name "amap",
                                           :signature ["[a idx ret expr]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_amap",
                                           :source {:code "(defmacro amap\n  [a idx ret expr]\n  `(let [a# ~a\n         ~ret (aclone a#)]\n     (loop  [~idx 0]\n       (if (< ~idx  (alength a#))\n         (do\n           (aset ~ret ~idx ~expr)\n           (recur (inc ~idx)))\n         ~ret))))",
                                                    :filename "clojurescript/src/clj/cljs/core.clj",
                                                    :lines [608 621],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L608-L621"},
                                           :full-name "cljs.core/amap",
                                           :clj-symbol "clojure.core/amap",
                                           :docstring "Maps an expression across an array a, using an index named idx, and\nreturn value named ret, initialized to a clone of a, then setting \neach element of ret to the evaluation of expr, returning the new \narray ret."},
                         "clojure.zip/children" {:ns "clojure.zip",
                                                 :name "children",
                                                 :signature ["[loc]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.zip_children",
                                                 :source {:code "(defn children\n  [loc]\n    (if (branch? loc)\n      ((:zip/children (meta loc)) (node loc))\n      (throw \"called children on a leaf node\")))",
                                                          :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                          :lines [69
                                                                  74],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L69-L74"},
                                                 :full-name "clojure.zip/children",
                                                 :clj-symbol "clojure.zip/children",
                                                 :docstring "Returns a seq of the children of node at loc, which must be a branch"},
                         "special/set!" {:full-name "special/set!",
                                         :ns "special",
                                         :name "set!",
                                         :type "special form",
                                         :source {:code "(defmethod parse 'set!\n  [_ env [_ target val] _]\n  (disallowing-recur\n   (let [enve (assoc env :context :expr)\n         targetexpr (if (symbol? target)\n                      (do\n                        (assert (nil? (-> env :locals target))\n                                \"Can't set! local var\")\n                        (analyze-symbol enve target))\n                      (when (seq? target)\n                        (let [targetexpr (analyze-seq enve target nil)]\n                          (when (:field targetexpr)\n                            targetexpr))))\n         valexpr (analyze enve val)]\n     (assert targetexpr \"set! target must be a field or a symbol naming a var\")\n     {:env env :op :set! :target targetexpr :val valexpr :children [targetexpr valexpr]})))",
                                                  :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                  :lines [781 796],
                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/compiler.clj#L781-L796"},
                                         :full-name-encode "special_set_BANG_",
                                         :clj-symbol "clojure.core/set!",
                                         :history [["+" "0.0-927"]]},
                         "cljs.core/when-not" {:ns "cljs.core",
                                               :name "when-not",
                                               :signature ["[test & body]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "macro",
                                               :full-name-encode "cljs.core_when-not",
                                               :source {:code "(defmacro when-not\n  [test & body]\n    (list 'if test nil (cons 'do body)))",
                                                        :filename "clojure/src/clj/clojure/core.clj",
                                                        :lines [460
                                                                464],
                                                        :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L460-L464"},
                                               :full-name "cljs.core/when-not",
                                               :clj-symbol "clojure.core/when-not",
                                               :docstring "Evaluates test. If logical false, evaluates body in an implicit do."},
                         "clojure.set/index" {:ns "clojure.set",
                                              :name "index",
                                              :signature ["[xrel ks]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.set_index",
                                              :source {:code "(defn index\n  [xrel ks]\n    (reduce\n     (fn [m x]\n       (let [ik (select-keys x ks)]\n         (assoc m ik (conj (get m ik #{}) x))))\n     {} xrel))",
                                                       :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                       :lines [88 96],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/set.cljs#L88-L96"},
                                              :full-name "clojure.set/index",
                                              :clj-symbol "clojure.set/index",
                                              :docstring "Returns a map of the distinct values of ks in the xrel mapped to a\nset of the maps in xrel with the corresponding values of ks."},
                         "clojure.browser.dom/log" {:full-name "clojure.browser.dom/log",
                                                    :ns "clojure.browser.dom",
                                                    :name "log",
                                                    :type "function",
                                                    :signature ["[& args]"],
                                                    :source {:code "(defn log [& args]\n  (.log js/console (apply pr-str args)))",
                                                             :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                             :lines [19
                                                                     20],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/dom.cljs#L19-L20"},
                                                    :full-name-encode "clojure.browser.dom_log",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "cljs.core/partition-by" {:ns "cljs.core",
                                                   :name "partition-by",
                                                   :signature ["[f coll]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.core_partition-by",
                                                   :source {:code "(defn partition-by\n  [f coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (let [fst (first s)\n           fv (f fst)\n           run (cons fst (take-while #(= fv (f %)) (next s)))]\n       (cons run (partition-by f (seq (drop (count run) s))))))))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [2664
                                                                    2673],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2664-L2673"},
                                                   :full-name "cljs.core/partition-by",
                                                   :clj-symbol "clojure.core/partition-by",
                                                   :docstring "Applies f to each value in coll, splitting it each time f returns\na new value.  Returns a lazy seq of partitions."},
                         "cljs.core/sort-by" {:ns "cljs.core",
                                              :name "sort-by",
                                              :signature ["[keyfn coll]"
                                                          "[keyfn comp coll]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_sort-by",
                                              :source {:code "(defn sort-by\n  ([keyfn coll]\n   (sort-by keyfn compare coll))\n  ([keyfn comp coll]\n     (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [725
                                                               733],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L725-L733"},
                                              :full-name "cljs.core/sort-by",
                                              :clj-symbol "clojure.core/sort-by",
                                              :docstring "Returns a sorted sequence of the items in coll, where the sort\norder is determined by comparing (keyfn item).  Comp can be\nboolean-valued comparison funcion, or a -/0/+ valued comparator.\nComp defaults to compare."},
                         "cljs.core/with-meta" {:ns "cljs.core",
                                                :name "with-meta",
                                                :signature ["[o meta]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_with-meta",
                                                :source {:code "(defn with-meta\n  [o meta]\n  (-with-meta o meta))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [506
                                                                 510],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L506-L510"},
                                                :full-name "cljs.core/with-meta",
                                                :clj-symbol "clojure.core/with-meta",
                                                :docstring "Returns an object of the same type and value as obj, with\nmap m as its metadata."},
                         "cljs.core/NeverEquiv" {:full-name "cljs.core/NeverEquiv",
                                                 :ns "cljs.core",
                                                 :name "NeverEquiv",
                                                 :type "type",
                                                 :signature ["[]"],
                                                 :source {:code "(deftype NeverEquiv []\n  IEquiv\n  (-equiv [o other] false))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2150
                                                                  2152],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2150-L2152"},
                                                 :full-name-encode "cljs.core_NeverEquiv",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "cljs.core/select-keys" {:ns "cljs.core",
                                                  :name "select-keys",
                                                  :signature ["[map keyseq]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_select-keys",
                                                  :source {:code "(defn select-keys\n  [map keyseq]\n    (loop [ret {} keys (seq keyseq)]\n      (if keys\n        (let [key   (first keys)\n              entry (get map key ::not-found)]\n          (recur\n           (if (not= entry ::not-found)\n             (assoc ret key entry)\n             ret)\n           (next keys)))\n        ret)))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [2410
                                                                   2422],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2410-L2422"},
                                                  :full-name "cljs.core/select-keys",
                                                  :clj-symbol "clojure.core/select-keys",
                                                  :docstring "Returns a map containing only those entries in map whose key is in keys"},
                         "special/loop*" {:full-name "special/loop*",
                                          :ns "special",
                                          :name "loop*",
                                          :type "special form",
                                          :source {:code "(defmethod parse 'loop*\n  [op encl-env form _]\n  (analyze-let encl-env form true))",
                                                   :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                   :lines [754 756],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/compiler.clj#L754-L756"},
                                          :full-name-encode "special_loop_STAR_",
                                          :history [["+" "0.0-927"]]},
                         "cljs.core/ISeq" {:ns "cljs.core",
                                           :name "ISeq",
                                           :type "protocol",
                                           :full-name-encode "cljs.core_ISeq",
                                           :source {:code "(defprotocol ISeq\n  (-first [coll])\n  (-rest [coll]))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [108 110],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L108-L110"},
                                           :methods [{:name "-first",
                                                      :signature ["[coll]"],
                                                      :docstring nil}
                                                     {:name "-rest",
                                                      :signature ["[coll]"],
                                                      :docstring nil}],
                                           :full-name "cljs.core/ISeq",
                                           :history [["+" "0.0-927"]]},
                         "clojure.walk/postwalk-replace" {:ns "clojure.walk",
                                                          :name "postwalk-replace",
                                                          :signature ["[smap form]"],
                                                          :history [["+"
                                                                     "0.0-927"]],
                                                          :type "function",
                                                          :full-name-encode "clojure.walk_postwalk-replace",
                                                          :source {:code "(defn postwalk-replace\n  [smap form]\n  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                                   :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                                   :lines [88
                                                                           94],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/walk.cljs#L88-L94"},
                                                          :full-name "clojure.walk/postwalk-replace",
                                                          :clj-symbol "clojure.walk/postwalk-replace",
                                                          :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the leaves of the tree first."},
                         "cljs.core/pr-with-opts" {:full-name "cljs.core/pr-with-opts",
                                                   :ns "cljs.core",
                                                   :name "pr-with-opts",
                                                   :docstring "Prints a sequence of objects using string-print, observing all\nthe options given in opts",
                                                   :type "function",
                                                   :signature ["[objs opts]"],
                                                   :source {:code "(defn pr-with-opts\n  [objs opts]\n  (let [first-obj (first objs)]\n    (doseq [obj objs]\n      (when-not (identical? obj first-obj)\n        (string-print \" \"))\n      (doseq [string (pr-seq obj opts)]\n        (string-print string)))))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [2840
                                                                    2849],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2840-L2849"},
                                                   :full-name-encode "cljs.core_pr-with-opts",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "cljs.core/->>" {:ns "cljs.core",
                                          :name "->>",
                                          :signature ["[x form]"
                                                      "[x form & more]"],
                                          :history [["+" "0.0-927"]],
                                          :type "macro",
                                          :full-name-encode "cljs.core_-_GT__GT_",
                                          :source {:code "(defmacro ->>\n  ([x form] (if (seq? form)\n              (with-meta `(~(first form) ~@(next form)  ~x) (meta form))\n              (list form x)))\n  ([x form & more] `(->> (->> ~x ~form) ~@more)))",
                                                   :filename "clojure/src/clj/clojure/core.clj",
                                                   :lines [1540 1549],
                                                   :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L1540-L1549"},
                                          :full-name "cljs.core/->>",
                                          :clj-symbol "clojure.core/->>",
                                          :docstring "Threads the expr through the forms. Inserts x as the\nlast item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nlast item in second form, etc."},
                         "cljs.core/nil?" {:full-name "cljs.core/nil?",
                                           :ns "cljs.core",
                                           :name "nil?",
                                           :type "function",
                                           :signature ["[x]"],
                                           :source {:code "(defn nil? [x]\n  \"Returns true if x is nil, false otherwise.\"\n  (identical? x nil))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [183 185],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L183-L185"},
                                           :full-name-encode "cljs.core_nil_QMARK_",
                                           :clj-symbol "clojure.core/nil?",
                                           :history [["+" "0.0-927"]]},
                         "clojure.walk/stringify-keys" {:ns "clojure.walk",
                                                        :name "stringify-keys",
                                                        :signature ["[m]"],
                                                        :history [["+"
                                                                   "0.0-927"]],
                                                        :type "function",
                                                        :full-name-encode "clojure.walk_stringify-keys",
                                                        :source {:code "(defn stringify-keys\n  [m]\n  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                                 :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                                 :lines [72
                                                                         78],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/walk.cljs#L72-L78"},
                                                        :full-name "clojure.walk/stringify-keys",
                                                        :clj-symbol "clojure.walk/stringify-keys",
                                                        :docstring "Recursively transforms all map keys from keywords to strings."},
                         "clojure.browser.repl/order" {:full-name "clojure.browser.repl/order",
                                                       :ns "clojure.browser.repl",
                                                       :name "order",
                                                       :type "var",
                                                       :source {:code "(def order (atom 0))",
                                                                :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                :lines [55
                                                                        55],
                                                                :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/repl.cljs#L55-L55"},
                                                       :full-name-encode "clojure.browser.repl_order",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.core/memoize" {:ns "cljs.core",
                                              :name "memoize",
                                              :signature ["[f]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_memoize",
                                              :source {:code "(defn memoize\n  [f]\n  (let [mem (atom {})]\n    (fn [& args]\n      (if-let [v (get @mem args)]\n        v\n        (let [ret (apply f args)]\n          (swap! mem assoc args ret)\n          ret)))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [3190
                                                               3202],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3190-L3202"},
                                              :full-name "cljs.core/memoize",
                                              :clj-symbol "clojure.core/memoize",
                                              :docstring "Returns a memoized version of a referentially transparent function. The\nmemoized version of the function keeps a cache of the mapping from arguments\nto results and, when calls with the same arguments are repeated often, has\nhigher performance at the expense of higher memory use."},
                         "cljs.core/pr-sequential" {:full-name "cljs.core/pr-sequential",
                                                    :ns "cljs.core",
                                                    :name "pr-sequential",
                                                    :type "function",
                                                    :signature ["[print-one begin sep end opts coll]"],
                                                    :source {:code "(defn pr-sequential [print-one begin sep end opts coll]\n  (concat [begin]\n          (flatten1\n            (interpose [sep] (map #(print-one % opts) coll)))\n          [end]))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [2801
                                                                     2805],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2801-L2805"},
                                                    :full-name-encode "cljs.core_pr-sequential",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "clojure.zip/make-node" {:ns "clojure.zip",
                                                  :name "make-node",
                                                  :signature ["[loc node children]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.zip_make-node",
                                                  :source {:code "(defn make-node\n  [loc node children]\n    ((:zip/make-node (meta loc)) node children))",
                                                           :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                           :lines [76
                                                                   80],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L76-L80"},
                                                  :full-name "clojure.zip/make-node",
                                                  :clj-symbol "clojure.zip/make-node",
                                                  :docstring "Returns a new branch node, given an existing node and new\nchildren. The loc is only used to supply the constructor."},
                         "specialrepl/load-namespace" {:full-name "specialrepl/load-namespace",
                                                       :ns "specialrepl",
                                                       :name "load-namespace",
                                                       :type "special form (repl)",
                                                       :source {:code "(defn repl\n  \"Note - repl will reload core.cljs every time, even if supplied old repl-env\"\n  [repl-env & {:keys [verbose warn-on-undeclared]}]\n  (prn \"Type: \" :cljs/quit \" to quit\")\n  (binding [comp/*cljs-ns* 'cljs.user\n            *cljs-verbose* verbose\n            comp/*cljs-warn-on-undeclared* warn-on-undeclared]\n    (let [env {:context :statement :locals {}}]\n      (-setup repl-env)\n      (loop []\n        (print (str \"ClojureScript:\" comp/*cljs-ns* \"> \"))\n        (flush)\n        (let [{:keys [status form]} (read-next-form)]\n          (cond\n           (= form :cljs/quit) :quit\n           \n           (= status :error) (recur)\n           \n           (and (seq? form) (= (first form) 'in-ns))\n           (do (set! comp/*cljs-ns* (second (second form))) (newline) (recur))\n           \n           (and (seq? form) ('#{load-file clojure.core/load-file} (first form)))\n           (do (load-file repl-env (second form)) (newline) (recur))\n           \n           (and (seq? form) ('#{load-namespace} (first form)))\n           (do (load-namespace repl-env (second form)) (newline) (recur))\n           \n           :else\n           (do (eval-and-print repl-env env form) (recur)))))\n      (-tear-down repl-env))))",
                                                                :filename "clojurescript/src/clj/cljs/repl.clj",
                                                                :lines [132
                                                                        161],
                                                                :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/repl.clj#L132-L161"},
                                                       :full-name-encode "specialrepl_load-namespace",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.reader/float-pattern" {:full-name "cljs.reader/float-pattern",
                                                      :ns "cljs.reader",
                                                      :name "float-pattern",
                                                      :type "var",
                                                      :source {:code "(def float-pattern (re-pattern \"([-+]?[0-9]+(\\\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?\"))",
                                                               :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                               :lines [97
                                                                       97],
                                                               :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L97-L97"},
                                                      :full-name-encode "cljs.reader_float-pattern",
                                                      :history [["+"
                                                                 "0.0-927"]]},
                         "cljs.core/ancestors" {:ns "cljs.core",
                                                :name "ancestors",
                                                :signature ["[tag]"
                                                            "[h tag]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_ancestors",
                                                :source {:code "(defn ancestors\n  ([tag] (ancestors @global-hierarchy tag))\n  ([h tag] (not-empty (get (:ancestors h) tag))))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [3284
                                                                 3290],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3284-L3290"},
                                                :full-name "cljs.core/ancestors",
                                                :clj-symbol "clojure.core/ancestors",
                                                :docstring "Returns the immediate and indirect parents of tag, either via a Java type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
                         "cljs.core/integer?" {:ns "cljs.core",
                                               :name "integer?",
                                               :signature ["[n]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_integer_QMARK_",
                                               :source {:code "(defn integer?\n  [n]\n  (and (number? n)\n       (js* \"(~{n} == ~{n}.toFixed())\")))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [647
                                                                651],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L647-L651"},
                                               :full-name "cljs.core/integer?",
                                               :clj-symbol "clojure.core/integer?",
                                               :docstring "Returns true if n is an integer.  Warning: returns true on underflow condition."},
                         "clojure.zip/xml-zip" {:ns "clojure.zip",
                                                :name "xml-zip",
                                                :signature ["[root]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.zip_xml-zip",
                                                :source {:code "(defn xml-zip\n  [root]\n    (zipper (complement string?) \n            (comp seq :content)\n            (fn [node children]\n              (assoc node :content (and children (apply vector children))))\n            root))",
                                                         :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                         :lines [50
                                                                 58],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L50-L58"},
                                                :full-name "clojure.zip/xml-zip",
                                                :clj-symbol "clojure.zip/xml-zip",
                                                :docstring "Returns a zipper for xml elements (as from xml/parse),\ngiven a root element"},
                         "clojure.walk/walk" {:ns "clojure.walk",
                                              :name "walk",
                                              :signature ["[inner outer form]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.walk_walk",
                                              :source {:code "(defn walk\n  [inner outer form]\n  (cond\n   (seq? form) (outer (doall (map inner form)))\n   (coll? form) (outer (into (empty form) (map inner form)))\n   :else (outer form)))",
                                                       :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                       :lines [37 48],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/walk.cljs#L37-L48"},
                                              :full-name "clojure.walk/walk",
                                              :clj-symbol "clojure.walk/walk",
                                              :docstring "Traverses form, an arbitrary data structure.  inner and outer are\nfunctions.  Applies inner to each element of form, building up a\ndata structure of the same type, then applies outer to the result.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
                         "cljs.core/bit-xor" {:ns "cljs.core",
                                              :name "bit-xor",
                                              :signature ["[x y]"],
                                              :shadowed-sources ({:code "(defmacro bit-xor\n  ([x y] (list 'js* \"(~{} ^ ~{})\" x y))\n  ([x y & more] `(bit-xor (bit-xor ~x ~y) ~@more)))",
                                                                  :filename "clojurescript/src/clj/cljs/core.clj",
                                                                  :lines [142
                                                                          144],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L142-L144"}),
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_bit-xor",
                                              :source {:code "(defn bit-xor\n  [x y] (js* \"(~{x} ^ ~{y})\"))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [898
                                                               900],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L898-L900"},
                                              :full-name "cljs.core/bit-xor",
                                              :clj-symbol "clojure.core/bit-xor",
                                              :docstring "Bitwise exclusive or"},
                         "clojure.set/union" {:ns "clojure.set",
                                              :name "union",
                                              :signature ["[]"
                                                          "[s1]"
                                                          "[s1 s2]"
                                                          "[s1 s2 & sets]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.set_union",
                                              :source {:code "(defn union\n  ([] #{})\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s1) (count s2))\n       (reduce conj s2 s1)\n       (reduce conj s1 s2)))\n  ([s1 s2 & sets]\n     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n       (reduce into (first bubbled-sets) (rest bubbled-sets)))))",
                                                       :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                       :lines [19 29],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/set.cljs#L19-L29"},
                                              :full-name "clojure.set/union",
                                              :clj-symbol "clojure.set/union",
                                              :docstring "Return a set that is the union of the input sets"},
                         "cljs.reader/PushbackReader" {:ns "cljs.reader",
                                                       :name "PushbackReader",
                                                       :type "protocol",
                                                       :full-name-encode "cljs.reader_PushbackReader",
                                                       :source {:code "(defprotocol PushbackReader\n  (read-char [reader] \"Returns the next char from the Reader,\nnil if the end of stream has been reached\")\n  (unread [reader ch] \"Push back a single character on to the stream\"))",
                                                                :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                :lines [12
                                                                        15],
                                                                :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L12-L15"},
                                                       :methods [{:name "read-char",
                                                                  :signature ["[reader]"],
                                                                  :docstring "Returns the next char from the Reader,\nnil if the end of stream has been reached"}
                                                                 {:name "unread",
                                                                  :signature ["[reader ch]"],
                                                                  :docstring "Push back a single character on to the stream"}],
                                                       :full-name "cljs.reader/PushbackReader",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.core/isa?" {:ns "cljs.core",
                                           :name "isa?",
                                           :signature ["[child parent]"
                                                       "[h child parent]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_isa_QMARK_",
                                           :source {:code "(defn isa?\n  ([child parent] (isa? @global-hierarchy child parent))\n  ([h child parent]\n     (or (= child parent)\n         ;; (and (class? parent) (class? child)\n         ;;    (. ^Class parent isAssignableFrom child))\n         (contains? ((:ancestors h) child) parent)\n         ;;(and (class? child) (some #(contains? ((:ancestors h) %) parent) (supers child)))\n         (and (vector? parent) (vector? child)\n              (= (count parent) (count child))\n              (loop [ret true i 0]\n                (if (or (not ret) (= i (count parent)))\n                  ret\n                  (recur (isa? h (child i) (parent i)) (inc i))))))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [3256 3274],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3256-L3274"},
                                           :full-name "cljs.core/isa?",
                                           :clj-symbol "clojure.core/isa?",
                                           :docstring "Returns true if (= child parent), or child is directly or indirectly derived from\nparent, either via a Java type inheritance relationship or a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy"},
                         "clojure.browser.net/xhr-connection" {:full-name "clojure.browser.net/xhr-connection",
                                                               :ns "clojure.browser.net",
                                                               :name "xhr-connection",
                                                               :docstring "Returns an XhrIo connection",
                                                               :type "function",
                                                               :signature ["[]"],
                                                               :source {:code "(defn xhr-connection\n  []\n  (goog.net.XhrIo.))",
                                                                        :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                        :lines [83
                                                                                86],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/net.cljs#L83-L86"},
                                                               :full-name-encode "clojure.browser.net_xhr-connection",
                                                               :history [["+"
                                                                          "0.0-927"]]},
                         "cljs.core/subs" {:ns "cljs.core",
                                           :name "subs",
                                           :signature ["[s start]"
                                                       "[s start end]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_subs",
                                           :source {:code "(defn subs\n  ([s start] (.substring s start))\n  ([s start end] (.substring s start end)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1023 1027],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1023-L1027"},
                                           :full-name "cljs.core/subs",
                                           :clj-symbol "clojure.core/subs",
                                           :docstring "Returns the substring of s beginning at start inclusive, and ending\nat end (defaults to length of string), exclusive."},
                         "cljs.core/symbol?" {:full-name "cljs.core/symbol?",
                                              :ns "cljs.core",
                                              :name "symbol?",
                                              :type "function",
                                              :signature ["[x]"],
                                              :source {:code "(defn symbol? [x]\n  (and (goog/isString x)\n       (= (.charAt x 0) \\uFDD1)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [637
                                                               639],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L637-L639"},
                                              :full-name-encode "cljs.core_symbol_QMARK_",
                                              :clj-symbol "clojure.core/symbol?",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "clojure.string/replace" {:ns "clojure.string",
                                                   :name "replace",
                                                   :signature ["[s match replacement]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.string_replace",
                                                   :source {:code "(defn replace\n  [s match replacement]\n  (cond (string? match)\n        (.replace s (js/RegExp. (gstring/regExpEscape match) \"g\") replacement)\n        (.hasOwnProperty match \"source\")\n        (.replace s (js/RegExp. (.-source match) \"g\") replacement)\n        :else (throw (str \"Invalid match arg: \" match))))",
                                                            :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                            :lines [23
                                                                    34],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/string.cljs#L23-L34"},
                                                   :full-name "clojure.string/replace",
                                                   :clj-symbol "clojure.string/replace",
                                                   :docstring "Replaces all instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
                         "cljs.core/string?" {:full-name "cljs.core/string?",
                                              :ns "cljs.core",
                                              :name "string?",
                                              :type "function",
                                              :signature ["[x]"],
                                              :source {:code "(defn string? [x]\n  (and (goog/isString x)\n       (not (or (= (.charAt x 0) \\uFDD0)\n                (= (.charAt x 0) \\uFDD1)))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [628
                                                               631],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L628-L631"},
                                              :full-name-encode "cljs.core_string_QMARK_",
                                              :clj-symbol "clojure.core/string?",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/partition-all" {:ns "cljs.core",
                                                    :name "partition-all",
                                                    :signature ["[n coll]"
                                                                "[n step coll]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_partition-all",
                                                    :source {:code "(defn partition-all\n  ([n coll]\n     (partition-all n n coll))\n  ([n step coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (cons (take n s) (partition-all n step (drop step s)))))))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [2566
                                                                     2574],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2566-L2574"},
                                                    :full-name "cljs.core/partition-all",
                                                    :clj-symbol "clojure.core/partition-all",
                                                    :docstring "Returns a lazy sequence of lists like partition, but may include\npartitions with fewer than n items at the end."},
                         "cljs.core/merge-with" {:ns "cljs.core",
                                                 :name "merge-with",
                                                 :signature ["[f & maps]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_merge-with",
                                                 :source {:code "(defn merge-with\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n                        (let [k (first e) v (second e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2394
                                                                  2408],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2394-L2408"},
                                                 :full-name "cljs.core/merge-with",
                                                 :clj-symbol "clojure.core/merge-with",
                                                 :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping(s)\nfrom the latter (left-to-right) will be combined with the mapping in\nthe result by calling (f val-in-result val-in-latter)."},
                         "clojure.browser.dom/set-properties" {:full-name "clojure.browser.dom/set-properties",
                                                               :ns "clojure.browser.dom",
                                                               :name "set-properties",
                                                               :docstring "Set properties on an element",
                                                               :type "function",
                                                               :signature ["[e m]"],
                                                               :source {:code "(defn set-properties\n  [e m]\n  (gdom/setProperties (ensure-element e)\n                      (.-strobj m)))",
                                                                        :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                        :lines [134
                                                                                138],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/dom.cljs#L134-L138"},
                                                               :full-name-encode "clojure.browser.dom_set-properties",
                                                               :history [["+"
                                                                          "0.0-927"]]},
                         "cljs.core/trampoline" {:ns "cljs.core",
                                                 :name "trampoline",
                                                 :signature ["[f]"
                                                             "[f & args]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_trampoline",
                                                 :source {:code "(defn trampoline\n  ([f]\n     (let [ret (f)]\n       (if (fn? ret)\n         (recur ret)\n         ret)))\n  ([f & args]\n     (trampoline #(apply f args))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [3204
                                                                  3218],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3204-L3218"},
                                                 :full-name "cljs.core/trampoline",
                                                 :clj-symbol "clojure.core/trampoline",
                                                 :docstring "trampoline can be used to convert algorithms requiring mutual\nrecursion without stack consumption. Calls f with supplied args, if\nany. If f returns a fn, calls that fn with no arguments, and\ncontinues to repeat, until the return value is not a fn, then\nreturns that non-fn value. Note that if you want to return a fn as a\nfinal value, you must wrap it in some data structure and unpack it\nafter trampoline returns."},
                         "clojure.browser.repl/send-print" {:full-name "clojure.browser.repl/send-print",
                                                            :ns "clojure.browser.repl",
                                                            :name "send-print",
                                                            :docstring "Send data to be printed in the REPL. If there is an error, try again\nup to 10 times.",
                                                            :type "function",
                                                            :signature ["[url data]"
                                                                        "[url data n]"],
                                                            :source {:code "(defn send-print\n  ([url data]\n     (send-print url data 0))\n  ([url data n]\n     (let [conn (net/xhr-connection)]\n       (event/listen conn :error\n                     (fn [_]\n                       (if (< n 10)\n                         (send-print url data (inc n))\n                         (.log js/console (str \"Could not send \" data \" after \" n \" attempts.\")))))\n       (net/transmit conn url \"POST\" data nil 0))))",
                                                                     :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                     :lines [41
                                                                             53],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/repl.cljs#L41-L53"},
                                                            :full-name-encode "clojure.browser.repl_send-print",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "cljs.core/ICounted" {:ns "cljs.core",
                                               :name "ICounted",
                                               :type "protocol",
                                               :full-name-encode "cljs.core_ICounted",
                                               :source {:code "(defprotocol ICounted\n  (-count [coll] \"constant time count\"))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [93 94],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L93-L94"},
                                               :methods [{:name "-count",
                                                          :signature ["[coll]"],
                                                          :docstring "constant time count"}],
                                               :full-name "cljs.core/ICounted",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/IEquiv" {:ns "cljs.core",
                                             :name "IEquiv",
                                             :type "protocol",
                                             :full-name-encode "cljs.core_IEquiv",
                                             :source {:code "(defprotocol IEquiv\n  (-equiv [o other]))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [149 150],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L149-L150"},
                                             :methods [{:name "-equiv",
                                                        :signature ["[o other]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/IEquiv",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/js-delete" {:full-name "cljs.core/js-delete",
                                                :ns "cljs.core",
                                                :name "js-delete",
                                                :type "function",
                                                :signature ["[obj key]"],
                                                :source {:code "(defn js-delete [obj key]\n  (js* \"delete ~{obj}[~{key}]\"))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [597
                                                                 598],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L597-L598"},
                                                :full-name-encode "cljs.core_js-delete",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/comment" {:ns "cljs.core",
                                              :name "comment",
                                              :signature ["[& body]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "macro",
                                              :full-name-encode "cljs.core_comment",
                                              :source {:code "(defmacro comment\n  [& body])",
                                                       :filename "clojure/src/clj/clojure/core.clj",
                                                       :lines [4161
                                                               4164],
                                                       :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L4161-L4164"},
                                              :full-name "cljs.core/comment",
                                              :clj-symbol "clojure.core/comment",
                                              :docstring "Ignores body, yields nil"},
                         "cljs.reader/special-symbols" {:full-name "cljs.reader/special-symbols",
                                                        :ns "cljs.reader",
                                                        :name "special-symbols",
                                                        :type "var",
                                                        :source {:code "(def special-symbols\n  {\"nil\" nil\n   \"true\" true\n   \"false\" false})",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [243
                                                                         246],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L243-L246"},
                                                        :full-name-encode "cljs.reader_special-symbols",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/alength" {:ns "cljs.core",
                                              :name "alength",
                                              :signature ["[array]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_alength",
                                              :source {:code "(defn alength\n  [array]\n  (js* \"~{array}.length\"))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [87 90],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L87-L90"},
                                              :full-name "cljs.core/alength",
                                              :clj-symbol "clojure.core/alength",
                                              :docstring "Returns the length of the Java array. Works on arrays of all types."},
                         "special/quote" {:full-name "special/quote",
                                          :ns "special",
                                          :name "quote",
                                          :type "special form",
                                          :source {:code "(defmethod parse 'quote\n  [_ env [_ x] _]\n  {:op :constant :env env :form x})",
                                                   :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                   :lines [769 771],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/compiler.clj#L769-L771"},
                                          :full-name-encode "special_quote",
                                          :clj-symbol "clojure.core/quote",
                                          :history [["+" "0.0-927"]]},
                         "cljs.core/tree-seq" {:ns "cljs.core",
                                               :name "tree-seq",
                                               :signature ["[branch? children root]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_tree-seq",
                                               :source {:code "(defn tree-seq\n   [branch? children root]\n   (let [walk (fn walk [node]\n                (lazy-seq\n                 (cons node\n                  (when (branch? node)\n                    (mapcat walk (children node))))))]\n     (walk root)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [1802
                                                                1815],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1802-L1815"},
                                               :full-name "cljs.core/tree-seq",
                                               :clj-symbol "clojure.core/tree-seq",
                                               :docstring "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n branch? must be a fn of one arg that returns true if passed a node\n that can have children (but may not).  children must be a fn of one\n arg that returns a sequence of the children. Will only be called on\n nodes for which branch? returns true. Root is the root node of the\ntree."},
                         "cljs.reader/read-unmatched-delimiter" {:full-name "cljs.reader/read-unmatched-delimiter",
                                                                 :ns "cljs.reader",
                                                                 :name "read-unmatched-delimiter",
                                                                 :type "function",
                                                                 :signature ["[rdr ch]"],
                                                                 :source {:code "(defn read-unmatched-delimiter\n  [rdr ch]\n  (reader-error rdr \"Unmached delimiter \" ch))",
                                                                          :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                          :lines [199
                                                                                  201],
                                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L199-L201"},
                                                                 :full-name-encode "cljs.reader_read-unmatched-delimiter",
                                                                 :history [["+"
                                                                            "0.0-927"]]},
                         "cljs.core/every-pred" {:ns "cljs.core",
                                                 :name "every-pred",
                                                 :signature ["[p]"
                                                             "[p1 p2]"
                                                             "[p1 p2 p3]"
                                                             "[p1 p2 p3 & ps]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_every-pred",
                                                 :source {:code "(defn every-pred\n  ([p]\n     (fn ep1\n       ([] true)\n       ([x] (boolean (p x)))\n       ([x y] (boolean (and (p x) (p y))))\n       ([x y z] (boolean (and (p x) (p y) (p z))))\n       ([x y z & args] (boolean (and (ep1 x y z)\n                                     (every? p args))))))\n  ([p1 p2]\n     (fn ep2\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x))))\n       ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n       ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n       ([x y z & args] (boolean (and (ep2 x y z)\n                                     (every? #(and (p1 %) (p2 %)) args))))))\n  ([p1 p2 p3]\n     (fn ep3\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n       ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n       ([x y z] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z))))\n       ([x y z & args] (boolean (and (ep3 x y z)\n                                     (every? #(and (p1 %) (p2 %) (p3 %)) args))))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn epn\n         ([] true)\n         ([x] (every? #(% x) ps))\n         ([x y] (every? #(and (% x) (% y)) ps))\n         ([x y z] (every? #(and (% x) (% y) (% z)) ps))\n         ([x y z & args] (boolean (and (epn x y z)\n                                       (every? #(every? % args) ps))))))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [1561
                                                                  1598],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1561-L1598"},
                                                 :full-name "cljs.core/every-pred",
                                                 :clj-symbol "clojure.core/every-pred",
                                                 :docstring "Takes a set of predicates and returns a function f that returns true if all of its\ncomposing predicates return a logical true value against all of its arguments, else it returns\nfalse. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical false result against the original predicates."},
                         "clojure.set/rename-keys" {:ns "clojure.set",
                                                    :name "rename-keys",
                                                    :signature ["[map kmap]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "clojure.set_rename-keys",
                                                    :source {:code "(defn rename-keys\n  [map kmap]\n    (reduce \n     (fn [m [old new]]\n       (if (and (not= old new)\n                (contains? m old))\n         (-> m (assoc new (get m old)) (dissoc old))\n         m)) \n     map kmap))",
                                                             :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                             :lines [72
                                                                     81],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/set.cljs#L72-L81"},
                                                    :full-name "clojure.set/rename-keys",
                                                    :clj-symbol "clojure.set/rename-keys",
                                                    :docstring "Returns the map with the keys in kmap renamed to the vals in kmap"},
                         "cljs.core/peek" {:ns "cljs.core",
                                           :name "peek",
                                           :signature ["[coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_peek",
                                           :source {:code "(defn peek\n  [coll]\n  (-peek coll))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [518 522],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L518-L522"},
                                           :full-name "cljs.core/peek",
                                           :clj-symbol "clojure.core/peek",
                                           :docstring "For a list or queue, same as first, for a vector, same as, but much\nmore efficient than, last. If the collection is empty, returns nil."},
                         "cljs.core/pr-str-with-opts" {:full-name "cljs.core/pr-str-with-opts",
                                                       :ns "cljs.core",
                                                       :name "pr-str-with-opts",
                                                       :docstring "Prints a sequence of objects to a string, observing all the\noptions given in opts",
                                                       :type "function",
                                                       :signature ["[objs opts]"],
                                                       :source {:code "(defn pr-str-with-opts\n  [objs opts]\n  (let [first-obj (first objs)\n        sb (gstring/StringBuffer.)]\n    (doseq [obj objs]\n      (when-not (identical? obj first-obj)\n        (.append sb \" \"))\n      (doseq [string (pr-seq obj opts)]\n        (.append sb string)))\n    (str sb)))",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [2827
                                                                        2838],
                                                                :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2827-L2838"},
                                                       :full-name-encode "cljs.core_pr-str-with-opts",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.core/map?" {:ns "cljs.core",
                                           :name "map?",
                                           :signature ["[x]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_map_QMARK_",
                                           :source {:code "(defn map?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? IMap x)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [577 582],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L577-L582"},
                                           :full-name "cljs.core/map?",
                                           :clj-symbol "clojure.core/map?",
                                           :docstring "Return true if x satisfies IMap"},
                         "cljs.reader/StringPushbackReader" {:full-name "cljs.reader/StringPushbackReader",
                                                             :ns "cljs.reader",
                                                             :name "StringPushbackReader",
                                                             :type "type",
                                                             :signature ["[s index-atom buffer-atom]"],
                                                             :source {:code "(deftype StringPushbackReader [s index-atom buffer-atom]\n  PushbackReader\n  (read-char [reader]\n             (if (empty? @buffer-atom)\n               (let [idx @index-atom]\n                 (swap! index-atom inc)\n                 (nth s idx))\n               (let [buf @buffer-atom]\n                 (swap! buffer-atom rest)\n                 (first buf))))\n  (unread [reader ch] (swap! buffer-atom #(cons ch %))))",
                                                                      :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                      :lines [18
                                                                              28],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L18-L28"},
                                                             :full-name-encode "cljs.reader_StringPushbackReader",
                                                             :history [["+"
                                                                        "0.0-927"]]},
                         "cljs.core/deref" {:full-name "cljs.core/deref",
                                            :ns "cljs.core",
                                            :name "deref",
                                            :type "function",
                                            :signature ["[o]"],
                                            :source {:code "(defn deref\n  [o]\n  (-deref o))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [3050
                                                             3052],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3050-L3052"},
                                            :full-name-encode "cljs.core_deref",
                                            :clj-symbol "clojure.core/deref",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/reductions" {:ns "cljs.core",
                                                 :name "reductions",
                                                 :signature ["[f coll]"
                                                             "[f init coll]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_reductions",
                                                 :source {:code "(defn reductions\n  ([f coll]\n     (lazy-seq\n      (if-let [s (seq coll)]\n        (reductions f (first s) (rest s))\n        (list (f)))))\n  ([f init coll]\n     (cons init\n           (lazy-seq\n            (when-let [s (seq coll)]\n              (reductions f (f init (first s)) (rest s)))))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2685
                                                                  2697],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2685-L2697"},
                                                 :full-name "cljs.core/reductions",
                                                 :clj-symbol "clojure.core/reductions",
                                                 :docstring "Returns a lazy seq of the intermediate values of the reduction (as\nper reduce) of coll by f, starting with init."},
                         "cljs.core/false?" {:ns "cljs.core",
                                             :name "false?",
                                             :signature ["[x]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_false_QMARK_",
                                             :source {:code "(defn false?\n  [x] (js* \"~{x} === false\"))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [604 606],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L604-L606"},
                                             :full-name "cljs.core/false?",
                                             :clj-symbol "clojure.core/false?",
                                             :docstring "Returns true if x is the value false, false otherwise."},
                         "cljs.core/bit-flip" {:ns "cljs.core",
                                               :name "bit-flip",
                                               :signature ["[x n]"],
                                               :shadowed-sources ({:code "(defmacro bit-flip [x n]\n  (list 'js* \"(~{} ^ (1 << ~{}))\" x n))",
                                                                   :filename "clojurescript/src/clj/cljs/core.clj",
                                                                   :lines [153
                                                                           154],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L153-L154"}),
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_bit-flip",
                                               :source {:code "(defn bit-flip\n  [x n]\n  (js* \"(~{x} ^ (1 << ~{n}))\"))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [919
                                                                922],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L919-L922"},
                                               :full-name "cljs.core/bit-flip",
                                               :clj-symbol "clojure.core/bit-flip",
                                               :docstring "Flip bit at index n"},
                         "cljs.core/ISet" {:ns "cljs.core",
                                           :name "ISet",
                                           :type "protocol",
                                           :full-name-encode "cljs.core_ISet",
                                           :source {:code "(defprotocol ISet\n  (-disjoin [coll v]))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [124 125],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L124-L125"},
                                           :methods [{:name "-disjoin",
                                                      :signature ["[coll v]"],
                                                      :docstring nil}],
                                           :full-name "cljs.core/ISet",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/LazySeq" {:full-name "cljs.core/LazySeq",
                                              :ns "cljs.core",
                                              :name "LazySeq",
                                              :type "type",
                                              :signature ["[meta realized x]"],
                                              :source {:code "(deftype LazySeq [meta realized x]\n  IWithMeta\n  (-with-meta [coll meta] (LazySeq. meta realized x))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first (lazy-seq-value coll)))\n  (-rest [coll] (rest (lazy-seq-value coll)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] (seq (lazy-seq-value coll))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1250
                                                               1275],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1250-L1275"},
                                              :full-name-encode "cljs.core_LazySeq",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/*2" {:full-name "cljs.core/*2",
                                         :ns "cljs.core",
                                         :name "*2",
                                         :docstring "bound in a repl thread to the second most recent value printed",
                                         :type "var",
                                         :source {:code "(def \n  ^{:doc \"bound in a repl thread to the second most recent value printed\"}\n  *2)",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [27 29],
                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L27-L29"},
                                         :full-name-encode "cljs.core__STAR_2",
                                         :clj-symbol "clojure.core/*2",
                                         :history [["+" "0.0-927"]]},
                         "clojure.browser.event/total-listener-count" {:full-name "clojure.browser.event/total-listener-count",
                                                                       :ns "clojure.browser.event",
                                                                       :name "total-listener-count",
                                                                       :type "function",
                                                                       :signature ["[]"],
                                                                       :source {:code "(defn total-listener-count []\n  (goog.events/getTotalListenerCount))",
                                                                                :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                                :lines [85
                                                                                        86],
                                                                                :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/event.cljs#L85-L86"},
                                                                       :full-name-encode "clojure.browser.event_total-listener-count",
                                                                       :history [["+"
                                                                                  "0.0-927"]]},
                         "cljs.core/alter-meta!" {:ns "cljs.core",
                                                  :name "alter-meta!",
                                                  :signature ["[iref f & args]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_alter-meta_BANG_",
                                                  :source {:code "(defn alter-meta!\n  [iref f & args]\n  (set! (.-meta iref) (apply f (.-meta iref) args)))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [3069
                                                                   3076],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3069-L3076"},
                                                  :full-name "cljs.core/alter-meta!",
                                                  :clj-symbol "clojure.core/alter-meta!",
                                                  :docstring "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n(apply f its-current-meta args)\n\nf must be free of side-effects"},
                         "clojure.browser.dom/click-element" {:full-name "clojure.browser.dom/click-element",
                                                              :ns "clojure.browser.dom",
                                                              :name "click-element",
                                                              :type "function",
                                                              :signature ["[e]"],
                                                              :source {:code "(defn click-element\n  [e]\n  (.click (ensure-element e) ()))",
                                                                       :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                       :lines [145
                                                                               147],
                                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/dom.cljs#L145-L147"},
                                                              :full-name-encode "clojure.browser.dom_click-element",
                                                              :history [["+"
                                                                         "0.0-927"]]},
                         "cljs.reader/read-meta" {:full-name "cljs.reader/read-meta",
                                                  :ns "cljs.reader",
                                                  :name "read-meta",
                                                  :type "function",
                                                  :signature ["[rdr _]"],
                                                  :source {:code "(defn read-meta\n  [rdr _]\n  (let [m (desugar-meta (read rdr true nil true))]\n    (when-not (map? m)\n      (reader-error rdr \"Metadata must be Symbol,Keyword,String or Map\"))\n    (let [o (read rdr true nil true)]\n      (if (satisfies? IWithMeta o)\n        (with-meta o (merge (meta o) m))\n        (reader-error rdr \"Metadata can only be applied to IWithMetas\")))))",
                                                           :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                           :lines [287
                                                                   295],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L287-L295"},
                                                  :full-name-encode "cljs.reader_read-meta",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "special/try*" {:full-name "special/try*",
                                         :ns "special",
                                         :name "try*",
                                         :type "special form",
                                         :source {:code "(defmethod parse 'try*\n  [op env [_ & body :as form] name]\n  (let [body (vec body)\n        catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        tail (peek body)\n        fblock (when (and (seq? tail) (= 'finally (first tail)))\n                  (rest tail))\n        finally (when fblock\n                  (analyze-block\n                   (assoc env :context :statement)\n                   fblock))\n        body (if finally (pop body) body)\n        tail (peek body)\n        cblock (when (and (seq? tail)\n                          (= 'catch (first tail)))\n                 (rest tail))\n        name (first cblock)\n        locals (:locals catchenv)\n        mname (when name (munge name))\n        locals (if name\n                 (assoc locals name {:name mname})\n                 locals)\n        catch (when cblock\n                (analyze-block (assoc catchenv :locals locals) (rest cblock)))\n        body (if name (pop body) body)\n        try (when body\n              (analyze-block (if (or name finally) catchenv env) body))]\n    (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n    {:env env :op :try* :form form\n     :try try\n     :finally finally\n     :name mname\n     :catch catch\n     :children [try {:name mname} catch finally]}))",
                                                  :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                  :lines [619 652],
                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/compiler.clj#L619-L652"},
                                         :full-name-encode "special_try_STAR_",
                                         :history [["+" "0.0-927"]]},
                         "cljs.core/range" {:ns "cljs.core",
                                            :name "range",
                                            :signature ["[]"
                                                        "[end]"
                                                        "[start end]"
                                                        "[start end step]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_range",
                                            :source {:code "(defn range\n  ([] (range 0 js/Number.MAX_VALUE 1))\n  ([end] (range 0 end 1))\n  ([start end] (range start end 1))\n  ([start end step] (Range. nil start end step)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2643
                                                             2650],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2643-L2650"},
                                            :full-name "cljs.core/range",
                                            :clj-symbol "clojure.core/range",
                                            :docstring "Returns a lazy seq of nums from start (inclusive) to end\n(exclusive), by step, where start defaults to 0, step to 1,\nand end to infinity."},
                         "cljs.core/reify" {:full-name "cljs.core/reify",
                                            :ns "cljs.core",
                                            :name "reify",
                                            :type "macro",
                                            :signature ["[& impls]"],
                                            :source {:code "(defmacro reify [& impls]\n  (let [t (gensym \"t\")\n        locals (keys (:locals &env))]\n   `(do\n      (when (undefined? ~t)\n        (deftype ~t [~@locals ~'__meta]\n          cljs.core.IWithMeta\n          (~'-with-meta [~'_ ~'__meta]\n            (new ~t ~@locals ~'__meta))\n          cljs.core.IMeta\n          (~'-meta [~'_] ~'__meta)\n          ~@impls))\n      (new ~t ~@locals nil))))",
                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                     :lines [178 190],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L178-L190"},
                                            :full-name-encode "cljs.core_reify",
                                            :clj-symbol "clojure.core/reify",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/satisfies?" {:ns "cljs.core",
                                                 :name "satisfies?",
                                                 :signature ["[psym x]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "macro",
                                                 :full-name-encode "cljs.core_satisfies_QMARK_",
                                                 :source {:code "(defmacro satisfies?\n  [psym x]\n  (let [p (:name (cljs.compiler/resolve-var (dissoc &env :locals) psym))\n        prefix (protocol-prefix p)]\n    `(let [x# ~x]\n       (if (and x#\n                (. x# ~(symbol (str \"-\" prefix)))        ;; Need prop lookup here\n                (not (. x# (~'hasOwnProperty ~prefix))))\n\t true\n\t (cljs.core/type_satisfies_ ~psym x#)))))",
                                                          :filename "clojurescript/src/clj/cljs/core.clj",
                                                          :lines [388
                                                                  398],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L388-L398"},
                                                 :full-name "cljs.core/satisfies?",
                                                 :clj-symbol "clojure.core/satisfies?",
                                                 :docstring "Returns true if x satisfies the protocol"},
                         "cljs.core/nth" {:ns "cljs.core",
                                          :name "nth",
                                          :signature ["[coll n]"
                                                      "[coll n not-found]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_nth",
                                          :source {:code "(defn nth\n  ([coll n]\n     (-nth coll (.floor js/Math n)))\n  ([coll n not-found]\n     (-nth coll (.floor js/Math n) not-found)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [464 472],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L464-L472"},
                                          :full-name "cljs.core/nth",
                                          :clj-symbol "clojure.core/nth",
                                          :docstring "Returns the value at the index. get returns nil if index out of\nbounds, nth throws an exception unless not-found is supplied.  nth\nalso works for strings, arrays, regex Matchers and Lists, and,\nin O(n) time, for sequences."},
                         "cljs.core/list" {:full-name "cljs.core/list",
                                           :ns "cljs.core",
                                           :name "list",
                                           :type "function",
                                           :signature ["[& items]"],
                                           :source {:code "(defn list [& items]\n  (reduce conj () (reverse items)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1154 1155],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1154-L1155"},
                                           :full-name-encode "cljs.core_list",
                                           :clj-symbol "clojure.core/list",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/defn" {:ns "cljs.core",
                                           :name "defn",
                                           :signature ["[name doc-string? attr-map? [params*] body]"
                                                       "[name doc-string? attr-map? ([params*] body) + attr-map?]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_defn",
                                           :source {:code "(def \n\n ^{:doc \"Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata\"\n   :arglists '([name doc-string? attr-map? [params*] body]\n                [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :added \"1.0\"}\n defn (fn defn [&form &env name & fdecl]\n        (let [m (if (string? (first fdecl))\n                  {:doc (first fdecl)}\n                  {})\n              fdecl (if (string? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              m (if (map? (first fdecl))\n                  (conj m (first fdecl))\n                  m)\n              fdecl (if (map? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              fdecl (if (vector? (first fdecl))\n                      (list fdecl)\n                      fdecl)\n              m (if (map? (last fdecl))\n                  (conj m (last fdecl))\n                  m)\n              fdecl (if (map? (last fdecl))\n                      (butlast fdecl)\n                      fdecl)\n              m (conj {:arglists (list 'quote (sigs fdecl))} m)\n              m (let [inline (:inline m)\n                      ifn (first inline)\n                      iname (second inline)]\n                  ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)\n                  (if (if (clojure.lang.Util/equiv 'fn ifn)\n                        (if (instance? clojure.lang.Symbol iname) false true))\n                    ;; inserts the same fn name to the inline fn if it does not have one\n                    (assoc m :inline (cons ifn (cons (clojure.lang.Symbol/intern (.concat (.getName ^clojure.lang.Symbol name) \"__inliner\"))\n                                                     (next inline))))\n                    m))\n              m (conj (if (meta name) (meta name) {}) m)]\n          (list 'def (with-meta name m)\n                ;;todo - restore propagation of fn name\n                ;;must figure out how to convey primitive hints to self calls first\n                (cons `fn fdecl) ))))",
                                                    :filename "clojure/src/clj/clojure/core.clj",
                                                    :lines [263 308],
                                                    :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L263-L308"},
                                           :full-name "cljs.core/defn",
                                           :clj-symbol "clojure.core/defn",
                                           :docstring "Same as (def name (fn [params* ] exprs*)) or (def\n name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n to the var metadata"},
                         "cljs.core/rand-nth" {:ns "cljs.core",
                                               :name "rand-nth",
                                               :signature ["[coll]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_rand-nth",
                                               :source {:code "(defn rand-nth\n  [coll]\n  (nth coll (rand-int (count coll))))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [3230
                                                                3235],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3230-L3235"},
                                               :full-name "cljs.core/rand-nth",
                                               :clj-symbol "clojure.core/rand-nth",
                                               :docstring "Return a random element of the (sequential) collection. Will have\nthe same performance characteristics as nth for the given\ncollection."},
                         "cljs.core/atom" {:ns "cljs.core",
                                           :name "atom",
                                           :signature ["[x]"
                                                       "[x & {:keys [meta validator]}]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_atom",
                                           :source {:code "(defn atom\n  ([x] (Atom. x nil nil nil))\n  ([x & {:keys [meta validator]}] (Atom. x meta validator nil)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2994 3009],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2994-L3009"},
                                           :full-name "cljs.core/atom",
                                           :clj-symbol "clojure.core/atom",
                                           :docstring "Creates and returns an Atom with an initial value of x and zero or\nmore options (in any order):\n\n:meta metadata-map\n\n:validator validate-fn\n\nIf metadata-map is supplied, it will be come the metadata on the\natom. validate-fn must be nil or a side-effect-free fn of one\nargument, which will be passed the intended new state on any state\nchange. If the new state is unacceptable, the validate-fn should\nreturn false or throw an Error.  If either of these error conditions\noccur, then the value of the atom will not change."},
                         "cljs.reader/read-keyword" {:full-name "cljs.reader/read-keyword",
                                                     :ns "cljs.reader",
                                                     :name "read-keyword",
                                                     :type "function",
                                                     :signature ["[reader initch]"],
                                                     :source {:code "(defn read-keyword\n  [reader initch]\n  (let [token (read-token reader (read-char reader))\n        [token ns name] (re-matches symbol-pattern token)]\n    (if (or (and (not (undefined? ns))\n                 (identical? (. ns (substring (- (.-length ns) 2) (.-length ns))) \":/\"))\n            (identical? (aget name (dec (.-length name))) \":\")\n            (not (== (.indexOf token \"::\" 1) -1)))\n      (reader-error reader \"Invalid token: \" token)\n      (if ns?\n        (keyword (.substring ns 0 (.indexOf ns \"/\")) name)\n        (keyword token)))))",
                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                              :lines [256
                                                                      267],
                                                              :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L256-L267"},
                                                     :full-name-encode "cljs.reader_read-keyword",
                                                     :history [["+"
                                                                "0.0-927"]]},
                         "cljs.core/Vector" {:full-name "cljs.core/Vector",
                                             :ns "cljs.core",
                                             :name "Vector",
                                             :type "type",
                                             :signature ["[meta array]"],
                                             :source {:code "(deftype Vector [meta array]\n  IWithMeta\n  (-with-meta [coll meta] (Vector. meta array))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (let [count (.-length array)]\n      (when (> count 0)\n        (aget array (dec count)))))\n  (-pop [coll]\n    (if (> (.-length array) 0)\n      (let [new-array (aclone array)]\n        (. new-array (pop))\n        (Vector. meta new-array))\n      (throw (js/Error. \"Can't pop empty vector\"))))\n\n  ICollection\n  (-conj [coll o]\n    (let [new-array (aclone array)]\n      (.push new-array o)\n      (Vector. meta new-array)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Vector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (when (> (.-length array) 0)\n      (let [vector-seq\n             (fn vector-seq [i]\n               (lazy-seq\n                 (when (< i (.-length array))\n                   (cons (aget array i) (vector-seq (inc i))))))]\n        (vector-seq 0))))\n\n  ICounted\n  (-count [coll] (.-length array))\n\n  IIndexed\n  (-nth [coll n]\n    (if (and (<= 0 n) (< n (.-length array)))\n      (aget array n)\n      #_(throw (js/Error. (str \"No item \" n \" in vector of length \" (.-length array))))))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n (.-length array)))\n      (aget array n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [new-array (aclone array)]\n      (aset new-array k v)\n      (Vector. meta new-array)))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [v f]\n\t   (ci-reduce array f))\n  (-reduce [v f start]\n\t   (ci-reduce array f start)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1895
                                                              1970],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1895-L1970"},
                                             :full-name-encode "cljs.core_Vector",
                                             :history [["+" "0.0-927"]]},
                         "cljs.reader/skip-line" {:full-name "cljs.reader/skip-line",
                                                  :ns "cljs.reader",
                                                  :name "skip-line",
                                                  :docstring "Advances the reader to the end of a line. Returns the reader",
                                                  :type "function",
                                                  :signature ["[reader _]"],
                                                  :source {:code "(defn skip-line\n  [reader _]\n  (loop []\n    (let [ch (read-char reader)]\n      (if (or (= ch \\n) (= ch \\r) (nil? ch))\n        reader\n        (recur)))))",
                                                           :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                           :lines [86
                                                                   93],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/reader.cljs#L86-L93"},
                                                  :full-name-encode "cljs.reader_skip-line",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/namespace" {:ns "cljs.core",
                                                :name "namespace",
                                                :signature ["[x]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_namespace",
                                                :source {:code "(defn namespace\n  [x]\n  (if (or (keyword? x) (symbol? x))\n    (let [i (.lastIndexOf x \"/\")]\n      (when (> i -1)\n        (subs x 2 i)))\n    (throw (js/Error. (str \"Doesn't support namespace: \" x)))))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [2531
                                                                 2538],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2531-L2538"},
                                                :full-name "cljs.core/namespace",
                                                :clj-symbol "clojure.core/namespace",
                                                :docstring "Returns the namespace String of a symbol or keyword, or nil if not present."},
                         "cljs.nodejs/require" {:full-name "cljs.nodejs/require",
                                                :ns "cljs.nodejs",
                                                :name "require",
                                                :type "var",
                                                :source {:code "(def require (js* \"require\"))",
                                                         :filename "clojurescript/src/cljs/cljs/nodejs.cljs",
                                                         :lines [7 7],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/nodejs.cljs#L7-L7"},
                                                :full-name-encode "cljs.nodejs_require",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "clojure.browser.event/EventType" {:ns "clojure.browser.event",
                                                            :name "EventType",
                                                            :type "protocol",
                                                            :full-name-encode "clojure.browser.event_EventType",
                                                            :source {:code "(defprotocol EventType\n  (event-types [this]))",
                                                                     :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                     :lines [17
                                                                             18],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/event.cljs#L17-L18"},
                                                            :methods [{:name "event-types",
                                                                       :signature ["[this]"],
                                                                       :docstring nil}],
                                                            :full-name "clojure.browser.event/EventType",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "cljs.core/merge" {:ns "cljs.core",
                                            :name "merge",
                                            :signature ["[& maps]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_merge",
                                            :source {:code "(defn merge\n  [& maps]\n  (when (some identity maps)\n    (reduce #(conj (or %1 {}) %2) maps)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2386
                                                             2392],
                                                     :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2386-L2392"},
                                            :full-name "cljs.core/merge",
                                            :clj-symbol "clojure.core/merge",
                                            :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping from\nthe latter (left-to-right) will be the mapping in the result."},
                         "clojure.browser.repl/send-result" {:full-name "clojure.browser.repl/send-result",
                                                             :ns "clojure.browser.repl",
                                                             :name "send-result",
                                                             :type "function",
                                                             :signature ["[connection url data]"],
                                                             :source {:code "(defn send-result [connection url data]\n  (net/transmit connection url \"POST\" data nil 0))",
                                                                      :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                      :lines [38
                                                                              39],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/repl.cljs#L38-L39"},
                                                             :full-name-encode "clojure.browser.repl_send-result",
                                                             :history [["+"
                                                                        "0.0-927"]]},
                         "clojure.walk/keywordize-keys" {:ns "clojure.walk",
                                                         :name "keywordize-keys",
                                                         :signature ["[m]"],
                                                         :history [["+"
                                                                    "0.0-927"]],
                                                         :type "function",
                                                         :full-name-encode "clojure.walk_keywordize-keys",
                                                         :source {:code "(defn keywordize-keys\n  [m]\n  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                                  :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                                  :lines [64
                                                                          70],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/walk.cljs#L64-L70"},
                                                         :full-name "clojure.walk/keywordize-keys",
                                                         :clj-symbol "clojure.walk/keywordize-keys",
                                                         :docstring "Recursively transforms all map keys from strings to keywords."},
                         "cljs.core/derive" {:ns "cljs.core",
                                             :name "derive",
                                             :signature ["[tag parent]"
                                                         "[h tag parent]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_derive",
                                             :source {:code "(defn derive\n  ([tag parent]\n   (assert (namespace parent))\n   ;; (assert (or (class? tag) (and (instance? cljs.core.Named tag) (namespace tag))))\n   (swap! global-hierarchy derive tag parent) nil)\n  ([h tag parent]\n   (assert (not= tag parent))\n   ;; (assert (or (class? tag) (instance? clojure.lang.Named tag)))\n   ;; (assert (instance? clojure.lang.INamed tag))\n   ;; (assert (instance? clojure.lang.INamed parent))\n   (let [tp (:parents h)\n         td (:descendants h)\n         ta (:ancestors h)\n         tf (fn [m source sources target targets]\n              (reduce (fn [ret k]\n                        (assoc ret k\n                               (reduce conj (get targets k #{}) (cons target (targets target)))))\n                      m (cons source (sources source))))]\n     (or\n      (when-not (contains? (tp tag) parent)\n        (when (contains? (ta tag) parent)\n          (throw (js/Error. (str tag \"already has\" parent \"as ancestor\"))))\n        (when (contains? (ta parent) tag)\n          (throw (js/Error. (str \"Cyclic derivation:\" parent \"has\" tag \"as ancestor\"))))\n        {:parents (assoc (:parents h) tag (conj (get tp tag #{}) parent))\n         :ancestors (tf (:ancestors h) tag td parent ta)\n         :descendants (tf (:descendants h) parent ta tag td)})\n      h))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [3301
                                                              3333],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3301-L3333"},
                                             :full-name "cljs.core/derive",
                                             :clj-symbol "clojure.core/derive",
                                             :docstring "Establishes a parent/child relationship between parent and\ntag. Parent must be a namespace-qualified symbol or keyword and\nchild can be either a namespace-qualified symbol or keyword or a\nclass. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
                         "clojure.zip/zipper" {:ns "clojure.zip",
                                               :name "zipper",
                                               :signature ["[branch? children make-node root]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.zip_zipper",
                                               :source {:code "(defn zipper\n  [branch? children make-node root]\n    ^{:zip/branch? branch? :zip/children children :zip/make-node make-node}\n    [root nil])",
                                                        :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                        :lines [18 32],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L18-L32"},
                                               :full-name "clojure.zip/zipper",
                                               :clj-symbol "clojure.zip/zipper",
                                               :docstring "Creates a new zipper structure. \n\nbranch? is a fn that, given a node, returns true if can have\nchildren, even if it currently doesn't.\n\nchildren is a fn that, given a branch node, returns a seq of its\nchildren.\n\nmake-node is a fn that, given an existing node and a seq of\nchildren, returns a new branch node with the supplied children.\nroot is the root node."},
                         "clojure.zip/remove" {:ns "clojure.zip",
                                               :name "remove",
                                               :signature ["[loc]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.zip_remove",
                                               :source {:code "(defn remove\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]\n      (if (nil? path)\n        (throw \"Remove at top\")\n        (if (pos? (count l))\n          (loop [loc (with-meta [(peek l) (assoc path :l (pop l) :changed? true)] (meta loc))]\n            (if-let [child (and (branch? loc) (down loc))]\n              (recur (rightmost child))\n              loc))\n          (with-meta [(make-node loc (peek pnodes) rs) \n                      (and ppath (assoc ppath :changed? true))]\n                     (meta loc))))))",
                                                        :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                        :lines [237
                                                                251],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/zip.cljs#L237-L251"},
                                               :full-name "clojure.zip/remove",
                                               :clj-symbol "clojure.zip/remove",
                                               :docstring "Removes the node at loc, returning the loc that would have preceded\nit in a depth-first walk."},
                         "cljs.core/find" {:ns "cljs.core",
                                           :name "find",
                                           :signature ["[coll k]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_find",
                                           :source {:code "(defn find\n  [coll k]\n  (when (and coll\n             (associative? coll)\n             (contains? coll k))\n    [k (-lookup coll k)]))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [664 670],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L664-L670"},
                                           :full-name "cljs.core/find",
                                           :clj-symbol "clojure.core/find",
                                           :docstring "Returns the map entry for key, or nil if key not present."},
                         "cljs.core/*print-dup*" {:full-name "cljs.core/*print-dup*",
                                                  :ns "cljs.core",
                                                  :name "*print-dup*",
                                                  :type "var",
                                                  :source {:code "(def *print-dup* false)",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [2859
                                                                   2859],
                                                           :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2859-L2859"},
                                                  :full-name-encode "cljs.core__STAR_print-dup_STAR_",
                                                  :clj-symbol "clojure.core/*print-dup*",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/partial" {:ns "cljs.core",
                                              :name "partial",
                                              :signature ["[f arg1]"
                                                          "[f arg1 arg2]"
                                                          "[f arg1 arg2 arg3]"
                                                          "[f arg1 arg2 arg3 & more]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_partial",
                                              :source {:code "(defn partial\n  ([f arg1]\n   (fn [& args] (apply f arg1 args)))\n  ([f arg1 arg2]\n   (fn [& args] (apply f arg1 arg2 args)))\n  ([f arg1 arg2 arg3]\n   (fn [& args] (apply f arg1 arg2 arg3 args)))\n  ([f arg1 arg2 arg3 & more]\n   (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1486
                                                               1497],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1486-L1497"},
                                              :full-name "cljs.core/partial",
                                              :clj-symbol "clojure.core/partial",
                                              :docstring "Takes a function f and fewer than the normal arguments to f, and\nreturns a fn that takes a variable number of additional args. When\ncalled, the returned function calls f with args + additional args."},
                         "cljs.core/keyword?" {:full-name "cljs.core/keyword?",
                                               :ns "cljs.core",
                                               :name "keyword?",
                                               :type "function",
                                               :signature ["[x]"],
                                               :source {:code "(defn keyword? [x]\n  (and (goog/isString x)\n       (= (.charAt x 0) \\uFDD0)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [633
                                                                635],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L633-L635"},
                                               :full-name-encode "cljs.core_keyword_QMARK_",
                                               :clj-symbol "clojure.core/keyword?",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "clojure.browser.event/fire-listeners" {:full-name "clojure.browser.event/fire-listeners",
                                                                 :ns "clojure.browser.event",
                                                                 :name "fire-listeners",
                                                                 :type "function",
                                                                 :signature ["[obj type capture event]"],
                                                                 :source {:code "(defn fire-listeners\n  [obj type capture event])",
                                                                          :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                          :lines [82
                                                                                  83],
                                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/event.cljs#L82-L83"},
                                                                 :full-name-encode "clojure.browser.event_fire-listeners",
                                                                 :history [["+"
                                                                            "0.0-927"]]},
                         "cljs.core/interleave" {:ns "cljs.core",
                                                 :name "interleave",
                                                 :signature ["[c1 c2]"
                                                             "[c1 c2 & colls]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_interleave",
                                                 :source {:code "(defn interleave\n  ([c1 c2]\n     (lazy-seq\n      (let [s1 (seq c1) s2 (seq c2)]\n        (when (and s1 s2)\n          (cons (first s1) (cons (first s2)\n                                 (interleave (rest s1) (rest s2))))))))\n  ([c1 c2 & colls]\n     (lazy-seq\n      (let [ss (map seq (conj colls c2 c1))]\n        (when (every? identity ss)\n          (concat (map first ss) (apply interleave (map rest ss))))))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [1745
                                                                  1757],
                                                          :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1745-L1757"},
                                                 :full-name "cljs.core/interleave",
                                                 :clj-symbol "clojure.core/interleave",
                                                 :docstring "Returns a lazy seq of the first item in each coll, then the second etc."},
                         "cljs.core/*flush-on-newline*" {:full-name "cljs.core/*flush-on-newline*",
                                                         :ns "cljs.core",
                                                         :name "*flush-on-newline*",
                                                         :type "var",
                                                         :source {:code "(def *flush-on-newline* true)",
                                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                  :lines [2856
                                                                          2856],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L2856-L2856"},
                                                         :full-name-encode "cljs.core__STAR_flush-on-newline_STAR_",
                                                         :clj-symbol "clojure.core/*flush-on-newline*",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "cljs.core/get-in" {:ns "cljs.core",
                                             :name "get-in",
                                             :signature ["[m ks]"
                                                         "[m ks not-found]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_get-in",
                                             :source {:code "(defn get-in\n  ([m ks]\n     (reduce get m ks))\n  ([m ks not-found]\n     (loop [sentinel lookup-sentinel\n            m m\n            ks (seq ks)]\n       (if ks\n         (let [m (get m (first ks) sentinel)]\n           (if (identical? sentinel m)\n             not-found\n             (recur sentinel m (next ks))))\n         m))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1853
                                                              1870],
                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1853-L1870"},
                                             :full-name "cljs.core/get-in",
                                             :clj-symbol "clojure.core/get-in",
                                             :docstring "Returns the value in a nested associative structure,\nwhere ks is a sequence of ke(ys. Returns nil if the key is not present,\nor the not-found value if supplied."},
                         "clojure.browser.dom/element" {:full-name "clojure.browser.dom/element",
                                                        :ns "clojure.browser.dom",
                                                        :name "element",
                                                        :type "function",
                                                        :signature ["[tag-or-text]"
                                                                    "[tag & children]"],
                                                        :source {:code "(defn element\n  ([tag-or-text]\n     (log \"(element \" tag-or-text \")\")\n     (-element tag-or-text))\n  ([tag & children]\n     (log \"(element \" tag \" \" children \")\")\n     (let [attrs (first children)]\n       (if (map? attrs)\n         (-element tag attrs (rest children))\n         (-element tag nil children)))))",
                                                                 :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                 :lines [79
                                                                         88],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/dom.cljs#L79-L88"},
                                                        :full-name-encode "clojure.browser.dom_element",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/prim-seq" {:full-name "cljs.core/prim-seq",
                                               :ns "cljs.core",
                                               :name "prim-seq",
                                               :type "function",
                                               :signature ["[prim i]"],
                                               :source {:code "(defn prim-seq [prim i]\n  (when-not (= 0 (.-length prim))\n    (IndexedSeq. prim i)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [331
                                                                333],
                                                        :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L331-L333"},
                                               :full-name-encode "cljs.core_prim-seq",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/<=" {:ns "cljs.core",
                                         :name "<=",
                                         :signature ["[x]"
                                                     "[x y]"
                                                     "[x y & more]"],
                                         :shadowed-sources ({:code "(defmacro <=\n  ([x] true)\n  ([x y] (list 'js* \"(~{} <= ~{})\" x y))\n  ([x y & more] `(and (<= ~x ~y) (<= ~y ~@more))))",
                                                             :filename "clojurescript/src/clj/cljs/core.clj",
                                                             :lines [83
                                                                     86],
                                                             :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L83-L86"}),
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core__LT__EQ_",
                                         :source {:code "(defn <=\n  ([x] true)\n  ([x y] (js* \"(~{x} <= ~{y})\"))\n  ([x y & more]\n   (if (<= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (<= y (first more)))\n     false)))",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [813 823],
                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L813-L823"},
                                         :full-name "cljs.core/<=",
                                         :clj-symbol "clojure.core/<=",
                                         :docstring "Returns non-nil if nums are in monotonically non-decreasing order,\notherwise false."},
                         "clojure.set/map-invert" {:ns "clojure.set",
                                                   :name "map-invert",
                                                   :signature ["[m]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.set_map-invert",
                                                   :source {:code "(defn map-invert\n  [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))",
                                                            :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                            :lines [98
                                                                    100],
                                                            :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/set.cljs#L98-L100"},
                                                   :full-name "clojure.set/map-invert",
                                                   :clj-symbol "clojure.set/map-invert",
                                                   :docstring "Returns the map with the vals mapped to the keys."},
                         "clojure.browser.event/listen" {:full-name "clojure.browser.event/listen",
                                                         :ns "clojure.browser.event",
                                                         :name "listen",
                                                         :type "function",
                                                         :signature ["[src type fn]"
                                                                     "[src type fn capture?]"],
                                                         :source {:code "(defn listen\n  ([src type fn]\n     (listen src type fn false))\n  ([src type fn capture?]\n     (goog.events/listen src\n                         (get (event-types src) type type)\n                         fn\n                         capture?)))",
                                                                  :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                  :lines [44
                                                                          51],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/event.cljs#L44-L51"},
                                                         :full-name-encode "clojure.browser.event_listen",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "cljs.core/neg?" {:ns "cljs.core",
                                           :name "neg?",
                                           :signature ["[x]"],
                                           :shadowed-sources ({:code "(defmacro neg? [x]\n  `(< ~x 0))",
                                                               :filename "clojurescript/src/clj/cljs/core.clj",
                                                               :lines [115
                                                                       116],
                                                               :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L115-L116"}),
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_neg_QMARK_",
                                           :source {:code "(defn neg?\n  [x] (js* \"(~{x} < 0)\"))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [966 968],
                                                    :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L966-L968"},
                                           :full-name "cljs.core/neg?",
                                           :clj-symbol "clojure.core/neg?",
                                           :docstring "Returns true if num is less than zero, else false"},
                         "clojure.browser.dom/replace-node" {:full-name "clojure.browser.dom/replace-node",
                                                             :ns "clojure.browser.dom",
                                                             :name "replace-node",
                                                             :docstring "Replace old-node with new-node. old-node can be an element or a\nkeyword which is the id of the node to replace.  new-node can be an\nelement or an html string.",
                                                             :type "function",
                                                             :signature ["[old-node new-node]"],
                                                             :source {:code "(defn replace-node\n  [old-node new-node]\n  (let [old-node (ensure-element old-node)\n        new-node (ensure-element new-node)]\n    (gdom/replaceNode new-node old-node)\n    new-node))",
                                                                      :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                      :lines [112
                                                                              120],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/clojure/browser/dom.cljs#L112-L120"},
                                                             :full-name-encode "clojure.browser.dom_replace-node",
                                                             :history [["+"
                                                                        "0.0-927"]]},
                         "special/catch" {:ns "special",
                                          :name "catch",
                                          :signature ["[protoname name expr*]"],
                                          :history [["+" "0.0-927"]],
                                          :type "special form",
                                          :full-name-encode "special_catch",
                                          :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (list? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                                   :filename "clojurescript/src/clj/cljs/core.clj",
                                                   :lines [470 498],
                                                   :link "https://github.com/clojure/clojurescript/blob/r927/src/clj/cljs/core.clj#L470-L498"},
                                          :full-name "special/catch",
                                          :clj-symbol "clojure.core/catch",
                                          :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions."},
                         "cljs.core/reverse" {:ns "cljs.core",
                                              :name "reverse",
                                              :signature ["[coll]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_reverse",
                                              :source {:code "(defn reverse\n  [coll]\n  (reduce conj () coll))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1149
                                                               1152],
                                                       :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L1149-L1152"},
                                              :full-name "cljs.core/reverse",
                                              :clj-symbol "clojure.core/reverse",
                                              :docstring "Returns a seq of the items in coll in reverse order. Not lazy."},
                         "cljs.core/realized?" {:ns "cljs.core",
                                                :name "realized?",
                                                :signature ["[d]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_realized_QMARK_",
                                                :source {:code "(defn realized?\n  [d]\n  (-realized? d))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [3166
                                                                 3169],
                                                         :link "https://github.com/clojure/clojurescript/blob/r927/src/cljs/cljs/core.cljs#L3166-L3169"},
                                                :full-name "cljs.core/realized?",
                                                :clj-symbol "clojure.core/realized?",
                                                :docstring "Returns true if a value has been produced for a promise, delay, future or lazy sequence."}},
               :changes [{:cljs-version "0.0-927",
                          :cljs-date "2012-01-18",
                          :clj-version "1.3.0",
                          :gclosure-lib "20110323-r790",
                          :added #{"cljs.core/keys"
                                   "cljs.core/reset!"
                                   "clojure.set/select"
                                   "cljs.core/delay"
                                   "cljs.core/bit-not"
                                   "cljs.core/partition"
                                   "cljs.core/parents"
                                   "cljs.core/aclone"
                                   "cljs.core/reset-meta!"
                                   "special/defrecord*"
                                   "cljs.reader/dispatch-macros"
                                   "cljs.core/ICollection"
                                   "cljs.core/every?"
                                   "clojure.zip/node"
                                   "cljs.core/IEmptyableCollection"
                                   "clojure.zip/right"
                                   "cljs.core/=="
                                   "special/."
                                   "clojure.browser.net/*timeout*"
                                   "cljs.core/remove-method"
                                   "cljs.core/frequencies"
                                   "cljs.core/pop"
                                   "cljs.core/not-every?"
                                   "cljs.core/some-fn"
                                   "clojure.browser.event/remove-all"
                                   "cljs.core/doto"
                                   "cljs.core/take-while"
                                   "cljs.reader/escape-char-map"
                                   "clojure.browser.event/all-listeners"
                                   "cljs.core/vals"
                                   "cljs.core/IDeref"
                                   "clojure.browser.dom/log-obj"
                                   "cljs.core/for"
                                   "cljs.core/instance?"
                                   "cljs.reader/read-comment"
                                   "cljs.reader/read-number"
                                   "cljs.core/ILookup"
                                   "cljs.core/when"
                                   "clojure.browser.dom/set-value"
                                   "cljs.reader/read-past"
                                   "cljs.core/to-array"
                                   "cljs.core/interpose"
                                   "clojure.browser.net/ICrossPageChannel"
                                   "special/finally"
                                   "cljs.core/Cons"
                                   "cljs.core/re-find"
                                   "cljs.core/IMeta"
                                   "cljs.core/assoc-in"
                                   "clojure.string/join"
                                   "clojure.zip/rights"
                                   "cljs.core/split-at"
                                   "clojure.zip/append-child"
                                   "cljs.core/binding"
                                   "cljs.core/Set"
                                   "cljs.reader/macro-terminating?"
                                   "cljs.core/prefers"
                                   "cljs.core/vary-meta"
                                   "cljs.core/when-let"
                                   "cljs.core/drop"
                                   "cljs.core/while"
                                   "cljs.core/import-macros"
                                   "cljs.core/string-print"
                                   "cljs.core/-"
                                   "clojure.zip/vector-zip"
                                   "cljs.core/js->clj"
                                   "cljs.core/List"
                                   "cljs.core/identical?"
                                   "cljs.core/*main-cli-fn*"
                                   "clojure.browser.dom/html->dom"
                                   "cljs.core/some"
                                   "cljs.core/doall"
                                   "cljs.core/condp"
                                   "clojure.zip/down"
                                   "cljs.core/IPending"
                                   "cljs.core/count"
                                   "cljs.core/bit-test"
                                   "cljs.core/fixture2"
                                   "cljs.core/loop"
                                   "cljs.core/subvec"
                                   "cljs.core/bit-clear"
                                   "cljs.core/gensym"
                                   "special/recur"
                                   "cljs.core/+"
                                   "cljs.core/comp"
                                   "cljs.reader/desugar-meta"
                                   "cljs.core/pr"
                                   "clojure.string/upper-case"
                                   "clojure.browser.event/expose"
                                   "clojure.browser.event/listen-once"
                                   "cljs.core/empty?"
                                   "cljs.core/newline"
                                   "cljs.core/replace"
                                   "cljs.core/rand"
                                   "cljs.core/add-watch"
                                   "clojure.string/capitalize"
                                   "cljs.core/replicate"
                                   "special/do"
                                   "cljs.core/sequential?"
                                   "cljs.core/underive"
                                   "cljs.core/get-method"
                                   "cljs.core/="
                                   "cljs.core/defn-"
                                   "cljs.reader/read-symbol"
                                   "cljs.reader/push-back-reader"
                                   "cljs.core/deftype"
                                   "cljs.core/Subvec"
                                   "special/ns"
                                   "cljs.core/extend-protocol"
                                   "cljs.reader/read"
                                   "cljs.core/EmptyList"
                                   "clojure.walk/postwalk"
                                   "clojure.zip/edit"
                                   "cljs.core/re-seq"
                                   "cljs.reader/read-list"
                                   "cljs.core/Atom"
                                   "cljs.core/IMap"
                                   "cljs.reader/read-vector"
                                   "clojure.set/join"
                                   "cljs.core/HashMap"
                                   "cljs.reader/int-pattern"
                                   "cljs.core/swap!"
                                   "cljs.core/dec"
                                   "clojure.browser.dom/remove-children"
                                   "cljs.core/get-validator"
                                   "cljs.core/coll?"
                                   "cljs.core/bit-or"
                                   "cljs.core/nfirst"
                                   "cljs.core/keep"
                                   "cljs.core/take"
                                   "cljs.core/cond"
                                   "cljs.core/bit-and"
                                   "clojure.browser.event/unique-event-id"
                                   "clojure.set/project"
                                   "special/js*"
                                   "clojure.string/trim-newline"
                                   "specialrepl/in-ns"
                                   "special/let*"
                                   "special/throw"
                                   "clojure.zip/insert-left"
                                   "cljs.core/true?"
                                   "clojure.browser.net/xpc-connection"
                                   "cljs.core/not"
                                   "cljs.core/js-obj"
                                   "cljs.core/complement"
                                   "cljs.core/spread"
                                   "cljs.core/keyword"
                                   "cljs.core/sort"
                                   "clojure.string/trim"
                                   "cljs.core/meta"
                                   "cljs.core/time"
                                   "cljs.core/boolean"
                                   "cljs.reader/read-token"
                                   "cljs.core/update-in"
                                   "cljs.core/map-indexed"
                                   "cljs.core/IStack"
                                   "cljs.core/IIndexed"
                                   "clojure.browser.repl/repl-print"
                                   "clojure.browser.net/xpc-config-fields"
                                   "cljs.core/nnext"
                                   "cljs.core/*print-meta*"
                                   "cljs.reader/read-dispatch"
                                   "cljs.core/distinct"
                                   "cljs.reader/wrapping-reader"
                                   "cljs.core/prn"
                                   "clojure.zip/leftmost"
                                   "cljs.core/>="
                                   "cljs.reader/macros"
                                   "cljs.core/doseq"
                                   "cljs.core/*"
                                   "cljs.core/into"
                                   "cljs.core/defmethod"
                                   "cljs.core/rest"
                                   "cljs.core/dotimes"
                                   "clojure.zip/lefts"
                                   "clojure.browser.dom/ensure-element"
                                   "cljs.core/defmacro"
                                   "cljs.core/remove"
                                   "cljs.core/if-not"
                                   "clojure.zip/path"
                                   "cljs.core/mapcat"
                                   "cljs.core/IWatchable"
                                   "clojure.zip/rightmost"
                                   "cljs.core/->"
                                   "cljs.core/remove-all-methods"
                                   "clojure.string/replace-first"
                                   "clojure.browser.dom/get-value"
                                   "cljs.nodejs/process"
                                   "cljs.core/not="
                                   "cljs.core/js-keys"
                                   "clojure.zip/seq-zip"
                                   "cljs.core/IVector"
                                   "cljs.core/empty"
                                   "cljs.core/re-matches"
                                   "clojure.browser.dom/DOMBuilder"
                                   "cljs.core/fixture1"
                                   "cljs.core/extend-type"
                                   "cljs.core/ISeqable"
                                   "cljs.core/assoc"
                                   "clojure.browser.repl/xpc-connection"
                                   "cljs.core/IDerefWithTimeout"
                                   "clojure.browser.repl/start-evaluator"
                                   "clojure.browser.event/unlisten"
                                   "cljs.core/fnil"
                                   "cljs.core/this-as"
                                   "cljs.core/PersistentQueueSeq"
                                   "cljs.core/counted?"
                                   "clojure.string/trimr"
                                   "cljs.core/force"
                                   "cljs.core/compare-and-set!"
                                   "cljs.core/set?"
                                   "clojure.string/escape"
                                   "cljs.core/remove-watch"
                                   "cljs.core/IMultiFn"
                                   "clojure.zip/end?"
                                   "clojure.set/superset?"
                                   "clojure.browser.net/IConnection"
                                   "cljs.core/let"
                                   "cljs.core/dorun"
                                   "cljs.core/pr-str"
                                   "cljs.core/IPrintable"
                                   "cljs.core/defprotocol"
                                   "cljs.core/assert"
                                   "cljs.core/declare"
                                   "cljs.core/fn?"
                                   "cljs.core/associative?"
                                   "cljs.core/list*"
                                   "cljs.core/reduce"
                                   "clojure.browser.event/has-listener"
                                   "cljs.core/compare"
                                   "cljs.core/contains?"
                                   "cljs.core/prefer-method"
                                   "cljs.core/array-seq"
                                   "cljs.core/PersistentQueue"
                                   "cljs.core/drop-last"
                                   "cljs.reader/read-string"
                                   "cljs.core/vector?"
                                   "cljs.core/defmulti"
                                   "clojure.browser.event/dispatch-event"
                                   "clojure.string/split-lines"
                                   "cljs.core/areduce"
                                   "cljs.core/disj"
                                   "clojure.browser.net/event-types"
                                   "clojure.string/lower-case"
                                   "cljs.core/*print-fn*"
                                   "cljs.core/str"
                                   "cljs.core/ISequential"
                                   "cljs.core/set"
                                   "special/def"
                                   "cljs.core/print"
                                   "clojure.string/blank?"
                                   "clojure.browser.dom/append"
                                   "cljs.core/take-last"
                                   "clojure.set/intersection"
                                   "cljs.core/fnext"
                                   "cljs.core/apply"
                                   "clojure.walk/prewalk"
                                   "cljs.core/flatten"
                                   "cljs.core/get"
                                   "cljs.core/.."
                                   "cljs.core/Range"
                                   "cljs.core/zero?"
                                   "cljs.core/identity"
                                   "cljs.core/first"
                                   "cljs.reader/ratio-pattern"
                                   "cljs.core/>"
                                   "cljs.core/juxt"
                                   "cljs.core/max"
                                   "cljs.core/*3"
                                   "cljs.core/number?"
                                   "cljs.core/array"
                                   "cljs.core/nthnext"
                                   "cljs.core/re-pattern"
                                   "cljs.core/missing-protocol"
                                   "clojure.browser.dom/set-text"
                                   "clojure.zip/up"
                                   "cljs.core/IWithMeta"
                                   "cljs.core/bit-and-not"
                                   "clojure.string/triml"
                                   "clojure.string/split"
                                   "cljs.core/hash-map"
                                   "cljs.core/rem"
                                   "cljs.core/IRecord"
                                   "cljs.core/constantly"
                                   "clojure.browser.dom/get-element"
                                   "cljs.core/and"
                                   "clojure.browser.repl/wrap-message"
                                   "clojure.browser.event/unlisten-by-key"
                                   "cljs.core/try"
                                   "cljs.core/iterate"
                                   "cljs.core/lazy-seq"
                                   "specialrepl/load-file"
                                   "cljs.core/IndexedSeq"
                                   "cljs.core/next"
                                   "cljs.core/*print-readably*"
                                   "cljs.core/last"
                                   "cljs.core/bit-shift-left"
                                   "clojure.string/reverse"
                                   "cljs.core/min"
                                   "cljs.reader/escape-char"
                                   "cljs.reader/read-map"
                                   "cljs.core/seq"
                                   "cljs.core/not-empty"
                                   "cljs.core/println"
                                   "clojure.browser.repl/connect"
                                   "clojure.browser.dom/insert-at"
                                   "cljs.core/quot"
                                   "clojure.browser.event/get-listener"
                                   "cljs.core/filter"
                                   "clojure.zip/branch?"
                                   "special/if"
                                   "cljs.core/ObjMap"
                                   "cljs.core/zipmap"
                                   "cljs.core/hash-combine"
                                   "cljs.core/max-key"
                                   "clojure.zip/insert-child"
                                   "cljs.core/defrecord"
                                   "cljs.core/butlast"
                                   "cljs.core/hash"
                                   "cljs.core/bit-set"
                                   "cljs.core/concat"
                                   "cljs.core/conj"
                                   "clojure.set/difference"
                                   "cljs.core/when-first"
                                   "cljs.core/distinct?"
                                   "cljs.core/pos?"
                                   "cljs.core/IHash"
                                   "cljs.core/is_proto_"
                                   "cljs.core/keep-indexed"
                                   "cljs.core/bit-shift-right"
                                   "clojure.zip/insert-right"
                                   "cljs.core/make-hierarchy"
                                   "cljs.core/repeat"
                                   "cljs.core/MultiFn"
                                   "cljs.core/not-any?"
                                   "cljs.reader/read-regex"
                                   "clojure.zip/next"
                                   "cljs.core/aget"
                                   "cljs.core/if-let"
                                   "cljs.core//"
                                   "cljs.core/min-key"
                                   "clojure.zip/root"
                                   "cljs.core/drop-while"
                                   "clojure.browser.repl/evaluate-javascript"
                                   "cljs.core/set-validator!"
                                   "cljs.core/<"
                                   "cljs.core/fn"
                                   "cljs.core/split-with"
                                   "cljs.core/IReduce"
                                   "cljs.reader/symbol-pattern"
                                   "cljs.core/repeatedly"
                                   "cljs.reader/read-delimited-list"
                                   "cljs.core/undefined?"
                                   "clojure.zip/prev"
                                   "cljs.core/seq?"
                                   "cljs.core/odd?"
                                   "cljs.core/cons"
                                   "special/deftype*"
                                   "cljs.reader/read-set"
                                   "cljs.core/descendants"
                                   "special/new"
                                   "cljs.core/take-nth"
                                   "cljs.reader/throwing-reader"
                                   "cljs.core/even?"
                                   "special/fn*"
                                   "clojure.set/subset?"
                                   "cljs.core/flush"
                                   "cljs.reader/reader-error"
                                   "clojure.walk/prewalk-replace"
                                   "cljs.core/*1"
                                   "cljs.reader/read-unicode-char"
                                   "cljs.core/dissoc"
                                   "cljs.core/ffirst"
                                   "clojure.zip/replace"
                                   "cljs.core/vec"
                                   "cljs.core/or"
                                   "cljs.core/mod"
                                   "cljs.core/aset"
                                   "cljs.core/second"
                                   "clojure.set/rename"
                                   "cljs.core/delay?"
                                   "clojure.zip/left"
                                   "cljs.reader/not-implemented"
                                   "cljs.core/IAssociative"
                                   "cljs.core/group-by"
                                   "cljs.core/symbol"
                                   "cljs.core/Delay"
                                   "cljs.core/methods"
                                   "cljs.core/vector"
                                   "cljs.core/rand-int"
                                   "cljs.core/letfn"
                                   "cljs.reader/read-discard"
                                   "cljs.core/inc"
                                   "cljs.core/name"
                                   "cljs.core/cycle"
                                   "cljs.core/map"
                                   "cljs.core/amap"
                                   "clojure.zip/children"
                                   "special/set!"
                                   "cljs.core/when-not"
                                   "clojure.set/index"
                                   "clojure.browser.dom/log"
                                   "cljs.core/partition-by"
                                   "cljs.core/sort-by"
                                   "cljs.core/with-meta"
                                   "cljs.core/NeverEquiv"
                                   "cljs.core/select-keys"
                                   "special/loop*"
                                   "cljs.core/ISeq"
                                   "clojure.walk/postwalk-replace"
                                   "cljs.core/pr-with-opts"
                                   "cljs.core/->>"
                                   "cljs.core/nil?"
                                   "clojure.walk/stringify-keys"
                                   "clojure.browser.repl/order"
                                   "cljs.core/memoize"
                                   "cljs.core/pr-sequential"
                                   "clojure.zip/make-node"
                                   "specialrepl/load-namespace"
                                   "cljs.reader/float-pattern"
                                   "cljs.core/ancestors"
                                   "cljs.core/integer?"
                                   "clojure.zip/xml-zip"
                                   "clojure.walk/walk"
                                   "cljs.core/bit-xor"
                                   "clojure.set/union"
                                   "cljs.reader/PushbackReader"
                                   "cljs.core/isa?"
                                   "clojure.browser.net/xhr-connection"
                                   "cljs.core/subs"
                                   "cljs.core/symbol?"
                                   "clojure.string/replace"
                                   "cljs.core/string?"
                                   "cljs.core/partition-all"
                                   "cljs.core/merge-with"
                                   "clojure.browser.dom/set-properties"
                                   "cljs.core/trampoline"
                                   "clojure.browser.repl/send-print"
                                   "cljs.core/ICounted"
                                   "cljs.core/IEquiv"
                                   "cljs.core/js-delete"
                                   "cljs.core/comment"
                                   "cljs.reader/special-symbols"
                                   "cljs.core/alength"
                                   "special/quote"
                                   "cljs.core/tree-seq"
                                   "cljs.reader/read-unmatched-delimiter"
                                   "cljs.core/every-pred"
                                   "clojure.set/rename-keys"
                                   "cljs.core/peek"
                                   "cljs.core/pr-str-with-opts"
                                   "cljs.core/map?"
                                   "cljs.reader/StringPushbackReader"
                                   "cljs.core/deref"
                                   "cljs.core/reductions"
                                   "cljs.core/false?"
                                   "cljs.core/bit-flip"
                                   "cljs.core/ISet"
                                   "cljs.core/LazySeq"
                                   "cljs.core/*2"
                                   "clojure.browser.event/total-listener-count"
                                   "cljs.core/alter-meta!"
                                   "clojure.browser.dom/click-element"
                                   "cljs.reader/read-meta"
                                   "special/try*"
                                   "cljs.core/range"
                                   "cljs.core/reify"
                                   "cljs.core/satisfies?"
                                   "cljs.core/nth"
                                   "cljs.core/list"
                                   "cljs.core/defn"
                                   "cljs.core/rand-nth"
                                   "cljs.core/atom"
                                   "cljs.reader/read-keyword"
                                   "cljs.core/Vector"
                                   "cljs.reader/skip-line"
                                   "cljs.core/namespace"
                                   "cljs.nodejs/require"
                                   "clojure.browser.event/EventType"
                                   "cljs.core/merge"
                                   "clojure.browser.repl/send-result"
                                   "clojure.walk/keywordize-keys"
                                   "cljs.core/derive"
                                   "clojure.zip/zipper"
                                   "clojure.zip/remove"
                                   "cljs.core/find"
                                   "cljs.core/*print-dup*"
                                   "cljs.core/partial"
                                   "cljs.core/keyword?"
                                   "clojure.browser.event/fire-listeners"
                                   "cljs.core/interleave"
                                   "cljs.core/*flush-on-newline*"
                                   "cljs.core/get-in"
                                   "clojure.browser.dom/element"
                                   "cljs.core/prim-seq"
                                   "cljs.core/<="
                                   "clojure.set/map-invert"
                                   "clojure.browser.event/listen"
                                   "cljs.core/neg?"
                                   "clojure.browser.dom/replace-node"
                                   "special/catch"
                                   "cljs.core/reverse"
                                   "cljs.core/realized?"}}]},
 :compiler-api {:symbols {},
                :changes [{:cljs-version "0.0-927",
                           :cljs-date "2012-01-18",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}]}}
