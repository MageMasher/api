{:release {:cljs-version "0.0-1011",
           :cljs-tag "r1011",
           :cljs-date "2012-03-31",
           :clj-version "1.3.0",
           :clj-tag "clojure-1.3.0",
           :gclosure-lib "20110323-r790"},
 :clj-not-cljs #{"clojure.core/conj!"
                 "clojure.core/the-ns"
                 "clojure.core/create-struct"
                 "clojure.data/diff-similar"
                 "clojure.data/EqualityPartition"
                 "clojure.core/*in*"
                 "clojure.core/unchecked-subtract-int"
                 "clojure.main/demunge"
                 "clojure.core/release-pending-sends"
                 "clojure.reflect/flag-descriptors"
                 "clojure.core/shorts"
                 "clojure.core/shutdown-agents"
                 "clojure.core/restart-agent"
                 "clojure.java.io/input-stream"
                 "clojure.stacktrace/print-cause-trace"
                 "clojure.test/use-fixtures"
                 "clojure.java.io/file"
                 "clojure.test/*load-tests*"
                 "clojure.test/deftest-"
                 "clojure.core/unchecked-add"
                 "clojure.core/assoc!"
                 "clojure.core/doubles"
                 "clojure.inspector/inspect-tree"
                 "clojure.core/remove-ns"
                 "clojure.core/unchecked-byte"
                 "clojure.repl/thread-stopper"
                 "clojure.core/+'"
                 "clojure.core/rationalize"
                 "clojure.main/repl"
                 "clojure.pprint/simple-dispatch"
                 "clojure.repl/dir-fn"
                 "clojure.pprint/write-out"
                 "clojure.core/proxy-super"
                 "clojure.core/unchecked-divide-int"
                 "clojure.core/refer"
                 "clojure.repl/apropos"
                 "clojure.stacktrace/print-trace-element"
                 "clojure.core/future-call"
                 "clojure.core/persistent!"
                 "clojure.pprint/print-table"
                 "clojure.core/var?"
                 "clojure.core.protocols/InternalReduce"
                 "clojure.core/loaded-libs"
                 "clojure.core/commute"
                 "clojure.core/agent-errors"
                 "clojure.main/repl-caught"
                 "clojure.core/printf"
                 "clojure.core/ArrayChunk"
                 "clojure.pprint/*print-base*"
                 "clojure.core/into-array"
                 "clojure.core/load-string"
                 "clojure.core/pmap"
                 "clojure.test/file-position"
                 "clojure.core/double-array"
                 "clojure.core/float"
                 "clojure.test/do-report"
                 "clojure.core/send"
                 "clojure.core/unchecked-float"
                 "clojure.test/testing"
                 "clojure.core/ref-history-count"
                 "clojure.core/iterator-seq"
                 "clojure.pprint/pprint-indent"
                 "clojure.core/find-var"
                 "clojure.core/defstruct"
                 "clojure.core/-'"
                 "clojure.core/agent-error"
                 "clojure.core/ns-refers"
                 "clojure.core/num"
                 "clojure.core/*clojure-version*"
                 "clojure.reflect/do-reflect"
                 "clojure.core/future-cancelled?"
                 "clojure.core/unchecked-short"
                 "clojure.java.io/make-writer"
                 "clojure.test/test-var"
                 "clojure.stacktrace/print-stack-trace"
                 "clojure.core/sorted-map"
                 "clojure.core/init-proxy"
                 "clojure.core/unchecked-inc-int"
                 "clojure.walk/postwalk-demo"
                 "clojure.core/read-line"
                 "clojure.core/alter-var-root"
                 "clojure.core/bases"
                 "clojure.core/ints"
                 "clojure.repl/source-fn"
                 "clojure.core/class"
                 "clojure.reflect/ClassResolver"
                 "clojure.reflect/type-reflect"
                 "clojure.test/testing-contexts-str"
                 "clojure.core/byte-array"
                 "clojure.pprint/print-length-loop"
                 "clojure.test/join-fixtures"
                 "clojure.java.shell/with-sh-dir"
                 "clojure.test/run-tests"
                 "clojure.core/short"
                 "clojure.core/unchecked-dec-int"
                 "clojure.core/unchecked-subtract"
                 "clojure.core/sorted-map-by"
                 "clojure.core/*err*"
                 "clojure.pprint/*print-pretty*"
                 "clojure.test/successful?"
                 "clojure.core/await"
                 "clojure.test/testing-vars-str"
                 "clojure.core/supers"
                 "clojure.test/is"
                 "clojure.reflect/Field"
                 "clojure.core/sorted?"
                 "clojure.core/vector-of"
                 "clojure.core/accessor"
                 "clojure.inspector/inspect-table"
                 "clojure.core/class?"
                 "clojure.core/ns-map"
                 "clojure.core/unchecked-negate"
                 "clojure.java.io/make-output-stream"
                 "clojure.core/import"
                 "clojure.pprint/fresh-line"
                 "clojure.core/aset-boolean"
                 "clojure.reflect/typename"
                 "clojure.walk/prewalk-demo"
                 "clojure.core/require"
                 "clojure.pprint/pprint-tab"
                 "clojure.core/case"
                 "clojure.reflect/reflect"
                 "clojure.core/with-bindings"
                 "clojure.core/sync"
                 "clojure.pprint/pprint-logical-block"
                 "clojure.java.javadoc/javadoc"
                 "clojure.repl/find-doc"
                 "clojure.core/ref-set"
                 "clojure.core/booleans"
                 "clojure.test/run-all-tests"
                 "clojure.test.tap/with-tap-output"
                 "clojure.core/*print-length*"
                 "clojure.java.io/copy"
                 "clojure.pprint/write"
                 "clojure.core/transient"
                 "clojure.core/with-redefs"
                 "clojure.core/use"
                 "clojure.test.junit/with-junit-output"
                 "clojure.pprint/*print-right-margin*"
                 "clojure.core/future?"
                 "clojure.core/proxy-mappings"
                 "clojure.core/*read-eval*"
                 "clojure.template/do-template"
                 "clojure.core/spit"
                 "clojure.core/Vec"
                 "clojure.core/longs"
                 "clojure.core/monitor-enter"
                 "clojure.core/alter"
                 "clojure.core/bytes"
                 "clojure.core/char?"
                 "clojure.java.io/resource"
                 "clojure.repl/root-cause"
                 "clojure.core/inc'"
                 "clojure.pprint/formatter"
                 "clojure.java.io/make-parents"
                 "clojure.core/ref-min-history"
                 "clojure.core/get-proxy-class"
                 "clojure.core/memfn"
                 "clojure.core/aset-double"
                 "clojure.pprint/formatter-out"
                 "clojure.pprint/*print-miser-width*"
                 "clojure.test/set-test"
                 "clojure.core/ref"
                 "clojure.core/future-cancel"
                 "clojure.core/nthrest"
                 "clojure.core/with-local-vars"
                 "clojure.core/agent"
                 "clojure.core/ns-name"
                 "clojure.pprint/pprint-newline"
                 "clojure.core/bean"
                 "clojure.test/compose-fixtures"
                 "clojure.core/aset-float"
                 "clojure.core/*file*"
                 "clojure.core/*out*"
                 "clojure.core/clojure-version"
                 "clojure.core/sorted-set-by"
                 "clojure.core/with-in-str"
                 "clojure.core/test"
                 "clojure.core/list?"
                 "clojure.repl/pst"
                 "clojure.xml/parse"
                 "clojure.core/with-bindings*"
                 "clojure.test/test-ns"
                 "clojure.test/assert-predicate"
                 "clojure.core/to-array-2d"
                 "clojure.core/update-proxy"
                 "clojure.java.io/make-input-stream"
                 "clojure.core/reversible?"
                 "clojure.core/promise"
                 "clojure.core/*compile-files*"
                 "clojure.core/pop!"
                 "clojure.pprint/set-pprint-dispatch"
                 "clojure.core/float?"
                 "clojure.core/eval"
                 "clojure.core/*compile-path*"
                 "clojure.core/gen-class"
                 "clojure.core/macroexpand-1"
                 "clojure.test.tap/print-tap-diagnostic"
                 "clojure.core/find-keyword"
                 "clojure.core/bound-fn*"
                 "clojure.core/find-ns"
                 "clojure.core/unchecked-double"
                 "clojure.reflect/Constructor"
                 "clojure.test/*stack-trace-depth*"
                 "clojure.core/array-map"
                 "clojure.reflect/resolve-class"
                 "clojure.java.io/as-file"
                 "clojure.core/dissoc!"
                 "clojure.core/ns-aliases"
                 "clojure.main/stack-element-str"
                 "clojure.core/extend"
                 "clojure.core/char-name-string"
                 "clojure.reflect/JavaReflector"
                 "clojure.inspector/inspect"
                 "clojure.core/shuffle"
                 "clojure.core/*e"
                 "clojure.core/defonce"
                 "clojure.core/unchecked-inc"
                 "clojure.core/create-ns"
                 "clojure.core/hash-set"
                 "clojure.repl/doc"
                 "clojure.core/aset-int"
                 "clojure.test/test-all-vars"
                 "clojure.stacktrace/print-throwable"
                 "clojure.pprint/*print-suppress-namespaces*"
                 "clojure.pprint/code-dispatch"
                 "clojure.pprint/*print-radix*"
                 "clojure.main/repl-prompt"
                 "clojure.core/int-array"
                 "clojure.test/with-test"
                 "clojure.core/unchecked-remainder-int"
                 "clojure.pprint/pp"
                 "clojure.core/struct-map"
                 "clojure.core/val"
                 "clojure.template/apply-template"
                 "clojure.core/cast"
                 "clojure.core/load"
                 "clojure.java.shell/with-sh-env"
                 "clojure.main/repl-read"
                 "clojure.core/io!"
                 "clojure.repl/dir"
                 "clojure.core/char"
                 "clojure.core/ensure"
                 "clojure.core/*print-level*"
                 "clojure.core/re-groups"
                 "clojure.core/pvalues"
                 "clojure.core/ifn?"
                 "clojure.core/deliver"
                 "clojure.main/load-script"
                 "clojure.core/numerator"
                 "clojure.core/VecNode"
                 "clojure.core/VecSeq"
                 "clojure.core/var-get"
                 "clojure.core/clear-agent-errors"
                 "clojure.core/var-set"
                 "clojure.core/slurp"
                 "clojure.core/make-array"
                 "clojure.core/bound-fn"
                 "clojure.core/special-symbol?"
                 "clojure.core/push-thread-bindings"
                 "clojure.core/*unchecked-math*"
                 "clojure.core/aset-short"
                 "clojure.java.io/make-reader"
                 "clojure.core/ns-resolve"
                 "clojure.core/long"
                 "clojure.core/locking"
                 "clojure.core/char-array"
                 "clojure.stacktrace/root-cause"
                 "clojure.core/ratio?"
                 "clojure.core/rational?"
                 "clojure.java.io/as-url"
                 "clojure.core/future"
                 "clojure.core/object-array"
                 "clojure.core/aset-byte"
                 "clojure.core/send-off"
                 "clojure.test/are"
                 "clojure.java.io/IOFactory"
                 "clojure.reflect/Method"
                 "clojure.core/float-array"
                 "clojure.core/rseq"
                 "clojure.core/thread-bound?"
                 "clojure.core/with-precision"
                 "clojure.core/proxy"
                 "clojure.core/macroexpand"
                 "clojure.core/floats"
                 "clojure.core/aset-char"
                 "clojure.java.io/output-stream"
                 "clojure.test/inc-report-counter"
                 "clojure.java.io/delete-file"
                 "clojure.core/compile"
                 "clojure.repl/stack-element-str"
                 "clojure.core/sorted-set"
                 "clojure.core/resolve"
                 "clojure.core/xml-seq"
                 "clojure.test/with-test-out"
                 "clojure.core/lazy-cat"
                 "clojure.core/file-seq"
                 "clojure.core/ns-interns"
                 "clojure.core/short-array"
                 "clojure.core/future-done?"
                 "clojure.core/comparator"
                 "clojure.core/get-thread-bindings"
                 "clojure.core/var"
                 "clojure.stacktrace/e"
                 "clojure.core/unchecked-add-int"
                 "clojure.pprint/cl-format"
                 "clojure.core/ns-unmap"
                 "clojure.core/struct"
                 "clojure.repl/set-break-handler!"
                 "clojure.core/&"
                 "clojure.java.javadoc/add-remote-javadoc"
                 "clojure.test.tap/print-tap-pass"
                 "clojure.main/root-cause"
                 "clojure.core/extenders"
                 "clojure.core/key"
                 "clojure.core/construct-proxy"
                 "clojure.core/intern"
                 "clojure.pprint/with-pprint-dispatch"
                 "clojure.core/unchecked-int"
                 "clojure.core/error-mode"
                 "clojure.core/subseq"
                 "clojure.core/all-ns"
                 "clojure.walk/macroexpand-all"
                 "clojure.core/*ns*"
                 "clojure.core/char-escape-string"
                 "clojure.repl/demunge"
                 "clojure.core/line-seq"
                 "clojure.core/disj!"
                 "clojure.core/enumeration-seq"
                 "clojure.core/bigdec"
                 "clojure.java.javadoc/add-local-javadoc"
                 "clojure.core/decimal?"
                 "clojure.core/pcalls"
                 "clojure.core/with-out-str"
                 "clojure.core/long-array"
                 "clojure.core/ns-unalias"
                 "clojure.core/double"
                 "clojure.core/error-handler"
                 "clojure.core/biginteger"
                 "clojure.pprint/get-pretty-writer"
                 "clojure.core/ref-max-history"
                 "clojure.reflect/TypeReference"
                 "clojure.test/function?"
                 "clojure.data/Diff"
                 "clojure.pprint/pprint"
                 "clojure.test/deftest"
                 "clojure.core/unchecked-negate-int"
                 "clojure.core/definline"
                 "clojure.core/namespace-munge"
                 "clojure.core/pop-thread-bindings"
                 "clojure.data/diff"
                 "clojure.main/main"
                 "clojure.core/unchecked-multiply"
                 "clojure.core/ns-imports"
                 "clojure.core/aset-long"
                 "clojure.core/dosync"
                 "clojure.core/chars"
                 "clojure.core/*'"
                 "clojure.core/seque"
                 "clojure.test/try-expr"
                 "clojure.main/skip-whitespace"
                 "clojure.main/with-bindings"
                 "clojure.core/load-reader"
                 "clojure.core/await-for"
                 "clojure.test.tap/print-tap-plan"
                 "clojure.core/*command-line-args*"
                 "clojure.test/report"
                 "clojure.core/unchecked-char"
                 "clojure.java.browse/browse-url"
                 "clojure.core/monitor-exit"
                 "clojure.core/re-matcher"
                 "clojure.java.io/as-relative-path"
                 "clojure.test/assert-any"
                 "clojure.core/gen-interface"
                 "clojure.core/with-redefs-fn"
                 "clojure.core/extends?"
                 "clojure.java.io/Coercions"
                 "clojure.core/set-error-mode!"
                 "clojure.core/format"
                 "clojure.core/int"
                 "clojure.core/*agent*"
                 "clojure.core/alias"
                 "clojure.core/ns-publics"
                 "clojure.core/bound?"
                 "clojure.java.io/writer"
                 "clojure.pprint/*print-pprint-dispatch*"
                 "clojure.core/with-open"
                 "clojure.core/set-error-handler!"
                 "clojure.repl/source"
                 "clojure.java.shell/sh"
                 "clojure.core/byte"
                 "clojure.core/unchecked-dec"
                 "clojure.core/sequence"
                 "clojure.core/denominator"
                 "clojure.main/skip-if-eol"
                 "clojure.core/dec'"
                 "clojure.data/equality-partition"
                 "clojure.core/refer-clojure"
                 "clojure.core/unchecked-long"
                 "clojure.java.io/reader"
                 "clojure.reflect/Reflector"
                 "clojure.main/repl-exception"
                 "clojure.test.tap/print-tap-fail"
                 "clojure.core/bigint"
                 "clojure.core/resultset-seq"
                 "clojure.test/get-possibly-unbound-var"
                 "clojure.core/unchecked-multiply-int"
                 "clojure.core.protocols/internal-reduce"
                 "clojure.reflect/AsmReflector"
                 "clojure.core/boolean-array"
                 "clojure.core/add-classpath"
                 "clojure.core/*warn-on-reflection*"
                 "clojure.core/rsubseq"},
 :library-api {:symbols {"cljs.core/keys" {:ns "cljs.core",
                                           :name "keys",
                                           :signature ["[hash-map]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_keys",
                                           :source {:code "(defn keys\n  [hash-map]\n  (seq (map first hash-map)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2609 2612],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2609-L2612"},
                                           :full-name "cljs.core/keys",
                                           :clj-symbol "clojure.core/keys",
                                           :docstring "Returns a sequence of the map's keys."},
                         "cljs.core/reset!" {:ns "cljs.core",
                                             :name "reset!",
                                             :signature ["[a new-value]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_reset_BANG_",
                                             :source {:code "(defn reset!\n  [a new-value]\n  (when-let [validate (.-validator a)]\n    (assert (validate new-value) \"Validator rejected reference state\"))\n  (let [old-value (.-state a)]\n    (set! (.-state a) new-value)\n    (-notify-watches a old-value new-value))\n  new-value)",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [3277
                                                              3286],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3277-L3286"},
                                             :full-name "cljs.core/reset!",
                                             :clj-symbol "clojure.core/reset!",
                                             :docstring "Sets the value of atom to newval without regard for the\ncurrent value. Returns newval."},
                         "clojure.set/select" {:ns "clojure.set",
                                               :name "select",
                                               :signature ["[pred xset]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.set_select",
                                               :source {:code "(defn select\n  [pred xset]\n    (reduce (fn [s k] (if (pred k) s (disj s k)))\n            xset xset))",
                                                        :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                        :lines [61 65],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/set.cljs#L61-L65"},
                                               :full-name "clojure.set/select",
                                               :clj-symbol "clojure.set/select",
                                               :docstring "Returns a set of the elements for which pred is true"},
                         "cljs.core/delay" {:full-name "cljs.core/delay",
                                            :ns "cljs.core",
                                            :name "delay",
                                            :type "macro",
                                            :signature ["[& body]"],
                                            :source {:code "(defmacro delay [& body]\n  \"Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls.\"\n  `(new cljs.core.Delay (atom {:done false, :value nil}) (fn [] ~@body)))",
                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                     :lines [437 442],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L437-L442"},
                                            :full-name-encode "cljs.core_delay",
                                            :clj-symbol "clojure.core/delay",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/bit-not" {:ns "cljs.core",
                                              :name "bit-not",
                                              :signature ["[x]"],
                                              :shadowed-sources ({:code "(defmacro bit-not [x]\n  (list 'js* \"(~ ~{})\" x))",
                                                                  :filename "clojurescript/src/clj/cljs/core.clj",
                                                                  :lines [141
                                                                          142],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L141-L142"}),
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_bit-not",
                                              :source {:code "(defn bit-not\n  [x] (cljs.core/bit-not x))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [961
                                                               963],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L961-L963"},
                                              :full-name "cljs.core/bit-not",
                                              :clj-symbol "clojure.core/bit-not",
                                              :docstring "Bitwise complement"},
                         "cljs.core/partition" {:ns "cljs.core",
                                                :name "partition",
                                                :signature ["[n coll]"
                                                            "[n step coll]"
                                                            "[n step pad coll]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_partition",
                                                :source {:code "(defn partition\n  ([n coll]\n     (partition n n coll))\n  ([n step coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (when (= n (count p))\n             (cons p (partition n step (drop step s))))))))\n  ([n step pad coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (if (= n (count p))\n             (cons p (partition n step pad (drop step s)))\n             (list (take n (concat p pad)))))))))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1874
                                                                 1894],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1874-L1894"},
                                                :full-name "cljs.core/partition",
                                                :clj-symbol "clojure.core/partition",
                                                :docstring "Returns a lazy sequence of lists of n items each, at offsets step\napart. If step is not supplied, defaults to n, i.e. the partitions\ndo not overlap. If a pad collection is supplied, use its elements as\nnecessary to complete last partition upto n items. In case there are\nnot enough padding elements, return a partition with less than n items."},
                         "cljs.core/parents" {:ns "cljs.core",
                                              :name "parents",
                                              :signature ["[tag]"
                                                          "[h tag]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_parents",
                                              :source {:code "(defn parents\n  ([tag] (parents @global-hierarchy tag))\n  ([h tag] (not-empty (get (:parents h) tag))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [3534
                                                               3540],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3534-L3540"},
                                              :full-name "cljs.core/parents",
                                              :clj-symbol "clojure.core/parents",
                                              :docstring "Returns the immediate parents of tag, either via a Java type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
                         "cljs.core/aclone" {:ns "cljs.core",
                                             :name "aclone",
                                             :signature ["[array-like]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_aclone",
                                             :source {:code "(defn aclone\n  [array-like]\n  #_(goog.array.clone array-like)\n  (js* \"Array.prototype.slice.call(~{array-like})\"))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [65 69],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L65-L69"},
                                             :full-name "cljs.core/aclone",
                                             :clj-symbol "clojure.core/aclone",
                                             :docstring "Returns a javascript array, cloned from the passed in array"},
                         "cljs.core/reset-meta!" {:ns "cljs.core",
                                                  :name "reset-meta!",
                                                  :signature ["[iref m]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_reset-meta_BANG_",
                                                  :source {:code "(defn reset-meta!\n  [iref m]\n  (set! (.-meta iref) m))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [3344
                                                                   3347],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3344-L3347"},
                                                  :full-name "cljs.core/reset-meta!",
                                                  :clj-symbol "clojure.core/reset-meta!",
                                                  :docstring "Atomically resets the metadata for an atom"},
                         "special/defrecord*" {:full-name "special/defrecord*",
                                               :ns "special",
                                               :name "defrecord*",
                                               :type "special form",
                                               :source {:code "(defmethod parse 'defrecord*\n  [_ env [_ tsym fields] _]\n  (let [t (munge (:name (resolve-var (dissoc env :locals) tsym)))]\n    (swap! namespaces update-in [(-> env :ns :name) :defs tsym]\n           (fn [m]\n             (let [m (assoc (or m {}) :name t)]\n               (if-let [line (:line env)]\n                 (-> m\n                     (assoc :file *cljs-file*)\n                     (assoc :line line))\n                 m))))\n    {:env env :op :defrecord* :t t :fields fields}))",
                                                        :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                        :lines [901
                                                                912],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/compiler.clj#L901-L912"},
                                               :full-name-encode "special_defrecord_STAR_",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.reader/dispatch-macros" {:full-name "cljs.reader/dispatch-macros",
                                                        :ns "cljs.reader",
                                                        :name "dispatch-macros",
                                                        :type "var",
                                                        :source {:code "(def dispatch-macros\n  {\"{\" read-set\n   \"<\" (throwing-reader \"Unreadable form\")\n   \"\\\"\" read-regex\n   \"!\" read-comment\n   \"_\" read-discard})",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [331
                                                                         336],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L331-L336"},
                                                        :full-name-encode "cljs.reader_dispatch-macros",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/ICollection" {:ns "cljs.core",
                                                  :name "ICollection",
                                                  :type "protocol",
                                                  :full-name-encode "cljs.core_ICollection",
                                                  :source {:code "(defprotocol ICollection\n  (-conj [coll o]))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [124
                                                                   125],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L124-L125"},
                                                  :methods [{:name "-conj",
                                                             :signature ["[coll o]"],
                                                             :docstring nil}],
                                                  :full-name "cljs.core/ICollection",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/every?" {:ns "cljs.core",
                                             :name "every?",
                                             :signature ["[pred coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_every_QMARK_",
                                             :source {:code "(defn every?\n  [pred coll]\n  (cond\n   (nil? (seq coll)) true\n   (pred (first coll)) (recur pred (next coll))\n   :else false))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1446
                                                              1453],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1446-L1453"},
                                             :full-name "cljs.core/every?",
                                             :clj-symbol "clojure.core/every?",
                                             :docstring "Returns true if (pred x) is logical true for every x in coll, else\nfalse."},
                         "clojure.zip/node" {:ns "clojure.zip",
                                             :name "node",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_node",
                                             :source {:code "(defn node\n  [loc] (loc 0))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [60 62],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L60-L62"},
                                             :full-name "clojure.zip/node",
                                             :clj-symbol "clojure.zip/node",
                                             :docstring "Returns the node at loc"},
                         "cljs.core/IEmptyableCollection" {:ns "cljs.core",
                                                           :name "IEmptyableCollection",
                                                           :type "protocol",
                                                           :full-name-encode "cljs.core_IEmptyableCollection",
                                                           :source {:code "(defprotocol IEmptyableCollection\n  (-empty [coll]))",
                                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                    :lines [121
                                                                            122],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L121-L122"},
                                                           :methods [{:name "-empty",
                                                                      :signature ["[coll]"],
                                                                      :docstring nil}],
                                                           :full-name "cljs.core/IEmptyableCollection",
                                                           :history [["+"
                                                                      "0.0-927"]]},
                         "clojure.zip/right" {:ns "clojure.zip",
                                              :name "right",
                                              :signature ["[loc]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.zip_right",
                                              :source {:code "(defn right\n  [loc]\n    (let [[node {l :l  [r & rnext :as rs] :r :as path}] loc]\n      (when (and path rs)\n        (with-meta [r (assoc path :l (conj l node) :r rnext)] (meta loc)))))",
                                                       :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                       :lines [135
                                                               140],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L135-L140"},
                                              :full-name "clojure.zip/right",
                                              :clj-symbol "clojure.zip/right",
                                              :docstring "Returns the loc of the right sibling of the node at this loc, or nil"},
                         "cljs.core/==" {:ns "cljs.core",
                                         :name "==",
                                         :signature ["[x]"
                                                     "[x y]"
                                                     "[x y & more]"],
                                         :shadowed-sources ({:code "(defmacro ==\n  ([x] true)\n  ([x y] (list 'js* \"(~{} === ~{})\" x y))\n  ([x y & more] `(and (== ~x ~y) (== ~y ~@more))))",
                                                             :filename "clojurescript/src/clj/cljs/core.clj",
                                                             :lines [108
                                                                     111],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L108-L111"}),
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core__EQ__EQ_",
                                         :source {:code "(defn ==\n  ([x] true)\n  ([x y] (-equiv x y))\n  ([x y & more]\n   (if (== x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (== y (first more)))\n     false)))",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [983 993],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L983-L993"},
                                         :full-name "cljs.core/==",
                                         :clj-symbol "clojure.core/==",
                                         :docstring "Returns non-nil if nums all have the equivalent\nvalue (type-independent), otherwise false"},
                         "special/." {:full-name "special/.",
                                      :ns "special",
                                      :name ".",
                                      :type "special form",
                                      :source {:code "(defmethod parse '.\n  [_ env [_ target & [field & member+]] _]\n  (disallowing-recur\n   (let [{:keys [dot-action target method field args]} (build-dot-form [target field member+])\n         enve        (assoc env :context :expr)\n         targetexpr  (analyze enve target)\n         children    [enve]]\n     (case dot-action\n           ::access {:env env :op :dot :children children\n                     :target targetexpr\n                     :field field}\n           ::call   (let [argexprs (map #(analyze enve %) args)]\n                      {:env env :op :dot :children (into children argexprs)\n                       :target targetexpr\n                       :method method\n                       :args argexprs})))))",
                                               :filename "clojurescript/src/clj/cljs/compiler.clj",
                                               :lines [977 992],
                                               :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/compiler.clj#L977-L992"},
                                      :full-name-encode "special__DOT_",
                                      :clj-symbol "clojure.core/.",
                                      :history [["+" "0.0-927"]]},
                         "clojure.browser.net/*timeout*" {:full-name "clojure.browser.net/*timeout*",
                                                          :ns "clojure.browser.net",
                                                          :name "*timeout*",
                                                          :type "var",
                                                          :source {:code "(def *timeout* 10000)",
                                                                   :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                   :lines [21
                                                                           21],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/net.cljs#L21-L21"},
                                                          :full-name-encode "clojure.browser.net__STAR_timeout_STAR_",
                                                          :history [["+"
                                                                     "0.0-927"]]},
                         "cljs.core/remove-method" {:ns "cljs.core",
                                                    :name "remove-method",
                                                    :signature ["[multifn dispatch-val]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_remove-method",
                                                    :source {:code "(defn remove-method\n [multifn dispatch-val]\n (-remove-method multifn dispatch-val))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [3744
                                                                     3747],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3744-L3747"},
                                                    :full-name "cljs.core/remove-method",
                                                    :clj-symbol "clojure.core/remove-method",
                                                    :docstring "Removes the method of multimethod associated with dispatch-value."},
                         "cljs.core/frequencies" {:ns "cljs.core",
                                                  :name "frequencies",
                                                  :signature ["[coll]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_frequencies",
                                                  :source {:code "(defn frequencies\n  [coll]\n  (reduce\n   (fn [counts x]\n     (assoc counts x (inc (get counts x 0))))\n   {}\n   coll))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [2908
                                                                   2916],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2908-L2916"},
                                                  :full-name "cljs.core/frequencies",
                                                  :clj-symbol "clojure.core/frequencies",
                                                  :docstring "Returns a map from distinct items in coll to the number of times\nthey appear."},
                         "cljs.core/pop" {:ns "cljs.core",
                                          :name "pop",
                                          :signature ["[coll]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_pop",
                                          :source {:code "(defn pop\n  [coll]\n  (-pop coll))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [561 566],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L561-L566"},
                                          :full-name "cljs.core/pop",
                                          :clj-symbol "clojure.core/pop",
                                          :docstring "For a list or queue, returns a new list/queue without the first\nitem, for a vector, returns a new vector without the last item.\nNote - not the same as next/butlast."},
                         "cljs.core/not-every?" {:ns "cljs.core",
                                                 :name "not-every?",
                                                 :signature ["[pred coll]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_not-every_QMARK_",
                                                 :source {:code "(defn not-every?\n  [pred coll] (not (every? pred coll)))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [1455
                                                                  1458],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1455-L1458"},
                                                 :full-name "cljs.core/not-every?",
                                                 :clj-symbol "clojure.core/not-every?",
                                                 :docstring "Returns false if (pred x) is logical true for every x in\ncoll, else true."},
                         "cljs.core/some-fn" {:ns "cljs.core",
                                              :name "some-fn",
                                              :signature ["[p]"
                                                          "[p1 p2]"
                                                          "[p1 p2 p3]"
                                                          "[p1 p2 p3 & ps]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_some-fn",
                                              :source {:code "(defn some-fn\n  ([p]\n     (fn sp1\n       ([] nil)\n       ([x] (p x))\n       ([x y] (or (p x) (p y)))\n       ([x y z] (or (p x) (p y) (p z)))\n       ([x y z & args] (or (sp1 x y z)\n                           (some p args)))))\n  ([p1 p2]\n     (fn sp2\n       ([] nil)\n       ([x] (or (p1 x) (p2 x)))\n       ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n       ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n       ([x y z & args] (or (sp2 x y z)\n                           (some #(or (p1 %) (p2 %)) args)))))\n  ([p1 p2 p3]\n     (fn sp3\n       ([] nil)\n       ([x] (or (p1 x) (p2 x) (p3 x)))\n       ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n       ([x y z] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z)))\n       ([x y z & args] (or (sp3 x y z)\n                           (some #(or (p1 %) (p2 %) (p3 %)) args)))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn spn\n         ([] nil)\n         ([x] (some #(% x) ps))\n         ([x y] (some #(or (% x) (% y)) ps))\n         ([x y z] (some #(or (% x) (% y) (% z)) ps))\n         ([x y z & args] (or (spn x y z)\n                             (some #(some % args) ps)))))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1643
                                                               1680],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1643-L1680"},
                                              :full-name "cljs.core/some-fn",
                                              :clj-symbol "clojure.core/some-fn",
                                              :docstring "Takes a set of predicates and returns a function f that returns the first logical true value\nreturned by one of its composing predicates against any of its arguments, else it returns\nlogical false. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical true result against the original predicates."},
                         "clojure.browser.event/remove-all" {:full-name "clojure.browser.event/remove-all",
                                                             :ns "clojure.browser.event",
                                                             :name "remove-all",
                                                             :type "function",
                                                             :signature ["[opt_obj opt_type opt_capt]"],
                                                             :source {:code "(defn remove-all [opt_obj opt_type opt_capt])",
                                                                      :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                      :lines [98
                                                                              98],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/event.cljs#L98-L98"},
                                                             :full-name-encode "clojure.browser.event_remove-all",
                                                             :history [["+"
                                                                        "0.0-927"]]},
                         "cljs.core/doto" {:ns "cljs.core",
                                           :name "doto",
                                           :signature ["[x & forms]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_doto",
                                           :source {:code "(defmacro doto\n  [x & forms]\n    (let [gx (gensym)]\n      `(let [~gx ~x]\n         ~@(map (fn [f]\n                  (if (seq? f)\n                    `(~(first f) ~gx ~@(next f))\n                    `(~f ~gx)))\n                forms)\n         ~gx)))",
                                                    :filename "clojure/src/clj/clojure/core.clj",
                                                    :lines [3395 3410],
                                                    :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L3395-L3410"},
                                           :full-name "cljs.core/doto",
                                           :clj-symbol "clojure.core/doto",
                                           :docstring "Evaluates x then calls all of the methods and functions with the\nvalue of x supplied at the front of the given arguments.  The forms\nare evaluated in order.  Returns x.\n\n(doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))"},
                         "cljs.core/take-while" {:ns "cljs.core",
                                                 :name "take-while",
                                                 :signature ["[pred coll]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_take-while",
                                                 :source {:code "(defn take-while\n  [pred coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (when (pred (first s))\n       (cons (first s) (take-while pred (rest s)))))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2810
                                                                  2817],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2810-L2817"},
                                                 :full-name "cljs.core/take-while",
                                                 :clj-symbol "clojure.core/take-while",
                                                 :docstring "Returns a lazy sequence of successive items from coll while\n(pred item) returns true. pred must be free of side-effects."},
                         "cljs.reader/escape-char-map" {:full-name "cljs.reader/escape-char-map",
                                                        :ns "cljs.reader",
                                                        :name "escape-char-map",
                                                        :type "var",
                                                        :source {:code "(def escape-char-map {\\t \"\\t\"\n                      \\r \"\\r\"\n                      \\n \"\\n\"\n                      \\\\ \\\\\n                      \\\" \\\"\n                      \\b \"\\b\"\n                      \\f \"\\f\"})",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [137
                                                                         143],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L137-L143"},
                                                        :full-name-encode "cljs.reader_escape-char-map",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "clojure.browser.event/all-listeners" {:full-name "clojure.browser.event/all-listeners",
                                                                :ns "clojure.browser.event",
                                                                :name "all-listeners",
                                                                :type "function",
                                                                :signature ["[obj type capture]"],
                                                                :source {:code "(defn all-listeners [obj type capture])",
                                                                         :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                         :lines [90
                                                                                 90],
                                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/event.cljs#L90-L90"},
                                                                :full-name-encode "clojure.browser.event_all-listeners",
                                                                :history [["+"
                                                                           "0.0-927"]]},
                         "cljs.core/vals" {:ns "cljs.core",
                                           :name "vals",
                                           :signature ["[hash-map]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_vals",
                                           :source {:code "(defn vals\n  [hash-map]\n  (seq (map second hash-map)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2614 2617],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2614-L2617"},
                                           :full-name "cljs.core/vals",
                                           :clj-symbol "clojure.core/vals",
                                           :docstring "Returns a sequence of the map's values."},
                         "cljs.core/IDeref" {:ns "cljs.core",
                                             :name "IDeref",
                                             :type "protocol",
                                             :full-name-encode "cljs.core_IDeref",
                                             :source {:code "(defprotocol IDeref\n (-deref [o]))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [159 160],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L159-L160"},
                                             :methods [{:name "-deref",
                                                        :signature ["[o]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/IDeref",
                                             :history [["+" "0.0-927"]]},
                         "clojure.browser.dom/log-obj" {:full-name "clojure.browser.dom/log-obj",
                                                        :ns "clojure.browser.dom",
                                                        :name "log-obj",
                                                        :type "function",
                                                        :signature ["[obj]"],
                                                        :source {:code "(defn log-obj [obj]\n  (.log js/console obj))",
                                                                 :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                 :lines [22
                                                                         23],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/dom.cljs#L22-L23"},
                                                        :full-name-encode "clojure.browser.dom_log-obj",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/for" {:ns "cljs.core",
                                          :name "for",
                                          :signature ["[seq-exprs body-expr]"],
                                          :shadowed-sources ({:code "(defmacro for\n  [seq-exprs body-expr]\n  (assert-args for\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [to-groups (fn [seq-exprs]\n                    (reduce1 (fn [groups [k v]]\n                              (if (keyword? k)\n                                (conj (pop groups) (conj (peek groups) [k v]))\n                                (conj groups [k v])))\n                            [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (IllegalArgumentException. ^String (apply str msg))))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (cond\n                                     (= k :let) `(let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(let [iterys# ~(emit-bind next-groups)\n                                             fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      (if next-groups\n                        #_\"not the inner-most loop\"\n                        `(fn ~giter [~gxs]\n                           (lazy-seq\n                             (loop [~gxs ~gxs]\n                               (when-first [~bind ~gxs]\n                                 ~(do-mod mod-pairs)))))\n                        #_\"inner-most loop\"\n                        (let [gi (gensym \"i__\")\n                              gb (gensym \"b__\")\n                              do-cmod (fn do-cmod [[[k v :as pair] & etc]]\n                                        (cond\n                                          (= k :let) `(let ~v ~(do-cmod etc))\n                                          (= k :while) `(when ~v ~(do-cmod etc))\n                                          (= k :when) `(if ~v\n                                                         ~(do-cmod etc)\n                                                         (recur\n                                                           (unchecked-inc ~gi)))\n                                          (keyword? k)\n                                            (err \"Invalid 'for' keyword \" k)\n                                          :else\n                                            `(do (chunk-append ~gb ~body-expr)\n                                                 (recur (unchecked-inc ~gi)))))]\n                          `(fn ~giter [~gxs]\n                             (lazy-seq\n                               (loop [~gxs ~gxs]\n                                 (when-let [~gxs (seq ~gxs)]\n                                   (if (chunked-seq? ~gxs)\n                                     (let [c# (chunk-first ~gxs)\n                                           size# (int (count c#))\n                                           ~gb (chunk-buffer size#)]\n                                       (if (loop [~gi (int 0)]\n                                             (if (< ~gi size#)\n                                               (let [~bind (.nth c# ~gi)]\n                                                 ~(do-cmod mod-pairs))\n                                               true))\n                                         (chunk-cons\n                                           (chunk ~gb)\n                                           (~giter (chunk-rest ~gxs)))\n                                         (chunk-cons (chunk ~gb) nil)))\n                                     (let [~bind (first ~gxs)]\n                                       ~(do-mod mod-pairs)))))))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n        (iter# ~(second seq-exprs)))))",
                                                              :filename "clojure/src/clj/clojure/core.clj",
                                                              :lines [4074
                                                                      4159],
                                                              :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L4074-L4159"}),
                                          :history [["+" "0.0-927"]],
                                          :type "macro",
                                          :full-name-encode "cljs.core_for",
                                          :source {:code "(defmacro for\n  [seq-exprs body-expr]\n  (assert-args for\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [to-groups (fn [seq-exprs]\n                    (reduce (fn [groups [k v]]\n                              (if (keyword? k)\n                                (conj (pop groups) (conj (peek groups) [k v]))\n                                (conj groups [k v])))\n                            [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (apply str msg)))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (cond\n                                     (= k :let) `(let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(let [iterys# ~(emit-bind next-groups)\n                                             fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      `(fn ~giter [~gxs]\n                         (lazy-seq\n                           (loop [~gxs ~gxs]\n                             (when-first [~bind ~gxs]\n                               ~(do-mod mod-pairs)))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n       (iter# ~(second seq-exprs)))))",
                                                   :filename "clojurescript/src/clj/cljs/core.clj",
                                                   :lines [563 610],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L563-L610"},
                                          :full-name "cljs.core/for",
                                          :clj-symbol "clojure.core/for",
                                          :docstring "List comprehension. Takes a vector of one or more\n binding-form/collection-expr pairs, each followed by zero or more\n modifiers, and yields a lazy sequence of evaluations of expr.\n Collections are iterated in a nested fashion, rightmost fastest,\n and nested coll-exprs can refer to bindings created in prior\n binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n :while test, :when test.\n\n(take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))"},
                         "cljs.core/instance?" {:full-name "cljs.core/instance?",
                                                :ns "cljs.core",
                                                :name "instance?",
                                                :type "function",
                                                :signature ["[t o]"],
                                                :source {:code "(defn instance? [t o]\n  (js* \"(~{o} != null && (~{o} instanceof ~{t} || ~{o}.constructor === ~{t} || ~{t} === Object))\"))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [652
                                                                 653],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L652-L653"},
                                                :full-name-encode "cljs.core_instance_QMARK_",
                                                :clj-symbol "clojure.core/instance?",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.reader/read-comment" {:full-name "cljs.reader/read-comment",
                                                     :ns "cljs.reader",
                                                     :name "read-comment",
                                                     :type "var",
                                                     :source {:code "(def read-comment skip-line)",
                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                              :lines [207
                                                                      207],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L207-L207"},
                                                     :full-name-encode "cljs.reader_read-comment",
                                                     :history [["+"
                                                                "0.0-927"]]},
                         "cljs.reader/read-number" {:full-name "cljs.reader/read-number",
                                                    :ns "cljs.reader",
                                                    :name "read-number",
                                                    :type "function",
                                                    :signature ["[reader initch]"],
                                                    :source {:code "(defn read-number\n  [reader initch]\n  (loop [buffer (gstring/StringBuffer. initch)\n         ch (read-char reader)]\n    (if (or (nil? ch) (whitespace? ch) (contains? macros ch))\n      (do\n        (unread reader ch)\n        (let [s (. buffer (toString))]\n          (or (match-number s)\n              (reader-error reader \"Invalid number format [\" s \"]\"))))\n      (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [220
                                                                     230],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L220-L230"},
                                                    :full-name-encode "cljs.reader_read-number",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "cljs.core/ILookup" {:ns "cljs.core",
                                              :name "ILookup",
                                              :type "protocol",
                                              :full-name-encode "cljs.core_ILookup",
                                              :source {:code "(defprotocol ILookup\n  (-lookup [o k] [o k not-found]))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [137
                                                               138],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L137-L138"},
                                              :methods [{:name "-lookup",
                                                         :signature ["[o k]"
                                                                     "[o k not-found]"],
                                                         :docstring nil}],
                                              :full-name "cljs.core/ILookup",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/when" {:ns "cljs.core",
                                           :name "when",
                                           :signature ["[test & body]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_when",
                                           :source {:code "(defmacro when\n  [test & body]\n  (list 'if test (cons 'do body)))",
                                                    :filename "clojure/src/clj/clojure/core.clj",
                                                    :lines [454 458],
                                                    :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L454-L458"},
                                           :full-name "cljs.core/when",
                                           :clj-symbol "clojure.core/when",
                                           :docstring "Evaluates test. If logical true, evaluates body in an implicit do."},
                         "clojure.browser.dom/set-value" {:full-name "clojure.browser.dom/set-value",
                                                          :ns "clojure.browser.dom",
                                                          :name "set-value",
                                                          :docstring "Set the value property for an element.",
                                                          :type "function",
                                                          :signature ["[e v]"],
                                                          :source {:code "(defn set-value\n  [e v]\n  (set-properties e {\"value\" v}))",
                                                                   :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                   :lines [140
                                                                           143],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/dom.cljs#L140-L143"},
                                                          :full-name-encode "clojure.browser.dom_set-value",
                                                          :history [["+"
                                                                     "0.0-927"]]},
                         "cljs.reader/read-past" {:full-name "cljs.reader/read-past",
                                                  :ns "cljs.reader",
                                                  :name "read-past",
                                                  :docstring "Read until first character that doesn't match pred, returning\nchar.",
                                                  :type "function",
                                                  :signature ["[pred rdr]"],
                                                  :source {:code "(defn read-past\n  [pred rdr]\n  (loop [ch (read-char rdr)]\n    (if (pred ch)\n      (recur (read-char rdr))\n      ch)))",
                                                           :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                           :lines [159
                                                                   166],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L159-L166"},
                                                  :full-name-encode "cljs.reader_read-past",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/to-array" {:ns "cljs.core",
                                               :name "to-array",
                                               :signature ["[s]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_to-array",
                                               :source {:code "(defn to-array\n  [s]\n  (let [ary (array)]\n    (loop [s s]\n      (if (seq s)\n        (do (. ary push (first s))\n            (recur (next s)))\n        ary))))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [1322
                                                                1330],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1322-L1330"},
                                               :full-name "cljs.core/to-array",
                                               :clj-symbol "clojure.core/to-array",
                                               :docstring "Naive impl of to-array as a start."},
                         "cljs.core/interpose" {:ns "cljs.core",
                                                :name "interpose",
                                                :signature ["[sep coll]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_interpose",
                                                :source {:code "(defn interpose\n  [sep coll] (drop 1 (interleave (repeat sep) coll)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1802
                                                                 1804],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1802-L1804"},
                                                :full-name "cljs.core/interpose",
                                                :clj-symbol "clojure.core/interpose",
                                                :docstring "Returns a lazy seq of the elements of coll separated by sep"},
                         "clojure.browser.net/ICrossPageChannel" {:ns "clojure.browser.net",
                                                                  :name "ICrossPageChannel",
                                                                  :type "protocol",
                                                                  :full-name-encode "clojure.browser.net_ICrossPageChannel",
                                                                  :source {:code "(defprotocol ICrossPageChannel\n  (register-service [this service-name fn] [this service-name fn encode-json?]))",
                                                                           :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                           :lines [88
                                                                                   89],
                                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/net.cljs#L88-L89"},
                                                                  :methods [{:name "register-service",
                                                                             :signature ["[this service-name fn]"
                                                                                         "[this service-name fn encode-json?]"],
                                                                             :docstring nil}],
                                                                  :full-name "clojure.browser.net/ICrossPageChannel",
                                                                  :history [["+"
                                                                             "0.0-927"]]},
                         "special/finally" {:ns "special",
                                            :name "finally",
                                            :signature ["[expr*]"],
                                            :history [["+" "0.0-927"]],
                                            :type "special form",
                                            :full-name-encode "special_finally",
                                            :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (list? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                     :lines [511 539],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L511-L539"},
                                            :full-name "special/finally",
                                            :clj-symbol "clojure.core/finally",
                                            :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions."},
                         "cljs.core/Cons" {:full-name "cljs.core/Cons",
                                           :ns "cljs.core",
                                           :name "Cons",
                                           :type "type",
                                           :signature ["[meta first rest]"],
                                           :source {:code "(deftype Cons [meta first rest]\n  IWithMeta\n  (-with-meta [coll meta] (Cons. meta first rest))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] first)\n  (-rest [coll] (if (nil? rest) () rest))\n\n  ICollection\n  (-conj [coll o] (Cons. nil o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] coll))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1201 1226],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1201-L1226"},
                                           :full-name-encode "cljs.core_Cons",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/re-find" {:ns "cljs.core",
                                              :name "re-find",
                                              :signature ["[re s]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_re-find",
                                              :source {:code "(defn re-find\n  [re s]\n  (let [matches (.exec re s)]\n    (when-not (nil? matches)\n      (if (= (count matches) 1)\n        (first matches)\n        (vec matches)))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [3006
                                                               3016],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3006-L3016"},
                                              :full-name "cljs.core/re-find",
                                              :clj-symbol "clojure.core/re-find",
                                              :docstring "Returns the first regex match, if any, of s to re, using\nre.exec(s). Returns a vector, containing first the matching\nsubstring, then any capturing groups if the regular expression contains\ncapturing groups."},
                         "cljs.core/IMeta" {:ns "cljs.core",
                                            :name "IMeta",
                                            :type "protocol",
                                            :full-name-encode "cljs.core_IMeta",
                                            :source {:code "(defprotocol IMeta\n  (-meta [o]))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [165 166],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L165-L166"},
                                            :methods [{:name "-meta",
                                                       :signature ["[o]"],
                                                       :docstring nil}],
                                            :full-name "cljs.core/IMeta",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/assoc-in" {:ns "cljs.core",
                                               :name "assoc-in",
                                               :signature ["[m [k & ks] v]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_assoc-in",
                                               :source {:code "(defn assoc-in\n  [m [k & ks] v]\n  (if ks\n    (assoc m k (assoc-in (get m k) ks v))\n    (assoc m k v)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [1915
                                                                1922],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1915-L1922"},
                                               :full-name "cljs.core/assoc-in",
                                               :clj-symbol "clojure.core/assoc-in",
                                               :docstring "Associates a value in a nested associative structure, where ks is a\nsequence of keys and v is the new value and returns a new nested structure.\nIf any levels do not exist, hash-maps will be created."},
                         "clojure.string/join" {:ns "clojure.string",
                                                :name "join",
                                                :signature ["[coll]"
                                                            "[separator coll]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.string_join",
                                                :source {:code "(defn join\n  ([coll]\n     (apply str coll))\n  ([separator coll]\n     (apply str (interpose separator coll))))",
                                                         :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                         :lines [45
                                                                 51],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/string.cljs#L45-L51"},
                                                :full-name "clojure.string/join",
                                                :clj-symbol "clojure.string/join",
                                                :docstring "Returns a string of all elements in coll, as returned by (seq coll),\nseparated by an optional separator."},
                         "clojure.zip/rights" {:ns "clojure.zip",
                                               :name "rights",
                                               :signature ["[loc]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.zip_rights",
                                               :source {:code "(defn rights\n  [loc]\n    (:r (loc 1)))",
                                                        :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                        :lines [92 95],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L92-L95"},
                                               :full-name "clojure.zip/rights",
                                               :clj-symbol "clojure.zip/rights",
                                               :docstring "Returns a seq of the right siblings of this loc"},
                         "cljs.core/split-at" {:ns "cljs.core",
                                               :name "split-at",
                                               :signature ["[n coll]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_split-at",
                                               :source {:code "(defn split-at\n  [n coll]\n  [(take n coll) (drop n coll)])",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [1762
                                                                1765],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1762-L1765"},
                                               :full-name "cljs.core/split-at",
                                               :clj-symbol "clojure.core/split-at",
                                               :docstring "Returns a vector of [(take n coll) (drop n coll)]"},
                         "clojure.zip/append-child" {:ns "clojure.zip",
                                                     :name "append-child",
                                                     :signature ["[loc item]"],
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "clojure.zip_append-child",
                                                     :source {:code "(defn append-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (concat (children loc) [item]))))",
                                                              :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                              :lines [200
                                                                      204],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L200-L204"},
                                                     :full-name "clojure.zip/append-child",
                                                     :clj-symbol "clojure.zip/append-child",
                                                     :docstring "Inserts the item as the rightmost child of the node at this loc,\nwithout moving"},
                         "cljs.core/binding" {:ns "cljs.core",
                                              :name "binding",
                                              :signature ["[bindings & body]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "macro",
                                              :full-name-encode "cljs.core_binding",
                                              :source {:code "(defmacro binding\n  [bindings & body]\n  (let [names (take-nth 2 bindings)\n        vals (take-nth 2 (drop 1 bindings))\n        tempnames (map (comp gensym name) names)\n        binds (map vector names vals)\n        resets (reverse (map vector names tempnames))]\n    `(let [~@(interleave tempnames names)]\n       (try\n        ~@(map\n           (fn [[k v]] (list 'set! k v))\n           binds)\n        ~@body\n        (finally\n         ~@(map\n            (fn [[k v]] (list 'set! k v))\n            resets))))))",
                                                       :filename "clojurescript/src/clj/cljs/core.clj",
                                                       :lines [444
                                                               467],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L444-L467"},
                                              :full-name "cljs.core/binding",
                                              :clj-symbol "clojure.core/binding",
                                              :docstring "binding => var-symbol init-expr\n\nCreates new bindings for the (already-existing) vars, with the\nsupplied initial values, executes the exprs in an implicit do, then\nre-establishes the bindings that existed before.  The new bindings\nare made in parallel (unlike let); all init-exprs are evaluated\nbefore the vars are bound to their new values."},
                         "cljs.core/Set" {:full-name "cljs.core/Set",
                                          :ns "cljs.core",
                                          :name "Set",
                                          :type "type",
                                          :signature ["[meta hash-map]"],
                                          :source {:code "(deftype Set [meta hash-map]\n  IWithMeta\n  (-with-meta [coll meta] (Set. meta hash-map))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (Set. meta (assoc hash-map o nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Set/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (= (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (count (seq coll)))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if (-contains-key? hash-map v)\n      v\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (Set. meta (dissoc hash-map v)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [2659 2706],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2659-L2706"},
                                          :full-name-encode "cljs.core_Set",
                                          :history [["+" "0.0-927"]]},
                         "cljs.reader/macro-terminating?" {:full-name "cljs.reader/macro-terminating?",
                                                           :ns "cljs.reader",
                                                           :name "macro-terminating?",
                                                           :type "function",
                                                           :signature ["[ch]"],
                                                           :source {:code "(defn macro-terminating? [ch]\n  (and (not= ch \"#\") (not= ch \\') (not= ch \":\") (contains? macros ch)))",
                                                                    :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                    :lines [73
                                                                            74],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L73-L74"},
                                                           :full-name-encode "cljs.reader_macro-terminating_QMARK_",
                                                           :history [["+"
                                                                      "0.0-927"]]},
                         "cljs.core/prefers" {:ns "cljs.core",
                                              :name "prefers",
                                              :signature ["[multifn]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_prefers",
                                              :source {:code "(defn prefers\n  [multifn] (-prefers multifn))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [3764
                                                               3766],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3764-L3766"},
                                              :full-name "cljs.core/prefers",
                                              :clj-symbol "clojure.core/prefers",
                                              :docstring "Given a multimethod, returns a map of preferred value -> set of other values"},
                         "cljs.core/vary-meta" {:ns "cljs.core",
                                                :name "vary-meta",
                                                :signature ["[obj f & args]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_vary-meta",
                                                :source {:code "(defn vary-meta\n [obj f & args]\n (with-meta obj (apply f (meta obj) args)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1429
                                                                 1433],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1429-L1433"},
                                                :full-name "cljs.core/vary-meta",
                                                :clj-symbol "clojure.core/vary-meta",
                                                :docstring "Returns an object of the same type and value as obj, with\n(apply f (meta obj) args) as its metadata."},
                         "cljs.core/when-let" {:ns "cljs.core",
                                               :name "when-let",
                                               :signature ["[bindings & body]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "macro",
                                               :full-name-encode "cljs.core_when-let",
                                               :source {:code "(defmacro when-let\n  [bindings & body]\n  (assert-args when-let\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n    `(let [temp# ~tst]\n       (when temp#\n         (let [~form temp#]\n           ~@body)))))",
                                                        :filename "clojure/src/clj/clojure/core.clj",
                                                        :lines [1685
                                                                1698],
                                                        :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L1685-L1698"},
                                               :full-name "cljs.core/when-let",
                                               :clj-symbol "clojure.core/when-let",
                                               :docstring "bindings => binding-form test\n\nWhen test is true, evaluates body with binding-form bound to the value of test"},
                         "cljs.core/drop" {:ns "cljs.core",
                                           :name "drop",
                                           :signature ["[n coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_drop",
                                           :source {:code "(defn drop\n  [n coll]\n  (let [step (fn [n coll]\n               (let [s (seq coll)]\n                 (if (and (pos? n) s)\n                   (recur (dec n) (rest s))\n                   s)))]\n    (lazy-seq (step n coll))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1721 1729],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1721-L1729"},
                                           :full-name "cljs.core/drop",
                                           :clj-symbol "clojure.core/drop",
                                           :docstring "Returns a lazy sequence of all but the first n items in coll."},
                         "cljs.core/while" {:ns "cljs.core",
                                            :name "while",
                                            :signature ["[test & body]"],
                                            :history [["+" "0.0-927"]],
                                            :type "macro",
                                            :full-name-encode "cljs.core_while",
                                            :source {:code "(defmacro while\n  [test & body]\n  `(loop []\n     (when ~test\n       ~@body\n       (recur))))",
                                                     :filename "clojure/src/clj/clojure/core.clj",
                                                     :lines [5569
                                                             5577],
                                                     :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L5569-L5577"},
                                            :full-name "cljs.core/while",
                                            :clj-symbol "clojure.core/while",
                                            :docstring "Repeatedly executes body while test expression is true. Presumes\nsome side-effect will cause test to become false/nil. Returns nil"},
                         "cljs.core/import-macros" {:full-name "cljs.core/import-macros",
                                                    :ns "cljs.core",
                                                    :name "import-macros",
                                                    :type "macro",
                                                    :signature ["[ns [& vars]]"],
                                                    :source {:code "(defmacro import-macros [ns [& vars]]\n  (core/let [ns (find-ns ns)\n             vars (map #(ns-resolve ns %) vars)\n             syms (map (core/fn [^clojure.lang.Var v] (core/-> v .sym (with-meta {:macro true}))) vars)\n             defs (map (core/fn [sym var]\n                                `(def ~sym (deref ~var))) syms vars)]\n            `(do ~@defs\n                 :imported)))",
                                                             :filename "clojurescript/src/clj/cljs/core.clj",
                                                             :lines [27
                                                                     34],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L27-L34"},
                                                    :full-name-encode "cljs.core_import-macros",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "cljs.core/string-print" {:full-name "cljs.core/string-print",
                                                   :ns "cljs.core",
                                                   :name "string-print",
                                                   :type "function",
                                                   :signature ["[x]"],
                                                   :source {:code "(defn string-print [x]\n  (*print-fn* x)\n  nil)",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [3041
                                                                    3043],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3041-L3043"},
                                                   :full-name-encode "cljs.core_string-print",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "cljs.core/-" {:ns "cljs.core",
                                        :name "-",
                                        :signature ["[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :shadowed-sources ({:code "(defmacro -\n  ([x] (list 'js* \"(- ~{})\" x))\n  ([x y] (list 'js* \"(~{} - ~{})\" x y))\n  ([x y & more] `(- (- ~x ~y) ~@more)))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [72
                                                                    75],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L72-L75"}),
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core_-",
                                        :source {:code "(defn -\n  ([x] (cljs.core/- x))\n  ([x y] (cljs.core/- x y))\n  ([x y & more] (reduce - (cljs.core/- x y) more)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [817 822],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L817-L822"},
                                        :full-name "cljs.core/-",
                                        :clj-symbol "clojure.core/-",
                                        :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
                         "clojure.zip/vector-zip" {:ns "clojure.zip",
                                                   :name "vector-zip",
                                                   :signature ["[root]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.zip_vector-zip",
                                                   :source {:code "(defn vector-zip\n  [root]\n    (zipper vector?\n            seq\n            (fn [node children] (with-meta (vec children) (meta node)))\n            root))",
                                                            :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                            :lines [42
                                                                    48],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L42-L48"},
                                                   :full-name "clojure.zip/vector-zip",
                                                   :clj-symbol "clojure.zip/vector-zip",
                                                   :docstring "Returns a zipper for nested vectors, given a root vector"},
                         "cljs.core/js->clj" {:full-name "cljs.core/js->clj",
                                              :ns "cljs.core",
                                              :name "js->clj",
                                              :docstring "Recursively transforms JavaScript arrays into ClojureScript\nvectors, and JavaScript objects into ClojureScript maps.  With\noption ':keywordize-keys true' will convert object fields from\nstrings to keywords.",
                                              :type "function",
                                              :signature ["[x & options]"],
                                              :source {:code "(defn js->clj\n  [x & options]\n  (let [{:keys [keywordize-keys]} options\n        keyfn (if keywordize-keys keyword str)\n        f (fn thisfn [x]\n            (cond\n             (seq? x) (doall (map thisfn x))\n             (coll? x) (into (empty x) (map thisfn x))\n             (goog.isArray x) (vec (map thisfn x))\n             (goog.isObject x) (into {} (for [k (js-keys x)]\n                                          [(keyfn k)\n                                           (thisfn (aget x k))]))\n             :else x))]\n    (f x)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [3429
                                                               3446],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3429-L3446"},
                                              :full-name-encode "cljs.core_js-_GT_clj",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/List" {:full-name "cljs.core/List",
                                           :ns "cljs.core",
                                           :name "List",
                                           :type "type",
                                           :signature ["[meta first rest count]"],
                                           :source {:code "(deftype List [meta first rest count]\n  IWithMeta\n  (-with-meta [coll meta] (List. meta first rest count))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] first)\n  (-rest [coll] rest)\n\n  IStack\n  (-peek [coll] first)\n  (-pop [coll] (-rest coll))\n\n  ICollection\n  (-conj [coll o] (List. meta o coll (inc count)))\n\n  IEmptyableCollection\n  (-empty [coll] cljs.core.List/EMPTY)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ICounted\n  (-count [coll] count))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1123 1155],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1123-L1155"},
                                           :full-name-encode "cljs.core_List",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/identical?" {:ns "cljs.core",
                                                 :name "identical?",
                                                 :signature ["[x y]"],
                                                 :shadowed-sources ({:code "(defmacro identical? [a b]\n  (list 'js* \"(~{} === ~{})\" a b))",
                                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                                     :lines [57
                                                                             58],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L57-L58"}),
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_identical_QMARK_",
                                                 :source {:code "(defn identical?\n  [x y]\n  (cljs.core/identical? x y))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [201
                                                                  204],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L201-L204"},
                                                 :full-name "cljs.core/identical?",
                                                 :clj-symbol "clojure.core/identical?",
                                                 :docstring "Tests if 2 arguments are the same object"},
                         "cljs.core/*main-cli-fn*" {:full-name "cljs.core/*main-cli-fn*",
                                                    :ns "cljs.core",
                                                    :name "*main-cli-fn*",
                                                    :docstring "When compiled for a command-line target, whatever\nfunction *main-fn* is set to will be called with the command-line\nargv as arguments",
                                                    :type "var",
                                                    :source {:code "(def\n  ^{:doc \"When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments\"}\n  *main-cli-fn* nil)",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [52
                                                                     56],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L52-L56"},
                                                    :full-name-encode "cljs.core__STAR_main-cli-fn_STAR_",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "clojure.browser.dom/html->dom" {:full-name "clojure.browser.dom/html->dom",
                                                          :ns "clojure.browser.dom",
                                                          :name "html->dom",
                                                          :type "function",
                                                          :signature ["[s]"],
                                                          :source {:code "(defn html->dom [s]\n  (gdom/htmlToDocumentFragment s))",
                                                                   :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                   :lines [99
                                                                           100],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/dom.cljs#L99-L100"},
                                                          :full-name-encode "clojure.browser.dom_html-_GT_dom",
                                                          :history [["+"
                                                                     "0.0-927"]]},
                         "cljs.core/some" {:ns "cljs.core",
                                           :name "some",
                                           :signature ["[pred coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_some",
                                           :source {:code "(defn some\n  [pred coll]\n    (when (seq coll)\n      (or (pred (first coll)) (recur pred (next coll)))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1460 1467],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1460-L1467"},
                                           :full-name "cljs.core/some",
                                           :clj-symbol "clojure.core/some",
                                           :docstring "Returns the first logical true value of (pred x) for any x in coll,\nelse nil.  One common idiom is to use a set as pred, for example\nthis will return :fred if :fred is in the sequence, otherwise nil:\n(some #{:fred} coll)"},
                         "cljs.core/doall" {:ns "cljs.core",
                                            :name "doall",
                                            :signature ["[coll]"
                                                        "[n coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_doall",
                                            :source {:code "(defn doall\n  ([coll]\n   (dorun coll)\n   coll)\n  ([n coll]\n   (dorun n coll)\n   coll))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2981
                                                             2993],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2981-L2993"},
                                            :full-name "cljs.core/doall",
                                            :clj-symbol "clojure.core/doall",
                                            :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. doall can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, retains the head and returns it, thus causing the entire\nseq to reside in memory at one time."},
                         "cljs.core/condp" {:ns "cljs.core",
                                            :name "condp",
                                            :signature ["[pred expr & clauses]"],
                                            :history [["+" "0.0-927"]],
                                            :type "macro",
                                            :full-name-encode "cljs.core_condp",
                                            :source {:code "(defmacro condp\n  [pred expr & clauses]\n  (let [gpred (gensym \"pred__\")\n        gexpr (gensym \"expr__\")\n        emit (fn emit [pred expr args]\n               (let [[[a b c :as clause] more]\n                       (split-at (if (= :>> (second args)) 3 2) args)\n                       n (count clause)]\n                 (cond\n                  (= 0 n) `(throw (js/Error. (str \"No matching clause: \" ~expr)))\n                  (= 1 n) a\n                  (= 2 n) `(if (~pred ~a ~expr)\n                             ~b\n                             ~(emit pred expr more))\n                  :else `(if-let [p# (~pred ~a ~expr)]\n                           (~c p#)\n                           ~(emit pred expr more)))))\n        gres (gensym \"res__\")]\n    `(let [~gpred ~pred\n           ~gexpr ~expr]\n       ~(emit gpred gexpr clauses))))",
                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                     :lines [469 509],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L469-L509"},
                                            :full-name "cljs.core/condp",
                                            :clj-symbol "clojure.core/condp",
                                            :docstring "Takes a binary predicate, an expression, and a set of clauses.\nEach clause can take the form of either:\n\ntest-expr result-expr\n\ntest-expr :>> result-fn\n\nNote :>> is an ordinary keyword.\n\nFor each clause, (pred test-expr expr) is evaluated. If it returns\nlogical true, the clause is a match. If a binary clause matches, the\nresult-expr is returned, if a ternary clause matches, its result-fn,\nwhich must be a unary function, is called with the result of the\npredicate as its argument, the result of that call being the return\nvalue of condp. A single default expression can follow the clauses,\nand its value will be returned if no clause matches. If no default\nexpression is provided and no clause matches, an\nIllegalArgumentException is thrown."},
                         "clojure.zip/down" {:ns "clojure.zip",
                                             :name "down",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_down",
                                             :source {:code "(defn down\n  [loc]\n    (when (branch? loc)\n      (let [[node path] loc\n            [c & cnext :as cs] (children loc)]\n        (when cs\n          (with-meta [c {:l [] \n                         :pnodes (if path (conj (:pnodes path) node) [node]) \n                         :ppath path \n                         :r cnext}] (meta loc))))))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [98 109],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L98-L109"},
                                             :full-name "clojure.zip/down",
                                             :clj-symbol "clojure.zip/down",
                                             :docstring "Returns the loc of the leftmost child of the node at this loc, or\nnil if no children"},
                         "cljs.core/IPending" {:ns "cljs.core",
                                               :name "IPending",
                                               :type "protocol",
                                               :full-name-encode "cljs.core_IPending",
                                               :source {:code "(defprotocol IPending\n  (-realized? [d]))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [192
                                                                193],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L192-L193"},
                                               :methods [{:name "-realized?",
                                                          :signature ["[d]"],
                                                          :docstring nil}],
                                               :full-name "cljs.core/IPending",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/count" {:ns "cljs.core",
                                            :name "count",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_count",
                                            :source {:code "(defn count\n  [coll]\n  (-count coll))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [495 499],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L495-L499"},
                                            :full-name "cljs.core/count",
                                            :clj-symbol "clojure.core/count",
                                            :docstring "Returns the number of items in the collection. (count nil) returns\n0.  Also works on strings, arrays, and Maps"},
                         "cljs.core/bit-test" {:ns "cljs.core",
                                               :name "bit-test",
                                               :signature ["[x n]"],
                                               :shadowed-sources ({:code "(defmacro bit-test [x n]\n  (list 'js* \"((~{} & (1 << ~{})) != 0)\" x n))",
                                                                   :filename "clojurescript/src/clj/cljs/core.clj",
                                                                   :lines [166
                                                                           167],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L166-L167"}),
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_bit-test",
                                               :source {:code "(defn bit-test\n  [x n]\n  (cljs.core/bit-test x n))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [970
                                                                973],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L970-L973"},
                                               :full-name "cljs.core/bit-test",
                                               :clj-symbol "clojure.core/bit-test",
                                               :docstring "Test bit at index n"},
                         "cljs.core/fixture2" {:full-name "cljs.core/fixture2",
                                               :ns "cljs.core",
                                               :name "fixture2",
                                               :type "var",
                                               :source {:code "(def fixture2 2)",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [3397
                                                                3397],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3397-L3397"},
                                               :full-name-encode "cljs.core_fixture2",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/loop" {:ns "cljs.core",
                                           :name "loop",
                                           :signature ["[bindings & body]"],
                                           :shadowed-sources ({:code "(def\n ^{:macro true\n   :added \"1.0\"}\n loop (fn* loop [&form &env & decl] (cons 'loop* decl)))",
                                                               :filename "clojure/src/clj/clojure/core.clj",
                                                               :lines [37
                                                                       40],
                                                               :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L37-L40"}),
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_loop",
                                           :source {:code "(defmacro loop\n  [bindings & body]\n    (assert-args loop\n      (vector? bindings) \"a vector for its binding\"\n      (even? (count bindings)) \"an even number of forms in binding vector\")\n    (let [db (destructure bindings)]\n      (if (= db bindings)\n        `(loop* ~bindings ~@body)\n        (let [vs (take-nth 2 (drop 1 bindings))\n              bs (take-nth 2 bindings)\n              gs (map (fn [b] (if (symbol? b) b (gensym))) bs)\n              bfs (reduce1 (fn [ret [b v g]]\n                            (if (symbol? b)\n                              (conj ret g v)\n                              (conj ret g v b g)))\n                          [] (map vector bs vs gs))]\n          `(let ~bfs\n             (loop* ~(vec (interleave gs gs))\n               (let ~(vec (interleave bs gs))\n                 ~@body)))))))",
                                                    :filename "clojure/src/clj/clojure/core.clj",
                                                    :lines [4025 4048],
                                                    :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L4025-L4048"},
                                           :full-name "cljs.core/loop",
                                           :clj-symbol "clojure.core/loop",
                                           :docstring "Evaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein. Acts as a recur target."},
                         "cljs.core/subvec" {:ns "cljs.core",
                                             :name "subvec",
                                             :signature ["[v start]"
                                                         "[v start end]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_subvec",
                                             :source {:code "(defn subvec\n  ([v start]\n     (subvec v start (count v)))\n  ([v start end]\n     (Subvec. nil v start end)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2280
                                                              2289],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2280-L2289"},
                                             :full-name "cljs.core/subvec",
                                             :clj-symbol "clojure.core/subvec",
                                             :docstring "Returns a persistent vector of the items in vector from\nstart (inclusive) to end (exclusive).  If end is not supplied,\ndefaults to (count vector). This operation is O(1) and very fast, as\nthe resulting vector shares structure with the original and no\ntrimming is done."},
                         "cljs.core/bit-clear" {:ns "cljs.core",
                                                :name "bit-clear",
                                                :signature ["[x n]"],
                                                :shadowed-sources ({:code "(defmacro bit-clear [x n]\n  (list 'js* \"(~{} & ~(1 << ~{}))\" x n))",
                                                                    :filename "clojurescript/src/clj/cljs/core.clj",
                                                                    :lines [160
                                                                            161],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L160-L161"}),
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_bit-clear",
                                                :source {:code "(defn bit-clear\n  [x n]\n  (cljs.core/bit-clear x n))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [951
                                                                 954],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L951-L954"},
                                                :full-name "cljs.core/bit-clear",
                                                :clj-symbol "clojure.core/bit-clear",
                                                :docstring "Clear bit at index n"},
                         "cljs.core/gensym" {:ns "cljs.core",
                                             :name "gensym",
                                             :signature ["[]"
                                                         "[prefix-string]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_gensym",
                                             :source {:code "(defn gensym\n  ([] (gensym \"G__\"))\n  ([prefix-string]\n     (when (nil? gensym_counter)\n       (set! gensym_counter (atom 0)))\n     (symbol (str prefix-string (swap! gensym_counter inc)))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [3384
                                                              3392],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3384-L3392"},
                                             :full-name "cljs.core/gensym",
                                             :clj-symbol "clojure.core/gensym",
                                             :docstring "Returns a new symbol with a unique name. If a prefix string is\nsupplied, the name is prefix# where # is some unique number. If\nprefix is not supplied, the prefix is 'G__'."},
                         "special/recur" {:full-name "special/recur",
                                          :ns "special",
                                          :name "recur",
                                          :type "special form",
                                          :source {:code "(defmethod parse 'recur\n  [op env [_ & exprs] _]\n  (let [context (:context env)\n        frame (first *recur-frames*)]\n    (assert frame \"Can't recur here\")\n    (assert (= (count exprs) (count (:names frame))) \"recur argument count mismatch\")\n    (reset! (:flag frame) true)\n    (assoc {:env env :op :recur}\n      :frame frame\n      :exprs (disallowing-recur (vec (map #(analyze (assoc env :context :expr) %) exprs))))))",
                                                   :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                   :lines [801 810],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/compiler.clj#L801-L810"},
                                          :full-name-encode "special_recur",
                                          :clj-symbol "clojure.core/recur",
                                          :history [["+" "0.0-927"]]},
                         "cljs.core/+" {:ns "cljs.core",
                                        :name "+",
                                        :signature ["[]"
                                                    "[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :shadowed-sources ({:code "(defmacro +\n  ([] 0)\n  ([x] x)\n  ([x y] (list 'js* \"(~{} + ~{})\" x y))\n  ([x y & more] `(+ (+ ~x ~y) ~@more)))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [66
                                                                    70],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L66-L70"}),
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core__PLUS_",
                                        :source {:code "(defn +\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/+ x y))\n  ([x y & more] (reduce + (cljs.core/+ x y) more)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [810 815],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L810-L815"},
                                        :full-name "cljs.core/+",
                                        :clj-symbol "clojure.core/+",
                                        :docstring "Returns the sum of nums. (+) returns 0."},
                         "cljs.core/comp" {:ns "cljs.core",
                                           :name "comp",
                                           :signature ["[]"
                                                       "[f]"
                                                       "[f g]"
                                                       "[f g h]"
                                                       "[f1 f2 f3 & fs]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_comp",
                                           :source {:code "(defn comp\n  ([] identity)\n  ([f] f)\n  ([f g]\n     (fn\n       ([] (f (g)))\n       ([x] (f (g x)))\n       ([x y] (f (g x y)))\n       ([x y z] (f (g x y z)))\n       ([x y z & args] (f (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (f (g (h))))\n       ([x] (f (g (h x))))\n       ([x y] (f (g (h x y))))\n       ([x y z] (f (g (h x y z))))\n       ([x y z & args] (f (g (apply h x y z args))))))\n  ([f1 f2 f3 & fs]\n    (let [fs (reverse (list* f1 f2 f3 fs))]\n      (fn [& args]\n        (loop [ret (apply (first fs) args) fs (next fs)]\n          (if fs\n            (recur ((first fs) ret) (next fs))\n            ret))))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1500 1527],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1500-L1527"},
                                           :full-name "cljs.core/comp",
                                           :clj-symbol "clojure.core/comp",
                                           :docstring "Takes a set of functions and returns a fn that is the composition\nof those fns.  The returned fn takes a variable number of args,\napplies the rightmost of fns to the args, the next\nfn (right-to-left) to the result, etc."},
                         "cljs.reader/desugar-meta" {:full-name "cljs.reader/desugar-meta",
                                                     :ns "cljs.reader",
                                                     :name "desugar-meta",
                                                     :type "function",
                                                     :signature ["[f]"],
                                                     :source {:code "(defn desugar-meta\n  [f]\n  (cond\n   (symbol? f) {:tag f}\n   (string? f) {:tag f}\n   (keyword? f) {f true}\n   :else f))",
                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                              :lines [269
                                                                      275],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L269-L275"},
                                                     :full-name-encode "cljs.reader_desugar-meta",
                                                     :history [["+"
                                                                "0.0-927"]]},
                         "cljs.core/pr" {:ns "cljs.core",
                                         :name "pr",
                                         :signature ["[& objs]"],
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core_pr",
                                         :source {:code "(defn pr\n  [& objs]\n  (pr-with-opts objs (pr-opts)))",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [3121 3127],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3121-L3127"},
                                         :full-name "cljs.core/pr",
                                         :clj-symbol "clojure.core/pr",
                                         :docstring "Prints the object(s) using string-print.  Prints the\nobject(s), separated by spaces if there is more than one.\nBy default, pr and prn print in a way that objects can be\nread by the reader"},
                         "clojure.string/upper-case" {:ns "clojure.string",
                                                      :name "upper-case",
                                                      :signature ["[s]"],
                                                      :history [["+"
                                                                 "0.0-927"]],
                                                      :type "function",
                                                      :full-name-encode "clojure.string_upper-case",
                                                      :source {:code "(defn upper-case\n  [s]\n  (. s (toUpperCase)))",
                                                               :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                               :lines [53
                                                                       56],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/string.cljs#L53-L56"},
                                                      :full-name "clojure.string/upper-case",
                                                      :clj-symbol "clojure.string/upper-case",
                                                      :docstring "Converts string to all upper-case."},
                         "clojure.browser.event/expose" {:full-name "clojure.browser.event/expose",
                                                         :ns "clojure.browser.event",
                                                         :name "expose",
                                                         :type "function",
                                                         :signature ["[e]"],
                                                         :source {:code "(defn expose [e]\n  (goog.events/expose e))",
                                                                  :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                  :lines [79
                                                                          80],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/event.cljs#L79-L80"},
                                                         :full-name-encode "clojure.browser.event_expose",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "clojure.browser.event/listen-once" {:full-name "clojure.browser.event/listen-once",
                                                              :ns "clojure.browser.event",
                                                              :name "listen-once",
                                                              :type "function",
                                                              :signature ["[src type fn]"
                                                                          "[src type fn capture?]"],
                                                              :source {:code "(defn listen-once\n  ([src type fn]\n     (listen-once src type fn false))\n  ([src type fn capture?]\n     (goog.events/listenOnce src\n                             (get (event-types src) type type)\n                             fn\n                             capture?)))",
                                                                       :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                       :lines [53
                                                                               60],
                                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/event.cljs#L53-L60"},
                                                              :full-name-encode "clojure.browser.event_listen-once",
                                                              :history [["+"
                                                                         "0.0-927"]]},
                         "cljs.core/empty?" {:ns "cljs.core",
                                             :name "empty?",
                                             :signature ["[coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_empty_QMARK_",
                                             :source {:code "(defn empty?\n  [coll] (not (seq coll)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [583 586],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L583-L586"},
                                             :full-name "cljs.core/empty?",
                                             :clj-symbol "clojure.core/empty?",
                                             :docstring "Returns true if coll has no items - same as (not (seq coll)).\nPlease use the idiom (seq x) rather than (not (empty? x))"},
                         "cljs.core/newline" {:full-name "cljs.core/newline",
                                              :ns "cljs.core",
                                              :name "newline",
                                              :type "function",
                                              :signature ["[opts]"],
                                              :source {:code "(defn newline [opts]\n  (string-print \"\\n\")\n  (when (get opts :flush-on-newline)\n    (flush)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [3095
                                                               3098],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3095-L3098"},
                                              :full-name-encode "cljs.core_newline",
                                              :clj-symbol "clojure.core/newline",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/replace" {:ns "cljs.core",
                                              :name "replace",
                                              :signature ["[smap coll]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_replace",
                                              :source {:code "(defn replace\n  [smap coll]\n  (if (vector? coll)\n    (let [n (count coll)]\n      (reduce (fn [v i]\n                (if-let [e (find smap (nth v i))]\n                  (assoc v i (second e))\n                  v))\n              coll (take n (iterate inc 0))))\n    (map #(if-let [e (find smap %)] (second e) %) coll)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2719
                                                               2731],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2719-L2731"},
                                              :full-name "cljs.core/replace",
                                              :clj-symbol "clojure.core/replace",
                                              :docstring "Given a map of replacement pairs and a vector/collection, returns a\nvector/seq with any elements = a key in smap replaced with the\ncorresponding val in smap"},
                         "cljs.core/rand" {:ns "cljs.core",
                                           :name "rand",
                                           :signature ["[]" "[n]"],
                                           :shadowed-sources ({:code "(defn rand\n  ([]  (Math/random))\n  ([n] (* n (rand))))",
                                                               :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                               :lines [926
                                                                       929],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L926-L929"}),
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_rand",
                                           :source {:code "(defn rand\n  ([] (rand 1))\n  ([n] (js* \"Math.random() * ~{n}\")))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [3478 3482],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3478-L3482"},
                                           :full-name "cljs.core/rand",
                                           :clj-symbol "clojure.core/rand",
                                           :docstring "Returns a random floating point number between 0 (inclusive) and\nn (default 1) (exclusive)."},
                         "cljs.core/add-watch" {:ns "cljs.core",
                                                :name "add-watch",
                                                :signature ["[iref key f]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_add-watch",
                                                :source {:code "(defn add-watch\n  [iref key f]\n  (-add-watch iref key f))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [3349
                                                                 3371],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3349-L3371"},
                                                :full-name "cljs.core/add-watch",
                                                :clj-symbol "clojure.core/add-watch",
                                                :docstring "Alpha - subject to change.\n\nAdds a watch function to an atom reference. The watch fn must be a\nfn of 4 args: a key, the reference, its old-state, its\nnew-state. Whenever the reference's state might have been changed,\nany registered watches will have their functions called. The watch\nfn will be called synchronously. Note that an atom's state\nmay have changed again prior to the fn call, so use old/new-state\nrather than derefing the reference. Keys must be unique per\nreference, and can be used to remove the watch with remove-watch,\nbut are otherwise considered opaque by the watch mechanism.  Bear in\nmind that regardless of the result or action of the watch fns the\natom's value will change.  Example:\n\n    (def a (atom 0))\n    (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n    (swap! a inc)\n    ;; Assertion Error\n    (deref a)\n    ;=> 1"},
                         "clojure.string/capitalize" {:ns "clojure.string",
                                                      :name "capitalize",
                                                      :signature ["[s]"],
                                                      :history [["+"
                                                                 "0.0-927"]],
                                                      :type "function",
                                                      :full-name-encode "clojure.string_capitalize",
                                                      :source {:code "(defn capitalize\n  [s]\n  (if (< (count s) 2)\n    (upper-case s)\n    (str (upper-case (subs s 0 1))\n         (lower-case (subs s 1)))))",
                                                               :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                               :lines [63
                                                                       70],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/string.cljs#L63-L70"},
                                                      :full-name "clojure.string/capitalize",
                                                      :clj-symbol "clojure.string/capitalize",
                                                      :docstring "Converts first character of the string to upper-case, all other\ncharacters to lower-case."},
                         "cljs.core/replicate" {:ns "cljs.core",
                                                :name "replicate",
                                                :signature ["[n x]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_replicate",
                                                :source {:code "(defn replicate\n  [n x] (take n (repeat x)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1772
                                                                 1774],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1772-L1774"},
                                                :full-name "cljs.core/replicate",
                                                :clj-symbol "clojure.core/replicate",
                                                :docstring "Returns a lazy seq of n xs."},
                         "special/do" {:full-name "special/do",
                                       :ns "special",
                                       :name "do",
                                       :type "special form",
                                       :source {:code "(defmethod parse 'do\n  [op env [_ & exprs] _]\n  (merge {:env env :op :do} (analyze-block env exprs)))",
                                                :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                :lines [761 763],
                                                :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/compiler.clj#L761-L763"},
                                       :full-name-encode "special_do",
                                       :clj-symbol "clojure.core/do",
                                       :history [["+" "0.0-927"]]},
                         "cljs.core/sequential?" {:ns "cljs.core",
                                                  :name "sequential?",
                                                  :signature ["[x]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_sequential_QMARK_",
                                                  :source {:code "(defn sequential?\n  [x] (satisfies? ISequential x))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [606
                                                                   608],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L606-L608"},
                                                  :full-name "cljs.core/sequential?",
                                                  :clj-symbol "clojure.core/sequential?",
                                                  :docstring "Returns true if coll satisfies ISequential"},
                         "cljs.core/underive" {:ns "cljs.core",
                                               :name "underive",
                                               :signature ["[tag parent]"
                                                           "[h tag parent]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_underive",
                                               :source {:code "(defn underive\n  ([tag parent]\n     ;; (alter-var-root #'global-hierarchy underive tag parent)\n     (swap! global-hierarchy underive tag parent) nil)\n  ([h tag parent]\n    (let [parentMap (:parents h)\n          childsParents (if (parentMap tag)\n                          (disj (parentMap tag) parent) #{})\n          newParents (if (not-empty childsParents)\n                      (assoc parentMap tag childsParents)\n                      (dissoc parentMap tag))\n          deriv-seq (flatten (map #(cons (first %) (interpose (first %) (second %)))\n                                  (seq newParents)))]\n      (if (contains? (parentMap tag) parent)\n        (reduce #(apply derive %1 %2) (make-hierarchy)\n                (partition 2 deriv-seq))\n        h))))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [3593
                                                                3612],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3593-L3612"},
                                               :full-name "cljs.core/underive",
                                               :clj-symbol "clojure.core/underive",
                                               :docstring "Removes a parent/child relationship between parent and\ntag. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
                         "cljs.core/get-method" {:ns "cljs.core",
                                                 :name "get-method",
                                                 :signature ["[multifn dispatch-val]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_get-method",
                                                 :source {:code "(defn get-method\n  [multifn dispatch-val] (-get-method multifn dispatch-val))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [3759
                                                                  3762],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3759-L3762"},
                                                 :full-name "cljs.core/get-method",
                                                 :clj-symbol "clojure.core/get-method",
                                                 :docstring "Given a multimethod and a dispatch value, returns the dispatch fn\nthat would apply to that value, or nil if none apply and no default"},
                         "cljs.core/=" {:ns "cljs.core",
                                        :name "=",
                                        :signature ["[x y]"],
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core__EQ_",
                                        :source {:code "(defn =\n  [x y]\n  (-equiv x y))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [206 212],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L206-L212"},
                                        :full-name "cljs.core/=",
                                        :clj-symbol "clojure.core/=",
                                        :docstring "Equality. Returns true if x equals y, false if not. Compares\nnumbers and collections in a type-independent manner.  Clojure's immutable data\nstructures define -equiv (and thus =) as a value, not an identity,\ncomparison."},
                         "cljs.core/defn-" {:ns "cljs.core",
                                            :name "defn-",
                                            :signature ["[name & decls]"],
                                            :history [["+" "0.0-927"]],
                                            :type "macro",
                                            :full-name-encode "cljs.core_defn-",
                                            :source {:code "(defmacro defn-\n  [name & decls]\n    (list* `defn (with-meta name (assoc (meta name) :private true)) decls))",
                                                     :filename "clojure/src/clj/clojure/core.clj",
                                                     :lines [4331
                                                             4335],
                                                     :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L4331-L4335"},
                                            :full-name "cljs.core/defn-",
                                            :clj-symbol "clojure.core/defn-",
                                            :docstring "same as defn, yielding non-public def"},
                         "cljs.reader/read-symbol" {:full-name "cljs.reader/read-symbol",
                                                    :ns "cljs.reader",
                                                    :name "read-symbol",
                                                    :type "function",
                                                    :signature ["[reader initch]"],
                                                    :source {:code "(defn read-symbol\n  [reader initch]\n  (let [token (read-token reader initch)]\n    (if (gstring/contains token \"/\")\n      (symbol (subs token 0 (.indexOf token \"/\"))\n              (subs token (inc (.indexOf token \"/\")) (.-length token)))\n      (get special-symbols token (symbol token)))))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [248
                                                                     254],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L248-L254"},
                                                    :full-name-encode "cljs.reader_read-symbol",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "cljs.reader/push-back-reader" {:full-name "cljs.reader/push-back-reader",
                                                         :ns "cljs.reader",
                                                         :name "push-back-reader",
                                                         :type "function",
                                                         :signature ["[s]"],
                                                         :source {:code "(defn push-back-reader [s]\n  \"Creates a StringPushbackReader from a given string\"\n  (StringPushbackReader. s (atom 0) (atom nil)))",
                                                                  :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                  :lines [30
                                                                          32],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L30-L32"},
                                                         :full-name-encode "cljs.reader_push-back-reader",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "cljs.core/deftype" {:full-name "cljs.core/deftype",
                                              :ns "cljs.core",
                                              :name "deftype",
                                              :type "macro",
                                              :signature ["[t fields & impls]"],
                                              :source {:code "(defmacro deftype [t fields & impls]\n  (let [adorn-params (fn [sig]\n                       (cons (vary-meta (second sig) assoc :cljs.compiler/fields fields)\n                             (nnext sig)))\n        ;;reshape for extend-type\n        dt->et (fn [specs]\n                 (loop [ret [] s specs]\n                   (if (seq s)\n                     (recur (-> ret\n                                (conj (first s))\n                                (into\n                                 (reduce (fn [v [f sigs]]\n                                           (conj v (cons f (map adorn-params sigs))))\n                                         []\n                                         (group-by first (take-while seq? (next s))))))\n                            (drop-while seq? (next s)))\n                     ret)))\n        r (:name (cljs.compiler/resolve-var (dissoc &env :locals) t))]\n    (if (seq impls)\n      `(do\n         (deftype* ~t ~fields)\n         (set! (.-cljs$core$IPrintable$_pr_seq ~t) (fn [this#] (list ~(str r))))\n         (extend-type ~t ~@(dt->et impls))\n         ~t)\n      `(do\n         (deftype* ~t ~fields)\n         (set! (.-cljs$core$IPrintable$_pr_seq ~t) (fn [this#] (list ~(str r))))\n         ~t))))",
                                                       :filename "clojurescript/src/clj/cljs/core.clj",
                                                       :lines [262
                                                               289],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L262-L289"},
                                              :full-name-encode "cljs.core_deftype",
                                              :clj-symbol "clojure.core/deftype",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/Subvec" {:full-name "cljs.core/Subvec",
                                             :ns "cljs.core",
                                             :name "Subvec",
                                             :type "type",
                                             :signature ["[meta v start end]"],
                                             :source {:code "(deftype Subvec [meta v start end]\n  IWithMeta\n  (-with-meta [coll meta] (Subvec. meta v start end))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (-nth v (dec end)))\n  (-pop [coll]\n    (if (= start end)\n      (throw (js/Error. \"Can't pop empty vector\"))\n      (Subvec. meta v start (dec end))))\n\n  ICollection\n  (-conj [coll o]\n    (Subvec. meta (-assoc-n v end o) start (inc end)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Vector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (let [subvec-seq (fn subvec-seq [i]\n                       (when-not (= i end)\n                         (cons (-nth v i)\n                               (lazy-seq\n                                (subvec-seq (inc i))))))]\n      (subvec-seq start)))\n\n  ICounted\n  (-count [coll] (- end start))\n\n  IIndexed\n  (-nth [coll n]\n    (-nth v (+ start n)))\n  (-nth [coll n not-found]\n    (-nth v (+ start n) not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll key val]\n    (let [v-pos (+ start key)]\n      (Subvec. meta (-assoc v v-pos val)\n               start (max end (inc v-pos)))))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [coll f]\n    (ci-reduce coll f))\n  (-reduce [coll f start]\n    (ci-reduce coll f start))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2208
                                                              2278],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2208-L2278"},
                                             :full-name-encode "cljs.core_Subvec",
                                             :history [["+" "0.0-927"]]},
                         "special/ns" {:full-name "special/ns",
                                       :ns "special",
                                       :name "ns",
                                       :type "special form",
                                       :source {:code "(defmethod parse 'ns\n  [_ env [_ name & args] _]\n  (let [excludes\n        (reduce (fn [s [k exclude xs]]\n                  (if (= k :refer-clojure)\n                    (do\n                      (assert (= exclude :exclude) \"Only [:refer-clojure :exclude [names]] form supported\")\n                      (into s xs))\n                    s))\n                #{} args)\n        {uses :use requires :require uses-macros :use-macros requires-macros :require-macros :as params}\n        (reduce (fn [m [k & libs]]\n                  (assert (#{:use :use-macros :require :require-macros} k)\n                          \"Only :refer-clojure, :require, :require-macros, :use and :use-macros libspecs supported\")\n                  (assoc m k (into {}\n                                   (mapcat (fn [[lib kw expr]]\n                                             (case k\n                                               (:require :require-macros)\n                                               (do (assert (and expr (= :as kw))\n                                                           \"Only (:require [lib.ns :as alias]*) form of :require / :require-macros is supported\")\n                                                   [[expr lib]])\n                                               (:use :use-macros)\n                                               (do (assert (and expr (= :only kw))\n                                                           \"Only (:use [lib.ns :only [names]]*) form of :use / :use-macros is supported\")\n                                                   (map vector expr (repeat lib)))))\n                                           libs))))\n                {} (remove (fn [[r]] (= r :refer-clojure)) args))]\n    (set! *cljs-ns* name)\n    (require 'cljs.core)\n    (doseq [nsym (concat (vals requires-macros) (vals uses-macros))]\n      (clojure.core/require nsym))\n    (swap! namespaces #(-> %\n                           (assoc-in [name :name] name)\n                           (assoc-in [name :excludes] excludes)\n                           (assoc-in [name :uses] uses)\n                           (assoc-in [name :requires] requires)\n                           (assoc-in [name :uses-macros] uses-macros)\n                           (assoc-in [name :requires-macros]\n                                     (into {} (map (fn [[alias nsym]]\n                                                     [alias (find-ns nsym)])\n                                                   requires-macros)))))\n    {:env env :op :ns :name name :uses uses :requires requires\n     :uses-macros uses-macros :requires-macros requires-macros :excludes excludes}))",
                                                :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                :lines [844 886],
                                                :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/compiler.clj#L844-L886"},
                                       :full-name-encode "special_ns",
                                       :clj-symbol "clojure.core/ns",
                                       :history [["+" "0.0-927"]]},
                         "cljs.core/extend-protocol" {:ns "cljs.core",
                                                      :name "extend-protocol",
                                                      :signature ["[p & specs]"],
                                                      :history [["+"
                                                                 "0.0-927"]],
                                                      :type "macro",
                                                      :full-name-encode "cljs.core_extend-protocol",
                                                      :source {:code "(defmacro extend-protocol \n  [p & specs]\n  (emit-extend-protocol p specs))",
                                                               :filename "clojure/src/clj/clojure/core_deftype.clj",
                                                               :lines [754
                                                                       792],
                                                               :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core_deftype.clj#L754-L792"},
                                                      :full-name "cljs.core/extend-protocol",
                                                      :clj-symbol "clojure.core/extend-protocol",
                                                      :docstring "Useful when you want to provide several implementations of the same\nprotocol all at once. Takes a single protocol and the implementation\nof that protocol for one or more types. Expands into calls to\nextend-type:\n\n(extend-protocol Protocol\n  AType\n    (foo [x] ...)\n    (bar [x y] ...)\n  BType\n    (foo [x] ...)\n    (bar [x y] ...)\n  AClass\n    (foo [x] ...)\n    (bar [x y] ...)\n  nil\n    (foo [x] ...)\n    (bar [x y] ...))\n\nexpands into:\n\n(do\n (clojure.core/extend-type AType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type BType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type AClass Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type nil Protocol \n   (foo [x] ...) \n   (bar [x y] ...)))"},
                         "cljs.reader/read" {:ns "cljs.reader",
                                             :name "read",
                                             :signature ["[reader eof-is-error sentinel is-recursive]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.reader_read",
                                             :source {:code "(defn read\n  [reader eof-is-error sentinel is-recursive]\n  (let [ch (read-char reader)]\n    (cond\n     (nil? ch) (if eof-is-error (reader-error reader \"EOF\") sentinel)\n     (whitespace? ch) (recur reader eof-is-error sentinel is-recursive)\n     (comment-prefix? ch) (recur (read-comment reader ch) eof-is-error sentinel is-recursive)\n     :else (let [res\n                 (cond\n                  (macros ch) ((macros ch) reader ch)\n                  (number-literal? reader ch) (read-number reader ch)\n                  :else (read-symbol reader ch))]\n     (if (= res reader)\n       (recur reader eof-is-error sentinel is-recursive)\n       res)))))",
                                                      :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                      :lines [338 354],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L338-L354"},
                                             :full-name "cljs.reader/read",
                                             :clj-symbol "clojure.core/read",
                                             :docstring "Reads the first object from a PushbackReader. Returns the object read.\nIf EOF, throws if eof-is-error is true. Otherwise returns sentinel."},
                         "cljs.core/EmptyList" {:full-name "cljs.core/EmptyList",
                                                :ns "cljs.core",
                                                :name "EmptyList",
                                                :type "type",
                                                :signature ["[meta]"],
                                                :source {:code "(deftype EmptyList [meta]\n  IWithMeta\n  (-with-meta [coll meta] (EmptyList. meta))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] nil)\n  (-rest [coll] nil)\n\n  IStack\n  (-peek [coll] nil)\n  (-pop [coll] #_(throw (js/Error. \"Can't pop empty list\")))\n\n  ICollection\n  (-conj [coll o] (List. meta o nil 1))\n\n  IEmptyableCollection\n  (-empty [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] nil)\n\n  ICounted\n  (-count [coll] 0))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1157
                                                                 1189],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1157-L1189"},
                                                :full-name-encode "cljs.core_EmptyList",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "clojure.walk/postwalk" {:ns "clojure.walk",
                                                  :name "postwalk",
                                                  :signature ["[f form]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.walk_postwalk",
                                                  :source {:code "(defn postwalk\n  [f form]\n  (walk (partial postwalk f) f form))",
                                                           :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                           :lines [50
                                                                   56],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/walk.cljs#L50-L56"},
                                                  :full-name "clojure.walk/postwalk",
                                                  :clj-symbol "clojure.walk/postwalk",
                                                  :docstring "Performs a depth-first, post-order traversal of form.  Calls f on\neach sub-form, uses f's return value in place of the original.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
                         "clojure.zip/edit" {:ns "clojure.zip",
                                             :name "edit",
                                             :signature ["[loc f & args]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_edit",
                                             :source {:code "(defn edit\n  [loc f & args]\n    (replace loc (apply f (node loc) args)))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [189 192],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L189-L192"},
                                             :full-name "clojure.zip/edit",
                                             :clj-symbol "clojure.zip/edit",
                                             :docstring "Replaces the node at this loc with the value of (f node args)"},
                         "cljs.core/re-seq" {:ns "cljs.core",
                                             :name "re-seq",
                                             :signature ["[re s]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_re-seq",
                                             :source {:code "(defn re-seq\n  [re s]\n  (let [match-data (re-find re s)\n        match-idx (.search s re)\n        match-str (if (coll? match-data) (first match-data) match-data)\n        post-match (subs s (+ match-idx (count match-str)))]\n    (when match-data (lazy-seq (cons match-data (re-seq re post-match))))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [3018
                                                              3025],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3018-L3025"},
                                             :full-name "cljs.core/re-seq",
                                             :clj-symbol "clojure.core/re-seq",
                                             :docstring "Returns a lazy sequence of successive matches of re in s."},
                         "cljs.reader/read-list" {:full-name "cljs.reader/read-list",
                                                  :ns "cljs.reader",
                                                  :name "read-list",
                                                  :type "function",
                                                  :signature ["[rdr _]"],
                                                  :source {:code "(defn read-list\n  [rdr _]\n  (apply list (read-delimited-list \")\" rdr true)))",
                                                           :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                           :lines [203
                                                                   205],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L203-L205"},
                                                  :full-name-encode "cljs.reader_read-list",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/Atom" {:full-name "cljs.core/Atom",
                                           :ns "cljs.core",
                                           :name "Atom",
                                           :type "type",
                                           :signature ["[state meta validator watches]"],
                                           :source {:code "(deftype Atom [state meta validator watches]\n  IEquiv\n  (-equiv [o other] (identical? o other))\n\n  IDeref\n  (-deref [_] state)\n\n  IMeta\n  (-meta [_] meta)\n\n  IPrintable\n  (-pr-seq [a opts]\n    (concat  [\"#<Atom: \"] (-pr-seq state opts) \">\"))\n\n  IWatchable\n  (-notify-watches [this oldval newval]\n    (doseq [[key f] watches]\n      (f key this oldval newval)))\n  (-add-watch [this key f]\n    (set! (.-watches this) (assoc watches key f)))\n  (-remove-watch [this key]\n    (set! (.-watches this) (dissoc watches key)))\n\n  IHash\n  (-hash [this] (goog.getUid this)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [3234 3258],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3234-L3258"},
                                           :full-name-encode "cljs.core_Atom",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/IMap" {:ns "cljs.core",
                                           :name "IMap",
                                           :type "protocol",
                                           :full-name-encode "cljs.core_IMap",
                                           :source {:code "(defprotocol IMap\n  #_(-assoc-ex [coll k v])\n  (-dissoc [coll k]))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [145 147],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L145-L147"},
                                           :methods [{:name "-dissoc",
                                                      :signature ["[coll k]"],
                                                      :docstring nil}],
                                           :full-name "cljs.core/IMap",
                                           :history [["+" "0.0-927"]]},
                         "cljs.reader/read-vector" {:full-name "cljs.reader/read-vector",
                                                    :ns "cljs.reader",
                                                    :name "read-vector",
                                                    :type "function",
                                                    :signature ["[rdr _]"],
                                                    :source {:code "(defn read-vector\n  [rdr _]\n  (read-delimited-list \"]\" rdr true))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [209
                                                                     211],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L209-L211"},
                                                    :full-name-encode "cljs.reader_read-vector",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "clojure.set/join" {:ns "clojure.set",
                                             :name "join",
                                             :signature ["[xrel yrel]"
                                                         "[xrel yrel km]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.set_join",
                                             :source {:code "(defn join\n  ([xrel yrel] ;natural join\n   (if (and (seq xrel) (seq yrel))\n     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n           [r s] (if (<= (count xrel) (count yrel))\n                   [xrel yrel]\n                   [yrel xrel])\n           idx (index r ks)]\n       (reduce (fn [ret x]\n                 (let [found (idx (select-keys x ks))]\n                   (if found\n                     (reduce #(conj %1 (merge %2 x)) ret found)\n                     ret)))\n               #{} s))\n     #{}))\n  ([xrel yrel km] ;arbitrary key mapping\n   (let [[r s k] (if (<= (count xrel) (count yrel))\n                   [xrel yrel (map-invert km)]\n                   [yrel xrel km])\n         idx (index r (vals k))]\n     (reduce (fn [ret x]\n               (let [found (idx (rename-keys (select-keys x (keys k)) k))]\n                 (if found\n                   (reduce #(conj %1 (merge %2 x)) ret found)\n                   ret)))\n             #{} s))))",
                                                      :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                      :lines [102 130],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/set.cljs#L102-L130"},
                                             :full-name "clojure.set/join",
                                             :clj-symbol "clojure.set/join",
                                             :docstring "When passed 2 rels, returns the rel corresponding to the natural\njoin. When passed an additional keymap, joins on the corresponding\nkeys."},
                         "cljs.core/HashMap" {:full-name "cljs.core/HashMap",
                                              :ns "cljs.core",
                                              :name "HashMap",
                                              :type "type",
                                              :signature ["[meta count hashobj]"],
                                              :source {:code "(deftype HashMap [meta count hashobj]\n  IWithMeta\n  (-with-meta [coll meta] (HashMap. meta count hashobj))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.HashMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? count)\n      (let [hashes (.sort (js-keys hashobj))]\n        (mapcat #(map vec (partition 2 (aget hashobj %)))\n                hashes))))\n\n  ICounted\n  (-count [coll] count)\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        (aget bucket (inc i))\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [h (hash k)\n          bucket (aget hashobj h)]\n      (if bucket\n        (let [new-bucket (aclone bucket)\n              new-hashobj (goog.object/clone hashobj)]\n          (aset new-hashobj h new-bucket)\n          (if-let [i (scan-array 2 k new-bucket)]\n            (do                         ; found key, replace\n              (aset new-bucket (inc i) v)\n              (HashMap. meta count new-hashobj))\n            (do                         ; did not find key, append\n              (.push new-bucket k v)\n              (HashMap. meta (inc count) new-hashobj))))\n        (let [new-hashobj (goog.object/clone hashobj)] ; did not find bucket\n          (aset new-hashobj h (array k v))\n          (HashMap. meta (inc count) new-hashobj)))))\n  (-contains-key? [coll k]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        true\n        false)))\n\n  IMap\n  (-dissoc [coll k]\n    (let [h (hash k)\n          bucket (aget hashobj h)\n          i (when bucket (scan-array 2 k bucket))]\n      (if (not i)\n        coll ; key not found, return coll unchanged\n        (let [new-hashobj (goog.object/clone hashobj)]\n          (if (> 3 (.-length bucket))\n            (js-delete new-hashobj h)\n            (let [new-bucket (aclone bucket)]\n              (.splice new-bucket i 2)\n              (aset new-hashobj h new-bucket)))\n          (HashMap. meta (dec count) new-hashobj)))))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2502
                                                               2589],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2502-L2589"},
                                              :full-name-encode "cljs.core_HashMap",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.reader/int-pattern" {:full-name "cljs.reader/int-pattern",
                                                    :ns "cljs.reader",
                                                    :name "int-pattern",
                                                    :type "var",
                                                    :source {:code "(def int-pattern (re-pattern \"([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?\"))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [95
                                                                     95],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L95-L95"},
                                                    :full-name-encode "cljs.reader_int-pattern",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "cljs.core/swap!" {:ns "cljs.core",
                                            :name "swap!",
                                            :signature ["[a f]"
                                                        "[a f x]"
                                                        "[a f x y]"
                                                        "[a f x y z]"
                                                        "[a f x y z & more]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_swap_BANG_",
                                            :source {:code "(defn swap!\n  ([a f]\n     (reset! a (f (.-state a))))\n  ([a f x]\n     (reset! a (f (.-state a) x)))\n  ([a f x y]\n     (reset! a (f (.-state a) x y)))\n  ([a f x y z]\n     (reset! a (f (.-state a) x y z)))\n  ([a f x y z & more]\n     (reset! a (apply f (.-state a) x y z more))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [3288
                                                             3302],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3288-L3302"},
                                            :full-name "cljs.core/swap!",
                                            :clj-symbol "clojure.core/swap!",
                                            :docstring "Atomically swaps the value of atom to be:\n(apply f current-value-of-atom args). Note that f may be called\nmultiple times, and thus should be free of side effects.  Returns\nthe value that was swapped in."},
                         "cljs.core/dec" {:ns "cljs.core",
                                          :name "dec",
                                          :signature ["[x]"],
                                          :shadowed-sources ({:code "(defmacro dec [x]\n  `(- ~x 1))",
                                                              :filename "clojurescript/src/clj/cljs/core.clj",
                                                              :lines [113
                                                                      114],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L113-L114"}),
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_dec",
                                          :source {:code "(defn dec\n  [x] (- x 1))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [886 888],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L886-L888"},
                                          :full-name "cljs.core/dec",
                                          :clj-symbol "clojure.core/dec",
                                          :docstring "Returns a number one less than num."},
                         "clojure.browser.dom/remove-children" {:full-name "clojure.browser.dom/remove-children",
                                                                :ns "clojure.browser.dom",
                                                                :name "remove-children",
                                                                :docstring "Remove all children from the element with the passed id.",
                                                                :type "function",
                                                                :signature ["[id]"],
                                                                :source {:code "(defn remove-children\n  [id]\n  (let [parent (gdom/getElement (name id))]\n    (do (gdom/removeChildren parent))))",
                                                                         :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                         :lines [90
                                                                                 94],
                                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/dom.cljs#L90-L94"},
                                                                :full-name-encode "clojure.browser.dom_remove-children",
                                                                :history [["+"
                                                                           "0.0-927"]]},
                         "cljs.core/get-validator" {:ns "cljs.core",
                                                    :name "get-validator",
                                                    :signature ["[iref]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_get-validator",
                                                    :source {:code "(defn get-validator\n  [iref]\n  (.-validator iref))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [3330
                                                                     3333],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3330-L3333"},
                                                    :full-name "cljs.core/get-validator",
                                                    :clj-symbol "clojure.core/get-validator",
                                                    :docstring "Gets the validator-fn for a var/ref/agent/atom."},
                         "cljs.core/coll?" {:ns "cljs.core",
                                            :name "coll?",
                                            :signature ["[x]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_coll_QMARK_",
                                            :source {:code "(defn coll?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ICollection x)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [588 593],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L588-L593"},
                                            :full-name "cljs.core/coll?",
                                            :clj-symbol "clojure.core/coll?",
                                            :docstring "Returns true if x satisfies ICollection"},
                         "cljs.core/bit-or" {:ns "cljs.core",
                                             :name "bit-or",
                                             :signature ["[x y]"],
                                             :shadowed-sources ({:code "(defmacro bit-or\n  ([x y] (list 'js* \"(~{} | ~{})\" x y))\n  ([x y & more] `(bit-or (bit-or ~x ~y) ~@more)))",
                                                                 :filename "clojurescript/src/clj/cljs/core.clj",
                                                                 :lines [148
                                                                         150],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L148-L150"}),
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_bit-or",
                                             :source {:code "(defn bit-or\n  [x y] (cljs.core/bit-or x y))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [943 945],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L943-L945"},
                                             :full-name "cljs.core/bit-or",
                                             :clj-symbol "clojure.core/bit-or",
                                             :docstring "Bitwise or"},
                         "cljs.core/nfirst" {:ns "cljs.core",
                                             :name "nfirst",
                                             :signature ["[coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_nfirst",
                                             :source {:code "(defn nfirst\n  [coll]\n  (next (first coll)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [442 445],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L442-L445"},
                                             :full-name "cljs.core/nfirst",
                                             :clj-symbol "clojure.core/nfirst",
                                             :docstring "Same as (next (first x))"},
                         "cljs.core/keep" {:ns "cljs.core",
                                           :name "keep",
                                           :signature ["[f coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_keep",
                                           :source {:code "(defn keep\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (let [x (f (first s))]\n        (if (nil? x)\n          (keep f (rest s))\n          (cons x (keep f (rest s)))))))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1578 1588],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1578-L1588"},
                                           :full-name "cljs.core/keep",
                                           :clj-symbol "clojure.core/keep",
                                           :docstring "Returns a lazy sequence of the non-nil results of (f item). Note,\nthis means false return values will be included.  f must be free of\nside-effects."},
                         "cljs.core/take" {:ns "cljs.core",
                                           :name "take",
                                           :signature ["[n coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_take",
                                           :source {:code "(defn take\n  [n coll]\n  (lazy-seq\n   (when (pos? n)\n     (when-let [s (seq coll)]\n      (cons (first s) (take (dec n) (rest s)))))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1712 1719],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1712-L1719"},
                                           :full-name "cljs.core/take",
                                           :clj-symbol "clojure.core/take",
                                           :docstring "Returns a lazy sequence of the first n items in coll, or all items if\nthere are fewer than n."},
                         "cljs.core/cond" {:ns "cljs.core",
                                           :name "cond",
                                           :signature ["[& clauses]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_cond",
                                           :source {:code "(defmacro cond\n  [& clauses]\n    (when clauses\n      (list 'if (first clauses)\n            (if (next clauses)\n                (second clauses)\n                (throw (IllegalArgumentException.\n                         \"cond requires an even number of forms\")))\n            (cons 'clojure.core/cond (next (next clauses))))))",
                                                    :filename "clojure/src/clj/clojure/core.clj",
                                                    :lines [534 547],
                                                    :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L534-L547"},
                                           :full-name "cljs.core/cond",
                                           :clj-symbol "clojure.core/cond",
                                           :docstring "Takes a set of test/expr pairs. It evaluates each test one at a\ntime.  If a test returns logical true, cond evaluates and returns\nthe value of the corresponding expr and doesn't evaluate any of the\nother tests or exprs. (cond) returns nil."},
                         "cljs.core/bit-and" {:ns "cljs.core",
                                              :name "bit-and",
                                              :signature ["[x y]"],
                                              :shadowed-sources ({:code "(defmacro bit-and\n  ([x y] (list 'js* \"(~{} & ~{})\" x y))\n  ([x y & more] `(bit-and (bit-and ~x ~y) ~@more)))",
                                                                  :filename "clojurescript/src/clj/cljs/core.clj",
                                                                  :lines [144
                                                                          146],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L144-L146"}),
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_bit-and",
                                              :source {:code "(defn bit-and\n  [x y] (cljs.core/bit-and x y))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [939
                                                               941],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L939-L941"},
                                              :full-name "cljs.core/bit-and",
                                              :clj-symbol "clojure.core/bit-and",
                                              :docstring "Bitwise and"},
                         "clojure.browser.event/unique-event-id" {:full-name "clojure.browser.event/unique-event-id",
                                                                  :ns "clojure.browser.event",
                                                                  :name "unique-event-id",
                                                                  :type "function",
                                                                  :signature ["[event-type]"],
                                                                  :source {:code "(defn unique-event-id [event-type])",
                                                                           :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                           :lines [92
                                                                                   92],
                                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/event.cljs#L92-L92"},
                                                                  :full-name-encode "clojure.browser.event_unique-event-id",
                                                                  :history [["+"
                                                                             "0.0-927"]]},
                         "clojure.set/project" {:ns "clojure.set",
                                                :name "project",
                                                :signature ["[xrel ks]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.set_project",
                                                :source {:code "(defn project\n  [xrel ks]\n    (set (map #(select-keys % ks) xrel)))",
                                                         :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                         :lines [67
                                                                 70],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/set.cljs#L67-L70"},
                                                :full-name "clojure.set/project",
                                                :clj-symbol "clojure.set/project",
                                                :docstring "Returns a rel of the elements of xrel with only the keys in ks"},
                         "special/js*" {:full-name "special/js*",
                                        :ns "special",
                                        :name "js*",
                                        :type "special form",
                                        :source {:code "(defmethod parse 'js*\n  [op env [_ form & args] _]\n  (assert (string? form))\n  (if args\n    (disallowing-recur\n     (let [seg (fn seg [^String s]\n                 (let [idx (.indexOf s \"~{\")]\n                   (if (= -1 idx)\n                     (list s)\n                     (let [end (.indexOf s \"}\" idx)]\n                       (cons (subs s 0 idx) (seg (subs s (inc end))))))))\n           enve (assoc env :context :expr)\n           argexprs (vec (map #(analyze enve %) args))]\n       {:env env :op :js :segs (seg form) :args argexprs :children argexprs}))\n    (let [interp (fn interp [^String s]\n                   (let [idx (.indexOf s \"~{\")]\n                     (if (= -1 idx)\n                       (list s)\n                       (let [end (.indexOf s \"}\" idx)\n                             inner (:name (resolve-existing-var env (symbol (subs s (+ 2 idx) end))))]\n                         (cons (subs s 0 idx) (cons inner (interp (subs s (inc end)))))))))]\n      {:env env :op :js :code (apply str (interp form))})))",
                                                 :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                 :lines [994 1015],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/compiler.clj#L994-L1015"},
                                        :full-name-encode "special_js_STAR_",
                                        :history [["+" "0.0-927"]]},
                         "clojure.string/trim-newline" {:ns "clojure.string",
                                                        :name "trim-newline",
                                                        :signature ["[s]"],
                                                        :history [["+"
                                                                   "0.0-927"]],
                                                        :type "function",
                                                        :full-name-encode "clojure.string_trim-newline",
                                                        :source {:code "(defn trim-newline\n  [s]\n  (loop [index (.-length s)]\n    (if (zero? index)\n      \"\"\n      (let [ch (get s (dec index))]\n        (if (or (= ch \\newline) (= ch \\return))\n          (recur (dec index))\n          (.substring s 0 index))))))",
                                                                 :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                                 :lines [121
                                                                         131],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/string.cljs#L121-L131"},
                                                        :full-name "clojure.string/trim-newline",
                                                        :clj-symbol "clojure.string/trim-newline",
                                                        :docstring "Removes all trailing newline \\n or return \\r characters from\nstring.  Similar to Perl's chomp."},
                         "specialrepl/in-ns" {:full-name "specialrepl/in-ns",
                                              :ns "specialrepl",
                                              :name "in-ns",
                                              :type "special form (repl)",
                                              :source {:code "(def default-special-fns\n  (let [load-file-fn (fn [repl-env file] (load-file repl-env file))]\n    {'in-ns (fn [_ quoted-ns] (set! comp/*cljs-ns* (second quoted-ns)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace (fn [repl-env ns] (load-namespace repl-env ns))}))",
                                                       :filename "clojurescript/src/clj/cljs/repl.clj",
                                                       :lines [134
                                                               139],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/repl.clj#L134-L139"},
                                              :full-name-encode "specialrepl_in-ns",
                                              :clj-symbol "clojure.core/in-ns",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "special/let*" {:full-name "special/let*",
                                         :ns "special",
                                         :name "let*",
                                         :type "special form",
                                         :source {:code "(defmethod parse 'let*\n  [op encl-env form _]\n  (analyze-let encl-env form false))",
                                                  :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                  :lines [793 795],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/compiler.clj#L793-L795"},
                                         :full-name-encode "special_let_STAR_",
                                         :history [["+" "0.0-927"]]},
                         "special/throw" {:full-name "special/throw",
                                          :ns "special",
                                          :name "throw",
                                          :type "special form",
                                          :source {:code "(defmethod parse 'throw\n  [op env [_ throw :as form] name]\n  (let [throw-expr (disallowing-recur (analyze (assoc env :context :expr) throw))]\n    {:env env :op :throw :form form\n     :throw throw-expr\n     :children [throw-expr]}))",
                                                   :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                   :lines [647 652],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/compiler.clj#L647-L652"},
                                          :full-name-encode "special_throw",
                                          :clj-symbol "clojure.core/throw",
                                          :history [["+" "0.0-927"]]},
                         "clojure.zip/insert-left" {:ns "clojure.zip",
                                                    :name "insert-left",
                                                    :signature ["[loc item]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "clojure.zip_insert-left",
                                                    :source {:code "(defn insert-left\n  [loc item]\n    (let [[node {l :l :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :l (conj l item) :changed? true)] (meta loc)))))",
                                                             :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                             :lines [165
                                                                     172],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L165-L172"},
                                                    :full-name "clojure.zip/insert-left",
                                                    :clj-symbol "clojure.zip/insert-left",
                                                    :docstring "Inserts the item as the left sibling of the node at this loc,\nwithout moving"},
                         "cljs.core/true?" {:ns "cljs.core",
                                            :name "true?",
                                            :signature ["[x]"],
                                            :shadowed-sources ({:code "(defmacro true? [x]\n  (list 'js* \"~{} === true\" x))",
                                                                :filename "clojurescript/src/clj/cljs/core.clj",
                                                                :lines [48
                                                                        49],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L48-L49"}),
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_true_QMARK_",
                                            :source {:code "(defn true?\n  [x] (cljs.core/true? x))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [645 647],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L645-L647"},
                                            :full-name "cljs.core/true?",
                                            :clj-symbol "clojure.core/true?",
                                            :docstring "Returns true if x is the value true, false otherwise."},
                         "clojure.browser.net/xpc-connection" {:full-name "clojure.browser.net/xpc-connection",
                                                               :ns "clojure.browser.net",
                                                               :name "xpc-connection",
                                                               :docstring "When passed with a config hash-map, returns a parent\nCrossPageChannel object. Keys in the config hash map are downcased\nversions of the goog.net.xpc.CfgFields enum keys,\ne.g. goog.net.xpc.CfgFields.PEER_URI becomes :peer_uri in the config\nhash.\n\nWhen passed with no args, creates a child CrossPageChannel object,\nand the config is automatically taken from the URL param 'xpc', as\nper the CrossPageChannel API.",
                                                               :type "function",
                                                               :signature ["[]"
                                                                           "[config]"],
                                                               :source {:code "(defn xpc-connection\n  ([]\n     (when-let [config (.getParameterValue\n                        (goog.Uri. (.-href (.-location js/window)))\n                        \"xpc\")]\n       (goog.net.xpc.CrossPageChannel. (gjson/parse config))))\n  ([config]\n     (goog.net.xpc.CrossPageChannel.\n      (.-strobj (reduce (fn [sum [k v]]\n                          (if-let [field (get xpc-config-fields k)]\n                            (assoc sum field v)\n                            sum))\n                       {}\n                       config)))))",
                                                                        :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                        :lines [118
                                                                                140],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/net.cljs#L118-L140"},
                                                               :full-name-encode "clojure.browser.net_xpc-connection",
                                                               :history [["+"
                                                                          "0.0-927"]]},
                         "cljs.core/not" {:ns "cljs.core",
                                          :name "not",
                                          :signature ["[x]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_not",
                                          :source {:code "(defn not\n  [x] (if x false true))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [475 477],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L475-L477"},
                                          :full-name "cljs.core/not",
                                          :clj-symbol "clojure.core/not",
                                          :docstring "Returns true if x is logical false, false otherwise."},
                         "cljs.core/js-obj" {:full-name "cljs.core/js-obj",
                                             :ns "cljs.core",
                                             :name "js-obj",
                                             :type "function",
                                             :signature ["[]"],
                                             :source {:code "(defn js-obj []\n  (js* \"{}\"))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [626 627],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L626-L627"},
                                             :full-name-encode "cljs.core_js-obj",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/complement" {:ns "cljs.core",
                                                 :name "complement",
                                                 :signature ["[f]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_complement",
                                                 :source {:code "(defn complement\n  [f]\n  (fn\n    ([] (not (f)))\n    ([x] (not (f x)))\n    ([x y] (not (f x y)))\n    ([x y & zs] (not (apply f x y zs)))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [1486
                                                                  1494],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1486-L1494"},
                                                 :full-name "cljs.core/complement",
                                                 :clj-symbol "clojure.core/complement",
                                                 :docstring "Takes a fn f and returns a fn that takes the same arguments as f,\nhas the same effects, if any, and returns the opposite truth value."},
                         "cljs.core/spread" {:full-name "cljs.core/spread",
                                             :ns "cljs.core",
                                             :name "spread",
                                             :type "function",
                                             :signature ["[arglist]"],
                                             :source {:code "(defn spread\n  [arglist]\n  (cond\n   (nil? arglist) nil\n   (nil? (next arglist)) (seq (first arglist))\n   :else (cons (first arglist)\n               (spread (next arglist)))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1341
                                                              1347],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1341-L1347"},
                                             :full-name-encode "cljs.core_spread",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/keyword" {:ns "cljs.core",
                                              :name "keyword",
                                              :signature ["[name]"
                                                          "[ns name]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_keyword",
                                              :source {:code "(defn keyword\n  ([name] (cond (keyword? name) name\n                (symbol? name) (str* \"\\uFDD0\" \"'\" (subs name 2))\n                :else (str* \"\\uFDD0\" \"'\" name)))\n  ([ns name] (keyword (str* ns \"/\" name))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1078
                                                               1084],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1078-L1084"},
                                              :full-name "cljs.core/keyword",
                                              :clj-symbol "clojure.core/keyword",
                                              :docstring "Returns a Keyword with the given namespace and name.  Do not use :\nin the keyword strings, it will be added automatically."},
                         "cljs.core/sort" {:ns "cljs.core",
                                           :name "sort",
                                           :signature ["[coll]"
                                                       "[comp coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_sort",
                                           :source {:code "(defn sort\n  ([coll]\n   (sort compare coll))\n  ([comp coll]\n   (if (seq coll)\n     (let [a (to-array coll)]\n       ;; matching Clojure's stable sort, though docs don't promise it\n       (garray/stableSort a (fn->comparator comp))\n       (seq a))\n     ())))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [748 760],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L748-L760"},
                                           :full-name "cljs.core/sort",
                                           :clj-symbol "clojure.core/sort",
                                           :docstring "Returns a sorted sequence of the items in coll. Comp can be\nboolean-valued comparison funcion, or a -/0/+ valued comparator.\nComp defaults to compare."},
                         "clojure.string/trim" {:ns "clojure.string",
                                                :name "trim",
                                                :signature ["[s]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.string_trim",
                                                :source {:code "(defn trim\n    [s]\n    (gstring/trim s))",
                                                         :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                         :lines [106
                                                                 109],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/string.cljs#L106-L109"},
                                                :full-name "clojure.string/trim",
                                                :clj-symbol "clojure.string/trim",
                                                :docstring "Removes whitespace from both ends of string."},
                         "cljs.core/meta" {:ns "cljs.core",
                                           :name "meta",
                                           :signature ["[o]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_meta",
                                           :source {:code "(defn meta\n  [o]\n  (when (satisfies? IMeta o)\n    (-meta o)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [549 553],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L549-L553"},
                                           :full-name "cljs.core/meta",
                                           :clj-symbol "clojure.core/meta",
                                           :docstring "Returns the metadata of obj, returns nil if there is no metadata."},
                         "cljs.core/time" {:ns "cljs.core",
                                           :name "time",
                                           :signature ["[expr]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_time",
                                           :source {:code "(defmacro time\n  [expr]\n  `(let [start# (.getTime (js/Date.) ())\n         ret# ~expr]\n     (prn (str \"Elapsed time: \" (- (.getTime (js/Date.) ()) start#) \" msecs\"))\n     ret#))",
                                                    :filename "clojurescript/src/clj/cljs/core.clj",
                                                    :lines [762 768],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L762-L768"},
                                           :full-name "cljs.core/time",
                                           :clj-symbol "clojure.core/time",
                                           :docstring "Evaluates expr and prints the time it took. Returns the value of expr."},
                         "cljs.core/boolean" {:full-name "cljs.core/boolean",
                                              :ns "cljs.core",
                                              :name "boolean",
                                              :type "function",
                                              :signature ["[x]"],
                                              :source {:code "(defn boolean [x]\n  (if x true false))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [662
                                                               663],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L662-L663"},
                                              :full-name-encode "cljs.core_boolean",
                                              :clj-symbol "clojure.core/boolean",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.reader/read-token" {:full-name "cljs.reader/read-token",
                                                   :ns "cljs.reader",
                                                   :name "read-token",
                                                   :type "function",
                                                   :signature ["[rdr initch]"],
                                                   :source {:code "(defn read-token\n  [rdr initch]\n  (loop [sb (gstring/StringBuffer. initch)\n         ch (read-char rdr)]\n    (if (or (nil? ch)\n            (whitespace? ch)\n            (macro-terminating? ch))\n      (do (unread rdr ch) (. sb (toString)))\n      (recur (do (.append sb ch) sb) (read-char rdr)))))",
                                                            :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                            :lines [76
                                                                    84],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L76-L84"},
                                                   :full-name-encode "cljs.reader_read-token",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "cljs.core/update-in" {:ns "cljs.core",
                                                :name "update-in",
                                                :signature ["[m [k & ks] f & args]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_update-in",
                                                :source {:code "(defn update-in\n  ([m [k & ks] f & args]\n   (if ks\n     (assoc m k (apply update-in (get m k) ks f args))\n     (assoc m k (apply f (get m k) args)))))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1924
                                                                 1933],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1924-L1933"},
                                                :full-name "cljs.core/update-in",
                                                :clj-symbol "clojure.core/update-in",
                                                :docstring "'Updates' a value in a nested associative structure, where ks is a\nsequence of keys and f is a function that will take the old value\nand any supplied args and return the new value, and returns a new\nnested structure.  If any levels do not exist, hash-maps will be\ncreated."},
                         "cljs.core/map-indexed" {:ns "cljs.core",
                                                  :name "map-indexed",
                                                  :signature ["[f coll]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_map-indexed",
                                                  :source {:code "(defn map-indexed\n  [f coll]\n  (let [mapi (fn mpi [idx coll]\n               (lazy-seq\n                (when-let [s (seq coll)]\n                  (cons (f idx (first s))\n                        (mpi (inc idx) (rest s))))))]\n    (mapi 0 coll)))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [1565
                                                                   1576],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1565-L1576"},
                                                  :full-name "cljs.core/map-indexed",
                                                  :clj-symbol "clojure.core/map-indexed",
                                                  :docstring "Returns a lazy sequence consisting of the result of applying f to 0\nand the first item of coll, followed by applying f to 1 and the second\nitem in coll, etc, until coll is exhausted. Thus function f should\naccept 2 arguments, index and item."},
                         "cljs.core/IStack" {:ns "cljs.core",
                                             :name "IStack",
                                             :type "protocol",
                                             :full-name-encode "cljs.core_IStack",
                                             :source {:code "(defprotocol IStack\n  (-peek [coll])\n  (-pop [coll]))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [152 154],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L152-L154"},
                                             :methods [{:name "-peek",
                                                        :signature ["[coll]"],
                                                        :docstring nil}
                                                       {:name "-pop",
                                                        :signature ["[coll]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/IStack",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/IIndexed" {:ns "cljs.core",
                                               :name "IIndexed",
                                               :type "protocol",
                                               :full-name-encode "cljs.core_IIndexed",
                                               :source {:code "(defprotocol IIndexed\n  (-nth [coll n] [coll n not-found]))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [130
                                                                131],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L130-L131"},
                                               :methods [{:name "-nth",
                                                          :signature ["[coll n]"
                                                                      "[coll n not-found]"],
                                                          :docstring nil}],
                                               :full-name "cljs.core/IIndexed",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "clojure.browser.repl/repl-print" {:full-name "clojure.browser.repl/repl-print",
                                                            :ns "clojure.browser.repl",
                                                            :name "repl-print",
                                                            :type "function",
                                                            :signature ["[data]"],
                                                            :source {:code "(defn repl-print [data]\n  (if-let [conn @xpc-connection]\n    (net/transmit conn :print (pr-str data))))",
                                                                     :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                     :lines [23
                                                                             25],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/repl.cljs#L23-L25"},
                                                            :full-name-encode "clojure.browser.repl_repl-print",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "clojure.browser.net/xpc-config-fields" {:full-name "clojure.browser.net/xpc-config-fields",
                                                                  :ns "clojure.browser.net",
                                                                  :name "xpc-config-fields",
                                                                  :type "var",
                                                                  :source {:code "(def xpc-config-fields\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (. k (toLowerCase)))\n            v])\n         (js->clj goog.net.xpc.CfgFields))))",
                                                                           :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                           :lines [75
                                                                                   81],
                                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/net.cljs#L75-L81"},
                                                                  :full-name-encode "clojure.browser.net_xpc-config-fields",
                                                                  :history [["+"
                                                                             "0.0-927"]]},
                         "cljs.core/nnext" {:ns "cljs.core",
                                            :name "nnext",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_nnext",
                                            :source {:code "(defn nnext\n  [coll]\n  (next (next coll)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [452 455],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L452-L455"},
                                            :full-name "cljs.core/nnext",
                                            :clj-symbol "clojure.core/nnext",
                                            :docstring "Same as (next (next x))"},
                         "cljs.core/*print-meta*" {:full-name "cljs.core/*print-meta*",
                                                   :ns "cljs.core",
                                                   :name "*print-meta*",
                                                   :type "var",
                                                   :source {:code "(def *print-meta* false)",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [3102
                                                                    3102],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3102-L3102"},
                                                   :full-name-encode "cljs.core__STAR_print-meta_STAR_",
                                                   :clj-symbol "clojure.core/*print-meta*",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "cljs.reader/read-dispatch" {:full-name "cljs.reader/read-dispatch",
                                                      :ns "cljs.reader",
                                                      :name "read-dispatch",
                                                      :type "function",
                                                      :signature ["[rdr _]"],
                                                      :source {:code "(defn read-dispatch\n  [rdr _]\n  (let [ch (read-char rdr)\n        dm (get dispatch-macros ch)]\n    (if dm\n      (dm rdr _)\n      (reader-error rdr \"No dispatch macro for \" ch))))",
                                                               :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                               :lines [191
                                                                       197],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L191-L197"},
                                                      :full-name-encode "cljs.reader_read-dispatch",
                                                      :history [["+"
                                                                 "0.0-927"]]},
                         "cljs.core/distinct" {:ns "cljs.core",
                                               :name "distinct",
                                               :signature ["[coll]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_distinct",
                                               :source {:code "(defn distinct\n  [coll]\n  (let [step (fn step [xs seen]\n               (lazy-seq\n                ((fn [[f :as xs] seen]\n                   (when-let [s (seq xs)]\n                     (if (contains? seen f)\n                       (recur (rest s) seen)\n                       (cons f (step (rest s) (conj seen f))))))\n                 xs seen)))]\n    (step coll #{})))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [2733
                                                                2744],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2733-L2744"},
                                               :full-name "cljs.core/distinct",
                                               :clj-symbol "clojure.core/distinct",
                                               :docstring "Returns a lazy sequence of the elements of coll with duplicates removed"},
                         "cljs.reader/wrapping-reader" {:full-name "cljs.reader/wrapping-reader",
                                                        :ns "cljs.reader",
                                                        :name "wrapping-reader",
                                                        :type "function",
                                                        :signature ["[sym]"],
                                                        :source {:code "(defn wrapping-reader\n  [sym]\n  (fn [rdr _]\n    (list sym (read rdr true nil true))))",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [277
                                                                         280],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L277-L280"},
                                                        :full-name-encode "cljs.reader_wrapping-reader",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/prn" {:ns "cljs.core",
                                          :name "prn",
                                          :signature ["[& objs]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_prn",
                                          :source {:code "(defn prn\n  [& objs]\n  (pr-with-opts objs (pr-opts))\n  (newline (pr-opts)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [3152 3156],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3152-L3156"},
                                          :full-name "cljs.core/prn",
                                          :clj-symbol "clojure.core/prn",
                                          :docstring "Same as pr followed by (newline)."},
                         "clojure.zip/leftmost" {:ns "clojure.zip",
                                                 :name "leftmost",
                                                 :signature ["[loc]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.zip_leftmost",
                                                 :source {:code "(defn leftmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path (seq l))\n        (with-meta [(first l) (assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))\n        loc)))",
                                                          :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                          :lines [157
                                                                  163],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L157-L163"},
                                                 :full-name "clojure.zip/leftmost",
                                                 :clj-symbol "clojure.zip/leftmost",
                                                 :docstring "Returns the loc of the leftmost sibling of the node at this loc, or self"},
                         "cljs.core/>=" {:ns "cljs.core",
                                         :name ">=",
                                         :signature ["[x]"
                                                     "[x y]"
                                                     "[x y & more]"],
                                         :shadowed-sources ({:code "(defmacro >=\n  ([x] true)\n  ([x y] (list 'js* \"(~{} >= ~{})\" x y))\n  ([x y & more] `(and (>= ~x ~y) (>= ~y ~@more))))",
                                                             :filename "clojurescript/src/clj/cljs/core.clj",
                                                             :lines [103
                                                                     106],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L103-L106"}),
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core__GT__EQ_",
                                         :source {:code "(defn >=\n  ([x] true)\n  ([x y] (cljs.core/>= x y))\n  ([x y & more]\n   (if (cljs.core/>= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/>= y (first more)))\n     false)))",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [874 884],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L874-L884"},
                                         :full-name "cljs.core/>=",
                                         :clj-symbol "clojure.core/>=",
                                         :docstring "Returns non-nil if nums are in monotonically non-increasing order,\notherwise false."},
                         "cljs.reader/macros" {:full-name "cljs.reader/macros",
                                               :ns "cljs.reader",
                                               :name "macros",
                                               :type "var",
                                               :source {:code "(def macros\n     { \\\" read-string\n       \\: read-keyword\n       \\; not-implemented ;; never hit this\n       \\' (wrapping-reader 'quote)\n       \\@ (wrapping-reader 'deref)\n       \\^ read-meta\n       \\` not-implemented\n       \\~ not-implemented\n       \\( read-list\n       \\) read-unmatched-delimiter\n       \\[ read-vector\n       \\] read-unmatched-delimiter\n       \\{ read-map\n       \\} read-unmatched-delimiter\n       \\\\ read-char\n       \\% not-implemented\n       \\# read-dispatch\n       })",
                                                        :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                        :lines [310
                                                                328],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L310-L328"},
                                               :full-name-encode "cljs.reader_macros",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/doseq" {:ns "cljs.core",
                                            :name "doseq",
                                            :signature ["[seq-exprs & body]"],
                                            :history [["+" "0.0-927"]],
                                            :type "macro",
                                            :full-name-encode "cljs.core_doseq",
                                            :source {:code "(defmacro doseq\n  [seq-exprs & body]\n  (assert-args doseq\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [step (fn step [recform exprs]\n               (if-not exprs\n                 [true `(do ~@body)]\n                 (let [k (first exprs)\n                       v (second exprs)\n                       \n                       seqsym (when-not (keyword? k) (gensym))\n                       recform (if (keyword? k) recform `(recur (first ~seqsym) ~seqsym))\n                       steppair (step recform (nnext exprs))\n                       needrec (steppair 0)\n                       subform (steppair 1)]\n                   (cond\n                     (= k :let) [needrec `(let ~v ~subform)]\n                     (= k :while) [false `(when ~v\n                                            ~subform\n                                            ~@(when needrec [recform]))]\n                     (= k :when) [false `(if ~v\n                                           (do\n                                             ~subform\n                                             ~@(when needrec [recform]))\n                                           ~recform)]\n                     :else [true `(let [~seqsym (seq ~v)]\n                                    (when ~seqsym\n                                      (loop [~k (first ~seqsym) ~seqsym ~seqsym]\n                                       ~subform\n                                       (when-let [~seqsym (next ~seqsym)]\n                                        ~@(when needrec [recform])))))]))))]\n    (nth (step nil (seq seq-exprs)) 1)))",
                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                     :lines [612 647],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L612-L647"},
                                            :full-name "cljs.core/doseq",
                                            :clj-symbol "clojure.core/doseq",
                                            :docstring "Repeatedly executes body (presumably for side-effects) with\nbindings and filtering as provided by \"for\".  Does not retain\nthe head of the sequence. Returns nil."},
                         "cljs.core/*" {:ns "cljs.core",
                                        :name "*",
                                        :signature ["[]"
                                                    "[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :shadowed-sources ({:code "(defmacro *\n  ([] 1)\n  ([x] x)\n  ([x y] (list 'js* \"(~{} * ~{})\" x y))\n  ([x y & more] `(* (* ~x ~y) ~@more)))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [77
                                                                    81],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L77-L81"}),
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core__STAR_",
                                        :source {:code "(defn *\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/* x y))\n  ([x y & more] (reduce * (cljs.core/* x y) more)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [824 829],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L824-L829"},
                                        :full-name "cljs.core/*",
                                        :clj-symbol "clojure.core/*",
                                        :docstring "Returns the product of nums. (*) returns 1."},
                         "cljs.core/into" {:ns "cljs.core",
                                           :name "into",
                                           :signature ["[to from]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_into",
                                           :source {:code "(defn into\n  [to from]\n  (reduce -conj to from))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1868 1872],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1868-L1872"},
                                           :full-name "cljs.core/into",
                                           :clj-symbol "clojure.core/into",
                                           :docstring "Returns a new coll consisting of to-coll with all of the items of\nfrom-coll conjoined."},
                         "cljs.core/defmethod" {:ns "cljs.core",
                                                :name "defmethod",
                                                :signature ["[multifn dispatch-val & fn-tail]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "macro",
                                                :full-name-encode "cljs.core_defmethod",
                                                :source {:code "(defmacro defmethod\n  [multifn dispatch-val & fn-tail]\n  `(-add-method ~(with-meta multifn {:tag 'cljs.core.MultiFn}) ~dispatch-val (fn ~@fn-tail)))",
                                                         :filename "clojurescript/src/clj/cljs/core.clj",
                                                         :lines [757
                                                                 760],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L757-L760"},
                                                :full-name "cljs.core/defmethod",
                                                :clj-symbol "clojure.core/defmethod",
                                                :docstring "Creates and installs a new method of multimethod associated with dispatch-value. "},
                         "cljs.core/rest" {:ns "cljs.core",
                                           :name "rest",
                                           :signature ["[coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_rest",
                                           :source {:code "(defn rest\n  [coll]\n  (-rest (seq coll)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [419 423],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L419-L423"},
                                           :full-name "cljs.core/rest",
                                           :clj-symbol "clojure.core/rest",
                                           :docstring "Returns a possibly empty seq of the items after the first. Calls seq on its\nargument."},
                         "cljs.core/dotimes" {:ns "cljs.core",
                                              :name "dotimes",
                                              :signature ["[bindings & body]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "macro",
                                              :full-name-encode "cljs.core_dotimes",
                                              :source {:code "(defmacro dotimes\n  [bindings & body]\n  (let [i (first bindings)\n        n (second bindings)]\n    `(let [n# ~n]\n       (loop [~i 0]\n         (when (< ~i n#)\n           ~@body\n           (recur (inc ~i)))))))",
                                                       :filename "clojurescript/src/clj/cljs/core.clj",
                                                       :lines [687
                                                               699],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L687-L699"},
                                              :full-name "cljs.core/dotimes",
                                              :clj-symbol "clojure.core/dotimes",
                                              :docstring "bindings => name n\n\nRepeatedly executes body (presumably for side-effects) with name\nbound to integers from 0 through n-1."},
                         "clojure.zip/lefts" {:ns "clojure.zip",
                                              :name "lefts",
                                              :signature ["[loc]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.zip_lefts",
                                              :source {:code "(defn lefts\n  [loc]\n    (seq (:l (loc 1))))",
                                                       :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                       :lines [87 90],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L87-L90"},
                                              :full-name "clojure.zip/lefts",
                                              :clj-symbol "clojure.zip/lefts",
                                              :docstring "Returns a seq of the left siblings of this loc"},
                         "clojure.browser.dom/ensure-element" {:full-name "clojure.browser.dom/ensure-element",
                                                               :ns "clojure.browser.dom",
                                                               :name "ensure-element",
                                                               :docstring "Coerce the argument to a dom element if possible.",
                                                               :type "function",
                                                               :signature ["[e]"],
                                                               :source {:code "(defn ensure-element\n  [e]\n  (cond (keyword? e) (get-element e)\n        (string? e) (html->dom e)\n        :else e))",
                                                                        :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                        :lines [105
                                                                                110],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/dom.cljs#L105-L110"},
                                                               :full-name-encode "clojure.browser.dom_ensure-element",
                                                               :history [["+"
                                                                          "0.0-927"]]},
                         "cljs.core/defmacro" {:ns "cljs.core",
                                               :name "defmacro",
                                               :signature ["[name doc-string? attr-map? [params*] body]"
                                                           "[name doc-string? attr-map? ([params*] body) + attr-map?]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "macro",
                                               :full-name-encode "cljs.core_defmacro",
                                               :source {:code "(def\n\n ^{:doc \"Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.\"\n   :arglists '([name doc-string? attr-map? [params*] body]\n                 [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :added \"1.0\"}\n defmacro (fn [&form &env \n                name & args]\n             (let [prefix (loop [p (list name) args args]\n                            (let [f (first args)]\n                              (if (string? f)\n                                (recur (cons f p) (next args))\n                                (if (map? f)\n                                  (recur (cons f p) (next args))\n                                  p))))\n                   fdecl (loop [fd args]\n                           (if (string? (first fd))\n                             (recur (next fd))\n                             (if (map? (first fd))\n                               (recur (next fd))\n                               fd)))\n                   fdecl (if (vector? (first fdecl))\n                           (list fdecl)\n                           fdecl)\n                   add-implicit-args (fn [fd]\n                             (let [args (first fd)]\n                               (cons (vec (cons '&form (cons '&env args))) (next fd))))\n                   add-args (fn [acc ds]\n                              (if (nil? ds)\n                                acc\n                                (let [d (first ds)]\n                                  (if (map? d)\n                                    (conj acc d)\n                                    (recur (conj acc (add-implicit-args d)) (next ds))))))\n                   fdecl (seq (add-args [] fdecl))\n                   decl (loop [p prefix d fdecl]\n                          (if p\n                            (recur (next p) (cons (first p) d))\n                            d))]\n               (list 'do\n                     (cons `defn decl)\n                     (list '. (list 'var name) '(setMacro))\n                     (list 'var name)))))",
                                                        :filename "clojure/src/clj/clojure/core.clj",
                                                        :lines [405
                                                                449],
                                                        :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L405-L449"},
                                               :full-name "cljs.core/defmacro",
                                               :clj-symbol "clojure.core/defmacro",
                                               :docstring "Like defn, but the resulting function name is declared as a\nmacro and will be used as a macro by the compiler when it is\ncalled."},
                         "cljs.core/remove" {:ns "cljs.core",
                                             :name "remove",
                                             :signature ["[pred coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_remove",
                                             :source {:code "(defn remove\n  [pred coll]\n  (filter (complement pred) coll))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1839
                                                              1843],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1839-L1843"},
                                             :full-name "cljs.core/remove",
                                             :clj-symbol "clojure.core/remove",
                                             :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns false. pred must be free of side-effects."},
                         "cljs.core/if-not" {:ns "cljs.core",
                                             :name "if-not",
                                             :signature ["[test then]"
                                                         "[test then else]"],
                                             :history [["+" "0.0-927"]],
                                             :type "macro",
                                             :full-name-encode "cljs.core_if-not",
                                             :source {:code "(defmacro if-not\n  ([test then] `(if-not ~test ~then nil))\n  ([test then else]\n   `(if (not ~test) ~then ~else)))",
                                                      :filename "clojure/src/clj/clojure/core.clj",
                                                      :lines [702 708],
                                                      :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L702-L708"},
                                             :full-name "cljs.core/if-not",
                                             :clj-symbol "clojure.core/if-not",
                                             :docstring "Evaluates test. If logical false, evaluates and returns then expr, \notherwise else expr, if supplied, else nil."},
                         "clojure.zip/path" {:ns "clojure.zip",
                                             :name "path",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_path",
                                             :source {:code "(defn path\n  [loc]\n    (:pnodes (loc 1)))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [82 85],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L82-L85"},
                                             :full-name "clojure.zip/path",
                                             :clj-symbol "clojure.zip/path",
                                             :docstring "Returns a seq of nodes leading to this loc"},
                         "cljs.core/mapcat" {:ns "cljs.core",
                                             :name "mapcat",
                                             :signature ["[f coll]"
                                                         "[f coll & colls]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_mapcat",
                                             :source {:code "(defn mapcat\n  ([f coll]\n    (flatten1 (map f coll)))\n  ([f coll & colls]\n    (flatten1 (apply map f coll colls))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1820
                                                              1826],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1820-L1826"},
                                             :full-name "cljs.core/mapcat",
                                             :clj-symbol "clojure.core/mapcat",
                                             :docstring "Returns the result of applying concat to the result of applying map\nto f and colls.  Thus function f should return a collection."},
                         "cljs.core/IWatchable" {:ns "cljs.core",
                                                 :name "IWatchable",
                                                 :type "protocol",
                                                 :full-name-encode "cljs.core_IWatchable",
                                                 :source {:code "(defprotocol IWatchable\n  (-notify-watches [this oldval newval])\n  (-add-watch [this key f])\n  (-remove-watch [this key]))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [195
                                                                  198],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L195-L198"},
                                                 :methods [{:name "-notify-watches",
                                                            :signature ["[this oldval newval]"],
                                                            :docstring nil}
                                                           {:name "-add-watch",
                                                            :signature ["[this key f]"],
                                                            :docstring nil}
                                                           {:name "-remove-watch",
                                                            :signature ["[this key]"],
                                                            :docstring nil}],
                                                 :full-name "cljs.core/IWatchable",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "clojure.zip/rightmost" {:ns "clojure.zip",
                                                  :name "rightmost",
                                                  :signature ["[loc]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.zip_rightmost",
                                                  :source {:code "(defn rightmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path r)\n        (with-meta [(last r) (assoc path :l (apply conj l node (butlast r)) :r nil)] (meta loc))\n        loc)))",
                                                           :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                           :lines [142
                                                                   148],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L142-L148"},
                                                  :full-name "clojure.zip/rightmost",
                                                  :clj-symbol "clojure.zip/rightmost",
                                                  :docstring "Returns the loc of the rightmost sibling of the node at this loc, or self"},
                         "cljs.core/->" {:ns "cljs.core",
                                         :name "->",
                                         :signature ["[x]"
                                                     "[x form]"
                                                     "[x form & more]"],
                                         :history [["+" "0.0-927"]],
                                         :type "macro",
                                         :full-name-encode "cljs.core_-_GT_",
                                         :source {:code "(defmacro ->\n  ([x] x)\n  ([x form] (if (seq? form)\n              (with-meta `(~(first form) ~x ~@(next form)) (meta form))\n              (list form x)))\n  ([x form & more] `(-> (-> ~x ~form) ~@more)))",
                                                  :filename "clojure/src/clj/clojure/core.clj",
                                                  :lines [1528 1538],
                                                  :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L1528-L1538"},
                                         :full-name "cljs.core/->",
                                         :clj-symbol "clojure.core/->",
                                         :docstring "Threads the expr through the forms. Inserts x as the\nsecond item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nsecond item in second form, etc."},
                         "cljs.core/remove-all-methods" {:ns "cljs.core",
                                                         :name "remove-all-methods",
                                                         :signature ["[multifn]"],
                                                         :history [["+"
                                                                    "0.0-927"]],
                                                         :type "function",
                                                         :full-name-encode "cljs.core_remove-all-methods",
                                                         :source {:code "(defn remove-all-methods\n [multifn]\n (-reset multifn))",
                                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                  :lines [3739
                                                                          3742],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3739-L3742"},
                                                         :full-name "cljs.core/remove-all-methods",
                                                         :clj-symbol "clojure.core/remove-all-methods",
                                                         :docstring "Removes all of the methods of multimethod."},
                         "clojure.string/replace-first" {:ns "clojure.string",
                                                         :name "replace-first",
                                                         :signature ["[s match replacement]"],
                                                         :history [["+"
                                                                    "0.0-927"]],
                                                         :type "function",
                                                         :full-name-encode "clojure.string_replace-first",
                                                         :source {:code "(defn replace-first\n  [s match replacement]\n  (.replace s match replacement))",
                                                                  :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                                  :lines [36
                                                                          43],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/string.cljs#L36-L43"},
                                                         :full-name "clojure.string/replace-first",
                                                         :clj-symbol "clojure.string/replace-first",
                                                         :docstring "Replaces the first instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
                         "clojure.browser.dom/get-value" {:full-name "clojure.browser.dom/get-value",
                                                          :ns "clojure.browser.dom",
                                                          :name "get-value",
                                                          :docstring "Get the value of an element.",
                                                          :type "function",
                                                          :signature ["[e]"],
                                                          :source {:code "(defn get-value\n  [e]\n  (.-value (ensure-element e)))",
                                                                   :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                   :lines [129
                                                                           132],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/dom.cljs#L129-L132"},
                                                          :full-name-encode "clojure.browser.dom_get-value",
                                                          :history [["+"
                                                                     "0.0-927"]]},
                         "cljs.nodejs/process" {:full-name "cljs.nodejs/process",
                                                :ns "cljs.nodejs",
                                                :name "process",
                                                :type "var",
                                                :source {:code "(def process (js* \"process\"))",
                                                         :filename "clojurescript/src/cljs/cljs/nodejs.cljs",
                                                         :lines [8 8],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/nodejs.cljs#L8-L8"},
                                                :full-name-encode "cljs.nodejs_process",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/not=" {:ns "cljs.core",
                                           :name "not=",
                                           :signature ["[x]"
                                                       "[x y]"
                                                       "[x y & more]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_not_EQ_",
                                           :source {:code "(defn not=\n  ([x] false)\n  ([x y] (not (= x y)))\n  ([x y & more]\n   (not (apply = x y more))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1435 1440],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1435-L1440"},
                                           :full-name "cljs.core/not=",
                                           :clj-symbol "clojure.core/not=",
                                           :docstring "Same as (not (= obj1 obj2))"},
                         "cljs.core/js-keys" {:full-name "cljs.core/js-keys",
                                              :ns "cljs.core",
                                              :name "js-keys",
                                              :type "function",
                                              :signature ["[obj]"],
                                              :source {:code "(defn js-keys [obj]\n  (let [keys (array)]\n    (goog.object/forEach obj (fn [val key obj] (.push keys key)))\n    keys))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [629
                                                               632],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L629-L632"},
                                              :full-name-encode "cljs.core_js-keys",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "clojure.zip/seq-zip" {:ns "clojure.zip",
                                                :name "seq-zip",
                                                :signature ["[root]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.zip_seq-zip",
                                                :source {:code "(defn seq-zip\n  [root]\n    (zipper seq?\n            identity\n            (fn [node children] (with-meta children (meta node)))\n            root))",
                                                         :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                         :lines [34
                                                                 40],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L34-L40"},
                                                :full-name "clojure.zip/seq-zip",
                                                :clj-symbol "clojure.zip/seq-zip",
                                                :docstring "Returns a zipper for nested sequences, given a root sequence"},
                         "cljs.core/IVector" {:ns "cljs.core",
                                              :name "IVector",
                                              :type "protocol",
                                              :full-name-encode "cljs.core_IVector",
                                              :source {:code "(defprotocol IVector\n  (-assoc-n [coll n val]))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [156
                                                               157],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L156-L157"},
                                              :methods [{:name "-assoc-n",
                                                         :signature ["[coll n val]"],
                                                         :docstring nil}],
                                              :full-name "cljs.core/IVector",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/empty" {:ns "cljs.core",
                                            :name "empty",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_empty",
                                            :source {:code "(defn empty\n  [coll]\n  (-empty coll))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [490 493],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L490-L493"},
                                            :full-name "cljs.core/empty",
                                            :clj-symbol "clojure.core/empty",
                                            :docstring "Returns an empty collection of the same category as coll, or nil"},
                         "cljs.core/re-matches" {:ns "cljs.core",
                                                 :name "re-matches",
                                                 :signature ["[re s]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_re-matches",
                                                 :source {:code "(defn re-matches\n  [re s]\n  (let [matches (.exec re s)]\n    (when (= (first matches) s)\n      (if (= (count matches) 1)\n        (first matches)\n        (vec matches)))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2997
                                                                  3004],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2997-L3004"},
                                                 :full-name "cljs.core/re-matches",
                                                 :clj-symbol "clojure.core/re-matches",
                                                 :docstring "Returns the result of (re-find re s) if re fully matches s."},
                         "clojure.browser.dom/DOMBuilder" {:ns "clojure.browser.dom",
                                                           :name "DOMBuilder",
                                                           :type "protocol",
                                                           :full-name-encode "clojure.browser.dom_DOMBuilder",
                                                           :source {:code "(defprotocol DOMBuilder\n  (-element [this] [this attrs-or-children] [this attrs children]))",
                                                                    :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                    :lines [16
                                                                            17],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/dom.cljs#L16-L17"},
                                                           :methods [{:name "-element",
                                                                      :signature ["[this]"
                                                                                  "[this attrs-or-children]"
                                                                                  "[this attrs children]"],
                                                                      :docstring nil}],
                                                           :full-name "clojure.browser.dom/DOMBuilder",
                                                           :history [["+"
                                                                      "0.0-927"]]},
                         "cljs.core/fixture1" {:full-name "cljs.core/fixture1",
                                               :ns "cljs.core",
                                               :name "fixture1",
                                               :type "var",
                                               :source {:code "(def fixture1 1)",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [3396
                                                                3396],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3396-L3396"},
                                               :full-name-encode "cljs.core_fixture1",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/extend-type" {:full-name "cljs.core/extend-type",
                                                  :ns "cljs.core",
                                                  :name "extend-type",
                                                  :type "macro",
                                                  :signature ["[tsym & impls]"],
                                                  :source {:code "(defmacro extend-type [tsym & impls]\n  (let [resolve #(let [ret (:name (cljs.compiler/resolve-var (dissoc &env :locals) %))]\n                   (assert ret (str \"Can't resolve: \" %))\n                   ret)\n        impl-map (loop [ret {} s impls]\n                   (if (seq s)\n                     (recur (assoc ret (first s) (take-while seq? (next s)))\n                            (drop-while seq? (next s)))\n                     ret))]\n    (if (base-type tsym)\n      (let [t (base-type tsym)\n            assign-impls (fn [[p sigs]]\n                           (let [psym (resolve p)\n                                 pfn-prefix (subs (str psym) 0 (clojure.core/inc (.lastIndexOf (str psym) \".\")))]\n                             (cons `(aset ~psym ~t true)\n                                   (map (fn [[f & meths]]\n                                          `(aset ~(symbol (str pfn-prefix f)) ~t (fn ~@meths)))\n                                        sigs))))]\n        `(do ~@(mapcat assign-impls impl-map)))\n      (let [t (resolve tsym)\n            prototype-prefix (str t \".prototype.\")\n            assign-impls (fn [[p sigs]]\n                           (let [psym (resolve p)\n                                 pprefix (protocol-prefix psym)]\n                             (if (= p 'Object)\n                               (let [adapt-params (fn [[sig & body]]\n                                                    (let [[tname & args] sig]\n                                                      (list (with-meta (vec args) (meta sig))\n                                                            (list* 'this-as tname body))))]\n                                 (map (fn [[f & meths]]\n                                        `(set! ~(symbol (str prototype-prefix f)) (fn ~@(map adapt-params meths))))\n                                      sigs))\n                               (cons `(set! ~(symbol (str prototype-prefix pprefix)) true)\n                                     (map (fn [[f & meths]]\n                                            (let [ifn? (= psym 'cljs.core.IFn)\n                                                  pf (if ifn?\n                                                       (str prototype-prefix 'call)\n                                                       (str prototype-prefix pprefix f))\n                                                  adapt-params (fn [[[targ & args :as sig] & body]]\n                                                                 (let [tsym (gensym \"tsym\")]\n                                                                   `(~(with-meta (vec (cons tsym args)) (meta sig))\n                                                                     (this-as ~tsym\n                                                                              (let [~targ ~tsym]\n                                                                                ~@body)))))\n                                                  meths (if ifn?\n                                                          (map adapt-params meths)\n                                                          meths)]\n                                              `(set! ~(symbol pf) (fn ~@meths))))\n                                          sigs)))))]\n        `(do ~@(mapcat assign-impls impl-map))))))",
                                                           :filename "clojurescript/src/clj/cljs/core.clj",
                                                           :lines [211
                                                                   260],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L211-L260"},
                                                  :full-name-encode "cljs.core_extend-type",
                                                  :clj-symbol "clojure.core/extend-type",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/ISeqable" {:ns "cljs.core",
                                               :name "ISeqable",
                                               :type "protocol",
                                               :full-name-encode "cljs.core_ISeqable",
                                               :source {:code "(defprotocol ISeqable\n  (-seq [o]))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [180
                                                                181],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L180-L181"},
                                               :methods [{:name "-seq",
                                                          :signature ["[o]"],
                                                          :docstring nil}],
                                               :full-name "cljs.core/ISeqable",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/assoc" {:ns "cljs.core",
                                            :name "assoc",
                                            :signature ["[coll k v]"
                                                        "[coll k v & kvs]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_assoc",
                                            :source {:code "(defn assoc\n  ([coll k v]\n     (-assoc coll k v))\n  ([coll k v & kvs]\n     (let [ret (assoc coll k v)]\n       (if kvs\n         (recur ret (first kvs) (second kvs) (nnext kvs))\n         ret))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [518 529],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L518-L529"},
                                            :full-name "cljs.core/assoc",
                                            :clj-symbol "clojure.core/assoc",
                                            :docstring "assoc[iate]. When applied to a map, returns a new map of the\nsame (hashed/sorted) type, that contains the mapping of key(s) to\nval(s). When applied to a vector, returns a new vector that\ncontains val at index."},
                         "clojure.browser.repl/xpc-connection" {:full-name "clojure.browser.repl/xpc-connection",
                                                                :ns "clojure.browser.repl",
                                                                :name "xpc-connection",
                                                                :type "var",
                                                                :source {:code "(def xpc-connection (atom nil))",
                                                                         :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                         :lines [21
                                                                                 21],
                                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/repl.cljs#L21-L21"},
                                                                :full-name-encode "clojure.browser.repl_xpc-connection",
                                                                :history [["+"
                                                                           "0.0-927"]]},
                         "cljs.core/IDerefWithTimeout" {:ns "cljs.core",
                                                        :name "IDerefWithTimeout",
                                                        :type "protocol",
                                                        :full-name-encode "cljs.core_IDerefWithTimeout",
                                                        :source {:code "(defprotocol IDerefWithTimeout\n  (-deref-with-timeout [o msec timeout-val]))",
                                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                 :lines [162
                                                                         163],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L162-L163"},
                                                        :methods [{:name "-deref-with-timeout",
                                                                   :signature ["[o msec timeout-val]"],
                                                                   :docstring nil}],
                                                        :full-name "cljs.core/IDerefWithTimeout",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "clojure.browser.repl/start-evaluator" {:full-name "clojure.browser.repl/start-evaluator",
                                                                 :ns "clojure.browser.repl",
                                                                 :name "start-evaluator",
                                                                 :docstring "Start the REPL server connection.",
                                                                 :type "function",
                                                                 :signature ["[url]"],
                                                                 :source {:code "(defn start-evaluator\n  [url]\n  (if-let [repl-connection (net/xpc-connection)]\n    (let [connection (net/xhr-connection)]\n      (event/listen connection\n                    :success\n                    (fn [e]\n                      (net/transmit\n                       repl-connection\n                       :evaluate-javascript\n                       (.getResponseText e/currentTarget\n                                         ()))))\n\n      (net/register-service repl-connection\n                            :send-result\n                            (fn [data]\n                              (send-result connection url (wrap-message :result data))))\n\n      (net/register-service repl-connection\n                            :print\n                            (fn [data]\n                              (send-print url (wrap-message :print data))))\n      \n      (net/connect repl-connection\n                   (constantly nil))\n\n      (js/setTimeout #(send-result connection url (wrap-message :ready \"ready\")) 50))\n    (js/alert \"No 'xpc' param provided to child iframe.\")))",
                                                                          :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                          :lines [60
                                                                                  88],
                                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/repl.cljs#L60-L88"},
                                                                 :full-name-encode "clojure.browser.repl_start-evaluator",
                                                                 :history [["+"
                                                                            "0.0-927"]]},
                         "clojure.browser.event/unlisten" {:full-name "clojure.browser.event/unlisten",
                                                           :ns "clojure.browser.event",
                                                           :name "unlisten",
                                                           :type "function",
                                                           :signature ["[src type fn]"
                                                                       "[src type fn capture?]"],
                                                           :source {:code "(defn unlisten\n  ([src type fn]\n     (unlisten src type fn false))\n  ([src type fn capture?]\n     (goog.events/unlisten src\n                           (get (event-types src) type type)\n                           fn\n                           capture?)))",
                                                                    :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                    :lines [62
                                                                            69],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/event.cljs#L62-L69"},
                                                           :full-name-encode "clojure.browser.event_unlisten",
                                                           :history [["+"
                                                                      "0.0-927"]]},
                         "cljs.core/fnil" {:ns "cljs.core",
                                           :name "fnil",
                                           :signature ["[f x]"
                                                       "[f x y]"
                                                       "[f x y z]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_fnil",
                                           :source {:code "(defn fnil\n  ([f x]\n   (fn\n     ([a] (f (if (nil? a) x a)))\n     ([a b] (f (if (nil? a) x a) b))\n     ([a b c] (f (if (nil? a) x a) b c))\n     ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n  ([f x y]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n  ([f x y z]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1542 1563],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1542-L1563"},
                                           :full-name "cljs.core/fnil",
                                           :clj-symbol "clojure.core/fnil",
                                           :docstring "Takes a function f, and returns a function that calls f, replacing\na nil first argument to f with the supplied value x. Higher arity\nversions can replace arguments in the second and third\npositions (y, z). Note that the function f can take any number of\narguments, not just the one(s) being nil-patched."},
                         "cljs.core/this-as" {:full-name "cljs.core/this-as",
                                              :ns "cljs.core",
                                              :name "this-as",
                                              :docstring "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided.",
                                              :type "macro",
                                              :signature ["[name & body]"],
                                              :source {:code "(defmacro this-as\n  [name & body]\n  `(let [~name (~'js* \"this\")]\n     ~@body))",
                                                       :filename "clojurescript/src/clj/cljs/core.clj",
                                                       :lines [205
                                                               209],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L205-L209"},
                                              :full-name-encode "cljs.core_this-as",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/PersistentQueueSeq" {:full-name "cljs.core/PersistentQueueSeq",
                                                         :ns "cljs.core",
                                                         :name "PersistentQueueSeq",
                                                         :type "type",
                                                         :signature ["[meta front rear]"],
                                                         :source {:code "(deftype PersistentQueueSeq [meta front rear]\n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueueSeq. meta front rear))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (-first front))\n  (-rest  [coll]\n    (if-let [f1 (next front)]\n      (PersistentQueueSeq. meta f1 rear)\n      (if (nil? rear)\n        (-empty coll)\n        (PersistentQueueSeq. meta rear nil))))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] coll))",
                                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                  :lines [2293
                                                                          2323],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2293-L2323"},
                                                         :full-name-encode "cljs.core_PersistentQueueSeq",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "cljs.core/counted?" {:ns "cljs.core",
                                               :name "counted?",
                                               :signature ["[x]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_counted_QMARK_",
                                               :source {:code "(defn counted?\n  [x] (satisfies? ICounted x))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [610
                                                                612],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L610-L612"},
                                               :full-name "cljs.core/counted?",
                                               :clj-symbol "clojure.core/counted?",
                                               :docstring "Returns true if coll implements count in constant time"},
                         "clojure.string/trimr" {:ns "clojure.string",
                                                 :name "trimr",
                                                 :signature ["[s]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.string_trimr",
                                                 :source {:code "(defn trimr\n    [s]\n    (gstring/trimRight s))",
                                                          :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                          :lines [116
                                                                  119],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/string.cljs#L116-L119"},
                                                 :full-name "clojure.string/trimr",
                                                 :clj-symbol "clojure.string/trimr",
                                                 :docstring "Removes whitespace from the right side of string."},
                         "cljs.core/force" {:ns "cljs.core",
                                            :name "force",
                                            :signature ["[x]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_force",
                                            :source {:code "(defn force\n  [x]\n  (if (delay? x)\n    (deref x)\n    x))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [3417
                                                             3422],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3417-L3422"},
                                            :full-name "cljs.core/force",
                                            :clj-symbol "clojure.core/force",
                                            :docstring "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"},
                         "cljs.core/compare-and-set!" {:ns "cljs.core",
                                                       :name "compare-and-set!",
                                                       :signature ["[a oldval newval]"],
                                                       :history [["+"
                                                                  "0.0-927"]],
                                                       :type "function",
                                                       :full-name-encode "cljs.core_compare-and-set_BANG_",
                                                       :source {:code "(defn compare-and-set!\n  [a oldval newval]\n  (if (= a.state oldval)\n    (do (reset! a newval) true)\n    false))",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [3304
                                                                        3311],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3304-L3311"},
                                                       :full-name "cljs.core/compare-and-set!",
                                                       :clj-symbol "clojure.core/compare-and-set!",
                                                       :docstring "Atomically sets the value of atom to newval if and only if the\ncurrent value of the atom is identical to oldval. Returns true if\nset happened, else false."},
                         "cljs.core/set?" {:ns "cljs.core",
                                           :name "set?",
                                           :signature ["[x]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_set_QMARK_",
                                           :source {:code "(defn set?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ISet x)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [595 600],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L595-L600"},
                                           :full-name "cljs.core/set?",
                                           :clj-symbol "clojure.core/set?",
                                           :docstring "Returns true if x satisfies ISet"},
                         "clojure.string/escape" {:ns "clojure.string",
                                                  :name "escape",
                                                  :signature ["[s cmap]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.string_escape",
                                                  :source {:code "(defn escape\n  [s cmap]\n  (let [buffer (gstring/StringBuffer.)\n        length (.-length s)]\n    (loop [index 0]\n      (if (= length index)\n        (. buffer (toString))\n        (let [ch (.charAt s index)]\n          (if-let [replacement (get cmap ch)]\n            (.append buffer (str replacement))\n            (.append buffer ch))\n          (recur (inc index)))))))",
                                                           :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                           :lines [144
                                                                   160],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/string.cljs#L144-L160"},
                                                  :full-name "clojure.string/escape",
                                                  :clj-symbol "clojure.string/escape",
                                                  :docstring "Return a new string, using cmap to escape each character ch\nfrom s as follows:\n\nIf (cmap ch) is nil, append ch to the new string.\nIf (cmap ch) is non-nil, append (str (cmap ch)) instead."},
                         "cljs.core/remove-watch" {:ns "cljs.core",
                                                   :name "remove-watch",
                                                   :signature ["[iref key]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.core_remove-watch",
                                                   :source {:code "(defn remove-watch\n  [iref key]\n  (-remove-watch iref key))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [3373
                                                                    3378],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3373-L3378"},
                                                   :full-name "cljs.core/remove-watch",
                                                   :clj-symbol "clojure.core/remove-watch",
                                                   :docstring "Alpha - subject to change.\n\nRemoves a watch (set by add-watch) from a reference"},
                         "cljs.core/IMultiFn" {:ns "cljs.core",
                                               :name "IMultiFn",
                                               :type "protocol",
                                               :full-name-encode "cljs.core_IMultiFn",
                                               :source {:code "(defprotocol IMultiFn\n  (-reset [mf])\n  (-add-method [mf dispatch-val method])\n  (-remove-method [mf dispatch-val])\n  (-prefer-method [mf dispatch-val dispatch-val-y])\n  (-get-method [mf dispatch-val])\n  (-methods [mf])\n  (-prefers [mf])\n  (-dispatch [mf args]))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [3666
                                                                3674],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3666-L3674"},
                                               :methods [{:name "-reset",
                                                          :signature ["[mf]"],
                                                          :docstring nil}
                                                         {:name "-add-method",
                                                          :signature ["[mf dispatch-val method]"],
                                                          :docstring nil}
                                                         {:name "-remove-method",
                                                          :signature ["[mf dispatch-val]"],
                                                          :docstring nil}
                                                         {:name "-prefer-method",
                                                          :signature ["[mf dispatch-val dispatch-val-y]"],
                                                          :docstring nil}
                                                         {:name "-get-method",
                                                          :signature ["[mf dispatch-val]"],
                                                          :docstring nil}
                                                         {:name "-methods",
                                                          :signature ["[mf]"],
                                                          :docstring nil}
                                                         {:name "-prefers",
                                                          :signature ["[mf]"],
                                                          :docstring nil}
                                                         {:name "-dispatch",
                                                          :signature ["[mf args]"],
                                                          :docstring nil}],
                                               :full-name "cljs.core/IMultiFn",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "clojure.zip/end?" {:ns "clojure.zip",
                                             :name "end?",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_end_QMARK_",
                                             :source {:code "(defn end?\n  [loc]\n    (= :end (loc 1)))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [232 235],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L232-L235"},
                                             :full-name "clojure.zip/end?",
                                             :clj-symbol "clojure.zip/end?",
                                             :docstring "Returns true if loc represents the end of a depth-first walk"},
                         "clojure.set/superset?" {:ns "clojure.set",
                                                  :name "superset?",
                                                  :signature ["[set1 set2]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.set_superset_QMARK_",
                                                  :source {:code "(defn superset? \n  [set1 set2]\n  (and (>= (count set1) (count set2))\n       (every? #(contains? set1 %) set2)))",
                                                           :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                           :lines [138
                                                                   142],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/set.cljs#L138-L142"},
                                                  :full-name "clojure.set/superset?",
                                                  :clj-symbol "clojure.set/superset?",
                                                  :docstring "Is set1 a superset of set2?"},
                         "clojure.browser.net/IConnection" {:ns "clojure.browser.net",
                                                            :name "IConnection",
                                                            :type "protocol",
                                                            :full-name-encode "clojure.browser.net_IConnection",
                                                            :source {:code "(defprotocol IConnection\n  (connect\n    [this]\n    [this opt1]\n    [this opt1 opt2]\n    [this opt1 opt2 opt3])\n  (transmit\n    [this opt]\n    [this opt opt2]\n    [this opt opt2 opt3]\n    [this opt opt2 opt3 opt4]\n    [this opt opt2 opt3 opt4 opt5])\n  (close [this]))",
                                                                     :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                     :lines [32
                                                                             44],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/net.cljs#L32-L44"},
                                                            :methods [{:name "connect",
                                                                       :signature ["[this]"
                                                                                   "[this opt1]"
                                                                                   "[this opt1 opt2]"
                                                                                   "[this opt1 opt2 opt3]"],
                                                                       :docstring nil}
                                                                      {:name "transmit",
                                                                       :signature ["[this opt]"
                                                                                   "[this opt opt2]"
                                                                                   "[this opt opt2 opt3]"
                                                                                   "[this opt opt2 opt3 opt4]"
                                                                                   "[this opt opt2 opt3 opt4 opt5]"],
                                                                       :docstring nil}
                                                                      {:name "close",
                                                                       :signature ["[this]"],
                                                                       :docstring nil}],
                                                            :full-name "clojure.browser.net/IConnection",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "cljs.core/let" {:ns "cljs.core",
                                          :name "let",
                                          :signature ["[bindings & body]"],
                                          :shadowed-sources ({:code "(def\n  ^{:macro true\n    :added \"1.0\"}\n  let (fn* let [&form &env & decl] (cons 'let* decl)))",
                                                              :filename "clojure/src/clj/clojure/core.clj",
                                                              :lines [32
                                                                      35],
                                                              :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L32-L35"}),
                                          :history [["+" "0.0-927"]],
                                          :type "macro",
                                          :full-name-encode "cljs.core_let",
                                          :source {:code "(defmacro let\n  [bindings & body]\n  (assert-args let\n     (vector? bindings) \"a vector for its binding\"\n     (even? (count bindings)) \"an even number of forms in binding vector\")\n  `(let* ~(destructure bindings) ~@body))",
                                                   :filename "clojure/src/clj/clojure/core.clj",
                                                   :lines [3953 3964],
                                                   :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L3953-L3964"},
                                          :full-name "cljs.core/let",
                                          :clj-symbol "clojure.core/let",
                                          :docstring "binding => binding-form init-expr\n\nEvaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein."},
                         "cljs.core/dorun" {:ns "cljs.core",
                                            :name "dorun",
                                            :signature ["[coll]"
                                                        "[n coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_dorun",
                                            :source {:code "(defn dorun\n  ([coll]\n   (when (seq coll)\n     (recur (next coll))))\n  ([n coll]\n   (when (and (seq coll) (pos? n))\n     (recur (dec n) (next coll)))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2968
                                                             2979],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2968-L2979"},
                                            :full-name "cljs.core/dorun",
                                            :clj-symbol "clojure.core/dorun",
                                            :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. dorun can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, does not retain the head and returns nil."},
                         "cljs.core/pr-str" {:ns "cljs.core",
                                             :name "pr-str",
                                             :signature ["[& objs]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_pr-str",
                                             :source {:code "(defn pr-str\n  [& objs]\n  (pr-str-with-opts objs (pr-opts)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [3111
                                                              3114],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3111-L3114"},
                                             :full-name "cljs.core/pr-str",
                                             :clj-symbol "clojure.core/pr-str",
                                             :docstring "pr to a string, returning it. Fundamental entrypoint to IPrintable."},
                         "cljs.core/IPrintable" {:ns "cljs.core",
                                                 :name "IPrintable",
                                                 :type "protocol",
                                                 :full-name-encode "cljs.core_IPrintable",
                                                 :source {:code "(defprotocol IPrintable\n  (-pr-seq [o opts]))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [189
                                                                  190],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L189-L190"},
                                                 :methods [{:name "-pr-seq",
                                                            :signature ["[o opts]"],
                                                            :docstring nil}],
                                                 :full-name "cljs.core/IPrintable",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "cljs.core/defprotocol" {:full-name "cljs.core/defprotocol",
                                                  :ns "cljs.core",
                                                  :name "defprotocol",
                                                  :type "macro",
                                                  :signature ["[psym & doc+methods]"],
                                                  :source {:code "(defmacro defprotocol [psym & doc+methods]\n  (let [p (:name (cljs.compiler/resolve-var (dissoc &env :locals) psym))\n        ns-name (-> &env :ns :name)\n        fqn (fn [n] (symbol (str ns-name \".\" n)))\n        prefix (protocol-prefix p)\n        methods (if (string? (first doc+methods)) (next doc+methods) doc+methods)\n        expand-sig (fn [fname slot sig]\n                     `(~sig\n                       (if (and ~(first sig) (. ~(first sig) ~(symbol (str \"-\" slot)))) ;; Property access needed here.\n                         (. ~(first sig) ~slot ~@sig)\n                         ((or\n                           (aget ~(fqn fname) (goog.typeOf ~(first sig)))\n                           (aget ~(fqn fname) \"_\")\n                           (throw (missing-protocol\n                                    ~(str psym \".\" fname) ~(first sig))))\n                          ~@sig))))\n        method (fn [[fname & sigs]]\n                 (let [sigs (take-while vector? sigs)\n                       slot (symbol (str prefix (name fname)))]\n                   `(defn ~fname ~@(map #(expand-sig fname slot %) sigs))))]\n    `(do\n       (def ~psym (~'js* \"{}\"))\n       ~@(map method methods))))",
                                                           :filename "clojurescript/src/clj/cljs/core.clj",
                                                           :lines [398
                                                                   420],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L398-L420"},
                                                  :full-name-encode "cljs.core_defprotocol",
                                                  :clj-symbol "clojure.core/defprotocol",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/assert" {:ns "cljs.core",
                                             :name "assert",
                                             :signature ["[x]"
                                                         "[x message]"],
                                             :shadowed-sources ({:code "(defmacro assert\n  ([x]\n     (when *assert*\n       `(when-not ~x\n          (throw (new AssertionError (str \"Assert failed: \" (pr-str '~x)))))))\n  ([x message]\n     (when *assert*\n       `(when-not ~x\n          (throw (new AssertionError (str \"Assert failed: \" ~message \"\\n\" (pr-str '~x))))))))",
                                                                 :filename "clojure/src/clj/clojure/core.clj",
                                                                 :lines [4222
                                                                         4233],
                                                                 :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L4222-L4233"}),
                                             :history [["+" "0.0-927"]],
                                             :type "macro",
                                             :full-name-encode "cljs.core_assert",
                                             :source {:code "(defmacro assert\n  ([x]\n     (when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" (cljs.core/pr-str '~x)))))))\n  ([x message]\n     (when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" ~message \"\\n\" (cljs.core/pr-str '~x))))))))",
                                                      :filename "clojurescript/src/clj/cljs/core.clj",
                                                      :lines [541 553],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L541-L553"},
                                             :full-name "cljs.core/assert",
                                             :clj-symbol "clojure.core/assert",
                                             :docstring "Evaluates expr and throws an exception if it does not evaluate to\nlogical true."},
                         "cljs.core/declare" {:ns "cljs.core",
                                              :name "declare",
                                              :signature ["[& names]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "macro",
                                              :full-name-encode "cljs.core_declare",
                                              :source {:code "(defmacro declare\n  [& names] `(do ~@(map #(list 'def (vary-meta % assoc :declared true)) names)))",
                                                       :filename "clojure/src/clj/clojure/core.clj",
                                                       :lines [2665
                                                               2668],
                                                       :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L2665-L2668"},
                                              :full-name "cljs.core/declare",
                                              :clj-symbol "clojure.core/declare",
                                              :docstring "defs the supplied var names with no bindings, useful for making forward declarations."},
                         "cljs.core/fn?" {:full-name "cljs.core/fn?",
                                          :ns "cljs.core",
                                          :name "fn?",
                                          :type "function",
                                          :signature ["[f]"],
                                          :source {:code "(defn fn? [f]\n  (goog/isFunction f))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [681 682],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L681-L682"},
                                          :full-name-encode "cljs.core_fn_QMARK_",
                                          :clj-symbol "clojure.core/fn?",
                                          :history [["+" "0.0-927"]]},
                         "cljs.core/associative?" {:ns "cljs.core",
                                                   :name "associative?",
                                                   :signature ["[x]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.core_associative_QMARK_",
                                                   :source {:code "(defn associative?\n  [x] (satisfies? IAssociative x))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [602
                                                                    604],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L602-L604"},
                                                   :full-name "cljs.core/associative?",
                                                   :clj-symbol "clojure.core/associative?",
                                                   :docstring "Returns true if coll implements Associative"},
                         "cljs.core/list*" {:ns "cljs.core",
                                            :name "list*",
                                            :signature ["[args]"
                                                        "[a args]"
                                                        "[a b args]"
                                                        "[a b c args]"
                                                        "[a b c d & more]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_list_STAR_",
                                            :source {:code "(defn list*\n  ([args] (seq args))\n  ([a args] (cons a args))\n  ([a b args] (cons a (cons b args)))\n  ([a b c args] (cons a (cons b (cons c args))))\n  ([a b c d & more]\n     (cons a (cons b (cons c (cons d (spread more)))))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [1369
                                                             1377],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1369-L1377"},
                                            :full-name "cljs.core/list*",
                                            :clj-symbol "clojure.core/list*",
                                            :docstring "Creates a new list containing the items prepended to the rest, the\nlast of which will be treated as a sequence."},
                         "cljs.core/reduce" {:ns "cljs.core",
                                             :name "reduce",
                                             :signature ["[f coll]"
                                                         "[f val coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_reduce",
                                             :source {:code "(defn reduce\n  ([f coll]\n     (-reduce coll f))\n  ([f val coll]\n     (-reduce coll f val)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [772 785],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L772-L785"},
                                             :full-name "cljs.core/reduce",
                                             :clj-symbol "clojure.core/reduce",
                                             :docstring "f should be a function of 2 arguments. If val is not supplied,\nreturns the result of applying f to the first 2 items in coll, then\napplying f to that result and the 3rd item, etc. If coll contains no\nitems, f must accept no arguments as well, and reduce returns the\nresult of calling f with no arguments.  If coll has only 1 item, it\nis returned and f is not called.  If val is supplied, returns the\nresult of applying f to val and the first item in coll, then\napplying f to that result and the 2nd item, etc. If coll contains no\nitems, returns val and f is not called."},
                         "clojure.browser.event/has-listener" {:full-name "clojure.browser.event/has-listener",
                                                               :ns "clojure.browser.event",
                                                               :name "has-listener",
                                                               :type "function",
                                                               :signature ["[obj opt_type opt_capture]"],
                                                               :source {:code "(defn has-listener [obj opt_type opt_capture])",
                                                                        :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                        :lines [94
                                                                                94],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/event.cljs#L94-L94"},
                                                               :full-name-encode "clojure.browser.event_has-listener",
                                                               :history [["+"
                                                                          "0.0-927"]]},
                         "cljs.core/compare" {:ns "cljs.core",
                                              :name "compare",
                                              :signature ["[x y]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_compare",
                                              :source {:code "(defn compare\n  [x y] (garray/defaultCompare x y))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [727
                                                               731],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L727-L731"},
                                              :full-name "cljs.core/compare",
                                              :clj-symbol "clojure.core/compare",
                                              :docstring "Comparator. Returns a negative number, zero, or a positive number\nwhen x is logically 'less than', 'equal to', or 'greater than'\ny. Uses google.array.defaultCompare."},
                         "cljs.core/contains?" {:ns "cljs.core",
                                                :name "contains?",
                                                :signature ["[coll v]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_contains_QMARK_",
                                                :source {:code "(defn contains?\n  [coll v]\n  (if (identical? (-lookup coll v lookup-sentinel) lookup-sentinel)\n    false\n    true))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [690
                                                                 699],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L690-L699"},
                                                :full-name "cljs.core/contains?",
                                                :clj-symbol "clojure.core/contains?",
                                                :docstring "Returns true if key is present in the given collection, otherwise\nreturns false.  Note that for numerically indexed collections like\nvectors and arrays, this tests if the numeric key is within the\nrange of indexes. 'contains?' operates constant or logarithmic time;\nit will not perform a linear search for a value.  See also 'some'."},
                         "cljs.core/prefer-method" {:ns "cljs.core",
                                                    :name "prefer-method",
                                                    :signature ["[multifn dispatch-val-x dispatch-val-y]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_prefer-method",
                                                    :source {:code "(defn prefer-method\n  [multifn dispatch-val-x dispatch-val-y]\n  (-prefer-method multifn dispatch-val-x dispatch-val-y))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [3749
                                                                     3753],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3749-L3753"},
                                                    :full-name "cljs.core/prefer-method",
                                                    :clj-symbol "clojure.core/prefer-method",
                                                    :docstring "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\nwhen there is a conflict"},
                         "cljs.core/array-seq" {:full-name "cljs.core/array-seq",
                                                :ns "cljs.core",
                                                :name "array-seq",
                                                :type "function",
                                                :signature ["[array i]"],
                                                :source {:code "(defn array-seq [array i]\n  (prim-seq array i))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [372
                                                                 373],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L372-L373"},
                                                :full-name-encode "cljs.core_array-seq",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/PersistentQueue" {:full-name "cljs.core/PersistentQueue",
                                                      :ns "cljs.core",
                                                      :name "PersistentQueue",
                                                      :type "type",
                                                      :signature ["[meta count front rear]"],
                                                      :source {:code "(deftype PersistentQueue [meta count front rear]\n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueue. meta count front rear))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest [coll] (rest (seq coll)))\n\n  IStack\n  (-peek [coll] (-first front))\n  (-pop [coll]\n    (if front\n      (if-let [f1 (next front)]\n        (PersistentQueue. meta (dec count) f1 rear)\n        (PersistentQueue. meta (dec count) (seq rear) []))\n      coll))\n\n  ICollection\n  (-conj [coll o]\n    (if front\n      (PersistentQueue. meta (inc count) front (conj (or rear []) o))\n      (PersistentQueue. meta (inc count) (conj front o) [])))\n\n  IEmptyableCollection\n  (-empty [coll] cljs.core.PersistentQueue/EMPTY)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (let [rear (seq rear)]\n      (if (or front rear)\n        (PersistentQueueSeq. nil front (seq rear))\n        cljs.core.List/EMPTY)))\n\n  ICounted\n  (-count [coll] count))",
                                                               :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                               :lines [2325
                                                                       2369],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2325-L2369"},
                                                      :full-name-encode "cljs.core_PersistentQueue",
                                                      :history [["+"
                                                                 "0.0-927"]]},
                         "cljs.core/drop-last" {:ns "cljs.core",
                                                :name "drop-last",
                                                :signature ["[s]"
                                                            "[n s]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_drop-last",
                                                :source {:code "(defn drop-last\n  ([s] (drop-last 1 s))\n  ([n s] (map (fn [x _] x) s (drop n s))))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1731
                                                                 1734],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1731-L1734"},
                                                :full-name "cljs.core/drop-last",
                                                :clj-symbol "clojure.core/drop-last",
                                                :docstring "Return a lazy sequence of all but the last n (default 1) items in coll"},
                         "cljs.reader/read-string" {:ns "cljs.reader",
                                                    :name "read-string",
                                                    :signature ["[s]"],
                                                    :shadowed-sources ({:code "(defn read-string\n  [reader _]\n  (loop [buffer (gstring/StringBuffer.)\n         ch (read-char reader)]\n    (cond\n     (nil? ch) (reader-error reader \"EOF while reading string\")\n     (= \"\\\\\" ch) (recur (do (.append buffer (escape-char buffer reader)) buffer)\n                        (read-char reader))\n     (= \\\" ch) (. buffer (toString))\n     :default (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                                                        :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                        :lines [232
                                                                                241],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L232-L241"}),
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.reader_read-string",
                                                    :source {:code "(defn read-string\n  [s]\n  (let [r (push-back-reader s)]\n    (read r true nil false)))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [356
                                                                     360],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L356-L360"},
                                                    :full-name "cljs.reader/read-string",
                                                    :clj-symbol "clojure.core/read-string",
                                                    :docstring "Reads one object from the string s"},
                         "cljs.core/vector?" {:ns "cljs.core",
                                              :name "vector?",
                                              :signature ["[x]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_vector_QMARK_",
                                              :source {:code "(defn vector?\n  [x] (satisfies? IVector x))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [621
                                                               623],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L621-L623"},
                                              :full-name "cljs.core/vector?",
                                              :clj-symbol "clojure.core/vector?",
                                              :docstring "Return true if x satisfies IVector"},
                         "cljs.core/defmulti" {:ns "cljs.core",
                                               :name "defmulti",
                                               :signature ["[mm-name & options]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "macro",
                                               :full-name-encode "cljs.core_defmulti",
                                               :source {:code "(defmacro defmulti\n  [mm-name & options]\n  (let [docstring   (if (string? (first options))\n                      (first options)\n                      nil)\n        options     (if (string? (first options))\n                      (next options)\n                      options)\n        m           (if (map? (first options))\n                      (first options)\n                      {})\n        options     (if (map? (first options))\n                      (next options)\n                      options)\n        dispatch-fn (first options)\n        options     (next options)\n        m           (if docstring\n                      (assoc m :doc docstring)\n                      m)\n        m           (if (meta mm-name)\n                      (conj (meta mm-name) m)\n                      m)]\n    (when (= (count options) 1)\n      (throw \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\"))\n    (let [options   (apply hash-map options)\n          default   (get options :default :default)\n          ;; hierarchy (get options :hierarchy #'cljs.core.global-hierarchy)\n\t  ]\n      (check-valid-options options :default :hierarchy)\n      `(def ~(with-meta mm-name m)\n\t (let [method-table# (atom {})\n\t       prefer-table# (atom {})\n\t       method-cache# (atom {})\n\t       cached-hierarchy# (atom {})\n\t       hierarchy# (get ~options :hierarchy cljs.core/global-hierarchy)\n\t       ]\n\t   (cljs.core.MultiFn. ~(name mm-name) ~dispatch-fn ~default hierarchy#\n\t\t\t       method-table# prefer-table# method-cache# cached-hierarchy#))))))",
                                                        :filename "clojurescript/src/clj/cljs/core.clj",
                                                        :lines [711
                                                                755],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L711-L755"},
                                               :full-name "cljs.core/defmulti",
                                               :clj-symbol "clojure.core/defmulti",
                                               :docstring "Creates a new multimethod with the associated dispatch function.\nThe docstring and attribute-map are optional.\n\nOptions are key-value pairs and may be one of:\n  :default    the default dispatch value, defaults to :default\n  :hierarchy  the isa? hierarchy to use for dispatching\n              defaults to the global hierarchy"},
                         "clojure.browser.event/dispatch-event" {:full-name "clojure.browser.event/dispatch-event",
                                                                 :ns "clojure.browser.event",
                                                                 :name "dispatch-event",
                                                                 :type "function",
                                                                 :signature ["[src event]"],
                                                                 :source {:code "(defn dispatch-event\n  [src event]\n  (goog.events/dispatchEvent src event))",
                                                                          :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                          :lines [75
                                                                                  77],
                                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/event.cljs#L75-L77"},
                                                                 :full-name-encode "clojure.browser.event_dispatch-event",
                                                                 :history [["+"
                                                                            "0.0-927"]]},
                         "clojure.string/split-lines" {:ns "clojure.string",
                                                       :name "split-lines",
                                                       :signature ["[s]"],
                                                       :history [["+"
                                                                  "0.0-927"]],
                                                       :type "function",
                                                       :full-name-encode "clojure.string_split-lines",
                                                       :source {:code "(defn split-lines\n  [s]\n  (split s #\"\\n|\\r\\n\"))",
                                                                :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                                :lines [101
                                                                        104],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/string.cljs#L101-L104"},
                                                       :full-name "clojure.string/split-lines",
                                                       :clj-symbol "clojure.string/split-lines",
                                                       :docstring "Splits s on \n or \r\n."},
                         "cljs.core/areduce" {:ns "cljs.core",
                                              :name "areduce",
                                              :signature ["[a idx ret init expr]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "macro",
                                              :full-name-encode "cljs.core_areduce",
                                              :source {:code "(defmacro areduce\n  [a idx ret init expr]\n  `(let [a# ~a]\n     (loop  [~idx 0 ~ret ~init]\n       (if (< ~idx  (alength a#))\n         (recur (inc ~idx) ~expr)\n         ~ret))))",
                                                       :filename "clojurescript/src/clj/cljs/core.clj",
                                                       :lines [676
                                                               685],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L676-L685"},
                                              :full-name "cljs.core/areduce",
                                              :clj-symbol "clojure.core/areduce",
                                              :docstring "Reduces an expression across an array a, using an index named idx,\nand return value named ret, initialized to init, setting ret to the \nevaluation of expr at each step, returning ret."},
                         "cljs.core/disj" {:ns "cljs.core",
                                           :name "disj",
                                           :signature ["[coll]"
                                                       "[coll k]"
                                                       "[coll k & ks]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_disj",
                                           :source {:code "(defn disj\n  ([coll] coll)\n  ([coll k]\n     (-disjoin coll k))\n  ([coll k & ks]\n     (let [ret (disj coll k)]\n       (if ks\n         (recur ret (first ks) (next ks))\n         ret))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [568 578],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L568-L578"},
                                           :full-name "cljs.core/disj",
                                           :clj-symbol "clojure.core/disj",
                                           :docstring "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\ndoes not contain key(s)."},
                         "clojure.browser.net/event-types" {:full-name "clojure.browser.net/event-types",
                                                            :ns "clojure.browser.net",
                                                            :name "event-types",
                                                            :type "var",
                                                            :source {:code "(def event-types\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (. k (toLowerCase)))\n            v])\n         (merge\n          (js->clj goog.net.EventType)))))",
                                                                     :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                     :lines [23
                                                                             30],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/net.cljs#L23-L30"},
                                                            :full-name-encode "clojure.browser.net_event-types",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "clojure.string/lower-case" {:ns "clojure.string",
                                                      :name "lower-case",
                                                      :signature ["[s]"],
                                                      :history [["+"
                                                                 "0.0-927"]],
                                                      :type "function",
                                                      :full-name-encode "clojure.string_lower-case",
                                                      :source {:code "(defn lower-case\n  [s]\n  (. s (toLowerCase)))",
                                                               :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                               :lines [58
                                                                       61],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/string.cljs#L58-L61"},
                                                      :full-name "clojure.string/lower-case",
                                                      :clj-symbol "clojure.string/lower-case",
                                                      :docstring "Converts string to all lower-case."},
                         "cljs.core/*print-fn*" {:full-name "cljs.core/*print-fn*",
                                                 :ns "cljs.core",
                                                 :name "*print-fn*",
                                                 :docstring "Each runtime environment provides a diffenent way to print output.\nWhatever function *print-fn* is bound to will be passed any\nStrings which should be printed.",
                                                 :type "function",
                                                 :source {:code "(def\n  ^{:doc \"Each runtime environment provides a diffenent way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.\"}\n  *print-fn*\n  (fn [_]\n    (throw (js/Error. \"No *print-fn* fn set for evaluation environment\"))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [15
                                                                  21],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L15-L21"},
                                                 :full-name-encode "cljs.core__STAR_print-fn_STAR_",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "cljs.core/str" {:ns "cljs.core",
                                          :name "str",
                                          :signature ["[]"
                                                      "[x]"
                                                      "[x & ys]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_str",
                                          :source {:code "(defn str\n  ([] \"\")\n  ([x] (cond\n        (symbol? x) (. x (substring 2 (.-length x)))\n        (keyword? x) (str* \":\" (. x (substring 2 (.-length x))))\n        (nil? x) \"\"\n        :else (. x (toString))))\n  ([x & ys]\n     ((fn [sb more]\n        (if more\n          (recur (. sb  (append (str (first more)))) (next more))\n          (str* sb)))\n      (gstring/StringBuffer. (str x)) ys)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [1048 1063],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1048-L1063"},
                                          :full-name "cljs.core/str",
                                          :clj-symbol "clojure.core/str",
                                          :docstring "With no args, returns the empty string. With one arg x, returns\nx.toString().  (str nil) returns the empty string. With more than\none arg, returns the concatenation of the str values of the args."},
                         "cljs.core/ISequential" {:ns "cljs.core",
                                                  :name "ISequential",
                                                  :type "protocol",
                                                  :full-name-encode "cljs.core_ISequential",
                                                  :source {:code "(defprotocol ISequential\n  \"Marker interface indicating a persistent collection of sequential items\")",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [183
                                                                   184],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L183-L184"},
                                                  :full-name "cljs.core/ISequential",
                                                  :docstring "Marker interface indicating a persistent collection of sequential items",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/set" {:ns "cljs.core",
                                          :name "set",
                                          :signature ["[coll]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_set",
                                          :source {:code "(defn set\n  [coll]\n  (loop [in (seq coll)\n         out cljs.core.Set/EMPTY]\n    (if-not (empty? in)\n      (recur (rest in) (conj out (first in)))\n      out)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [2710 2717],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2710-L2717"},
                                          :full-name "cljs.core/set",
                                          :clj-symbol "clojure.core/set",
                                          :docstring "Returns a set of the distinct elements of coll."},
                         "special/def" {:full-name "special/def",
                                        :ns "special",
                                        :name "def",
                                        :type "special form",
                                        :source {:code "(defmethod parse 'def\n  [op env form name]\n  (let [pfn (fn ([_ sym] {:sym sym})\n              ([_ sym init] {:sym sym :init init})\n              ([_ sym doc init] {:sym sym :doc doc :init init}))\n        args (apply pfn form)\n        sym (:sym args)]\n    (assert (not (namespace sym)) \"Can't def ns-qualified name\")\n    (let [name (munge (:name (resolve-var (dissoc env :locals) sym)))\n          init-expr (when (contains? args :init) (disallowing-recur\n                                                  (analyze (assoc env :context :expr) (:init args) sym)))\n          export-as (when-let [export-val (-> sym meta :export)]\n                      (if (= true export-val) name export-val))\n          doc (or (:doc args) (-> sym meta :doc))]\n      (swap! namespaces update-in [(-> env :ns :name) :defs sym]\n             (fn [m]\n               (let [m (assoc (or m {}) :name name)]\n                 (if-let [line (:line env)]\n                   (-> m\n                       (assoc :file *cljs-file*)\n                       (assoc :line line))\n                   m))))\n      (merge {:env env :op :def :form form\n              :name name :doc doc :init init-expr}\n             (when init-expr {:children [init-expr]})\n             (when export-as {:export export-as})))))",
                                                 :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                 :lines [689 714],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/compiler.clj#L689-L714"},
                                        :full-name-encode "special_def",
                                        :clj-symbol "clojure.core/def",
                                        :history [["+" "0.0-927"]]},
                         "cljs.core/print" {:full-name "cljs.core/print",
                                            :ns "cljs.core",
                                            :name "print",
                                            :docstring "Prints the object(s) using string-print.\nprint and println produce output for human consumption.",
                                            :type "function",
                                            :source {:code "(def ^{:doc\n  \"Prints the object(s) using string-print.\n  print and println produce output for human consumption.\"}\n  print\n  (fn cljs-core-print [& objs]\n    (pr-with-opts objs (assoc (pr-opts) :readably false))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [3129
                                                             3134],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3129-L3134"},
                                            :full-name-encode "cljs.core_print",
                                            :clj-symbol "clojure.core/print",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/type" {:full-name "cljs.core/type",
                                           :ns "cljs.core",
                                           :name "type",
                                           :type "function",
                                           :signature ["[x]"],
                                           :source {:code "(defn type [x]\n  (js* \"(~{x}).constructor\"))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [219 220],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L219-L220"},
                                           :full-name-encode "cljs.core_type",
                                           :clj-symbol "clojure.core/type",
                                           :history [["+" "0.0-971"]]},
                         "clojure.string/blank?" {:ns "clojure.string",
                                                  :name "blank?",
                                                  :signature ["[s]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.string_blank_QMARK_",
                                                  :source {:code "(defn blank?\n  [s]\n  (let [s (str s)]\n    (if (or\n         (not s)\n         (= \"\" s)\n         (re-matches #\"\\s+\" s))\n      true\n      false)))",
                                                           :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                           :lines [133
                                                                   142],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/string.cljs#L133-L142"},
                                                  :full-name "clojure.string/blank?",
                                                  :clj-symbol "clojure.string/blank?",
                                                  :docstring "True is s is nil, empty, or contains only whitespace."},
                         "clojure.browser.dom/append" {:full-name "clojure.browser.dom/append",
                                                       :ns "clojure.browser.dom",
                                                       :name "append",
                                                       :type "function",
                                                       :signature ["[parent & children]"],
                                                       :source {:code "(defn append [parent & children]\n  (apply gdom/append parent children)\n  parent)",
                                                                :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                :lines [12
                                                                        14],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/dom.cljs#L12-L14"},
                                                       :full-name-encode "clojure.browser.dom_append",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.core/take-last" {:ns "cljs.core",
                                                :name "take-last",
                                                :signature ["[n coll]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_take-last",
                                                :source {:code "(defn take-last\n  [n coll]\n  (loop [s (seq coll), lead (seq (drop n coll))]\n    (if lead\n      (recur (next s) (next lead))\n      s)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1736
                                                                 1743],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1736-L1743"},
                                                :full-name "cljs.core/take-last",
                                                :clj-symbol "clojure.core/take-last",
                                                :docstring "Returns a seq of the last n items in coll.  Depending on the type\nof coll may be no better than linear time.  For vectors, see also subvec."},
                         "clojure.set/intersection" {:ns "clojure.set",
                                                     :name "intersection",
                                                     :signature ["[s1]"
                                                                 "[s1 s2]"
                                                                 "[s1 s2 & sets]"],
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "clojure.set_intersection",
                                                     :source {:code "(defn intersection\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s2) (count s1))\n       (recur s2 s1)\n       (reduce (fn [result item]\n                   (if (contains? s2 item)\n\t\t     result\n                     (disj result item)))\n\t       s1 s1)))\n  ([s1 s2 & sets] \n     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]\n       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))",
                                                              :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                              :lines [31
                                                                      44],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/set.cljs#L31-L44"},
                                                     :full-name "clojure.set/intersection",
                                                     :clj-symbol "clojure.set/intersection",
                                                     :docstring "Return a set that is the intersection of the input sets"},
                         "cljs.core/fnext" {:ns "cljs.core",
                                            :name "fnext",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_fnext",
                                            :source {:code "(defn fnext\n  [coll]\n  (first (next coll)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [447 450],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L447-L450"},
                                            :full-name "cljs.core/fnext",
                                            :clj-symbol "clojure.core/fnext",
                                            :docstring "Same as (first (next x))"},
                         "cljs.core/apply" {:ns "cljs.core",
                                            :name "apply",
                                            :signature ["[f args]"
                                                        "[f x args]"
                                                        "[f x y args]"
                                                        "[f x y z args]"
                                                        "[f a b c d & args]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_apply",
                                            :source {:code "(defn apply\n  ([f args]\n     (let [fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count args (inc fixed-arity))\n                 fixed-arity)\n           (.apply f f (to-array args))\n           (.cljs$lang$applyTo f args))\n         (.apply f f (to-array args)))))\n  ([f x args]\n     (let [arglist (list* x args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count arglist fixed-arity)\n                 fixed-arity)\n           (.apply f f (to-array arglist))\n           (.cljs$lang$applyTo f arglist))\n         (.apply f f (to-array arglist)))))\n  ([f x y args]\n     (let [arglist (list* x y args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count arglist fixed-arity)\n                 fixed-arity)\n           (.apply f f (to-array arglist))\n           (.cljs$lang$applyTo f arglist))\n         (.apply f f (to-array arglist)))))\n  ([f x y z args]\n     (let [arglist (list* x y z args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count arglist fixed-arity)\n                 fixed-arity)\n           (.apply f f (to-array arglist))\n           (.cljs$lang$applyTo f arglist))\n         (.apply f f (to-array arglist)))))\n  ([f a b c d & args]\n     (let [arglist (cons a (cons b (cons c (cons d (spread args)))))\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count arglist fixed-arity)\n                 fixed-arity)\n           (.apply f f (to-array arglist))\n           (.cljs$lang$applyTo f arglist))\n         (.apply f f (to-array arglist))))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [1381
                                                             1427],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1381-L1427"},
                                            :full-name "cljs.core/apply",
                                            :clj-symbol "clojure.core/apply",
                                            :docstring "Applies fn f to the argument list formed by prepending intervening arguments to args.\nFirst cut.  Not lazy.  Needs to use emitted toApply."},
                         "clojure.walk/prewalk" {:ns "clojure.walk",
                                                 :name "prewalk",
                                                 :signature ["[f form]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.walk_prewalk",
                                                 :source {:code "(defn prewalk\n  [f form]\n  (walk (partial prewalk f) identity (f form)))",
                                                          :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                          :lines [58
                                                                  62],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/walk.cljs#L58-L62"},
                                                 :full-name "clojure.walk/prewalk",
                                                 :clj-symbol "clojure.walk/prewalk",
                                                 :docstring "Like postwalk, but does pre-order traversal."},
                         "cljs.core/flatten" {:ns "cljs.core",
                                              :name "flatten",
                                              :signature ["[x]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_flatten",
                                              :source {:code "(defn flatten\n  [x]\n  (filter #(not (sequential? %))\n          (rest (tree-seq sequential? seq x))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1860
                                                               1866],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1860-L1866"},
                                              :full-name "cljs.core/flatten",
                                              :clj-symbol "clojure.core/flatten",
                                              :docstring "Takes any nested combination of sequential things (lists, vectors,\netc.) and returns their contents as a single, flat sequence.\n(flatten nil) returns nil."},
                         "cljs.core/get" {:ns "cljs.core",
                                          :name "get",
                                          :signature ["[o k]"
                                                      "[o k not-found]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_get",
                                          :source {:code "(defn get\n  ([o k]\n     (-lookup o k))\n  ([o k not-found]\n     (-lookup o k not-found)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [511 516],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L511-L516"},
                                          :full-name "cljs.core/get",
                                          :clj-symbol "clojure.core/get",
                                          :docstring "Returns the value mapped to key, not-found or nil if key not present."},
                         "cljs.core/.." {:ns "cljs.core",
                                         :name "..",
                                         :signature ["[x form]"
                                                     "[x form & more]"],
                                         :history [["+" "0.0-927"]],
                                         :type "macro",
                                         :full-name-encode "cljs.core__DOT__DOT_",
                                         :source {:code "(defmacro ..\n  ([x form] `(. ~x ~form))\n  ([x form & more] `(.. (. ~x ~form) ~@more)))",
                                                  :filename "clojure/src/clj/clojure/core.clj",
                                                  :lines [1510 1526],
                                                  :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L1510-L1526"},
                                         :full-name "cljs.core/..",
                                         :clj-symbol "clojure.core/..",
                                         :docstring "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\nExpands into a member access (.) of the first member on the first\nargument, followed by the next member on the result, etc. For\ninstance:\n\n(.. System (getProperties) (get \"os.name\"))\n\nexpands to:\n\n(. (. System (getProperties)) (get \"os.name\"))\n\nbut is easier to write, read, and understand."},
                         "cljs.core/Range" {:full-name "cljs.core/Range",
                                            :ns "cljs.core",
                                            :name "Range",
                                            :type "type",
                                            :signature ["[meta start end step]"],
                                            :source {:code "(deftype Range [meta start end step]\n  IWithMeta\n  (-with-meta [rng meta] (Range. meta start end step))\n\n  IMeta\n  (-meta [rng] meta)\n\n  ISeq\n  (-first [rng] start)\n  (-rest [rng]\n    (if (-seq rng)\n      (Range. meta (+ start step) end step)\n      (list)))\n\n  ICollection\n  (-conj [rng o] (cons o rng))\n\n  IEmptyableCollection\n  (-empty [rng] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [rng other] (equiv-sequential rng other))\n\n  IHash\n  (-hash [rng] (hash-coll rng))\n\n  ICounted\n  (-count [rng]\n    (if-not (-seq rng)\n      0\n      (js/Math.ceil (/ (- end start) step))))\n\n  IIndexed\n  (-nth [rng n]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (= step 0))\n        start\n        (throw (js/Error. \"Index out of bounds\")))))\n  (-nth [rng n not-found]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (= step 0))\n        start\n        not-found)))\n\n  ISeqable\n  (-seq [rng]\n    (let [comp (if (pos? step) < >)]\n      (when (comp start end)\n        rng)))\n\n  IReduce\n  (-reduce [rng f] (ci-reduce rng f))\n  (-reduce [rng f s] (ci-reduce rng f s)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2819
                                                             2874],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2819-L2874"},
                                            :full-name-encode "cljs.core_Range",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/zero?" {:ns "cljs.core",
                                            :name "zero?",
                                            :signature ["[n]"],
                                            :shadowed-sources ({:code "(defmacro zero? [x]\n  `(== ~x 0))",
                                                                :filename "clojurescript/src/clj/cljs/core.clj",
                                                                :lines [119
                                                                        120],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L119-L120"}),
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_zero_QMARK_",
                                            :source {:code "(defn zero? [n]\n  (cljs.core/zero? n))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [999 1000],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L999-L1000"},
                                            :full-name "cljs.core/zero?",
                                            :clj-symbol "clojure.core/zero?"},
                         "cljs.core/identity" {:full-name "cljs.core/identity",
                                               :ns "cljs.core",
                                               :name "identity",
                                               :type "function",
                                               :signature ["[x]"],
                                               :source {:code "(defn identity [x] x)",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [1484
                                                                1484],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1484-L1484"},
                                               :full-name-encode "cljs.core_identity",
                                               :clj-symbol "clojure.core/identity",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/first" {:ns "cljs.core",
                                            :name "first",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_first",
                                            :source {:code "(defn first\n  [coll]\n  (when-let [s (seq coll)]\n    (-first s)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [412 417],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L412-L417"},
                                            :full-name "cljs.core/first",
                                            :clj-symbol "clojure.core/first",
                                            :docstring "Returns the first item in the collection. Calls seq on its\nargument. If coll is nil, returns nil."},
                         "cljs.reader/ratio-pattern" {:full-name "cljs.reader/ratio-pattern",
                                                      :ns "cljs.reader",
                                                      :name "ratio-pattern",
                                                      :type "var",
                                                      :source {:code "(def ratio-pattern (re-pattern \"([-+]?[0-9]+)/([0-9]+)\"))",
                                                               :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                               :lines [96
                                                                       96],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L96-L96"},
                                                      :full-name-encode "cljs.reader_ratio-pattern",
                                                      :history [["+"
                                                                 "0.0-927"]]},
                         "cljs.core/println-str" {:ns "cljs.core",
                                                  :name "println-str",
                                                  :signature ["[& objs]"],
                                                  :history [["+"
                                                             "0.0-1011"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_println-str",
                                                  :source {:code "(defn println-str\n  [& objs]\n  (prn-str-with-opts objs (assoc (pr-opts) :readably false)))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [3147
                                                                   3150],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3147-L3150"},
                                                  :full-name "cljs.core/println-str",
                                                  :clj-symbol "clojure.core/println-str",
                                                  :docstring "println to a string, returning it"},
                         "cljs.core/>" {:ns "cljs.core",
                                        :name ">",
                                        :signature ["[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :shadowed-sources ({:code "(defmacro >\n  ([x] true)\n  ([x y] (list 'js* \"(~{} > ~{})\" x y))\n  ([x y & more] `(and (> ~x ~y) (> ~y ~@more))))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [98
                                                                    101],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L98-L101"}),
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core__GT_",
                                        :source {:code "(defn >\n  ([x] true)\n  ([x y] (cljs.core/> x y))\n  ([x y & more]\n   (if (cljs.core/> x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/> y (first more)))\n     false)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [862 872],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L862-L872"},
                                        :full-name "cljs.core/>",
                                        :clj-symbol "clojure.core/>",
                                        :docstring "Returns non-nil if nums are in monotonically decreasing order,\notherwise false."},
                         "cljs.core/juxt" {:ns "cljs.core",
                                           :name "juxt",
                                           :signature ["[f]"
                                                       "[f g]"
                                                       "[f g h]"
                                                       "[f g h & fs]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_juxt",
                                           :source {:code "(defn juxt\n  ([f]\n     (fn\n       ([] (vector (f)))\n       ([x] (vector (f x)))\n       ([x y] (vector (f x y)))\n       ([x y z] (vector (f x y z)))\n       ([x y z & args] (vector (apply f x y z args)))))\n  ([f g]\n     (fn\n       ([] (vector (f) (g)))\n       ([x] (vector (f x) (g x)))\n       ([x y] (vector (f x y) (g x y)))\n       ([x y z] (vector (f x y z) (g x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (vector (f) (g) (h)))\n       ([x] (vector (f x) (g x) (h x)))\n       ([x y] (vector (f x y) (g x y) (h x y)))\n       ([x y z] (vector (f x y z) (g x y z) (h x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args) (apply h x y z args)))))\n  ([f g h & fs]\n     (let [fs (list* f g h fs)]\n       (fn\n         ([] (reduce #(conj %1 (%2)) [] fs))\n         ([x] (reduce #(conj %1 (%2 x)) [] fs))\n         ([x y] (reduce #(conj %1 (%2 x y)) [] fs))\n         ([x y z] (reduce #(conj %1 (%2 x y z)) [] fs))\n         ([x y z & args] (reduce #(conj %1 (apply %2 x y z args)) [] fs))))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2932 2966],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2932-L2966"},
                                           :full-name "cljs.core/juxt",
                                           :clj-symbol "clojure.core/juxt",
                                           :docstring "Takes a set of functions and returns a fn that is the juxtaposition\nof those fns.  The returned fn takes a variable number of args, and\nreturns a vector containing the result of applying each fn to the\nargs (left-to-right).\n((juxt a b c) x) => [(a x) (b x) (c x)]"},
                         "cljs.core/max" {:ns "cljs.core",
                                          :name "max",
                                          :signature ["[x]"
                                                      "[x y]"
                                                      "[x y & more]"],
                                          :shadowed-sources ({:code "(defmacro max\n  ([x] x)\n  ([x y] (list 'js* \"((~{} > ~{}) ? ~{} : ~{})\" x y x y))\n  ([x y & more] `(max (max ~x ~y) ~@more)))",
                                                              :filename "clojurescript/src/clj/cljs/core.clj",
                                                              :lines [128
                                                                      131],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L128-L131"}),
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_max",
                                          :source {:code "(defn max\n  ([x] x)\n  ([x y] (cljs.core/max x y))\n  ([x y & more]\n   (reduce max (cljs.core/max x y) more)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [890 895],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L890-L895"},
                                          :full-name "cljs.core/max",
                                          :clj-symbol "clojure.core/max",
                                          :docstring "Returns the greatest of the nums."},
                         "cljs.core/*3" {:full-name "cljs.core/*3",
                                         :ns "cljs.core",
                                         :name "*3",
                                         :docstring "bound in a repl thread to the third most recent value printed",
                                         :type "var",
                                         :source {:code "(def\n  ^{:doc \"bound in a repl thread to the third most recent value printed\"}\n  *3)",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [31 33],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L31-L33"},
                                         :full-name-encode "cljs.core__STAR_3",
                                         :clj-symbol "clojure.core/*3",
                                         :history [["+" "0.0-927"]]},
                         "cljs.core/number?" {:full-name "cljs.core/number?",
                                              :ns "cljs.core",
                                              :name "number?",
                                              :type "function",
                                              :signature ["[n]"],
                                              :source {:code "(defn number? [n]\n  (goog/isNumber n))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [678
                                                               679],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L678-L679"},
                                              :full-name-encode "cljs.core_number_QMARK_",
                                              :clj-symbol "clojure.core/number?",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/array" {:ns "cljs.core",
                                            :name "array",
                                            :signature ["[var-args]"],
                                            :shadowed-sources ({:code "(defmacro array [& rest]\n  (let [xs-str (->> (repeat \"~{}\")\n                    (take (count rest))\n                    (interpose \",\")\n                    (apply str))]\n   (concat\n    (list 'js* (str \"[\" xs-str \"]\"))\n    rest)))",
                                                                :filename "clojurescript/src/clj/cljs/core.clj",
                                                                :lines [649
                                                                        656],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L649-L656"}),
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_array",
                                            :source {:code "(defn array\n  [var-args]            ;; [& items]\n  (js* \"Array.prototype.slice.call(arguments)\"))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [71 75],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L71-L75"},
                                            :full-name "cljs.core/array",
                                            :docstring "Creates a new javascript array.\n@param {...*} var_args"},
                         "cljs.core/nthnext" {:ns "cljs.core",
                                              :name "nthnext",
                                              :signature ["[coll n]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_nthnext",
                                              :source {:code "(defn nthnext\n  [coll n]\n  (loop [n n xs (seq coll)]\n    (if (and xs (pos? n))\n      (recur (dec n) (next xs))\n      xs)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1010
                                                               1016],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1010-L1016"},
                                              :full-name "cljs.core/nthnext",
                                              :clj-symbol "clojure.core/nthnext",
                                              :docstring "Returns the nth next of coll, (seq coll) when n is 0."},
                         "cljs.core/re-pattern" {:ns "cljs.core",
                                                 :name "re-pattern",
                                                 :signature ["[s]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_re-pattern",
                                                 :source {:code "(defn re-pattern\n  [s]\n  (let [[_ flags pattern] (re-find #\"^(?:\\(\\?([idmsux]*)\\))?(.*)\" s)]\n    (js/RegExp. pattern flags)))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [3027
                                                                  3031],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3027-L3031"},
                                                 :full-name "cljs.core/re-pattern",
                                                 :clj-symbol "clojure.core/re-pattern",
                                                 :docstring "Returns an instance of RegExp which has compiled the provided string."},
                         "cljs.core/missing-protocol" {:full-name "cljs.core/missing-protocol",
                                                       :ns "cljs.core",
                                                       :name "missing-protocol",
                                                       :type "function",
                                                       :signature ["[proto obj]"],
                                                       :source {:code "(defn missing-protocol [proto obj]\n  (js/Error (js* \"~{}+~{}+~{}+~{}+~{}+~{}\"\n                 \"No protocol method \" proto\n                 \" defined for type \" (goog/typeOf obj) \": \" obj)))",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [58
                                                                        61],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L58-L61"},
                                                       :full-name-encode "cljs.core_missing-protocol",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "clojure.browser.dom/set-text" {:full-name "clojure.browser.dom/set-text",
                                                         :ns "clojure.browser.dom",
                                                         :name "set-text",
                                                         :docstring "Set the text content for the passed element returning the\nelement. If a keyword is passed in the place of e, the element with\nthat id will be used and returned.",
                                                         :type "function",
                                                         :signature ["[e s]"],
                                                         :source {:code "(defn set-text\n  [e s]\n  (gdom/setTextContent (ensure-element e) s))",
                                                                  :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                  :lines [122
                                                                          127],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/dom.cljs#L122-L127"},
                                                         :full-name-encode "clojure.browser.dom_set-text",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "clojure.zip/up" {:ns "clojure.zip",
                                           :name "up",
                                           :signature ["[loc]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.zip_up",
                                           :source {:code "(defn up\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes r :r, changed? :changed?, :as path}] loc]\n      (when pnodes\n        (let [pnode (peek pnodes)]\n          (with-meta (if changed?\n                       [(make-node loc pnode (concat l (cons node r))) \n                        (and ppath (assoc ppath :changed? true))]\n                       [pnode ppath])\n                     (meta loc))))))",
                                                    :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                    :lines [111 122],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L111-L122"},
                                           :full-name "clojure.zip/up",
                                           :clj-symbol "clojure.zip/up",
                                           :docstring "Returns the loc of the parent of the node at this loc, or nil if at\nthe top"},
                         "cljs.core/IWithMeta" {:ns "cljs.core",
                                                :name "IWithMeta",
                                                :type "protocol",
                                                :full-name-encode "cljs.core_IWithMeta",
                                                :source {:code "(defprotocol IWithMeta\n  (-with-meta [o meta]))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [168
                                                                 169],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L168-L169"},
                                                :methods [{:name "-with-meta",
                                                           :signature ["[o meta]"],
                                                           :docstring nil}],
                                                :full-name "cljs.core/IWithMeta",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/bit-and-not" {:ns "cljs.core",
                                                  :name "bit-and-not",
                                                  :signature ["[x y]"],
                                                  :shadowed-sources ({:code "(defmacro bit-and-not\n  ([x y] (list 'js* \"(~{} & ~~{})\" x y))\n  ([x y & more] `(bit-and-not (bit-and-not ~x ~y) ~@more)))",
                                                                      :filename "clojurescript/src/clj/cljs/core.clj",
                                                                      :lines [156
                                                                              158],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L156-L158"}),
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_bit-and-not",
                                                  :source {:code "(defn bit-and-not\n  [x y] (cljs.core/bit-and-not x y))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [947
                                                                   949],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L947-L949"},
                                                  :full-name "cljs.core/bit-and-not",
                                                  :clj-symbol "clojure.core/bit-and-not",
                                                  :docstring "Bitwise and"},
                         "clojure.string/triml" {:ns "clojure.string",
                                                 :name "triml",
                                                 :signature ["[s]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.string_triml",
                                                 :source {:code "(defn triml\n    [s]\n    (gstring/trimLeft s))",
                                                          :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                          :lines [111
                                                                  114],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/string.cljs#L111-L114"},
                                                 :full-name "clojure.string/triml",
                                                 :clj-symbol "clojure.string/triml",
                                                 :docstring "Removes whitespace from the left side of string."},
                         "clojure.string/split" {:ns "clojure.string",
                                                 :name "split",
                                                 :signature ["[s re]"
                                                             "[s re limit]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.string_split",
                                                 :source {:code "(defn split\n  ([s re]\n     (vec (.split (str s) re)))\n  ([s re limit]\n     (if (< limit 1)\n       (vec (.split (str s) re))\n       (loop [s s\n              limit limit\n              parts []]\n         (if (= limit 1)\n           (conj parts s)\n           (if-let [m (re-find re s)]\n             (let [index (.indexOf s m)]\n               (recur (.substring s (+ index (count m)))\n                      (dec limit)\n                      (conj parts (.substring s 0 index))))\n             (conj parts s)))))))",
                                                          :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                          :lines [81
                                                                  99],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/string.cljs#L81-L99"},
                                                 :full-name "clojure.string/split",
                                                 :clj-symbol "clojure.string/split",
                                                 :docstring "Splits string on a regular expression. Optional argument limit is\nthe maximum number of splits. Not lazy. Returns vector of the splits."},
                         "cljs.core/hash-map" {:ns "cljs.core",
                                               :name "hash-map",
                                               :signature ["[& keyvals]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_hash-map",
                                               :source {:code "(defn hash-map\n  [& keyvals]\n  (loop [in (seq keyvals), out cljs.core.HashMap/EMPTY]\n    (if in\n      (recur (nnext in) (assoc out (first in) (second in)))\n      out)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [2600
                                                                2607],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2600-L2607"},
                                               :full-name "cljs.core/hash-map",
                                               :clj-symbol "clojure.core/hash-map",
                                               :docstring "keyval => key val\nReturns a new hash map with supplied mappings."},
                         "cljs.core/rem" {:ns "cljs.core",
                                          :name "rem",
                                          :signature ["[n d]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_rem",
                                          :source {:code "(defn rem\n  [n d]\n  (let [q (quot n d)]\n    (js* \"(~{n} - (~{d} * ~{q}))\")))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [920 924],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L920-L924"},
                                          :full-name "cljs.core/rem",
                                          :clj-symbol "clojure.core/rem",
                                          :docstring "remainder of dividing numerator by denominator."},
                         "cljs.core/IRecord" {:ns "cljs.core",
                                              :name "IRecord",
                                              :type "protocol",
                                              :full-name-encode "cljs.core_IRecord",
                                              :source {:code "(defprotocol IRecord\n  \"Marker interface indicating a record object\")",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [186
                                                               187],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L186-L187"},
                                              :full-name "cljs.core/IRecord",
                                              :docstring "Marker interface indicating a record object",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/constantly" {:ns "cljs.core",
                                                 :name "constantly",
                                                 :signature ["[x]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_constantly",
                                                 :source {:code "(defn constantly\n  [x] (fn [& args] x))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [1496
                                                                  1498],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1496-L1498"},
                                                 :full-name "cljs.core/constantly",
                                                 :clj-symbol "clojure.core/constantly",
                                                 :docstring "Returns a function that takes any number of arguments and returns x."},
                         "clojure.browser.dom/get-element" {:full-name "clojure.browser.dom/get-element",
                                                            :ns "clojure.browser.dom",
                                                            :name "get-element",
                                                            :type "function",
                                                            :signature ["[id]"],
                                                            :source {:code "(defn get-element [id]\n  (gdom/getElement (name id)))",
                                                                     :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                     :lines [96
                                                                             97],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/dom.cljs#L96-L97"},
                                                            :full-name-encode "clojure.browser.dom_get-element",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "cljs.core/and" {:ns "cljs.core",
                                          :name "and",
                                          :signature ["[]"
                                                      "[x]"
                                                      "[x & next]"],
                                          :history [["+" "0.0-927"]],
                                          :type "macro",
                                          :full-name-encode "cljs.core_and",
                                          :source {:code "(defmacro and\n  ([] true)\n  ([x] x)\n  ([x & next]\n   `(let [and# ~x]\n      (if and# (and ~@next) and#))))",
                                                   :filename "clojure/src/clj/clojure/core.clj",
                                                   :lines [777 787],
                                                   :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L777-L787"},
                                          :full-name "cljs.core/and",
                                          :clj-symbol "clojure.core/and",
                                          :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns logical false (nil or false), and returns that value and\ndoesn't evaluate any of the other expressions, otherwise it returns\nthe value of the last expr. (and) returns true."},
                         "clojure.browser.repl/wrap-message" {:full-name "clojure.browser.repl/wrap-message",
                                                              :ns "clojure.browser.repl",
                                                              :name "wrap-message",
                                                              :type "function",
                                                              :signature ["[t data]"],
                                                              :source {:code "(defn wrap-message [t data]\n  (pr-str {:type t :content data :order (swap! order inc)}))",
                                                                       :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                       :lines [57
                                                                               58],
                                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/repl.cljs#L57-L58"},
                                                              :full-name-encode "clojure.browser.repl_wrap-message",
                                                              :history [["+"
                                                                         "0.0-927"]]},
                         "clojure.browser.event/unlisten-by-key" {:full-name "clojure.browser.event/unlisten-by-key",
                                                                  :ns "clojure.browser.event",
                                                                  :name "unlisten-by-key",
                                                                  :type "function",
                                                                  :signature ["[key]"],
                                                                  :source {:code "(defn unlisten-by-key\n  [key]\n  (goog.events/unlistenByKey key))",
                                                                           :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                           :lines [71
                                                                                   73],
                                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/event.cljs#L71-L73"},
                                                                  :full-name-encode "clojure.browser.event_unlisten-by-key",
                                                                  :history [["+"
                                                                             "0.0-927"]]},
                         "cljs.core/try" {:ns "cljs.core",
                                          :name "try",
                                          :signature ["[& forms]"],
                                          :history [["+" "0.0-927"]],
                                          :type "macro",
                                          :full-name-encode "cljs.core_try",
                                          :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (list? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                                   :filename "clojurescript/src/clj/cljs/core.clj",
                                                   :lines [511 539],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L511-L539"},
                                          :full-name "cljs.core/try",
                                          :clj-symbol "clojure.core/try",
                                          :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions."},
                         "cljs.core/iterate" {:ns "cljs.core",
                                              :name "iterate",
                                              :signature ["[f x]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_iterate",
                                              :source {:code "(defn iterate\n  [f x] (cons x (lazy-seq (iterate f (f x)))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1783
                                                               1786],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1783-L1786"},
                                              :full-name "cljs.core/iterate",
                                              :clj-symbol "clojure.core/iterate",
                                              :docstring "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"},
                         "cljs.core/lazy-seq" {:full-name "cljs.core/lazy-seq",
                                               :ns "cljs.core",
                                               :name "lazy-seq",
                                               :type "macro",
                                               :signature ["[& body]"],
                                               :source {:code "(defmacro lazy-seq [& body]\n  `(new cljs.core.LazySeq nil false (fn [] ~@body)))",
                                                        :filename "clojurescript/src/clj/cljs/core.clj",
                                                        :lines [434
                                                                435],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L434-L435"},
                                               :full-name-encode "cljs.core_lazy-seq",
                                               :clj-symbol "clojure.core/lazy-seq",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "specialrepl/load-file" {:full-name "specialrepl/load-file",
                                                  :ns "specialrepl",
                                                  :name "load-file",
                                                  :type "special form (repl)",
                                                  :source {:code "(def default-special-fns\n  (let [load-file-fn (fn [repl-env file] (load-file repl-env file))]\n    {'in-ns (fn [_ quoted-ns] (set! comp/*cljs-ns* (second quoted-ns)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace (fn [repl-env ns] (load-namespace repl-env ns))}))",
                                                           :filename "clojurescript/src/clj/cljs/repl.clj",
                                                           :lines [134
                                                                   139],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/repl.clj#L134-L139"},
                                                  :full-name-encode "specialrepl_load-file",
                                                  :clj-symbol "clojure.core/load-file",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/IndexedSeq" {:full-name "cljs.core/IndexedSeq",
                                                 :ns "cljs.core",
                                                 :name "IndexedSeq",
                                                 :type "type",
                                                 :signature ["[a i]"],
                                                 :source {:code "(deftype IndexedSeq [a i]\n  ISeqable\n  (-seq [this] this)\n  ISeq\n  (-first [_] (aget a i))\n  (-rest [_] (if (< (inc i) (.-length a))\n               (IndexedSeq. a (inc i))\n               (list)))\n\n  ICounted\n  (-count [_] (- (.-length a) i))\n\n  IIndexed\n  (-nth [coll n]\n    (let [i (+ n i)]\n      (when (< i (.-length a))\n        (aget a i))))\n  (-nth [coll n not-found]\n    (let [i (+ n i)]\n      (if (< i (.-length a))\n        (aget a i)\n        not-found)))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IReduce\n  (-reduce [_ f]\n    (ci-reduce a f (aget a i) (inc i)))\n  (-reduce [_ f start]\n    (ci-reduce a f start i))\n\n  IHash\n  (-hash [coll] (hash-coll coll)))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [329
                                                                  366],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L329-L366"},
                                                 :full-name-encode "cljs.core_IndexedSeq",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "cljs.core/next" {:ns "cljs.core",
                                           :name "next",
                                           :signature ["[coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_next",
                                           :source {:code "(defn next\n  [coll]\n  (when coll\n    (seq (rest coll))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [425 430],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L425-L430"},
                                           :full-name "cljs.core/next",
                                           :clj-symbol "clojure.core/next",
                                           :docstring "Returns a seq of the items after the first. Calls seq on its\nargument.  If there are no more items, returns nil"},
                         "cljs.core/*print-readably*" {:full-name "cljs.core/*print-readably*",
                                                       :ns "cljs.core",
                                                       :name "*print-readably*",
                                                       :type "var",
                                                       :source {:code "(def *print-readably* true)",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [3101
                                                                        3101],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3101-L3101"},
                                                       :full-name-encode "cljs.core__STAR_print-readably_STAR_",
                                                       :clj-symbol "clojure.core/*print-readably*",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.core/last" {:ns "cljs.core",
                                           :name "last",
                                           :signature ["[s]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_last",
                                           :source {:code "(defn last\n  [s]\n  (if (next s)\n    (recur (next s))\n    (first s)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [457 462],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L457-L462"},
                                           :full-name "cljs.core/last",
                                           :clj-symbol "clojure.core/last",
                                           :docstring "Return the last item in coll, in linear time"},
                         "cljs.core/bit-shift-left" {:ns "cljs.core",
                                                     :name "bit-shift-left",
                                                     :signature ["[x n]"],
                                                     :shadowed-sources ({:code "(defmacro bit-shift-left [x n]\n  (list 'js* \"(~{} << ~{})\" x n))",
                                                                         :filename "clojurescript/src/clj/cljs/core.clj",
                                                                         :lines [169
                                                                                 170],
                                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L169-L170"}),
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.core_bit-shift-left",
                                                     :source {:code "(defn bit-shift-left\n  [x n] (cljs.core/bit-shift-left x n))",
                                                              :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                              :lines [975
                                                                      977],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L975-L977"},
                                                     :full-name "cljs.core/bit-shift-left",
                                                     :clj-symbol "clojure.core/bit-shift-left",
                                                     :docstring "Bitwise shift left"},
                         "clojure.string/reverse" {:ns "clojure.string",
                                                   :name "reverse",
                                                   :signature ["[s]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.string_reverse",
                                                   :source {:code "(defn reverse\n  [s]\n  (.. s (split \"\") (reverse) (join \"\")))",
                                                            :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                            :lines [18
                                                                    21],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/string.cljs#L18-L21"},
                                                   :full-name "clojure.string/reverse",
                                                   :clj-symbol "clojure.string/reverse",
                                                   :docstring "Returns s with its characters reversed."},
                         "cljs.core/min" {:ns "cljs.core",
                                          :name "min",
                                          :signature ["[x]"
                                                      "[x y]"
                                                      "[x y & more]"],
                                          :shadowed-sources ({:code "(defmacro min\n  ([x] x)\n  ([x y] (list 'js* \"((~{} < ~{}) ? ~{} : ~{})\" x y x y))\n  ([x y & more] `(min (min ~x ~y) ~@more)))",
                                                              :filename "clojurescript/src/clj/cljs/core.clj",
                                                              :lines [133
                                                                      136],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L133-L136"}),
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_min",
                                          :source {:code "(defn min\n  ([x] x)\n  ([x y] (cljs.core/min x y))\n  ([x y & more]\n   (reduce min (cljs.core/min x y) more)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [897 902],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L897-L902"},
                                          :full-name "cljs.core/min",
                                          :clj-symbol "clojure.core/min",
                                          :docstring "Returns the least of the nums."},
                         "cljs.reader/escape-char" {:full-name "cljs.reader/escape-char",
                                                    :ns "cljs.reader",
                                                    :name "escape-char",
                                                    :type "function",
                                                    :signature ["[buffer reader]"],
                                                    :source {:code "(defn escape-char\n  [buffer reader]\n  (let [ch (read-char reader)\n        mapresult (get escape-char-map ch)]\n    (if mapresult\n      mapresult\n      (if (or (= \\u ch) (numeric? ch))\n        (read-unicode-char reader ch)\n        (reader-error reader \"Unsupported escape charater: \\\\\" ch)))))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [149
                                                                     157],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L149-L157"},
                                                    :full-name-encode "cljs.reader_escape-char",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "cljs.reader/read-map" {:full-name "cljs.reader/read-map",
                                                 :ns "cljs.reader",
                                                 :name "read-map",
                                                 :type "function",
                                                 :signature ["[rdr _]"],
                                                 :source {:code "(defn read-map\n  [rdr _]\n  (let [l (read-delimited-list \"}\" rdr true)]\n    (when (odd? (count l))\n      (reader-error rdr \"Map literal must contain an even number of forms\"))\n    (apply hash-map l)))",
                                                          :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                          :lines [213
                                                                  218],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L213-L218"},
                                                 :full-name-encode "cljs.reader_read-map",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "cljs.core/seq" {:ns "cljs.core",
                                          :name "seq",
                                          :signature ["[coll]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_seq",
                                          :source {:code "(defn seq\n  [coll]\n  (when coll\n    (-seq coll)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [404 410],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L404-L410"},
                                          :full-name "cljs.core/seq",
                                          :clj-symbol "clojure.core/seq",
                                          :docstring "Returns a seq on the collection. If the collection is\nempty, returns nil.  (seq nil) returns nil. seq also works on\nStrings."},
                         "cljs.core/not-empty" {:ns "cljs.core",
                                                :name "not-empty",
                                                :signature ["[coll]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_not-empty",
                                                :source {:code "(defn not-empty\n  [coll] (when (seq coll) coll))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1442
                                                                 1444],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1442-L1444"},
                                                :full-name "cljs.core/not-empty",
                                                :clj-symbol "clojure.core/not-empty",
                                                :docstring "If coll is empty, returns nil, else coll"},
                         "cljs.core/println" {:ns "cljs.core",
                                              :name "println",
                                              :signature ["[& objs]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_println",
                                              :source {:code "(defn println\n  [& objs]\n  (pr-with-opts objs (assoc (pr-opts) :readably false))\n  (newline (pr-opts)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [3141
                                                               3145],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3141-L3145"},
                                              :full-name "cljs.core/println",
                                              :clj-symbol "clojure.core/println",
                                              :docstring "Same as print followed by (newline)"},
                         "clojure.browser.repl/connect" {:full-name "clojure.browser.repl/connect",
                                                         :ns "clojure.browser.repl",
                                                         :name "connect",
                                                         :docstring "Connects to a REPL server from an HTML document. After the\nconnection is made, the REPL will evaluate forms in the context of\nthe document that called this function.",
                                                         :type "function",
                                                         :signature ["[repl-server-url]"],
                                                         :source {:code "(defn connect\n  [repl-server-url]\n  (let [repl-connection (net/xpc-connection\n                         {:peer_uri repl-server-url})]\n    (swap! xpc-connection (constantly repl-connection))\n    (net/register-service repl-connection\n                          :evaluate-javascript\n                          (fn [js]\n                            (net/transmit\n                             repl-connection\n                             :send-result\n                             (evaluate-javascript repl-connection js))))\n    (net/connect repl-connection\n                 (constantly nil)\n                 (fn [iframe]\n                   (set! iframe.style.display\n                         \"none\")))))",
                                                                  :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                  :lines [90
                                                                          109],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/repl.cljs#L90-L109"},
                                                         :full-name-encode "clojure.browser.repl_connect",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "clojure.browser.dom/insert-at" {:full-name "clojure.browser.dom/insert-at",
                                                          :ns "clojure.browser.dom",
                                                          :name "insert-at",
                                                          :type "function",
                                                          :signature ["[parent child index]"],
                                                          :source {:code "(defn insert-at [parent child index]\n  (gdom/insertChildAt parent child index))",
                                                                   :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                   :lines [102
                                                                           103],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/dom.cljs#L102-L103"},
                                                          :full-name-encode "clojure.browser.dom_insert-at",
                                                          :history [["+"
                                                                     "0.0-927"]]},
                         "cljs.core/quot" {:ns "cljs.core",
                                           :name "quot",
                                           :signature ["[n d]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_quot",
                                           :source {:code "(defn quot\n  [n d]\n  (let [rem (mod n d)]\n    (fix (js* \"((~{n} - ~{rem}) / ~{d})\"))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [914 918],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L914-L918"},
                                           :full-name "cljs.core/quot",
                                           :clj-symbol "clojure.core/quot",
                                           :docstring "quot[ient] of dividing numerator by denominator."},
                         "clojure.browser.event/get-listener" {:full-name "clojure.browser.event/get-listener",
                                                               :ns "clojure.browser.event",
                                                               :name "get-listener",
                                                               :type "function",
                                                               :signature ["[src type listener opt_capt opt_handler]"],
                                                               :source {:code "(defn get-listener [src type listener opt_capt opt_handler])",
                                                                        :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                        :lines [89
                                                                                89],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/event.cljs#L89-L89"},
                                                               :full-name-encode "clojure.browser.event_get-listener",
                                                               :history [["+"
                                                                          "0.0-927"]]},
                         "cljs.core/filter" {:ns "cljs.core",
                                             :name "filter",
                                             :signature ["[pred coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_filter",
                                             :source {:code "(defn filter\n  ([pred coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (let [f (first s) r (rest s)]\n        (if (pred f)\n          (cons f (filter pred r))\n          (filter pred r)))))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1828
                                                              1837],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1828-L1837"},
                                             :full-name "cljs.core/filter",
                                             :clj-symbol "clojure.core/filter",
                                             :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns true. pred must be free of side-effects."},
                         "clojure.zip/branch?" {:ns "clojure.zip",
                                                :name "branch?",
                                                :signature ["[loc]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.zip_branch_QMARK_",
                                                :source {:code "(defn branch?\n  [loc]\n    ((:zip/branch? (meta loc)) (node loc)))",
                                                         :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                         :lines [64
                                                                 67],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L64-L67"},
                                                :full-name "clojure.zip/branch?",
                                                :clj-symbol "clojure.zip/branch?",
                                                :docstring "Returns true if the node at loc is a branch"},
                         "special/if" {:full-name "special/if",
                                       :ns "special",
                                       :name "if",
                                       :type "special form",
                                       :source {:code "(defmethod parse 'if\n  [op env [_ test then else :as form] name]\n  (let [test-expr (disallowing-recur (analyze (assoc env :context :expr) test))\n        then-expr (analyze env then)\n        else-expr (analyze env else)]\n    {:env env :op :if :form form\n     :test test-expr :then then-expr :else else-expr\n     :children [test-expr then-expr else-expr]}))",
                                                :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                :lines [638 645],
                                                :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/compiler.clj#L638-L645"},
                                       :full-name-encode "special_if",
                                       :clj-symbol "clojure.core/if",
                                       :history [["+" "0.0-927"]]},
                         "cljs.core/ObjMap" {:full-name "cljs.core/ObjMap",
                                             :ns "cljs.core",
                                             :name "ObjMap",
                                             :type "type",
                                             :signature ["[meta keys strobj]"],
                                             :source {:code "(deftype ObjMap [meta keys strobj]\n  IWithMeta\n  (-with-meta [coll meta] (ObjMap. meta keys strobj))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.ObjMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? (.-length keys))\n      (map #(vector % (aget strobj %))\n           (.sort keys obj-map-compare-keys))))\n\n  ICounted\n  (-count [coll] (.-length keys))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (obj-map-contains-key? k strobj (aget strobj k) not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (goog/isString k)\n      (let [new-strobj (goog.object/clone strobj)\n            overwrite? (.hasOwnProperty new-strobj k)]\n        (aset new-strobj k v)\n        (if overwrite?\n          (ObjMap. meta keys new-strobj)     ; overwrite\n          (let [new-keys (aclone keys)] ; append\n            (.push new-keys k)\n            (ObjMap. meta new-keys new-strobj))))\n      ; non-string key. game over.\n      (with-meta (into (hash-map k v) (seq coll)) meta)))\n  (-contains-key? [coll k]\n    (obj-map-contains-key? k strobj))\n\n  IMap\n  (-dissoc [coll k]\n    (if (and (goog/isString k) (.hasOwnProperty strobj k))\n      (let [new-keys (aclone keys)\n            new-strobj (goog.object/clone strobj)]\n        (.splice new-keys (scan-array 1 k new-keys) 1)\n        (js-delete new-strobj k)\n        (ObjMap. meta new-keys new-strobj))\n      coll)) ; key not found, return coll unchanged\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2423
                                                              2491],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2423-L2491"},
                                             :full-name-encode "cljs.core_ObjMap",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/zipmap" {:ns "cljs.core",
                                             :name "zipmap",
                                             :signature ["[keys vals]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_zipmap",
                                             :source {:code "(defn zipmap\n  [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2774
                                                              2784],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2774-L2784"},
                                             :full-name "cljs.core/zipmap",
                                             :clj-symbol "clojure.core/zipmap",
                                             :docstring "Returns a map with the keys mapped to the corresponding vals."},
                         "cljs.core/hash-combine" {:full-name "cljs.core/hash-combine",
                                                   :ns "cljs.core",
                                                   :name "hash-combine",
                                                   :type "function",
                                                   :signature ["[seed hash]"],
                                                   :source {:code "(defn hash-combine [seed hash]\n  ; a la boost\n  (bit-xor seed (+ hash 0x9e3779b9\n                   (bit-shift-left seed 6)\n                   (bit-shift-right seed 2))))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [1100
                                                                    1104],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1100-L1104"},
                                                   :full-name-encode "cljs.core_hash-combine",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "cljs.core/max-key" {:ns "cljs.core",
                                              :name "max-key",
                                              :signature ["[k x]"
                                                          "[k x y]"
                                                          "[k x y & more]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_max-key",
                                              :source {:code "(defn max-key\n  ([k x] x)\n  ([k x y] (if (> (k x) (k y)) x y))\n  ([k x y & more]\n   (reduce #(max-key k %1 %2) (max-key k x y) more)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2786
                                                               2791],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2786-L2791"},
                                              :full-name "cljs.core/max-key",
                                              :clj-symbol "clojure.core/max-key",
                                              :docstring "Returns the x for which (k x), a number, is greatest."},
                         "clojure.zip/insert-child" {:ns "clojure.zip",
                                                     :name "insert-child",
                                                     :signature ["[loc item]"],
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "clojure.zip_insert-child",
                                                     :source {:code "(defn insert-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (cons item (children loc)))))",
                                                              :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                              :lines [194
                                                                      198],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L194-L198"},
                                                     :full-name "clojure.zip/insert-child",
                                                     :clj-symbol "clojure.zip/insert-child",
                                                     :docstring "Inserts the item as the leftmost child of the node at this loc,\nwithout moving"},
                         "cljs.core/defrecord" {:full-name "cljs.core/defrecord",
                                                :ns "cljs.core",
                                                :name "defrecord",
                                                :type "macro",
                                                :signature ["[rsym fields & impls]"],
                                                :source {:code "(defmacro defrecord [rsym fields & impls]\n  (let [r (:name (cljs.compiler/resolve-var (dissoc &env :locals) rsym))]\n    `(let []\n       ~(emit-defrecord rsym r fields impls)\n       (set! (.-cljs$core$IPrintable$_pr_seq ~r) (fn [this#] (list ~(str r))))\n       ~(build-positional-factory rsym r fields)\n       ~(build-map-factory rsym r fields)\n       ~r)))",
                                                         :filename "clojurescript/src/clj/cljs/core.clj",
                                                         :lines [389
                                                                 396],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L389-L396"},
                                                :full-name-encode "cljs.core_defrecord",
                                                :clj-symbol "clojure.core/defrecord",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/butlast" {:full-name "cljs.core/butlast",
                                              :ns "cljs.core",
                                              :name "butlast",
                                              :type "function",
                                              :signature ["[s]"],
                                              :source {:code "(defn butlast [s]\n  (loop [ret [] s s]\n    (if (next s)\n      (recur (conj ret (first s)) (next s))\n      (seq ret))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2747
                                                               2751],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2747-L2751"},
                                              :full-name-encode "cljs.core_butlast",
                                              :clj-symbol "clojure.core/butlast",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/print-str" {:ns "cljs.core",
                                                :name "print-str",
                                                :signature ["[& objs]"],
                                                :history [["+"
                                                           "0.0-1011"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_print-str",
                                                :source {:code "(defn print-str\n  [& objs]\n  (pr-str-with-opts objs (assoc (pr-opts) :readably false)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [3136
                                                                 3139],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3136-L3139"},
                                                :full-name "cljs.core/print-str",
                                                :clj-symbol "clojure.core/print-str",
                                                :docstring "print to a string, returning it"},
                         "cljs.core/hash" {:full-name "cljs.core/hash",
                                           :ns "cljs.core",
                                           :name "hash",
                                           :type "function",
                                           :signature ["[o]"],
                                           :source {:code "(defn hash [o]\n  (-hash o))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [580 581],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L580-L581"},
                                           :full-name-encode "cljs.core_hash",
                                           :clj-symbol "clojure.core/hash",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/bit-set" {:ns "cljs.core",
                                              :name "bit-set",
                                              :signature ["[x n]"],
                                              :shadowed-sources ({:code "(defmacro bit-set [x n]\n  (list 'js* \"(~{} | (1 << ~{}))\" x n))",
                                                                  :filename "clojurescript/src/clj/cljs/core.clj",
                                                                  :lines [175
                                                                          176],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L175-L176"}),
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_bit-set",
                                              :source {:code "(defn bit-set\n  [x n]\n  (cljs.core/bit-set x n))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [965
                                                               968],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L965-L968"},
                                              :full-name "cljs.core/bit-set",
                                              :clj-symbol "clojure.core/bit-set",
                                              :docstring "Set bit at index n"},
                         "cljs.core/concat" {:ns "cljs.core",
                                             :name "concat",
                                             :signature ["[]"
                                                         "[x]"
                                                         "[x y]"
                                                         "[x y & zs]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_concat",
                                             :source {:code "(defn concat\n  ([] (lazy-seq nil))\n  ([x] (lazy-seq x))\n  ([x y]\n    (lazy-seq\n      (let [s (seq x)]\n        (if s\n          (cons (first s) (concat (rest s) y))\n          y))))\n  ([x y & zs]\n     (let [cat (fn cat [xys zs]\n                 (lazy-seq\n                   (let [xys (seq xys)]\n                     (if xys\n                       (cons (first xys) (cat (rest xys) zs))\n                       (when zs\n                         (cat (first zs) (next zs)))))))]\n       (cat (concat x y) zs))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1349
                                                              1367],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1349-L1367"},
                                             :full-name "cljs.core/concat",
                                             :clj-symbol "clojure.core/concat",
                                             :docstring "Returns a lazy seq representing the concatenation of the elements in the supplied colls."},
                         "cljs.core/conj" {:ns "cljs.core",
                                           :name "conj",
                                           :signature ["[coll x]"
                                                       "[coll x & xs]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_conj",
                                           :source {:code "(defn conj\n  ([coll x]\n     (-conj coll x))\n  ([coll x & xs]\n     (if xs\n       (recur (conj coll x) (first xs) (next xs))\n       (conj coll x))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [479 488],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L479-L488"},
                                           :full-name "cljs.core/conj",
                                           :clj-symbol "clojure.core/conj",
                                           :docstring "conj[oin]. Returns a new collection with the xs\n'added'. (conj nil item) returns (item).  The 'addition' may\nhappen at different 'places' depending on the concrete type."},
                         "clojure.set/difference" {:ns "clojure.set",
                                                   :name "difference",
                                                   :signature ["[s1]"
                                                               "[s1 s2]"
                                                               "[s1 s2 & sets]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.set_difference",
                                                   :source {:code "(defn difference\n  ([s1] s1)\n  ([s1 s2] \n     (if (< (count s1) (count s2))\n       (reduce (fn [result item] \n                   (if (contains? s2 item) \n                     (disj result item) \n                     result))\n               s1 s1)\n       (reduce disj s1 s2)))\n  ([s1 s2 & sets] \n     (reduce difference s1 (conj sets s2))))",
                                                            :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                            :lines [46
                                                                    58],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/set.cljs#L46-L58"},
                                                   :full-name "clojure.set/difference",
                                                   :clj-symbol "clojure.set/difference",
                                                   :docstring "Return a set that is the first set without elements of the remaining sets"},
                         "cljs.core/when-first" {:ns "cljs.core",
                                                 :name "when-first",
                                                 :signature ["[bindings & body]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "macro",
                                                 :full-name-encode "cljs.core_when-first",
                                                 :source {:code "(defmacro when-first\n  [bindings & body]\n  (assert-args when-first\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n  (let [[x xs] bindings]\n    `(when (seq ~xs)\n       (let [~x (first ~xs)]\n         ~@body))))",
                                                          :filename "clojure/src/clj/clojure/core.clj",
                                                          :lines [4050
                                                                  4062],
                                                          :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L4050-L4062"},
                                                 :full-name "cljs.core/when-first",
                                                 :clj-symbol "clojure.core/when-first",
                                                 :docstring "bindings => x xs\n\nSame as (when (seq xs) (let [x (first xs)] body))"},
                         "cljs.core/distinct?" {:ns "cljs.core",
                                                :name "distinct?",
                                                :signature ["[x]"
                                                            "[x y]"
                                                            "[x y & more]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_distinct_QMARK_",
                                                :source {:code "(defn distinct?\n  ([x] true)\n  ([x y] (not (= x y)))\n  ([x y & more]\n     (if (not (= x y))\n     (loop [s #{x y} xs more]\n       (let [x (first xs)\n             etc (next xs)]\n         (if xs\n           (if (contains? s x)\n             false\n             (recur (conj s x) etc))\n           true)))\n     false)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [709
                                                                 723],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L709-L723"},
                                                :full-name "cljs.core/distinct?",
                                                :clj-symbol "clojure.core/distinct?",
                                                :docstring "Returns true if no two of the arguments are ="},
                         "cljs.core/pos?" {:ns "cljs.core",
                                           :name "pos?",
                                           :signature ["[n]"],
                                           :shadowed-sources ({:code "(defmacro pos? [x]\n  `(> ~x 0))",
                                                               :filename "clojurescript/src/clj/cljs/core.clj",
                                                               :lines [122
                                                                       123],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L122-L123"}),
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_pos_QMARK_",
                                           :source {:code "(defn pos?\n  [n] (cljs.core/pos? n))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [995 997],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L995-L997"},
                                           :full-name "cljs.core/pos?",
                                           :clj-symbol "clojure.core/pos?",
                                           :docstring "Returns true if num is greater than zero, else false"},
                         "cljs.core/PersistentVector" {:full-name "cljs.core/PersistentVector",
                                                       :ns "cljs.core",
                                                       :name "PersistentVector",
                                                       :type "type",
                                                       :signature ["[meta cnt shift root tail]"],
                                                       :source {:code "(deftype PersistentVector [meta cnt shift root tail]\n  IWithMeta\n  (-with-meta [coll meta] (PersistentVector. meta cnt shift root tail))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (when (> cnt 0)\n      (-nth coll (dec cnt))))\n  (-pop [coll]\n    (cond\n     (zero? cnt) (throw (js/Error. \"Can't pop empty vector\"))\n     (= 1 cnt) (-with-meta cljs.core.PersistentVector/EMPTY meta)\n     (< 1 (- cnt (tail-off coll)))\n      (PersistentVector. meta (dec cnt) shift root (aclone tail))\n      :else (let [new-tail (array-for coll (- cnt 2))\n                  nr (pop-tail shift root)\n                  new-root (if (nil? nr) cljs.core.PersistentVector/EMPTY_NODE nr)\n                  cnt-1 (dec cnt)]\n              (if (and (< 5 shift) (nil? (aget new-root 1)))\n                (PersistentVector. meta cnt-1 (- shift 5) (aget new-root 0) new-tail)\n                (PersistentVector. meta cnt-1 shift new-root new-tail)))))\n\n  ICollection\n  (-conj [coll o]\n    (if (< (- cnt (tail-off coll)) 32)\n      (let [new-tail (aclone tail)]\n        (.push new-tail o)\n        (PersistentVector. meta (inc cnt) shift root new-tail))\n      (let [root-overflow? (> (bit-shift-right cnt 5) (bit-shift-left 1 shift))\n            new-shift (if root-overflow? (+ shift 5) shift)\n            new-root (if root-overflow?\n                       (let [n-r (aclone cljs.core.PersistentVector/EMPTY_NODE)]\n                           (aset n-r 0 root)\n                           (aset n-r 1 (new-path shift tail))\n                           n-r)\n                       (push-tail coll shift root tail))]\n        (PersistentVector. meta (inc cnt) new-shift new-root (array o)))))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.PersistentVector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (when (> cnt 0)\n      (let [vector-seq\n             (fn vector-seq [i]\n               (lazy-seq\n                 (when (< i cnt)\n                   (cons (-nth coll i) (vector-seq (inc i))))))]\n        (vector-seq 0))))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IIndexed\n  (-nth [coll n]\n    (aget (array-for coll n) (bit-and n 0x01f)))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n cnt))\n      (-nth coll n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (cond\n       (and (<= 0 k) (< k cnt))\n       (if (<= (tail-off coll) k)\n         (let [new-tail (aclone tail)]\n           (aset new-tail (bit-and k 0x01f) v)\n           (PersistentVector. meta cnt shift root new-tail))\n         (PersistentVector. meta cnt shift (do-assoc coll shift root k v) tail))\n       (= k cnt) (-conj coll v)\n       :else (throw (js/Error. (str \"Index \" k \" out of bounds  [0,\" cnt \"]\")))))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [v f]\n    (ci-reduce v f))\n  (-reduce [v f start]\n    (ci-reduce v f start))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [2096
                                                                        2197],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2096-L2197"},
                                                       :full-name-encode "cljs.core_PersistentVector",
                                                       :history [["+"
                                                                  "0.0-1006"]]},
                         "cljs.core/IHash" {:ns "cljs.core",
                                            :name "IHash",
                                            :type "protocol",
                                            :full-name-encode "cljs.core_IHash",
                                            :source {:code "(defprotocol IHash\n  (-hash [o]))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [177 178],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L177-L178"},
                                            :methods [{:name "-hash",
                                                       :signature ["[o]"],
                                                       :docstring nil}],
                                            :full-name "cljs.core/IHash",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/is_proto_" {:full-name "cljs.core/is_proto_",
                                                :ns "cljs.core",
                                                :name "is_proto_",
                                                :type "function",
                                                :signature ["[x]"],
                                                :source {:code "(defn is_proto_\n  [x]\n  (js* \"(~{x}).constructor.prototype === ~{x}\"))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [48
                                                                 50],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L48-L50"},
                                                :full-name-encode "cljs.core_is_proto_",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/keep-indexed" {:ns "cljs.core",
                                                   :name "keep-indexed",
                                                   :signature ["[f coll]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.core_keep-indexed",
                                                   :source {:code "(defn keep-indexed\n  ([f coll]\n     (let [keepi (fn kpi [idx coll]\n                   (lazy-seq\n                    (when-let [s (seq coll)]\n                      (let [x (f idx (first s))]\n                        (if (nil? x)\n                          (kpi (inc idx) (rest s))\n                          (cons x (kpi (inc idx) (rest s))))))))]\n       (keepi 0 coll))))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [1590
                                                                    1602],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1590-L1602"},
                                                   :full-name "cljs.core/keep-indexed",
                                                   :clj-symbol "clojure.core/keep-indexed",
                                                   :docstring "Returns a lazy sequence of the non-nil results of (f index item). Note,\nthis means false return values will be included.  f must be free of\nside-effects."},
                         "cljs.core/bit-shift-right" {:ns "cljs.core",
                                                      :name "bit-shift-right",
                                                      :signature ["[x n]"],
                                                      :shadowed-sources ({:code "(defmacro bit-shift-right [x n]\n  (list 'js* \"(~{} >> ~{})\" x n))",
                                                                          :filename "clojurescript/src/clj/cljs/core.clj",
                                                                          :lines [172
                                                                                  173],
                                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L172-L173"}),
                                                      :history [["+"
                                                                 "0.0-927"]],
                                                      :type "function",
                                                      :full-name-encode "cljs.core_bit-shift-right",
                                                      :source {:code "(defn bit-shift-right\n  [x n] (cljs.core/bit-shift-right x n))",
                                                               :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                               :lines [979
                                                                       981],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L979-L981"},
                                                      :full-name "cljs.core/bit-shift-right",
                                                      :clj-symbol "clojure.core/bit-shift-right",
                                                      :docstring "Bitwise shift right"},
                         "clojure.zip/insert-right" {:ns "clojure.zip",
                                                     :name "insert-right",
                                                     :signature ["[loc item]"],
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "clojure.zip_insert-right",
                                                     :source {:code "(defn insert-right\n  [loc item]\n    (let [[node {r :r :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :r (cons item r) :changed? true)] (meta loc)))))",
                                                              :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                              :lines [174
                                                                      181],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L174-L181"},
                                                     :full-name "clojure.zip/insert-right",
                                                     :clj-symbol "clojure.zip/insert-right",
                                                     :docstring "Inserts the item as the right sibling of the node at this loc,\nwithout moving"},
                         "cljs.core/make-hierarchy" {:ns "cljs.core",
                                                     :name "make-hierarchy",
                                                     :signature ["[]"],
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.core_make-hierarchy",
                                                     :source {:code "(defn make-hierarchy\n  [] {:parents {} :descendants {} :ancestors {}})",
                                                              :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                              :lines [3506
                                                                      3508],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3506-L3508"},
                                                     :full-name "cljs.core/make-hierarchy",
                                                     :clj-symbol "clojure.core/make-hierarchy",
                                                     :docstring "Creates a hierarchy object for use with derive, isa? etc."},
                         "cljs.core/repeat" {:ns "cljs.core",
                                             :name "repeat",
                                             :signature ["[x]"
                                                         "[n x]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_repeat",
                                             :source {:code "(defn repeat\n  ([x] (lazy-seq (cons x (repeat x))))\n  ([n x] (take n (repeat x))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1767
                                                              1770],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1767-L1770"},
                                             :full-name "cljs.core/repeat",
                                             :clj-symbol "clojure.core/repeat",
                                             :docstring "Returns a lazy (infinite!, or length n if supplied) sequence of xs."},
                         "cljs.core/prn-str-with-opts" {:full-name "cljs.core/prn-str-with-opts",
                                                        :ns "cljs.core",
                                                        :name "prn-str-with-opts",
                                                        :docstring "Same as pr-str-with-opts followed by (newline)",
                                                        :type "function",
                                                        :signature ["[objs opts]"],
                                                        :source {:code "(defn prn-str-with-opts\n  [objs opts]\n  (let [sb (pr-sb objs opts)]\n    (.append sb \\newline)\n    (str sb)))",
                                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                 :lines [3077
                                                                         3082],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3077-L3082"},
                                                        :full-name-encode "cljs.core_prn-str-with-opts",
                                                        :history [["+"
                                                                   "0.0-1011"]]},
                         "cljs.core/MultiFn" {:full-name "cljs.core/MultiFn",
                                              :ns "cljs.core",
                                              :name "MultiFn",
                                              :type "type",
                                              :signature ["[name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]"],
                                              :source {:code "(deftype MultiFn [name dispatch-fn default-dispatch-val hierarchy\n                  method-table prefer-table method-cache cached-hierarchy]\n  IMultiFn\n  (-reset [mf]\n    (swap! method-table (fn [mf] {}))\n    (swap! method-cache (fn [mf] {}))\n    (swap! prefer-table (fn [mf] {}))\n    (swap! cached-hierarchy (fn [mf] nil))\n    mf)\n\n  (-add-method [mf dispatch-val method]\n    (swap! method-table assoc dispatch-val method)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-remove-method [mf dispatch-val]\n    (swap! method-table dissoc dispatch-val)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-get-method [mf dispatch-val]\n    (when-not (= @cached-hierarchy @hierarchy)\n      (reset-cache method-cache method-table cached-hierarchy hierarchy))\n    (if-let [target-fn (@method-cache dispatch-val)]\n      target-fn\n      (if-let [target-fn (find-and-cache-best-method name dispatch-val hierarchy method-table\n                                                     prefer-table method-cache cached-hierarchy)]\n        target-fn\n        (@method-table default-dispatch-val))))\n\n  (-prefer-method [mf dispatch-val-x dispatch-val-y]\n    (when (prefers* dispatch-val-x dispatch-val-y prefer-table)\n      (throw (js/Error. (str \"Preference conflict in multimethod '\" name \"': \" dispatch-val-y\n                   \" is already preferred to \" dispatch-val-x))))\n    (swap! prefer-table\n           (fn [old]\n             (assoc old dispatch-val-x\n                    (conj (get old dispatch-val-x #{})\n                          dispatch-val-y))))\n    (reset-cache method-cache method-table cached-hierarchy hierarchy))\n\n  (-methods [mf] @method-table)\n  (-prefers [mf] @prefer-table)\n\n  (-dispatch [mf args] (do-dispatch mf dispatch-fn args))\n\n  IHash\n  (-hash [this] (goog.getUid this)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [3684
                                                               3731],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3684-L3731"},
                                              :full-name-encode "cljs.core_MultiFn",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/not-any?" {:ns "cljs.core",
                                               :name "not-any?",
                                               :signature ["[pred coll]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_not-any_QMARK_",
                                               :source {:code "(defn not-any?\n  [pred coll] (not (some pred coll)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [1469
                                                                1472],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1469-L1472"},
                                               :full-name "cljs.core/not-any?",
                                               :clj-symbol "clojure.core/not-any?",
                                               :docstring "Returns false if (pred x) is logical true for any x in coll,\nelse true."},
                         "cljs.reader/read-regex" {:full-name "cljs.reader/read-regex",
                                                   :ns "cljs.reader",
                                                   :name "read-regex",
                                                   :type "function",
                                                   :signature ["[rdr ch]"],
                                                   :source {:code "(defn read-regex\n  [rdr ch]\n  (-> (read-string rdr ch) re-pattern))",
                                                            :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                            :lines [301
                                                                    303],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L301-L303"},
                                                   :full-name-encode "cljs.reader_read-regex",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "clojure.zip/next" {:ns "clojure.zip",
                                             :name "next",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_next",
                                             :source {:code "(defn next\n  [loc]\n    (if (= :end (loc 1))\n      loc\n      (or \n       (and (branch? loc) (down loc))\n       (right loc)\n       (loop [p loc]\n         (if (up p)\n           (or (right (up p)) (recur (up p)))\n           [(node p) :end])))))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [206 219],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L206-L219"},
                                             :full-name "clojure.zip/next",
                                             :clj-symbol "clojure.zip/next",
                                             :docstring "Moves to the next loc in the hierarchy, depth-first. When reaching\nthe end, returns a distinguished loc detectable via end?. If already\nat the end, stays there."},
                         "cljs.core/IFn" {:ns "cljs.core",
                                          :name "IFn",
                                          :type "protocol",
                                          :full-name-encode "cljs.core_IFn",
                                          :source {:code "(defprotocol IFn\n  (-invoke\n    [this]\n    [this a]\n    [this a b]\n    [this a b c]\n    [this a b c d]\n    [this a b c d e]\n    [this a b c d e f]\n    [this a b c d e f g]\n    [this a b c d e f g h]\n    [this a b c d e f g h i]\n    [this a b c d e f g h i j]\n    [this a b c d e f g h i j k]\n    [this a b c d e f g h i j k l]\n    [this a b c d e f g h i j k l m]\n    [this a b c d e f g h i j k l m n]\n    [this a b c d e f g h i j k l m n o]\n    [this a b c d e f g h i j k l m n o p]\n    [this a b c d e f g h i j k l m n o p q]\n    [this a b c d e f g h i j k l m n o p q s]\n    [this a b c d e f g h i j k l m n o p q s t]\n    [this a b c d e f g h i j k l m n o p q s t rest]))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [94 116],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L94-L116"},
                                          :methods [{:name "-invoke",
                                                     :signature ["[this]"
                                                                 "[this a]"
                                                                 "[this a b]"
                                                                 "[this a b c]"
                                                                 "[this a b c d]"
                                                                 "[this a b c d e]"
                                                                 "[this a b c d e f]"
                                                                 "[this a b c d e f g]"
                                                                 "[this a b c d e f g h]"
                                                                 "[this a b c d e f g h i]"
                                                                 "[this a b c d e f g h i j]"
                                                                 "[this a b c d e f g h i j k]"
                                                                 "[this a b c d e f g h i j k l]"
                                                                 "[this a b c d e f g h i j k l m]"
                                                                 "[this a b c d e f g h i j k l m n]"
                                                                 "[this a b c d e f g h i j k l m n o]"
                                                                 "[this a b c d e f g h i j k l m n o p]"
                                                                 "[this a b c d e f g h i j k l m n o p q]"
                                                                 "[this a b c d e f g h i j k l m n o p q s]"
                                                                 "[this a b c d e f g h i j k l m n o p q s t]"
                                                                 "[this a b c d e f g h i j k l m n o p q s t rest]"],
                                                     :docstring nil}],
                                          :full-name "cljs.core/IFn",
                                          :history [["+" "0.0-971"]]},
                         "cljs.core/aget" {:ns "cljs.core",
                                           :name "aget",
                                           :signature ["[array i]"],
                                           :shadowed-sources ({:code "(defmacro aget [a i]\n  (list 'js* \"(~{}[~{}])\" a i))",
                                                               :filename "clojurescript/src/clj/cljs/core.clj",
                                                               :lines [60
                                                                       61],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L60-L61"}),
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_aget",
                                           :source {:code "(defn aget\n  [array i]\n  (cljs.core/aget array i))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [77 80],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L77-L80"},
                                           :full-name "cljs.core/aget",
                                           :clj-symbol "clojure.core/aget",
                                           :docstring "Returns the value at the index."},
                         "cljs.core/if-let" {:ns "cljs.core",
                                             :name "if-let",
                                             :signature ["[bindings then]"
                                                         "[bindings then else & oldform]"],
                                             :history [["+" "0.0-927"]],
                                             :type "macro",
                                             :full-name-encode "cljs.core_if-let",
                                             :source {:code "(defmacro if-let\n  ([bindings then]\n   `(if-let ~bindings ~then nil))\n  ([bindings then else & oldform]\n   (assert-args if-let\n     (and (vector? bindings) (nil? oldform)) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if temp#\n          (let [~form temp#]\n            ~then)\n          ~else)))))",
                                                      :filename "clojure/src/clj/clojure/core.clj",
                                                      :lines [1666
                                                              1683],
                                                      :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L1666-L1683"},
                                             :full-name "cljs.core/if-let",
                                             :clj-symbol "clojure.core/if-let",
                                             :docstring "bindings => binding-form test\n\nIf test is true, evaluates then with binding-form bound to the value of \ntest, if not, yields else"},
                         "cljs.core//" {:ns "cljs.core",
                                        :name "/",
                                        :signature ["[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :shadowed-sources ({:code "(defmacro /\n  ([x] `(/ 1 ~x))\n  ([x y] (list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [83
                                                                    86],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L83-L86"}),
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core__SLASH_",
                                        :source {:code "(defn /\n  ([x] (/ 1 x))\n  ([x y] (js* \"(~{x} / ~{y})\")) ;; FIXME: waiting on cljs.core//\n  ([x y & more] (reduce / (/ x y) more)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [831 836],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L831-L836"},
                                        :full-name "cljs.core//",
                                        :clj-symbol "clojure.core//",
                                        :docstring "If no denominators are supplied, returns 1/numerator,\nelse returns numerator divided by all of the denominators."},
                         "cljs.core/min-key" {:ns "cljs.core",
                                              :name "min-key",
                                              :signature ["[k x]"
                                                          "[k x y]"
                                                          "[k x y & more]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_min-key",
                                              :source {:code "(defn min-key\n  ([k x] x)\n  ([k x y] (if (< (k x) (k y)) x y))\n  ([k x y & more]\n     (reduce #(min-key k %1 %2) (min-key k x y) more)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2793
                                                               2798],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2793-L2798"},
                                              :full-name "cljs.core/min-key",
                                              :clj-symbol "clojure.core/min-key",
                                              :docstring "Returns the x for which (k x), a number, is least."},
                         "clojure.zip/root" {:ns "clojure.zip",
                                             :name "root",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_root",
                                             :source {:code "(defn root\n  [loc]\n    (if (= :end (loc 1))\n      (node loc)\n      (let [p (up loc)]\n        (if p\n          (recur p)\n          (node loc)))))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [124 133],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L124-L133"},
                                             :full-name "clojure.zip/root",
                                             :clj-symbol "clojure.zip/root",
                                             :docstring "zips all the way up and returns the root node, reflecting any\nchanges."},
                         "cljs.core/drop-while" {:ns "cljs.core",
                                                 :name "drop-while",
                                                 :signature ["[pred coll]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_drop-while",
                                                 :source {:code "(defn drop-while\n  [pred coll]\n  (let [step (fn [pred coll]\n               (let [s (seq coll)]\n                 (if (and s (pred (first s)))\n                   (recur pred (rest s))\n                   s)))]\n    (lazy-seq (step pred coll))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [1745
                                                                  1754],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1745-L1754"},
                                                 :full-name "cljs.core/drop-while",
                                                 :clj-symbol "clojure.core/drop-while",
                                                 :docstring "Returns a lazy sequence of the items in coll starting from the first\nitem for which (pred item) returns nil."},
                         "clojure.browser.repl/evaluate-javascript" {:full-name "clojure.browser.repl/evaluate-javascript",
                                                                     :ns "clojure.browser.repl",
                                                                     :name "evaluate-javascript",
                                                                     :docstring "Process a single block of JavaScript received from the server",
                                                                     :type "function",
                                                                     :signature ["[conn block]"],
                                                                     :source {:code "(defn evaluate-javascript\n  [conn block]\n  (let [result (try {:status :success :value (str (js* \"eval(~{block})\"))}\n                    (catch js/Error e\n                      {:status :exception :value (pr-str e)\n                       :stacktrace (if (.hasOwnProperty e \"stack\")\n                                     (.-stack e)\n                                     \"No stacktrace available.\")}))]\n    (pr-str result)))",
                                                                              :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                              :lines [27
                                                                                      36],
                                                                              :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/repl.cljs#L27-L36"},
                                                                     :full-name-encode "clojure.browser.repl_evaluate-javascript",
                                                                     :history [["+"
                                                                                "0.0-927"]]},
                         "cljs.core/set-validator!" {:ns "cljs.core",
                                                     :name "set-validator!",
                                                     :signature ["[iref val]"],
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.core_set-validator_BANG_",
                                                     :source {:code "(defn set-validator!\n  [iref val]\n  (set! (.-validator iref) val))",
                                                              :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                              :lines [3320
                                                                      3328],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3320-L3328"},
                                                     :full-name "cljs.core/set-validator!",
                                                     :clj-symbol "clojure.core/set-validator!",
                                                     :docstring "Sets the validator-fn for an atom. validator-fn must be nil or a\nside-effect-free fn of one argument, which will be passed the intended\nnew state on any state change. If the new state is unacceptable, the\nvalidator-fn should return false or throw an Error. If the current state\nis not acceptable to the new validator, an Error will be thrown and the\nvalidator will not be changed."},
                         "cljs.core/<" {:ns "cljs.core",
                                        :name "<",
                                        :signature ["[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :shadowed-sources ({:code "(defmacro <\n  ([x] true)\n  ([x y] (list 'js* \"(~{} < ~{})\" x y))\n  ([x y & more] `(and (< ~x ~y) (< ~y ~@more))))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [88
                                                                    91],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L88-L91"}),
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core__LT_",
                                        :source {:code "(defn <\n  ([x] true)\n  ([x y] (cljs.core/< x y))\n  ([x y & more]\n     (if (cljs.core/< x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (cljs.core/< y (first more)))\n       false)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [838 848],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L838-L848"},
                                        :full-name "cljs.core/<",
                                        :clj-symbol "clojure.core/<",
                                        :docstring "Returns non-nil if nums are in monotonically increasing order,\notherwise false."},
                         "cljs.core/fn" {:ns "cljs.core",
                                         :name "fn",
                                         :signature ["[& sigs]"],
                                         :shadowed-sources ({:code "(def\n ^{:macro true\n   :added \"1.0\"}\n fn (fn* fn [&form &env & decl] \n         (.withMeta ^clojure.lang.IObj (cons 'fn* decl) \n                    (.meta ^clojure.lang.IMeta &form))))",
                                                             :filename "clojure/src/clj/clojure/core.clj",
                                                             :lines [42
                                                                     47],
                                                             :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L42-L47"}),
                                         :history [["+" "0.0-927"]],
                                         :type "macro",
                                         :full-name-encode "cljs.core_fn",
                                         :source {:code "(defmacro fn\n  [& sigs]\n    (let [name (if (symbol? (first sigs)) (first sigs) nil)\n          sigs (if name (next sigs) sigs)\n          sigs (if (vector? (first sigs)) (list sigs) sigs)\n          psig (fn* [sig]\n                 (let [[params & body] sig\n                       conds (when (and (next body) (map? (first body))) \n                                           (first body))\n                       body (if conds (next body) body)\n                       conds (or conds (meta params))\n                       pre (:pre conds)\n                       post (:post conds)                       \n                       body (if post\n                              `((let [~'% ~(if (< 1 (count body)) \n                                            `(do ~@body) \n                                            (first body))]\n                                 ~@(map (fn* [c] `(assert ~c)) post)\n                                 ~'%))\n                              body)\n                       body (if pre\n                              (concat (map (fn* [c] `(assert ~c)) pre) \n                                      body)\n                              body)]\n                   (maybe-destructured params body)))\n          new-sigs (map psig sigs)]\n      (with-meta\n        (if name\n          (list* 'fn* name new-sigs)\n          (cons 'fn* new-sigs))\n        (meta &form))))",
                                                  :filename "clojure/src/clj/clojure/core.clj",
                                                  :lines [3985 4023],
                                                  :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L3985-L4023"},
                                         :full-name "cljs.core/fn",
                                         :clj-symbol "clojure.core/fn",
                                         :docstring "params => positional-params* , or positional-params* & next-param\npositional-param => binding-form\nnext-param => binding-form\nname => symbol\n\nDefines a function"},
                         "cljs.core/split-with" {:ns "cljs.core",
                                                 :name "split-with",
                                                 :signature ["[pred coll]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_split-with",
                                                 :source {:code "(defn split-with\n  [pred coll]\n  [(take-while pred coll) (drop-while pred coll)])",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2892
                                                                  2895],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2892-L2895"},
                                                 :full-name "cljs.core/split-with",
                                                 :clj-symbol "clojure.core/split-with",
                                                 :docstring "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"},
                         "cljs.core/IReduce" {:ns "cljs.core",
                                              :name "IReduce",
                                              :type "protocol",
                                              :full-name-encode "cljs.core_IReduce",
                                              :source {:code "(defprotocol IReduce\n  (-reduce [coll f] [coll f start]))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [171
                                                               172],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L171-L172"},
                                              :methods [{:name "-reduce",
                                                         :signature ["[coll f]"
                                                                     "[coll f start]"],
                                                         :docstring nil}],
                                              :full-name "cljs.core/IReduce",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.reader/symbol-pattern" {:full-name "cljs.reader/symbol-pattern",
                                                       :ns "cljs.reader",
                                                       :name "symbol-pattern",
                                                       :type "var",
                                                       :source {:code "(def symbol-pattern (re-pattern \"[:]?([^0-9/].*/)?([^0-9/][^/]*)\"))",
                                                                :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                :lines [98
                                                                        98],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L98-L98"},
                                                       :full-name-encode "cljs.reader_symbol-pattern",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.core/repeatedly" {:ns "cljs.core",
                                                 :name "repeatedly",
                                                 :signature ["[f]"
                                                             "[n f]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_repeatedly",
                                                 :source {:code "(defn repeatedly\n  ([f] (lazy-seq (cons (f) (repeatedly f))))\n  ([n f] (take n (repeatedly f))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [1776
                                                                  1781],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1776-L1781"},
                                                 :full-name "cljs.core/repeatedly",
                                                 :clj-symbol "clojure.core/repeatedly",
                                                 :docstring "Takes a function of no args, presumably with side effects, and\nreturns an infinite (or length n if supplied) lazy sequence of calls\nto it"},
                         "cljs.reader/read-delimited-list" {:full-name "cljs.reader/read-delimited-list",
                                                            :ns "cljs.reader",
                                                            :name "read-delimited-list",
                                                            :type "function",
                                                            :signature ["[delim rdr recursive?]"],
                                                            :source {:code "(defn read-delimited-list\n  [delim rdr recursive?]\n  (loop [a []]\n    (let [ch (read-past whitespace? rdr)]\n      (when-not ch (reader-error rdr \"EOF\"))\n      (if (= delim ch)\n        a\n        (if-let [macrofn (get macros ch)]\n          (let [mret (macrofn rdr ch)]\n            (recur (if (= mret rdr) a (conj a mret))))\n          (do\n            (unread rdr ch)\n            (let [o (read rdr true nil recursive?)]\n              (recur (if (= o rdr) a (conj a o))))))))))",
                                                                     :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                     :lines [168
                                                                             181],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L168-L181"},
                                                            :full-name-encode "cljs.reader_read-delimited-list",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "cljs.core/undefined?" {:full-name "cljs.core/undefined?",
                                                 :ns "cljs.core",
                                                 :name "undefined?",
                                                 :type "function",
                                                 :signature ["[x]"],
                                                 :source {:code "(defn undefined? [x]\n  (cljs.core/undefined? x))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [649
                                                                  650],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L649-L650"},
                                                 :full-name-encode "cljs.core_undefined_QMARK_",
                                                 :shadowed-sources ({:code "(defmacro undefined? [x]\n  (list 'js* \"(void 0 === ~{})\" x))",
                                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                                     :lines [54
                                                                             55],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L54-L55"}),
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "clojure.zip/prev" {:ns "clojure.zip",
                                             :name "prev",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_prev",
                                             :source {:code "(defn prev\n  [loc]\n    (if-let [lloc (left loc)]\n      (loop [loc lloc]\n        (if-let [child (and (branch? loc) (down loc))]\n          (recur (rightmost child))\n          loc))\n      (up loc)))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [221 230],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L221-L230"},
                                             :full-name "clojure.zip/prev",
                                             :clj-symbol "clojure.zip/prev",
                                             :docstring "Moves to the previous loc in the hierarchy, depth-first. If already\nat the root, returns nil."},
                         "cljs.core/seq?" {:ns "cljs.core",
                                           :name "seq?",
                                           :signature ["[s]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_seq_QMARK_",
                                           :source {:code "(defn seq?\n  [s]\n  (if (nil? s)\n    false\n    (satisfies? ISeq s)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [655 660],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L655-L660"},
                                           :full-name "cljs.core/seq?",
                                           :clj-symbol "clojure.core/seq?",
                                           :docstring "Return true if s satisfies ISeq"},
                         "cljs.core/prn-str" {:ns "cljs.core",
                                              :name "prn-str",
                                              :signature ["[& objs]"],
                                              :history [["+"
                                                         "0.0-1011"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_prn-str",
                                              :source {:code "(defn prn-str\n  [& objs]\n  (prn-str-with-opts objs (pr-opts)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [3116
                                                               3119],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3116-L3119"},
                                              :full-name "cljs.core/prn-str",
                                              :clj-symbol "clojure.core/prn-str",
                                              :docstring "Same as pr-str followed by (newline)"},
                         "cljs.core/odd?" {:ns "cljs.core",
                                           :name "odd?",
                                           :signature ["[n]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_odd_QMARK_",
                                           :source {:code "(defn odd?\n  [n] (not (even? n)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1480 1482],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1480-L1482"},
                                           :full-name "cljs.core/odd?",
                                           :clj-symbol "clojure.core/odd?",
                                           :docstring "Returns true if n is odd, throws an exception if n is not an integer"},
                         "cljs.core/cons" {:ns "cljs.core",
                                           :name "cons",
                                           :signature ["[x seq]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_cons",
                                           :source {:code "(defn cons\n  [x seq]\n  (Cons. nil x seq))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1228 1231],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1228-L1231"},
                                           :full-name "cljs.core/cons",
                                           :clj-symbol "clojure.core/cons",
                                           :docstring "Returns a new seq where x is the first element and seq is the rest."},
                         "special/deftype*" {:full-name "special/deftype*",
                                             :ns "special",
                                             :name "deftype*",
                                             :type "special form",
                                             :source {:code "(defmethod parse 'deftype*\n  [_ env [_ tsym fields] _]\n  (let [t (munge (:name (resolve-var (dissoc env :locals) tsym)))]\n    (swap! namespaces update-in [(-> env :ns :name) :defs tsym]\n           (fn [m]\n             (let [m (assoc (or m {}) :name t)]\n               (if-let [line (:line env)]\n                 (-> m\n                     (assoc :file *cljs-file*)\n                     (assoc :line line))\n                 m))))\n    {:env env :op :deftype* :t t :fields fields}))",
                                                      :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                      :lines [888 899],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/compiler.clj#L888-L899"},
                                             :full-name-encode "special_deftype_STAR_",
                                             :history [["+" "0.0-927"]]},
                         "cljs.reader/read-set" {:full-name "cljs.reader/read-set",
                                                 :ns "cljs.reader",
                                                 :name "read-set",
                                                 :type "function",
                                                 :signature ["[rdr _]"],
                                                 :source {:code "(defn read-set\n  [rdr _]\n  (set (read-delimited-list \"}\" rdr true)))",
                                                          :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                          :lines [297
                                                                  299],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L297-L299"},
                                                 :full-name-encode "cljs.reader_read-set",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "cljs.core/descendants" {:ns "cljs.core",
                                                  :name "descendants",
                                                  :signature ["[tag]"
                                                              "[h tag]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_descendants",
                                                  :source {:code "(defn descendants\n  ([tag] (descendants @global-hierarchy tag))\n  ([h tag] (not-empty (get (:descendants h) tag))))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [3550
                                                                   3557],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3550-L3557"},
                                                  :full-name "cljs.core/descendants",
                                                  :clj-symbol "clojure.core/descendants",
                                                  :docstring "Returns the immediate and indirect children of tag, through a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy. Note: does not work on Java type inheritance\nrelationships."},
                         "special/new" {:full-name "special/new",
                                        :ns "special",
                                        :name "new",
                                        :type "special form",
                                        :source {:code "(defmethod parse 'new\n  [_ env [_ ctor & args] _]\n  (disallowing-recur\n   (let [enve (assoc env :context :expr)\n         ctorexpr (analyze enve ctor)\n         argexprs (vec (map #(analyze enve %) args))]\n     {:env env :op :new :ctor ctorexpr :args argexprs :children (conj argexprs ctorexpr)})))",
                                                 :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                 :lines [816 822],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/compiler.clj#L816-L822"},
                                        :full-name-encode "special_new",
                                        :clj-symbol "clojure.core/new",
                                        :history [["+" "0.0-927"]]},
                         "cljs.core/take-nth" {:ns "cljs.core",
                                               :name "take-nth",
                                               :signature ["[n coll]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_take-nth",
                                               :source {:code "(defn take-nth\n  [n coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (cons (first s) (take-nth n (drop n s))))))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [2885
                                                                2890],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2885-L2890"},
                                               :full-name "cljs.core/take-nth",
                                               :clj-symbol "clojure.core/take-nth",
                                               :docstring "Returns a lazy seq of every nth item in coll."},
                         "cljs.reader/throwing-reader" {:full-name "cljs.reader/throwing-reader",
                                                        :ns "cljs.reader",
                                                        :name "throwing-reader",
                                                        :type "function",
                                                        :signature ["[msg]"],
                                                        :source {:code "(defn throwing-reader\n  [msg]\n  (fn [rdr _]\n    (reader-error rdr msg)))",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [282
                                                                         285],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L282-L285"},
                                                        :full-name-encode "cljs.reader_throwing-reader",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/even?" {:ns "cljs.core",
                                            :name "even?",
                                            :signature ["[n]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_even_QMARK_",
                                            :source {:code "(defn even?\n   [n] (if (integer? n)\n        (zero? (bit-and n 1))\n        (throw (js/Error. (str \"Argument must be an integer: \" n)))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [1474
                                                             1478],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1474-L1478"},
                                            :full-name "cljs.core/even?",
                                            :clj-symbol "clojure.core/even?",
                                            :docstring "Returns true if n is even, throws an exception if n is not an integer"},
                         "special/fn*" {:full-name "special/fn*",
                                        :ns "special",
                                        :name "fn*",
                                        :type "special form",
                                        :source {:code "(defmethod parse 'fn*\n  [op env [_ & args] name]\n  (let [[name meths] (if (symbol? (first args))\n                       [(first args) (next args)]\n                       [name (seq args)])\n        ;;turn (fn [] ...) into (fn ([]...))\n        meths (if (vector? (first meths)) (list meths) meths)\n        mname (when name (munge name))\n        locals (:locals env)\n        locals (if name (assoc locals name {:name mname}) locals)\n        menv (if (> (count meths) 1) (assoc env :context :expr) env)\n        methods (map #(analyze-fn-method menv locals %) meths)\n        max-fixed-arity (apply max (map :max-fixed-arity methods))\n        variadic (boolean (some :variadic methods))]\n    ;;todo - validate unique arities, at most one variadic, variadic takes max required args\n    {:env env :op :fn :name mname :methods methods :variadic variadic\n     :recur-frames *recur-frames* :loop-lets *loop-lets*\n     :jsdoc [(when variadic \"@param {...*} var_args\")]\n     :max-fixed-arity max-fixed-arity}))",
                                                 :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                 :lines [741 759],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/compiler.clj#L741-L759"},
                                        :full-name-encode "special_fn_STAR_",
                                        :history [["+" "0.0-927"]]},
                         "clojure.set/subset?" {:ns "clojure.set",
                                                :name "subset?",
                                                :signature ["[set1 set2]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.set_subset_QMARK_",
                                                :source {:code "(defn subset? \n  [set1 set2]\n  (and (<= (count set1) (count set2))\n       (every? #(contains? set2 %) set1)))",
                                                         :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                         :lines [132
                                                                 136],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/set.cljs#L132-L136"},
                                                :full-name "clojure.set/subset?",
                                                :clj-symbol "clojure.set/subset?",
                                                :docstring "Is set1 a subset of set2?"},
                         "cljs.core/flush" {:full-name "cljs.core/flush",
                                            :ns "cljs.core",
                                            :name "flush",
                                            :type "function",
                                            :signature ["[]"],
                                            :source {:code "(defn flush [] ;stub\n  nil)",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [3045
                                                             3046],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3045-L3046"},
                                            :full-name-encode "cljs.core_flush",
                                            :clj-symbol "clojure.core/flush",
                                            :history [["+" "0.0-927"]]},
                         "cljs.reader/reader-error" {:full-name "cljs.reader/reader-error",
                                                     :ns "cljs.reader",
                                                     :name "reader-error",
                                                     :type "function",
                                                     :signature ["[rdr & msg]"],
                                                     :source {:code "(defn reader-error\n  [rdr & msg]\n  (throw (apply str msg)))",
                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                              :lines [69
                                                                      71],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L69-L71"},
                                                     :full-name-encode "cljs.reader_reader-error",
                                                     :history [["+"
                                                                "0.0-927"]]},
                         "clojure.walk/prewalk-replace" {:ns "clojure.walk",
                                                         :name "prewalk-replace",
                                                         :signature ["[smap form]"],
                                                         :history [["+"
                                                                    "0.0-927"]],
                                                         :type "function",
                                                         :full-name-encode "clojure.walk_prewalk-replace",
                                                         :source {:code "(defn prewalk-replace\n  [smap form]\n  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                                  :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                                  :lines [80
                                                                          86],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/walk.cljs#L80-L86"},
                                                         :full-name "clojure.walk/prewalk-replace",
                                                         :clj-symbol "clojure.walk/prewalk-replace",
                                                         :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the root of the tree first."},
                         "cljs.core/*1" {:full-name "cljs.core/*1",
                                         :ns "cljs.core",
                                         :name "*1",
                                         :docstring "bound in a repl thread to the most recent value printed",
                                         :type "var",
                                         :source {:code "(def\n  ^{:doc \"bound in a repl thread to the most recent value printed\"}\n  *1)",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [23 25],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L23-L25"},
                                         :full-name-encode "cljs.core__STAR_1",
                                         :clj-symbol "clojure.core/*1",
                                         :history [["+" "0.0-927"]]},
                         "cljs.reader/read-unicode-char" {:full-name "cljs.reader/read-unicode-char",
                                                          :ns "cljs.reader",
                                                          :name "read-unicode-char",
                                                          :type "function",
                                                          :signature ["[reader initch]"],
                                                          :source {:code "(defn read-unicode-char\n  [reader initch]\n  (reader-error reader \"Unicode characters not supported by reader (yet)\"))",
                                                                   :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                   :lines [145
                                                                           147],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L145-L147"},
                                                          :full-name-encode "cljs.reader_read-unicode-char",
                                                          :history [["+"
                                                                     "0.0-927"]]},
                         "cljs.core/dissoc" {:ns "cljs.core",
                                             :name "dissoc",
                                             :signature ["[coll]"
                                                         "[coll k]"
                                                         "[coll k & ks]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_dissoc",
                                             :source {:code "(defn dissoc\n  ([coll] coll)\n  ([coll k]\n     (-dissoc coll k))\n  ([coll k & ks]\n     (let [ret (dissoc coll k)]\n       (if ks\n         (recur ret (first ks) (next ks))\n         ret))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [531 541],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L531-L541"},
                                             :full-name "cljs.core/dissoc",
                                             :clj-symbol "clojure.core/dissoc",
                                             :docstring "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\nthat does not contain a mapping for key(s)."},
                         "cljs.core/ffirst" {:ns "cljs.core",
                                             :name "ffirst",
                                             :signature ["[coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_ffirst",
                                             :source {:code "(defn ffirst\n  [coll]\n  (first (first coll)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [437 440],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L437-L440"},
                                             :full-name "cljs.core/ffirst",
                                             :clj-symbol "clojure.core/ffirst",
                                             :docstring "Same as (first (first x))"},
                         "clojure.zip/replace" {:ns "clojure.zip",
                                                :name "replace",
                                                :signature ["[loc node]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.zip_replace",
                                                :source {:code "(defn replace\n  [loc node]\n    (let [[_ path] loc]\n      (with-meta [node (assoc path :changed? true)] (meta loc))))",
                                                         :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                         :lines [183
                                                                 187],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L183-L187"},
                                                :full-name "clojure.zip/replace",
                                                :clj-symbol "clojure.zip/replace",
                                                :docstring "Replaces the node at this loc, without moving"},
                         "cljs.core/vec" {:full-name "cljs.core/vec",
                                          :ns "cljs.core",
                                          :name "vec",
                                          :type "function",
                                          :signature ["[coll]"],
                                          :source {:code "(defn vec [coll]\n  (reduce conj cljs.core.PersistentVector/EMPTY coll))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [2203 2204],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2203-L2204"},
                                          :full-name-encode "cljs.core_vec",
                                          :clj-symbol "clojure.core/vec",
                                          :history [["+" "0.0-927"]]},
                         "cljs.core/or" {:ns "cljs.core",
                                         :name "or",
                                         :signature ["[]"
                                                     "[x]"
                                                     "[x & next]"],
                                         :history [["+" "0.0-927"]],
                                         :type "macro",
                                         :full-name-encode "cljs.core_or",
                                         :source {:code "(defmacro or\n  ([] nil)\n  ([x] x)\n  ([x & next]\n      `(let [or# ~x]\n         (if or# or# (or ~@next)))))",
                                                  :filename "clojure/src/clj/clojure/core.clj",
                                                  :lines [789 799],
                                                  :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L789-L799"},
                                         :full-name "cljs.core/or",
                                         :clj-symbol "clojure.core/or",
                                         :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns a logical true value, or returns that value and doesn't\nevaluate any of the other expressions, otherwise it returns the\nvalue of the last expression. (or) returns nil."},
                         "cljs.core/mod" {:ns "cljs.core",
                                          :name "mod",
                                          :signature ["[n d]"],
                                          :shadowed-sources ({:code "(defmacro mod [num div]\n  (list 'js* \"(~{} % ~{})\" num div))",
                                                              :filename "clojurescript/src/clj/cljs/core.clj",
                                                              :lines [138
                                                                      139],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L138-L139"}),
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_mod",
                                          :source {:code "(defn mod\n  [n d]\n  (cljs.core/mod n d))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [909 912],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L909-L912"},
                                          :full-name "cljs.core/mod",
                                          :clj-symbol "clojure.core/mod",
                                          :docstring "Modulus of num and div. Truncates toward negative infinity."},
                         "cljs.core/aset" {:ns "cljs.core",
                                           :name "aset",
                                           :signature ["[array i val]"],
                                           :shadowed-sources ({:code "(defmacro aset [a i v]\n  (list 'js* \"(~{}[~{}] = ~{})\" a i v))",
                                                               :filename "clojurescript/src/clj/cljs/core.clj",
                                                               :lines [63
                                                                       64],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L63-L64"}),
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_aset",
                                           :source {:code "(defn aset\n  [array i val]\n  (cljs.core/aset array i val))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [82 85],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L82-L85"},
                                           :full-name "cljs.core/aset",
                                           :clj-symbol "clojure.core/aset",
                                           :docstring "Sets the value at the index."},
                         "cljs.core/second" {:ns "cljs.core",
                                             :name "second",
                                             :signature ["[coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_second",
                                             :source {:code "(defn second\n  [coll]\n  (first (next coll)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [432 435],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L432-L435"},
                                             :full-name "cljs.core/second",
                                             :clj-symbol "clojure.core/second",
                                             :docstring "Same as (first (next x))"},
                         "clojure.set/rename" {:ns "clojure.set",
                                               :name "rename",
                                               :signature ["[xrel kmap]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.set_rename",
                                               :source {:code "(defn rename\n  [xrel kmap]\n    (set (map #(rename-keys % kmap) xrel)))",
                                                        :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                        :lines [83 86],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/set.cljs#L83-L86"},
                                               :full-name "clojure.set/rename",
                                               :clj-symbol "clojure.set/rename",
                                               :docstring "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap"},
                         "cljs.core/delay?" {:ns "cljs.core",
                                             :name "delay?",
                                             :signature ["[x]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_delay_QMARK_",
                                             :source {:code "(defn delay?\n  [x] (instance? cljs.core.Delay x))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [3413
                                                              3415],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3413-L3415"},
                                             :full-name "cljs.core/delay?",
                                             :clj-symbol "clojure.core/delay?",
                                             :docstring "returns true if x is a Delay created with delay"},
                         "clojure.zip/left" {:ns "clojure.zip",
                                             :name "left",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_left",
                                             :source {:code "(defn left\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (when (and path (seq l))\n        (with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))] (meta loc)))))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [150 155],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L150-L155"},
                                             :full-name "clojure.zip/left",
                                             :clj-symbol "clojure.zip/left",
                                             :docstring "Returns the loc of the left sibling of the node at this loc, or nil"},
                         "cljs.reader/not-implemented" {:full-name "cljs.reader/not-implemented",
                                                        :ns "cljs.reader",
                                                        :name "not-implemented",
                                                        :type "function",
                                                        :signature ["[rdr ch]"],
                                                        :source {:code "(defn not-implemented\n  [rdr ch]\n  (reader-error rdr \"Reader for \" ch \" not implemented yet\"))",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [187
                                                                         189],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L187-L189"},
                                                        :full-name-encode "cljs.reader_not-implemented",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/IAssociative" {:ns "cljs.core",
                                                   :name "IAssociative",
                                                   :type "protocol",
                                                   :full-name-encode "cljs.core_IAssociative",
                                                   :source {:code "(defprotocol IAssociative\n  (-contains-key? [coll k])\n  #_(-entry-at [coll k])\n  (-assoc [coll k v]))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [140
                                                                    143],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L140-L143"},
                                                   :methods [{:name "-contains-key?",
                                                              :signature ["[coll k]"],
                                                              :docstring nil}
                                                             {:name "-assoc",
                                                              :signature ["[coll k v]"],
                                                              :docstring nil}],
                                                   :full-name "cljs.core/IAssociative",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "cljs.core/group-by" {:ns "cljs.core",
                                               :name "group-by",
                                               :signature ["[f coll]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_group-by",
                                               :source {:code "(defn group-by\n  [f coll]\n  (reduce\n   (fn [ret x]\n     (let [k (f x)]\n       (assoc ret k (conj (get ret k []) x))))\n   {} coll))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [3495
                                                                3504],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3495-L3504"},
                                               :full-name "cljs.core/group-by",
                                               :clj-symbol "clojure.core/group-by",
                                               :docstring "Returns a map of the elements of coll keyed by the result of\nf on each element. The value at each key will be a vector of the\ncorresponding elements, in the order they appeared in coll."},
                         "cljs.core/symbol" {:ns "cljs.core",
                                             :name "symbol",
                                             :signature ["[name]"
                                                         "[ns name]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_symbol",
                                             :source {:code "(defn symbol\n  ([name] (cond (symbol? name) name\n                (keyword? name) (str* \"\\uFDD1\" \"'\" (subs name 2)))\n     :else (str* \"\\uFDD1\" \"'\" name))\n  ([ns name] (symbol (str* ns \"/\" name))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1071
                                                              1076],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1071-L1076"},
                                             :full-name "cljs.core/symbol",
                                             :clj-symbol "clojure.core/symbol",
                                             :docstring "Returns a Symbol with the given namespace and name."},
                         "cljs.core/Delay" {:full-name "cljs.core/Delay",
                                            :ns "cljs.core",
                                            :name "Delay",
                                            :type "type",
                                            :signature ["[state f]"],
                                            :source {:code "(deftype Delay [state f]\n  IDeref\n  (-deref [_]\n    (:value (swap! state (fn [{:keys [done] :as curr-state}]\n                           (if done\n                             curr-state,\n                             {:done true :value (f)})))))\n\n  IPending\n  (-realized? [d]\n    (:done @state)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [3401
                                                             3411],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3401-L3411"},
                                            :full-name-encode "cljs.core_Delay",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/methods" {:ns "cljs.core",
                                              :name "methods",
                                              :signature ["[multifn]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_methods",
                                              :source {:code "(defn methods\n  [multifn] (-methods multifn))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [3755
                                                               3757],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3755-L3757"},
                                              :full-name "cljs.core/methods",
                                              :clj-symbol "clojure.core/methods",
                                              :docstring "Given a multimethod, returns a map of dispatch values -> dispatch fns"},
                         "cljs.core/vector" {:full-name "cljs.core/vector",
                                             :ns "cljs.core",
                                             :name "vector",
                                             :type "function",
                                             :signature ["[& args]"],
                                             :source {:code "(defn vector [& args] (vec args))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2206
                                                              2206],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2206-L2206"},
                                             :full-name-encode "cljs.core_vector",
                                             :clj-symbol "clojure.core/vector",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/rand-int" {:ns "cljs.core",
                                               :name "rand-int",
                                               :signature ["[n]"],
                                               :shadowed-sources ({:code "(defn rand-int\n  [n] (fix (rand n)))",
                                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                   :lines [931
                                                                           933],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L931-L933"}),
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_rand-int",
                                               :source {:code "(defn rand-int\n  [n] (js* \"Math.floor(Math.random() * ~{n})\"))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [3484
                                                                3486],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3484-L3486"},
                                               :full-name "cljs.core/rand-int",
                                               :clj-symbol "clojure.core/rand-int",
                                               :docstring "Returns a random integer between 0 (inclusive) and n (exclusive)."},
                         "cljs.core/letfn" {:ns "cljs.core",
                                            :name "letfn",
                                            :signature ["[fnspecs & body]"],
                                            :history [["+" "0.0-927"]],
                                            :type "macro",
                                            :full-name-encode "cljs.core_letfn",
                                            :source {:code "(defmacro letfn \n  [fnspecs & body] \n  `(letfn* ~(vec (interleave (map first fnspecs) \n                             (map #(cons `fn %) fnspecs)))\n           ~@body))",
                                                     :filename "clojure/src/clj/clojure/core.clj",
                                                     :lines [5751
                                                             5762],
                                                     :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L5751-L5762"},
                                            :full-name "cljs.core/letfn",
                                            :clj-symbol "clojure.core/letfn",
                                            :docstring "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\nTakes a vector of function specs and a body, and generates a set of\nbindings of functions to their names. All of the names are available\nin all of the definitions of the functions, as well as the body."},
                         "cljs.reader/read-discard" {:full-name "cljs.reader/read-discard",
                                                     :ns "cljs.reader",
                                                     :name "read-discard",
                                                     :type "function",
                                                     :signature ["[rdr _]"],
                                                     :source {:code "(defn read-discard\n  [rdr _]\n  (read rdr true nil true)\n  rdr)",
                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                              :lines [305
                                                                      308],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L305-L308"},
                                                     :full-name-encode "cljs.reader_read-discard",
                                                     :history [["+"
                                                                "0.0-927"]]},
                         "cljs.core/inc" {:ns "cljs.core",
                                          :name "inc",
                                          :signature ["[x]"],
                                          :shadowed-sources ({:code "(defmacro inc [x]\n  `(+ ~x 1))",
                                                              :filename "clojurescript/src/clj/cljs/core.clj",
                                                              :lines [116
                                                                      117],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L116-L117"}),
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_inc",
                                          :source {:code "(defn inc\n  [x] (cljs.core/+ x 1))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [302 304],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L302-L304"},
                                          :full-name "cljs.core/inc",
                                          :clj-symbol "clojure.core/inc",
                                          :docstring "Returns a number one greater than num."},
                         "cljs.core/name" {:ns "cljs.core",
                                           :name "name",
                                           :signature ["[x]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_name",
                                           :source {:code "(defn name\n  [x]\n  (cond\n    (string? x) x\n    (or (keyword? x) (symbol? x))\n      (let [i (.lastIndexOf x \"/\")]\n        (if (< i 0)\n          (subs x 2)\n          (subs x (inc i))))\n    :else (throw (js/Error. (str \"Doesn't support name: \" x)))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2753 2763],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2753-L2763"},
                                           :full-name "cljs.core/name",
                                           :clj-symbol "clojure.core/name",
                                           :docstring "Returns the name String of a string, symbol or keyword."},
                         "cljs.core/cycle" {:ns "cljs.core",
                                            :name "cycle",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_cycle",
                                            :source {:code "(defn cycle\n  [coll] (lazy-seq\n          (when-let [s (seq coll)]\n            (concat s (cycle s)))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [1756
                                                             1760],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1756-L1760"},
                                            :full-name "cljs.core/cycle",
                                            :clj-symbol "clojure.core/cycle",
                                            :docstring "Returns a lazy (infinite!) sequence of repetitions of the items in coll."},
                         "cljs.core/map" {:ns "cljs.core",
                                          :name "map",
                                          :signature ["[f coll]"
                                                      "[f c1 c2]"
                                                      "[f c1 c2 c3]"
                                                      "[f c1 c2 c3 & colls]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_map",
                                          :source {:code "(defn map\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (cons (f (first s)) (map f (rest s))))))\n  ([f c1 c2]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2)]\n      (when (and s1 s2)\n        (cons (f (first s1) (first s2))\n              (map f (rest s1) (rest s2)))))))\n  ([f c1 c2 c3]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n      (when (and  s1 s2 s3)\n        (cons (f (first s1) (first s2) (first s3))\n              (map f (rest s1) (rest s2) (rest s3)))))))\n  ([f c1 c2 c3 & colls]\n   (let [step (fn step [cs]\n                 (lazy-seq\n                  (let [ss (map seq cs)]\n                    (when (every? identity ss)\n                      (cons (map first ss) (step (map rest ss)))))))]\n     (map #(apply f %) (step (conj colls c3 c2 c1))))))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [1682 1710],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1682-L1710"},
                                          :full-name "cljs.core/map",
                                          :clj-symbol "clojure.core/map",
                                          :docstring "Returns a lazy sequence consisting of the result of applying f to the\nset of first items of each coll, followed by applying f to the set\nof second items in each coll, until any one of the colls is\nexhausted.  Any remaining items in other colls are ignored. Function\nf should accept number-of-colls arguments."},
                         "cljs.core/amap" {:ns "cljs.core",
                                           :name "amap",
                                           :signature ["[a idx ret expr]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_amap",
                                           :source {:code "(defmacro amap\n  [a idx ret expr]\n  `(let [a# ~a\n         ~ret (aclone a#)]\n     (loop  [~idx 0]\n       (if (< ~idx  (alength a#))\n         (do\n           (aset ~ret ~idx ~expr)\n           (recur (inc ~idx)))\n         ~ret))))",
                                                    :filename "clojurescript/src/clj/cljs/core.clj",
                                                    :lines [661 674],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L661-L674"},
                                           :full-name "cljs.core/amap",
                                           :clj-symbol "clojure.core/amap",
                                           :docstring "Maps an expression across an array a, using an index named idx, and\nreturn value named ret, initialized to a clone of a, then setting \neach element of ret to the evaluation of expr, returning the new \narray ret."},
                         "clojure.zip/children" {:ns "clojure.zip",
                                                 :name "children",
                                                 :signature ["[loc]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.zip_children",
                                                 :source {:code "(defn children\n  [loc]\n    (if (branch? loc)\n      ((:zip/children (meta loc)) (node loc))\n      (throw \"called children on a leaf node\")))",
                                                          :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                          :lines [69
                                                                  74],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L69-L74"},
                                                 :full-name "clojure.zip/children",
                                                 :clj-symbol "clojure.zip/children",
                                                 :docstring "Returns a seq of the children of node at loc, which must be a branch"},
                         "special/set!" {:full-name "special/set!",
                                         :ns "special",
                                         :name "set!",
                                         :type "special form",
                                         :source {:code "(defmethod parse 'set!\n  [_ env [_ target val] _]\n  (disallowing-recur\n   (let [enve (assoc env :context :expr)\n         targetexpr (if (symbol? target)\n                      (do\n                        (let [local (-> env :locals target)]\n                          (assert (or (nil? local)\n                                      (and (:field local)\n                                           (:mutable local)))\n                                  \"Can't set! local var or non-mutable field\"))\n                        (analyze-symbol enve target))\n                      (when (seq? target)\n                        (let [targetexpr (analyze-seq enve target nil)]\n                          (when (:field targetexpr)\n                            targetexpr))))\n         valexpr (analyze enve val)]\n     (assert targetexpr \"set! target must be a field or a symbol naming a var\")\n     {:env env :op :set! :target targetexpr :val valexpr :children [targetexpr valexpr]})))",
                                                  :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                  :lines [824 842],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/compiler.clj#L824-L842"},
                                         :full-name-encode "special_set_BANG_",
                                         :clj-symbol "clojure.core/set!",
                                         :history [["+" "0.0-927"]]},
                         "cljs.core/when-not" {:ns "cljs.core",
                                               :name "when-not",
                                               :signature ["[test & body]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "macro",
                                               :full-name-encode "cljs.core_when-not",
                                               :source {:code "(defmacro when-not\n  [test & body]\n    (list 'if test nil (cons 'do body)))",
                                                        :filename "clojure/src/clj/clojure/core.clj",
                                                        :lines [460
                                                                464],
                                                        :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L460-L464"},
                                               :full-name "cljs.core/when-not",
                                               :clj-symbol "clojure.core/when-not",
                                               :docstring "Evaluates test. If logical false, evaluates body in an implicit do."},
                         "clojure.set/index" {:ns "clojure.set",
                                              :name "index",
                                              :signature ["[xrel ks]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.set_index",
                                              :source {:code "(defn index\n  [xrel ks]\n    (reduce\n     (fn [m x]\n       (let [ik (select-keys x ks)]\n         (assoc m ik (conj (get m ik #{}) x))))\n     {} xrel))",
                                                       :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                       :lines [88 96],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/set.cljs#L88-L96"},
                                              :full-name "clojure.set/index",
                                              :clj-symbol "clojure.set/index",
                                              :docstring "Returns a map of the distinct values of ks in the xrel mapped to a\nset of the maps in xrel with the corresponding values of ks."},
                         "clojure.browser.dom/log" {:full-name "clojure.browser.dom/log",
                                                    :ns "clojure.browser.dom",
                                                    :name "log",
                                                    :type "function",
                                                    :signature ["[& args]"],
                                                    :source {:code "(defn log [& args]\n  (.log js/console (apply pr-str args)))",
                                                             :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                             :lines [19
                                                                     20],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/dom.cljs#L19-L20"},
                                                    :full-name-encode "clojure.browser.dom_log",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "cljs.core/partition-by" {:ns "cljs.core",
                                                   :name "partition-by",
                                                   :signature ["[f coll]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.core_partition-by",
                                                   :source {:code "(defn partition-by\n  [f coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (let [fst (first s)\n           fv (f fst)\n           run (cons fst (take-while #(= fv (f %)) (next s)))]\n       (cons run (partition-by f (seq (drop (count run) s))))))))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [2897
                                                                    2906],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2897-L2906"},
                                                   :full-name "cljs.core/partition-by",
                                                   :clj-symbol "clojure.core/partition-by",
                                                   :docstring "Applies f to each value in coll, splitting it each time f returns\na new value.  Returns a lazy seq of partitions."},
                         "cljs.core/sort-by" {:ns "cljs.core",
                                              :name "sort-by",
                                              :signature ["[keyfn coll]"
                                                          "[keyfn comp coll]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_sort-by",
                                              :source {:code "(defn sort-by\n  ([keyfn coll]\n   (sort-by keyfn compare coll))\n  ([keyfn comp coll]\n     (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [762
                                                               770],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L762-L770"},
                                              :full-name "cljs.core/sort-by",
                                              :clj-symbol "clojure.core/sort-by",
                                              :docstring "Returns a sorted sequence of the items in coll, where the sort\norder is determined by comparing (keyfn item).  Comp can be\nboolean-valued comparison funcion, or a -/0/+ valued comparator.\nComp defaults to compare."},
                         "cljs.core/with-meta" {:ns "cljs.core",
                                                :name "with-meta",
                                                :signature ["[o meta]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_with-meta",
                                                :source {:code "(defn with-meta\n  [o meta]\n  (-with-meta o meta))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [543
                                                                 547],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L543-L547"},
                                                :full-name "cljs.core/with-meta",
                                                :clj-symbol "clojure.core/with-meta",
                                                :docstring "Returns an object of the same type and value as obj, with\nmap m as its metadata."},
                         "cljs.core/NeverEquiv" {:full-name "cljs.core/NeverEquiv",
                                                 :ns "cljs.core",
                                                 :name "NeverEquiv",
                                                 :type "type",
                                                 :signature ["[]"],
                                                 :source {:code "(deftype NeverEquiv []\n  IEquiv\n  (-equiv [o other] false))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2373
                                                                  2375],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2373-L2375"},
                                                 :full-name-encode "cljs.core_NeverEquiv",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "cljs.core/select-keys" {:ns "cljs.core",
                                                  :name "select-keys",
                                                  :signature ["[map keyseq]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_select-keys",
                                                  :source {:code "(defn select-keys\n  [map keyseq]\n    (loop [ret {} keys (seq keyseq)]\n      (if keys\n        (let [key   (first keys)\n              entry (get map key ::not-found)]\n          (recur\n           (if (not= entry ::not-found)\n             (assoc ret key entry)\n             ret)\n           (next keys)))\n        ret)))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [2643
                                                                   2655],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2643-L2655"},
                                                  :full-name "cljs.core/select-keys",
                                                  :clj-symbol "clojure.core/select-keys",
                                                  :docstring "Returns a map containing only those entries in map whose key is in keys"},
                         "special/loop*" {:full-name "special/loop*",
                                          :ns "special",
                                          :name "loop*",
                                          :type "special form",
                                          :source {:code "(defmethod parse 'loop*\n  [op encl-env form _]\n  (analyze-let encl-env form true))",
                                                   :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                   :lines [797 799],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/compiler.clj#L797-L799"},
                                          :full-name-encode "special_loop_STAR_",
                                          :history [["+" "0.0-927"]]},
                         "cljs.core/ISeq" {:ns "cljs.core",
                                           :name "ISeq",
                                           :type "protocol",
                                           :full-name-encode "cljs.core_ISeq",
                                           :source {:code "(defprotocol ISeq\n  (-first [coll])\n  (-rest [coll]))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [133 135],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L133-L135"},
                                           :methods [{:name "-first",
                                                      :signature ["[coll]"],
                                                      :docstring nil}
                                                     {:name "-rest",
                                                      :signature ["[coll]"],
                                                      :docstring nil}],
                                           :full-name "cljs.core/ISeq",
                                           :history [["+" "0.0-927"]]},
                         "clojure.walk/postwalk-replace" {:ns "clojure.walk",
                                                          :name "postwalk-replace",
                                                          :signature ["[smap form]"],
                                                          :history [["+"
                                                                     "0.0-927"]],
                                                          :type "function",
                                                          :full-name-encode "clojure.walk_postwalk-replace",
                                                          :source {:code "(defn postwalk-replace\n  [smap form]\n  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                                   :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                                   :lines [88
                                                                           94],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/walk.cljs#L88-L94"},
                                                          :full-name "clojure.walk/postwalk-replace",
                                                          :clj-symbol "clojure.walk/postwalk-replace",
                                                          :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the leaves of the tree first."},
                         "cljs.core/pr-with-opts" {:full-name "cljs.core/pr-with-opts",
                                                   :ns "cljs.core",
                                                   :name "pr-with-opts",
                                                   :docstring "Prints a sequence of objects using string-print, observing all\nthe options given in opts",
                                                   :type "function",
                                                   :signature ["[objs opts]"],
                                                   :source {:code "(defn pr-with-opts\n  [objs opts]\n  (let [first-obj (first objs)]\n    (doseq [obj objs]\n      (when-not (identical? obj first-obj)\n        (string-print \" \"))\n      (doseq [string (pr-seq obj opts)]\n        (string-print string)))))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [3084
                                                                    3093],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3084-L3093"},
                                                   :full-name-encode "cljs.core_pr-with-opts",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "cljs.core/->>" {:ns "cljs.core",
                                          :name "->>",
                                          :signature ["[x form]"
                                                      "[x form & more]"],
                                          :history [["+" "0.0-927"]],
                                          :type "macro",
                                          :full-name-encode "cljs.core_-_GT__GT_",
                                          :source {:code "(defmacro ->>\n  ([x form] (if (seq? form)\n              (with-meta `(~(first form) ~@(next form)  ~x) (meta form))\n              (list form x)))\n  ([x form & more] `(->> (->> ~x ~form) ~@more)))",
                                                   :filename "clojure/src/clj/clojure/core.clj",
                                                   :lines [1540 1549],
                                                   :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L1540-L1549"},
                                          :full-name "cljs.core/->>",
                                          :clj-symbol "clojure.core/->>",
                                          :docstring "Threads the expr through the forms. Inserts x as the\nlast item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nlast item in second form, etc."},
                         "cljs.core/nil?" {:ns "cljs.core",
                                           :name "nil?",
                                           :signature ["[x]"],
                                           :shadowed-sources ({:code "(defmacro nil? [x]\n  `(identical? ~x nil))",
                                                               :filename "clojurescript/src/clj/cljs/core.clj",
                                                               :lines [45
                                                                       46],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L45-L46"}),
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_nil_QMARK_",
                                           :source {:code "(defn nil?\n  [x]\n  (identical? x nil))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [214 217],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L214-L217"},
                                           :full-name "cljs.core/nil?",
                                           :clj-symbol "clojure.core/nil?",
                                           :docstring "Returns true if x is nil, false otherwise."},
                         "clojure.walk/stringify-keys" {:ns "clojure.walk",
                                                        :name "stringify-keys",
                                                        :signature ["[m]"],
                                                        :history [["+"
                                                                   "0.0-927"]],
                                                        :type "function",
                                                        :full-name-encode "clojure.walk_stringify-keys",
                                                        :source {:code "(defn stringify-keys\n  [m]\n  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                                 :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                                 :lines [72
                                                                         78],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/walk.cljs#L72-L78"},
                                                        :full-name "clojure.walk/stringify-keys",
                                                        :clj-symbol "clojure.walk/stringify-keys",
                                                        :docstring "Recursively transforms all map keys from keywords to strings."},
                         "clojure.browser.repl/order" {:full-name "clojure.browser.repl/order",
                                                       :ns "clojure.browser.repl",
                                                       :name "order",
                                                       :type "var",
                                                       :source {:code "(def order (atom 0))",
                                                                :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                :lines [55
                                                                        55],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/repl.cljs#L55-L55"},
                                                       :full-name-encode "clojure.browser.repl_order",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.core/memoize" {:ns "cljs.core",
                                              :name "memoize",
                                              :signature ["[f]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_memoize",
                                              :source {:code "(defn memoize\n  [f]\n  (let [mem (atom {})]\n    (fn [& args]\n      (if-let [v (get @mem args)]\n        v\n        (let [ret (apply f args)]\n          (swap! mem assoc args ret)\n          ret)))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [3448
                                                               3460],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3448-L3460"},
                                              :full-name "cljs.core/memoize",
                                              :clj-symbol "clojure.core/memoize",
                                              :docstring "Returns a memoized version of a referentially transparent function. The\nmemoized version of the function keeps a cache of the mapping from arguments\nto results and, when calls with the same arguments are repeated often, has\nhigher performance at the expense of higher memory use."},
                         "cljs.core/pr-sequential" {:full-name "cljs.core/pr-sequential",
                                                    :ns "cljs.core",
                                                    :name "pr-sequential",
                                                    :type "function",
                                                    :signature ["[print-one begin sep end opts coll]"],
                                                    :source {:code "(defn pr-sequential [print-one begin sep end opts coll]\n  (concat [begin]\n          (flatten1\n            (interpose [sep] (map #(print-one % opts) coll)))\n          [end]))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [3035
                                                                     3039],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3035-L3039"},
                                                    :full-name-encode "cljs.core_pr-sequential",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "clojure.zip/make-node" {:ns "clojure.zip",
                                                  :name "make-node",
                                                  :signature ["[loc node children]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.zip_make-node",
                                                  :source {:code "(defn make-node\n  [loc node children]\n    ((:zip/make-node (meta loc)) node children))",
                                                           :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                           :lines [76
                                                                   80],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L76-L80"},
                                                  :full-name "clojure.zip/make-node",
                                                  :clj-symbol "clojure.zip/make-node",
                                                  :docstring "Returns a new branch node, given an existing node and new\nchildren. The loc is only used to supply the constructor."},
                         "specialrepl/load-namespace" {:full-name "specialrepl/load-namespace",
                                                       :ns "specialrepl",
                                                       :name "load-namespace",
                                                       :type "special form (repl)",
                                                       :source {:code "(def default-special-fns\n  (let [load-file-fn (fn [repl-env file] (load-file repl-env file))]\n    {'in-ns (fn [_ quoted-ns] (set! comp/*cljs-ns* (second quoted-ns)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace (fn [repl-env ns] (load-namespace repl-env ns))}))",
                                                                :filename "clojurescript/src/clj/cljs/repl.clj",
                                                                :lines [134
                                                                        139],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/repl.clj#L134-L139"},
                                                       :full-name-encode "specialrepl_load-namespace",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.reader/float-pattern" {:full-name "cljs.reader/float-pattern",
                                                      :ns "cljs.reader",
                                                      :name "float-pattern",
                                                      :type "var",
                                                      :source {:code "(def float-pattern (re-pattern \"([-+]?[0-9]+(\\\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?\"))",
                                                               :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                               :lines [97
                                                                       97],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L97-L97"},
                                                      :full-name-encode "cljs.reader_float-pattern",
                                                      :history [["+"
                                                                 "0.0-927"]]},
                         "cljs.core/ancestors" {:ns "cljs.core",
                                                :name "ancestors",
                                                :signature ["[tag]"
                                                            "[h tag]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_ancestors",
                                                :source {:code "(defn ancestors\n  ([tag] (ancestors @global-hierarchy tag))\n  ([h tag] (not-empty (get (:ancestors h) tag))))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [3542
                                                                 3548],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3542-L3548"},
                                                :full-name "cljs.core/ancestors",
                                                :clj-symbol "clojure.core/ancestors",
                                                :docstring "Returns the immediate and indirect parents of tag, either via a Java type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
                         "cljs.core/integer?" {:ns "cljs.core",
                                               :name "integer?",
                                               :signature ["[n]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_integer_QMARK_",
                                               :source {:code "(defn integer?\n  [n]\n  (and (number? n)\n       (js* \"(~{n} == ~{n}.toFixed())\")))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [684
                                                                688],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L684-L688"},
                                               :full-name "cljs.core/integer?",
                                               :clj-symbol "clojure.core/integer?",
                                               :docstring "Returns true if n is an integer.  Warning: returns true on underflow condition."},
                         "clojure.zip/xml-zip" {:ns "clojure.zip",
                                                :name "xml-zip",
                                                :signature ["[root]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.zip_xml-zip",
                                                :source {:code "(defn xml-zip\n  [root]\n    (zipper (complement string?) \n            (comp seq :content)\n            (fn [node children]\n              (assoc node :content (and children (apply vector children))))\n            root))",
                                                         :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                         :lines [50
                                                                 58],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L50-L58"},
                                                :full-name "clojure.zip/xml-zip",
                                                :clj-symbol "clojure.zip/xml-zip",
                                                :docstring "Returns a zipper for xml elements (as from xml/parse),\ngiven a root element"},
                         "clojure.walk/walk" {:ns "clojure.walk",
                                              :name "walk",
                                              :signature ["[inner outer form]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.walk_walk",
                                              :source {:code "(defn walk\n  [inner outer form]\n  (cond\n   (seq? form) (outer (doall (map inner form)))\n   (coll? form) (outer (into (empty form) (map inner form)))\n   :else (outer form)))",
                                                       :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                       :lines [37 48],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/walk.cljs#L37-L48"},
                                              :full-name "clojure.walk/walk",
                                              :clj-symbol "clojure.walk/walk",
                                              :docstring "Traverses form, an arbitrary data structure.  inner and outer are\nfunctions.  Applies inner to each element of form, building up a\ndata structure of the same type, then applies outer to the result.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
                         "cljs.core/bit-xor" {:ns "cljs.core",
                                              :name "bit-xor",
                                              :signature ["[x y]"],
                                              :shadowed-sources ({:code "(defmacro bit-xor\n  ([x y] (list 'js* \"(~{} ^ ~{})\" x y))\n  ([x y & more] `(bit-xor (bit-xor ~x ~y) ~@more)))",
                                                                  :filename "clojurescript/src/clj/cljs/core.clj",
                                                                  :lines [152
                                                                          154],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L152-L154"}),
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_bit-xor",
                                              :source {:code "(defn bit-xor\n  [x y] (cljs.core/bit-xor x y))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [935
                                                               937],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L935-L937"},
                                              :full-name "cljs.core/bit-xor",
                                              :clj-symbol "clojure.core/bit-xor",
                                              :docstring "Bitwise exclusive or"},
                         "clojure.set/union" {:ns "clojure.set",
                                              :name "union",
                                              :signature ["[]"
                                                          "[s1]"
                                                          "[s1 s2]"
                                                          "[s1 s2 & sets]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.set_union",
                                              :source {:code "(defn union\n  ([] #{})\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s1) (count s2))\n       (reduce conj s2 s1)\n       (reduce conj s1 s2)))\n  ([s1 s2 & sets]\n     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n       (reduce into (first bubbled-sets) (rest bubbled-sets)))))",
                                                       :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                       :lines [19 29],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/set.cljs#L19-L29"},
                                              :full-name "clojure.set/union",
                                              :clj-symbol "clojure.set/union",
                                              :docstring "Return a set that is the union of the input sets"},
                         "cljs.reader/PushbackReader" {:ns "cljs.reader",
                                                       :name "PushbackReader",
                                                       :type "protocol",
                                                       :full-name-encode "cljs.reader_PushbackReader",
                                                       :source {:code "(defprotocol PushbackReader\n  (read-char [reader] \"Returns the next char from the Reader,\nnil if the end of stream has been reached\")\n  (unread [reader ch] \"Push back a single character on to the stream\"))",
                                                                :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                :lines [12
                                                                        15],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L12-L15"},
                                                       :methods [{:name "read-char",
                                                                  :signature ["[reader]"],
                                                                  :docstring "Returns the next char from the Reader,\nnil if the end of stream has been reached"}
                                                                 {:name "unread",
                                                                  :signature ["[reader ch]"],
                                                                  :docstring "Push back a single character on to the stream"}],
                                                       :full-name "cljs.reader/PushbackReader",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.core/isa?" {:ns "cljs.core",
                                           :name "isa?",
                                           :signature ["[child parent]"
                                                       "[h child parent]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_isa_QMARK_",
                                           :source {:code "(defn isa?\n  ([child parent] (isa? @global-hierarchy child parent))\n  ([h child parent]\n     (or (= child parent)\n         ;; (and (class? parent) (class? child)\n         ;;    (. ^Class parent isAssignableFrom child))\n         (contains? ((:ancestors h) child) parent)\n         ;;(and (class? child) (some #(contains? ((:ancestors h) %) parent) (supers child)))\n         (and (vector? parent) (vector? child)\n              (= (count parent) (count child))\n              (loop [ret true i 0]\n                (if (or (not ret) (= i (count parent)))\n                  ret\n                  (recur (isa? h (child i) (parent i)) (inc i))))))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [3514 3532],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3514-L3532"},
                                           :full-name "cljs.core/isa?",
                                           :clj-symbol "clojure.core/isa?",
                                           :docstring "Returns true if (= child parent), or child is directly or indirectly derived from\nparent, either via a Java type inheritance relationship or a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy"},
                         "clojure.browser.net/xhr-connection" {:full-name "clojure.browser.net/xhr-connection",
                                                               :ns "clojure.browser.net",
                                                               :name "xhr-connection",
                                                               :docstring "Returns an XhrIo connection",
                                                               :type "function",
                                                               :signature ["[]"],
                                                               :source {:code "(defn xhr-connection\n  []\n  (goog.net.XhrIo.))",
                                                                        :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                        :lines [83
                                                                                86],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/net.cljs#L83-L86"},
                                                               :full-name-encode "clojure.browser.net_xhr-connection",
                                                               :history [["+"
                                                                          "0.0-927"]]},
                         "cljs.core/subs" {:ns "cljs.core",
                                           :name "subs",
                                           :signature ["[s start]"
                                                       "[s start end]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_subs",
                                           :source {:code "(defn subs\n  ([s start] (.substring s start))\n  ([s start end] (.substring s start end)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1065 1069],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1065-L1069"},
                                           :full-name "cljs.core/subs",
                                           :clj-symbol "clojure.core/subs",
                                           :docstring "Returns the substring of s beginning at start inclusive, and ending\nat end (defaults to length of string), exclusive."},
                         "cljs.core/symbol?" {:full-name "cljs.core/symbol?",
                                              :ns "cljs.core",
                                              :name "symbol?",
                                              :type "function",
                                              :signature ["[x]"],
                                              :source {:code "(defn symbol? [x]\n  (and (goog/isString x)\n       (= (.charAt x 0) \\uFDD1)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [674
                                                               676],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L674-L676"},
                                              :full-name-encode "cljs.core_symbol_QMARK_",
                                              :clj-symbol "clojure.core/symbol?",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "clojure.string/replace" {:ns "clojure.string",
                                                   :name "replace",
                                                   :signature ["[s match replacement]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.string_replace",
                                                   :source {:code "(defn replace\n  [s match replacement]\n  (cond (string? match)\n        (.replace s (js/RegExp. (gstring/regExpEscape match) \"g\") replacement)\n        (.hasOwnProperty match \"source\")\n        (.replace s (js/RegExp. (.-source match) \"g\") replacement)\n        :else (throw (str \"Invalid match arg: \" match))))",
                                                            :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                            :lines [23
                                                                    34],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/string.cljs#L23-L34"},
                                                   :full-name "clojure.string/replace",
                                                   :clj-symbol "clojure.string/replace",
                                                   :docstring "Replaces all instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
                         "cljs.core/string?" {:full-name "cljs.core/string?",
                                              :ns "cljs.core",
                                              :name "string?",
                                              :type "function",
                                              :signature ["[x]"],
                                              :source {:code "(defn string? [x]\n  (and (goog/isString x)\n       (not (or (= (.charAt x 0) \\uFDD0)\n                (= (.charAt x 0) \\uFDD1)))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [665
                                                               668],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L665-L668"},
                                              :full-name-encode "cljs.core_string_QMARK_",
                                              :clj-symbol "clojure.core/string?",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/partition-all" {:ns "cljs.core",
                                                    :name "partition-all",
                                                    :signature ["[n coll]"
                                                                "[n step coll]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_partition-all",
                                                    :source {:code "(defn partition-all\n  ([n coll]\n     (partition-all n n coll))\n  ([n step coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (cons (take n s) (partition-all n step (drop step s)))))))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [2800
                                                                     2808],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2800-L2808"},
                                                    :full-name "cljs.core/partition-all",
                                                    :clj-symbol "clojure.core/partition-all",
                                                    :docstring "Returns a lazy sequence of lists like partition, but may include\npartitions with fewer than n items at the end."},
                         "cljs.core/merge-with" {:ns "cljs.core",
                                                 :name "merge-with",
                                                 :signature ["[f & maps]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_merge-with",
                                                 :source {:code "(defn merge-with\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n                        (let [k (first e) v (second e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2627
                                                                  2641],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2627-L2641"},
                                                 :full-name "cljs.core/merge-with",
                                                 :clj-symbol "clojure.core/merge-with",
                                                 :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping(s)\nfrom the latter (left-to-right) will be combined with the mapping in\nthe result by calling (f val-in-result val-in-latter)."},
                         "clojure.browser.dom/set-properties" {:full-name "clojure.browser.dom/set-properties",
                                                               :ns "clojure.browser.dom",
                                                               :name "set-properties",
                                                               :docstring "Set properties on an element",
                                                               :type "function",
                                                               :signature ["[e m]"],
                                                               :source {:code "(defn set-properties\n  [e m]\n  (gdom/setProperties (ensure-element e)\n                      (.-strobj m)))",
                                                                        :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                        :lines [134
                                                                                138],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/dom.cljs#L134-L138"},
                                                               :full-name-encode "clojure.browser.dom_set-properties",
                                                               :history [["+"
                                                                          "0.0-927"]]},
                         "cljs.core/trampoline" {:ns "cljs.core",
                                                 :name "trampoline",
                                                 :signature ["[f]"
                                                             "[f & args]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_trampoline",
                                                 :source {:code "(defn trampoline\n  ([f]\n     (let [ret (f)]\n       (if (fn? ret)\n         (recur ret)\n         ret)))\n  ([f & args]\n     (trampoline #(apply f args))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [3462
                                                                  3476],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3462-L3476"},
                                                 :full-name "cljs.core/trampoline",
                                                 :clj-symbol "clojure.core/trampoline",
                                                 :docstring "trampoline can be used to convert algorithms requiring mutual\nrecursion without stack consumption. Calls f with supplied args, if\nany. If f returns a fn, calls that fn with no arguments, and\ncontinues to repeat, until the return value is not a fn, then\nreturns that non-fn value. Note that if you want to return a fn as a\nfinal value, you must wrap it in some data structure and unpack it\nafter trampoline returns."},
                         "clojure.browser.repl/send-print" {:full-name "clojure.browser.repl/send-print",
                                                            :ns "clojure.browser.repl",
                                                            :name "send-print",
                                                            :docstring "Send data to be printed in the REPL. If there is an error, try again\nup to 10 times.",
                                                            :type "function",
                                                            :signature ["[url data]"
                                                                        "[url data n]"],
                                                            :source {:code "(defn send-print\n  ([url data]\n     (send-print url data 0))\n  ([url data n]\n     (let [conn (net/xhr-connection)]\n       (event/listen conn :error\n                     (fn [_]\n                       (if (< n 10)\n                         (send-print url data (inc n))\n                         (.log js/console (str \"Could not send \" data \" after \" n \" attempts.\")))))\n       (net/transmit conn url \"POST\" data nil 0))))",
                                                                     :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                     :lines [41
                                                                             53],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/repl.cljs#L41-L53"},
                                                            :full-name-encode "clojure.browser.repl_send-print",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "cljs.core/ICounted" {:ns "cljs.core",
                                               :name "ICounted",
                                               :type "protocol",
                                               :full-name-encode "cljs.core_ICounted",
                                               :source {:code "(defprotocol ICounted\n  (-count [coll] \"constant time count\"))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [118
                                                                119],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L118-L119"},
                                               :methods [{:name "-count",
                                                          :signature ["[coll]"],
                                                          :docstring "constant time count"}],
                                               :full-name "cljs.core/ICounted",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/IEquiv" {:ns "cljs.core",
                                             :name "IEquiv",
                                             :type "protocol",
                                             :full-name-encode "cljs.core_IEquiv",
                                             :source {:code "(defprotocol IEquiv\n  (-equiv [o other]))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [174 175],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L174-L175"},
                                             :methods [{:name "-equiv",
                                                        :signature ["[o other]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/IEquiv",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/js-delete" {:full-name "cljs.core/js-delete",
                                                :ns "cljs.core",
                                                :name "js-delete",
                                                :type "function",
                                                :signature ["[obj key]"],
                                                :source {:code "(defn js-delete [obj key]\n  (js* \"delete ~{obj}[~{key}]\"))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [634
                                                                 635],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L634-L635"},
                                                :full-name-encode "cljs.core_js-delete",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/comment" {:ns "cljs.core",
                                              :name "comment",
                                              :signature ["[& body]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "macro",
                                              :full-name-encode "cljs.core_comment",
                                              :source {:code "(defmacro comment\n  [& body])",
                                                       :filename "clojure/src/clj/clojure/core.clj",
                                                       :lines [4161
                                                               4164],
                                                       :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L4161-L4164"},
                                              :full-name "cljs.core/comment",
                                              :clj-symbol "clojure.core/comment",
                                              :docstring "Ignores body, yields nil"},
                         "cljs.reader/special-symbols" {:full-name "cljs.reader/special-symbols",
                                                        :ns "cljs.reader",
                                                        :name "special-symbols",
                                                        :type "var",
                                                        :source {:code "(def special-symbols\n  {\"nil\" nil\n   \"true\" true\n   \"false\" false})",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [243
                                                                         246],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L243-L246"},
                                                        :full-name-encode "cljs.reader_special-symbols",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/alength" {:ns "cljs.core",
                                              :name "alength",
                                              :signature ["[array]"],
                                              :shadowed-sources ({:code "(defmacro alength [a]\n  (list 'js* \"~{}.length\" a))",
                                                                  :filename "clojurescript/src/clj/cljs/core.clj",
                                                                  :lines [658
                                                                          659],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L658-L659"}),
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_alength",
                                              :source {:code "(defn alength\n  [array]\n  (.-length array))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [87 90],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L87-L90"},
                                              :full-name "cljs.core/alength",
                                              :clj-symbol "clojure.core/alength",
                                              :docstring "Returns the length of the Java array. Works on arrays of all types."},
                         "special/quote" {:full-name "special/quote",
                                          :ns "special",
                                          :name "quote",
                                          :type "special form",
                                          :source {:code "(defmethod parse 'quote\n  [_ env [_ x] _]\n  {:op :constant :env env :form x})",
                                                   :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                   :lines [812 814],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/compiler.clj#L812-L814"},
                                          :full-name-encode "special_quote",
                                          :clj-symbol "clojure.core/quote",
                                          :history [["+" "0.0-927"]]},
                         "cljs.core/tree-seq" {:ns "cljs.core",
                                               :name "tree-seq",
                                               :signature ["[branch? children root]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_tree-seq",
                                               :source {:code "(defn tree-seq\n   [branch? children root]\n   (let [walk (fn walk [node]\n                (lazy-seq\n                 (cons node\n                  (when (branch? node)\n                    (mapcat walk (children node))))))]\n     (walk root)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [1845
                                                                1858],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1845-L1858"},
                                               :full-name "cljs.core/tree-seq",
                                               :clj-symbol "clojure.core/tree-seq",
                                               :docstring "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n branch? must be a fn of one arg that returns true if passed a node\n that can have children (but may not).  children must be a fn of one\n arg that returns a sequence of the children. Will only be called on\n nodes for which branch? returns true. Root is the root node of the\ntree."},
                         "cljs.reader/read-unmatched-delimiter" {:full-name "cljs.reader/read-unmatched-delimiter",
                                                                 :ns "cljs.reader",
                                                                 :name "read-unmatched-delimiter",
                                                                 :type "function",
                                                                 :signature ["[rdr ch]"],
                                                                 :source {:code "(defn read-unmatched-delimiter\n  [rdr ch]\n  (reader-error rdr \"Unmached delimiter \" ch))",
                                                                          :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                          :lines [199
                                                                                  201],
                                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L199-L201"},
                                                                 :full-name-encode "cljs.reader_read-unmatched-delimiter",
                                                                 :history [["+"
                                                                            "0.0-927"]]},
                         "cljs.core/every-pred" {:ns "cljs.core",
                                                 :name "every-pred",
                                                 :signature ["[p]"
                                                             "[p1 p2]"
                                                             "[p1 p2 p3]"
                                                             "[p1 p2 p3 & ps]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_every-pred",
                                                 :source {:code "(defn every-pred\n  ([p]\n     (fn ep1\n       ([] true)\n       ([x] (boolean (p x)))\n       ([x y] (boolean (and (p x) (p y))))\n       ([x y z] (boolean (and (p x) (p y) (p z))))\n       ([x y z & args] (boolean (and (ep1 x y z)\n                                     (every? p args))))))\n  ([p1 p2]\n     (fn ep2\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x))))\n       ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n       ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n       ([x y z & args] (boolean (and (ep2 x y z)\n                                     (every? #(and (p1 %) (p2 %)) args))))))\n  ([p1 p2 p3]\n     (fn ep3\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n       ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n       ([x y z] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z))))\n       ([x y z & args] (boolean (and (ep3 x y z)\n                                     (every? #(and (p1 %) (p2 %) (p3 %)) args))))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn epn\n         ([] true)\n         ([x] (every? #(% x) ps))\n         ([x y] (every? #(and (% x) (% y)) ps))\n         ([x y z] (every? #(and (% x) (% y) (% z)) ps))\n         ([x y z & args] (boolean (and (epn x y z)\n                                       (every? #(every? % args) ps))))))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [1604
                                                                  1641],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1604-L1641"},
                                                 :full-name "cljs.core/every-pred",
                                                 :clj-symbol "clojure.core/every-pred",
                                                 :docstring "Takes a set of predicates and returns a function f that returns true if all of its\ncomposing predicates return a logical true value against all of its arguments, else it returns\nfalse. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical false result against the original predicates."},
                         "clojure.set/rename-keys" {:ns "clojure.set",
                                                    :name "rename-keys",
                                                    :signature ["[map kmap]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "clojure.set_rename-keys",
                                                    :source {:code "(defn rename-keys\n  [map kmap]\n    (reduce \n     (fn [m [old new]]\n       (if (and (not= old new)\n                (contains? m old))\n         (-> m (assoc new (get m old)) (dissoc old))\n         m)) \n     map kmap))",
                                                             :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                             :lines [72
                                                                     81],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/set.cljs#L72-L81"},
                                                    :full-name "clojure.set/rename-keys",
                                                    :clj-symbol "clojure.set/rename-keys",
                                                    :docstring "Returns the map with the keys in kmap renamed to the vals in kmap"},
                         "cljs.core/peek" {:ns "cljs.core",
                                           :name "peek",
                                           :signature ["[coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_peek",
                                           :source {:code "(defn peek\n  [coll]\n  (-peek coll))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [555 559],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L555-L559"},
                                           :full-name "cljs.core/peek",
                                           :clj-symbol "clojure.core/peek",
                                           :docstring "For a list or queue, same as first, for a vector, same as, but much\nmore efficient than, last. If the collection is empty, returns nil."},
                         "cljs.core/pr-str-with-opts" {:full-name "cljs.core/pr-str-with-opts",
                                                       :ns "cljs.core",
                                                       :name "pr-str-with-opts",
                                                       :docstring "Prints a sequence of objects to a string, observing all the\noptions given in opts",
                                                       :type "function",
                                                       :signature ["[objs opts]"],
                                                       :source {:code "(defn pr-str-with-opts\n  [objs opts]\n  (str (pr-sb objs opts)))",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [3071
                                                                        3075],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3071-L3075"},
                                                       :full-name-encode "cljs.core_pr-str-with-opts",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.core/map?" {:ns "cljs.core",
                                           :name "map?",
                                           :signature ["[x]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_map_QMARK_",
                                           :source {:code "(defn map?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? IMap x)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [614 619],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L614-L619"},
                                           :full-name "cljs.core/map?",
                                           :clj-symbol "clojure.core/map?",
                                           :docstring "Return true if x satisfies IMap"},
                         "cljs.reader/StringPushbackReader" {:full-name "cljs.reader/StringPushbackReader",
                                                             :ns "cljs.reader",
                                                             :name "StringPushbackReader",
                                                             :type "type",
                                                             :signature ["[s index-atom buffer-atom]"],
                                                             :source {:code "(deftype StringPushbackReader [s index-atom buffer-atom]\n  PushbackReader\n  (read-char [reader]\n             (if (empty? @buffer-atom)\n               (let [idx @index-atom]\n                 (swap! index-atom inc)\n                 (nth s idx))\n               (let [buf @buffer-atom]\n                 (swap! buffer-atom rest)\n                 (first buf))))\n  (unread [reader ch] (swap! buffer-atom #(cons ch %))))",
                                                                      :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                      :lines [18
                                                                              28],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L18-L28"},
                                                             :full-name-encode "cljs.reader_StringPushbackReader",
                                                             :history [["+"
                                                                        "0.0-927"]]},
                         "cljs.core/deref" {:full-name "cljs.core/deref",
                                            :ns "cljs.core",
                                            :name "deref",
                                            :type "function",
                                            :signature ["[o]"],
                                            :source {:code "(defn deref\n  [o]\n  (-deref o))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [3316
                                                             3318],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3316-L3318"},
                                            :full-name-encode "cljs.core_deref",
                                            :clj-symbol "clojure.core/deref",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/reductions" {:ns "cljs.core",
                                                 :name "reductions",
                                                 :signature ["[f coll]"
                                                             "[f init coll]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_reductions",
                                                 :source {:code "(defn reductions\n  ([f coll]\n     (lazy-seq\n      (if-let [s (seq coll)]\n        (reductions f (first s) (rest s))\n        (list (f)))))\n  ([f init coll]\n     (cons init\n           (lazy-seq\n            (when-let [s (seq coll)]\n              (reductions f (f init (first s)) (rest s)))))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2918
                                                                  2930],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2918-L2930"},
                                                 :full-name "cljs.core/reductions",
                                                 :clj-symbol "clojure.core/reductions",
                                                 :docstring "Returns a lazy seq of the intermediate values of the reduction (as\nper reduce) of coll by f, starting with init."},
                         "cljs.core/false?" {:ns "cljs.core",
                                             :name "false?",
                                             :signature ["[x]"],
                                             :shadowed-sources ({:code "(defmacro false? [x]\n  (list 'js* \"~{} === false\" x))",
                                                                 :filename "clojurescript/src/clj/cljs/core.clj",
                                                                 :lines [51
                                                                         52],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L51-L52"}),
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_false_QMARK_",
                                             :source {:code "(defn false?\n  [x] (cljs.core/false? x))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [641 643],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L641-L643"},
                                             :full-name "cljs.core/false?",
                                             :clj-symbol "clojure.core/false?",
                                             :docstring "Returns true if x is the value false, false otherwise."},
                         "cljs.core/bit-flip" {:ns "cljs.core",
                                               :name "bit-flip",
                                               :signature ["[x n]"],
                                               :shadowed-sources ({:code "(defmacro bit-flip [x n]\n  (list 'js* \"(~{} ^ (1 << ~{}))\" x n))",
                                                                   :filename "clojurescript/src/clj/cljs/core.clj",
                                                                   :lines [163
                                                                           164],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L163-L164"}),
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_bit-flip",
                                               :source {:code "(defn bit-flip\n  [x n]\n  (cljs.core/bit-flip x n))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [956
                                                                959],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L956-L959"},
                                               :full-name "cljs.core/bit-flip",
                                               :clj-symbol "clojure.core/bit-flip",
                                               :docstring "Flip bit at index n"},
                         "cljs.core/ISet" {:ns "cljs.core",
                                           :name "ISet",
                                           :type "protocol",
                                           :full-name-encode "cljs.core_ISet",
                                           :source {:code "(defprotocol ISet\n  (-disjoin [coll v]))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [149 150],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L149-L150"},
                                           :methods [{:name "-disjoin",
                                                      :signature ["[coll v]"],
                                                      :docstring nil}],
                                           :full-name "cljs.core/ISet",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/LazySeq" {:full-name "cljs.core/LazySeq",
                                              :ns "cljs.core",
                                              :name "LazySeq",
                                              :type "type",
                                              :signature ["[meta realized x]"],
                                              :source {:code "(deftype LazySeq [meta realized x]\n  IWithMeta\n  (-with-meta [coll meta] (LazySeq. meta realized x))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first (lazy-seq-value coll)))\n  (-rest [coll] (rest (lazy-seq-value coll)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] (seq (lazy-seq-value coll))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1293
                                                               1318],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1293-L1318"},
                                              :full-name-encode "cljs.core_LazySeq",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/*2" {:full-name "cljs.core/*2",
                                         :ns "cljs.core",
                                         :name "*2",
                                         :docstring "bound in a repl thread to the second most recent value printed",
                                         :type "var",
                                         :source {:code "(def\n  ^{:doc \"bound in a repl thread to the second most recent value printed\"}\n  *2)",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [27 29],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L27-L29"},
                                         :full-name-encode "cljs.core__STAR_2",
                                         :clj-symbol "clojure.core/*2",
                                         :history [["+" "0.0-927"]]},
                         "clojure.browser.event/total-listener-count" {:full-name "clojure.browser.event/total-listener-count",
                                                                       :ns "clojure.browser.event",
                                                                       :name "total-listener-count",
                                                                       :type "function",
                                                                       :signature ["[]"],
                                                                       :source {:code "(defn total-listener-count []\n  (goog.events/getTotalListenerCount))",
                                                                                :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                                :lines [85
                                                                                        86],
                                                                                :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/event.cljs#L85-L86"},
                                                                       :full-name-encode "clojure.browser.event_total-listener-count",
                                                                       :history [["+"
                                                                                  "0.0-927"]]},
                         "cljs.core/alter-meta!" {:ns "cljs.core",
                                                  :name "alter-meta!",
                                                  :signature ["[iref f & args]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_alter-meta_BANG_",
                                                  :source {:code "(defn alter-meta!\n  [iref f & args]\n  (set! (.-meta iref) (apply f (.-meta iref) args)))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [3335
                                                                   3342],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3335-L3342"},
                                                  :full-name "cljs.core/alter-meta!",
                                                  :clj-symbol "clojure.core/alter-meta!",
                                                  :docstring "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n(apply f its-current-meta args)\n\nf must be free of side-effects"},
                         "clojure.browser.dom/click-element" {:full-name "clojure.browser.dom/click-element",
                                                              :ns "clojure.browser.dom",
                                                              :name "click-element",
                                                              :type "function",
                                                              :signature ["[e]"],
                                                              :source {:code "(defn click-element\n  [e]\n  (.click (ensure-element e) ()))",
                                                                       :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                       :lines [145
                                                                               147],
                                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/dom.cljs#L145-L147"},
                                                              :full-name-encode "clojure.browser.dom_click-element",
                                                              :history [["+"
                                                                         "0.0-927"]]},
                         "cljs.reader/read-meta" {:full-name "cljs.reader/read-meta",
                                                  :ns "cljs.reader",
                                                  :name "read-meta",
                                                  :type "function",
                                                  :signature ["[rdr _]"],
                                                  :source {:code "(defn read-meta\n  [rdr _]\n  (let [m (desugar-meta (read rdr true nil true))]\n    (when-not (map? m)\n      (reader-error rdr \"Metadata must be Symbol,Keyword,String or Map\"))\n    (let [o (read rdr true nil true)]\n      (if (satisfies? IWithMeta o)\n        (with-meta o (merge (meta o) m))\n        (reader-error rdr \"Metadata can only be applied to IWithMetas\")))))",
                                                           :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                           :lines [287
                                                                   295],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L287-L295"},
                                                  :full-name-encode "cljs.reader_read-meta",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "special/try*" {:full-name "special/try*",
                                         :ns "special",
                                         :name "try*",
                                         :type "special form",
                                         :source {:code "(defmethod parse 'try*\n  [op env [_ & body :as form] name]\n  (let [body (vec body)\n        catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        tail (peek body)\n        fblock (when (and (seq? tail) (= 'finally (first tail)))\n                  (rest tail))\n        finally (when fblock\n                  (analyze-block\n                   (assoc env :context :statement)\n                   fblock))\n        body (if finally (pop body) body)\n        tail (peek body)\n        cblock (when (and (seq? tail)\n                          (= 'catch (first tail)))\n                 (rest tail))\n        name (first cblock)\n        locals (:locals catchenv)\n        mname (when name (munge name))\n        locals (if name\n                 (assoc locals name {:name mname})\n                 locals)\n        catch (when cblock\n                (analyze-block (assoc catchenv :locals locals) (rest cblock)))\n        body (if name (pop body) body)\n        try (when body\n              (analyze-block (if (or name finally) catchenv env) body))]\n    (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n    {:env env :op :try* :form form\n     :try try\n     :finally finally\n     :name mname\n     :catch catch\n     :children [try {:name mname} catch finally]}))",
                                                  :filename "clojurescript/src/clj/cljs/compiler.clj",
                                                  :lines [654 687],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/compiler.clj#L654-L687"},
                                         :full-name-encode "special_try_STAR_",
                                         :history [["+" "0.0-927"]]},
                         "cljs.core/range" {:ns "cljs.core",
                                            :name "range",
                                            :signature ["[]"
                                                        "[end]"
                                                        "[start end]"
                                                        "[start end step]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_range",
                                            :source {:code "(defn range\n  ([] (range 0 js/Number.MAX_VALUE 1))\n  ([end] (range 0 end 1))\n  ([start end] (range start end 1))\n  ([start end step] (Range. nil start end step)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2876
                                                             2883],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2876-L2883"},
                                            :full-name "cljs.core/range",
                                            :clj-symbol "clojure.core/range",
                                            :docstring "Returns a lazy seq of nums from start (inclusive) to end\n(exclusive), by step, where start defaults to 0, step to 1,\nand end to infinity."},
                         "cljs.core/reify" {:full-name "cljs.core/reify",
                                            :ns "cljs.core",
                                            :name "reify",
                                            :type "macro",
                                            :signature ["[& impls]"],
                                            :source {:code "(defmacro reify [& impls]\n  (let [t (gensym \"t\")\n        locals (keys (:locals &env))]\n    `(do\n       (when (undefined? ~t)\n         (deftype ~t [~@locals __meta#]\n           cljs.core.IWithMeta\n           (~'-with-meta [_# __meta#]\n             (new ~t ~@locals __meta#))\n           cljs.core.IMeta\n           (~'-meta [_#] __meta#)\n           ~@impls))\n       (new ~t ~@locals nil))))",
                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                     :lines [191 203],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L191-L203"},
                                            :full-name-encode "cljs.core_reify",
                                            :clj-symbol "clojure.core/reify",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/satisfies?" {:ns "cljs.core",
                                                 :name "satisfies?",
                                                 :signature ["[psym x]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "macro",
                                                 :full-name-encode "cljs.core_satisfies_QMARK_",
                                                 :source {:code "(defmacro satisfies?\n  [psym x]\n  (let [p (:name (cljs.compiler/resolve-var (dissoc &env :locals) psym))\n        prefix (protocol-prefix p)]\n    `(let [x# ~x]\n       (if (and x#\n                (. x# ~(symbol (str \"-\" prefix)))        ;; Need prop lookup here\n                (not (. x# (~'hasOwnProperty ~prefix))))\n\t true\n\t (cljs.core/type_satisfies_ ~psym x#)))))",
                                                          :filename "clojurescript/src/clj/cljs/core.clj",
                                                          :lines [422
                                                                  432],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L422-L432"},
                                                 :full-name "cljs.core/satisfies?",
                                                 :clj-symbol "clojure.core/satisfies?",
                                                 :docstring "Returns true if x satisfies the protocol"},
                         "cljs.core/nth" {:ns "cljs.core",
                                          :name "nth",
                                          :signature ["[coll n]"
                                                      "[coll n not-found]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_nth",
                                          :source {:code "(defn nth\n  ([coll n]\n     (-nth coll (.floor js/Math n)))\n  ([coll n not-found]\n     (-nth coll (.floor js/Math n) not-found)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [501 509],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L501-L509"},
                                          :full-name "cljs.core/nth",
                                          :clj-symbol "clojure.core/nth",
                                          :docstring "Returns the value at the index. get returns nil if index out of\nbounds, nth throws an exception unless not-found is supplied.  nth\nalso works for strings, arrays, regex Matchers and Lists, and,\nin O(n) time, for sequences."},
                         "cljs.core/list" {:full-name "cljs.core/list",
                                           :ns "cljs.core",
                                           :name "list",
                                           :type "function",
                                           :signature ["[& items]"],
                                           :source {:code "(defn list [& items]\n  (reduce conj () (reverse items)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1198 1199],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1198-L1199"},
                                           :full-name-encode "cljs.core_list",
                                           :clj-symbol "clojure.core/list",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/defn" {:ns "cljs.core",
                                           :name "defn",
                                           :signature ["[name doc-string? attr-map? [params*] body]"
                                                       "[name doc-string? attr-map? ([params*] body) + attr-map?]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_defn",
                                           :source {:code "(def \n\n ^{:doc \"Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata\"\n   :arglists '([name doc-string? attr-map? [params*] body]\n                [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :added \"1.0\"}\n defn (fn defn [&form &env name & fdecl]\n        (let [m (if (string? (first fdecl))\n                  {:doc (first fdecl)}\n                  {})\n              fdecl (if (string? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              m (if (map? (first fdecl))\n                  (conj m (first fdecl))\n                  m)\n              fdecl (if (map? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              fdecl (if (vector? (first fdecl))\n                      (list fdecl)\n                      fdecl)\n              m (if (map? (last fdecl))\n                  (conj m (last fdecl))\n                  m)\n              fdecl (if (map? (last fdecl))\n                      (butlast fdecl)\n                      fdecl)\n              m (conj {:arglists (list 'quote (sigs fdecl))} m)\n              m (let [inline (:inline m)\n                      ifn (first inline)\n                      iname (second inline)]\n                  ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)\n                  (if (if (clojure.lang.Util/equiv 'fn ifn)\n                        (if (instance? clojure.lang.Symbol iname) false true))\n                    ;; inserts the same fn name to the inline fn if it does not have one\n                    (assoc m :inline (cons ifn (cons (clojure.lang.Symbol/intern (.concat (.getName ^clojure.lang.Symbol name) \"__inliner\"))\n                                                     (next inline))))\n                    m))\n              m (conj (if (meta name) (meta name) {}) m)]\n          (list 'def (with-meta name m)\n                ;;todo - restore propagation of fn name\n                ;;must figure out how to convey primitive hints to self calls first\n                (cons `fn fdecl) ))))",
                                                    :filename "clojure/src/clj/clojure/core.clj",
                                                    :lines [263 308],
                                                    :link "https://github.com/clojure/clojure/blob/clojure-1.3.0/src/clj/clojure/core.clj#L263-L308"},
                                           :full-name "cljs.core/defn",
                                           :clj-symbol "clojure.core/defn",
                                           :docstring "Same as (def name (fn [params* ] exprs*)) or (def\n name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n to the var metadata"},
                         "cljs.core/rand-nth" {:ns "cljs.core",
                                               :name "rand-nth",
                                               :signature ["[coll]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_rand-nth",
                                               :source {:code "(defn rand-nth\n  [coll]\n  (nth coll (rand-int (count coll))))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [3488
                                                                3493],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3488-L3493"},
                                               :full-name "cljs.core/rand-nth",
                                               :clj-symbol "clojure.core/rand-nth",
                                               :docstring "Return a random element of the (sequential) collection. Will have\nthe same performance characteristics as nth for the given\ncollection."},
                         "cljs.core/atom" {:ns "cljs.core",
                                           :name "atom",
                                           :signature ["[x]"
                                                       "[x & {:keys [meta validator]}]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_atom",
                                           :source {:code "(defn atom\n  ([x] (Atom. x nil nil nil))\n  ([x & {:keys [meta validator]}] (Atom. x meta validator nil)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [3260 3275],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3260-L3275"},
                                           :full-name "cljs.core/atom",
                                           :clj-symbol "clojure.core/atom",
                                           :docstring "Creates and returns an Atom with an initial value of x and zero or\nmore options (in any order):\n\n:meta metadata-map\n\n:validator validate-fn\n\nIf metadata-map is supplied, it will be come the metadata on the\natom. validate-fn must be nil or a side-effect-free fn of one\nargument, which will be passed the intended new state on any state\nchange. If the new state is unacceptable, the validate-fn should\nreturn false or throw an Error.  If either of these error conditions\noccur, then the value of the atom will not change."},
                         "cljs.reader/read-keyword" {:full-name "cljs.reader/read-keyword",
                                                     :ns "cljs.reader",
                                                     :name "read-keyword",
                                                     :type "function",
                                                     :signature ["[reader initch]"],
                                                     :source {:code "(defn read-keyword\n  [reader initch]\n  (let [token (read-token reader (read-char reader))\n        [token ns name] (re-matches symbol-pattern token)]\n    (if (or (and (not (undefined? ns))\n                 (identical? (. ns (substring (- (.-length ns) 2) (.-length ns))) \":/\"))\n            (identical? (aget name (dec (.-length name))) \":\")\n            (not (== (.indexOf token \"::\" 1) -1)))\n      (reader-error reader \"Invalid token: \" token)\n      (if ns?\n        (keyword (.substring ns 0 (.indexOf ns \"/\")) name)\n        (keyword token)))))",
                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                              :lines [256
                                                                      267],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L256-L267"},
                                                     :full-name-encode "cljs.reader_read-keyword",
                                                     :history [["+"
                                                                "0.0-927"]]},
                         "cljs.core/Vector" {:full-name "cljs.core/Vector",
                                             :ns "cljs.core",
                                             :name "Vector",
                                             :type "type",
                                             :signature ["[meta array]"],
                                             :source {:code "(deftype Vector [meta array]\n  IWithMeta\n  (-with-meta [coll meta] (Vector. meta array))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (let [count (.-length array)]\n      (when (> count 0)\n        (aget array (dec count)))))\n  (-pop [coll]\n    (if (> (.-length array) 0)\n      (let [new-array (aclone array)]\n        (. new-array (pop))\n        (Vector. meta new-array))\n      (throw (js/Error. \"Can't pop empty vector\"))))\n\n  ICollection\n  (-conj [coll o]\n    (let [new-array (aclone array)]\n      (.push new-array o)\n      (Vector. meta new-array)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Vector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (when (> (.-length array) 0)\n      (let [vector-seq\n             (fn vector-seq [i]\n               (lazy-seq\n                 (when (< i (.-length array))\n                   (cons (aget array i) (vector-seq (inc i))))))]\n        (vector-seq 0))))\n\n  ICounted\n  (-count [coll] (.-length array))\n\n  IIndexed\n  (-nth [coll n]\n    (if (and (<= 0 n) (< n (.-length array)))\n      (aget array n)\n      #_(throw (js/Error. (str \"No item \" n \" in vector of length \" (.-length array))))))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n (.-length array)))\n      (aget array n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [new-array (aclone array)]\n      (aset new-array k v)\n      (Vector. meta new-array)))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [v f]\n    (ci-reduce array f))\n  (-reduce [v f start]\n    (ci-reduce array f start))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1939
                                                              2020],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1939-L2020"},
                                             :full-name-encode "cljs.core_Vector",
                                             :history [["+" "0.0-927"]]},
                         "cljs.reader/skip-line" {:full-name "cljs.reader/skip-line",
                                                  :ns "cljs.reader",
                                                  :name "skip-line",
                                                  :docstring "Advances the reader to the end of a line. Returns the reader",
                                                  :type "function",
                                                  :signature ["[reader _]"],
                                                  :source {:code "(defn skip-line\n  [reader _]\n  (loop []\n    (let [ch (read-char reader)]\n      (if (or (= ch \\n) (= ch \\r) (nil? ch))\n        reader\n        (recur)))))",
                                                           :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                           :lines [86
                                                                   93],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/reader.cljs#L86-L93"},
                                                  :full-name-encode "cljs.reader_skip-line",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/namespace" {:ns "cljs.core",
                                                :name "namespace",
                                                :signature ["[x]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_namespace",
                                                :source {:code "(defn namespace\n  [x]\n  (if (or (keyword? x) (symbol? x))\n    (let [i (.lastIndexOf x \"/\")]\n      (when (> i -1)\n        (subs x 2 i)))\n    (throw (js/Error. (str \"Doesn't support namespace: \" x)))))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [2765
                                                                 2772],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2765-L2772"},
                                                :full-name "cljs.core/namespace",
                                                :clj-symbol "clojure.core/namespace",
                                                :docstring "Returns the namespace String of a symbol or keyword, or nil if not present."},
                         "cljs.nodejs/require" {:full-name "cljs.nodejs/require",
                                                :ns "cljs.nodejs",
                                                :name "require",
                                                :type "var",
                                                :source {:code "(def require (js* \"require\"))",
                                                         :filename "clojurescript/src/cljs/cljs/nodejs.cljs",
                                                         :lines [7 7],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/nodejs.cljs#L7-L7"},
                                                :full-name-encode "cljs.nodejs_require",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "clojure.browser.event/EventType" {:ns "clojure.browser.event",
                                                            :name "EventType",
                                                            :type "protocol",
                                                            :full-name-encode "clojure.browser.event_EventType",
                                                            :source {:code "(defprotocol EventType\n  (event-types [this]))",
                                                                     :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                     :lines [17
                                                                             18],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/event.cljs#L17-L18"},
                                                            :methods [{:name "event-types",
                                                                       :signature ["[this]"],
                                                                       :docstring nil}],
                                                            :full-name "clojure.browser.event/EventType",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "cljs.core/merge" {:ns "cljs.core",
                                            :name "merge",
                                            :signature ["[& maps]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_merge",
                                            :source {:code "(defn merge\n  [& maps]\n  (when (some identity maps)\n    (reduce #(conj (or %1 {}) %2) maps)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2619
                                                             2625],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2619-L2625"},
                                            :full-name "cljs.core/merge",
                                            :clj-symbol "clojure.core/merge",
                                            :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping from\nthe latter (left-to-right) will be the mapping in the result."},
                         "clojure.browser.repl/send-result" {:full-name "clojure.browser.repl/send-result",
                                                             :ns "clojure.browser.repl",
                                                             :name "send-result",
                                                             :type "function",
                                                             :signature ["[connection url data]"],
                                                             :source {:code "(defn send-result [connection url data]\n  (net/transmit connection url \"POST\" data nil 0))",
                                                                      :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                      :lines [38
                                                                              39],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/repl.cljs#L38-L39"},
                                                             :full-name-encode "clojure.browser.repl_send-result",
                                                             :history [["+"
                                                                        "0.0-927"]]},
                         "clojure.walk/keywordize-keys" {:ns "clojure.walk",
                                                         :name "keywordize-keys",
                                                         :signature ["[m]"],
                                                         :history [["+"
                                                                    "0.0-927"]],
                                                         :type "function",
                                                         :full-name-encode "clojure.walk_keywordize-keys",
                                                         :source {:code "(defn keywordize-keys\n  [m]\n  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                                  :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                                  :lines [64
                                                                          70],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/walk.cljs#L64-L70"},
                                                         :full-name "clojure.walk/keywordize-keys",
                                                         :clj-symbol "clojure.walk/keywordize-keys",
                                                         :docstring "Recursively transforms all map keys from strings to keywords."},
                         "cljs.core/derive" {:ns "cljs.core",
                                             :name "derive",
                                             :signature ["[tag parent]"
                                                         "[h tag parent]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_derive",
                                             :source {:code "(defn derive\n  ([tag parent]\n   (assert (namespace parent))\n   ;; (assert (or (class? tag) (and (instance? cljs.core.Named tag) (namespace tag))))\n   (swap! global-hierarchy derive tag parent) nil)\n  ([h tag parent]\n   (assert (not= tag parent))\n   ;; (assert (or (class? tag) (instance? clojure.lang.Named tag)))\n   ;; (assert (instance? clojure.lang.INamed tag))\n   ;; (assert (instance? clojure.lang.INamed parent))\n   (let [tp (:parents h)\n         td (:descendants h)\n         ta (:ancestors h)\n         tf (fn [m source sources target targets]\n              (reduce (fn [ret k]\n                        (assoc ret k\n                               (reduce conj (get targets k #{}) (cons target (targets target)))))\n                      m (cons source (sources source))))]\n     (or\n      (when-not (contains? (tp tag) parent)\n        (when (contains? (ta tag) parent)\n          (throw (js/Error. (str tag \"already has\" parent \"as ancestor\"))))\n        (when (contains? (ta parent) tag)\n          (throw (js/Error. (str \"Cyclic derivation:\" parent \"has\" tag \"as ancestor\"))))\n        {:parents (assoc (:parents h) tag (conj (get tp tag #{}) parent))\n         :ancestors (tf (:ancestors h) tag td parent ta)\n         :descendants (tf (:descendants h) parent ta tag td)})\n      h))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [3559
                                                              3591],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3559-L3591"},
                                             :full-name "cljs.core/derive",
                                             :clj-symbol "clojure.core/derive",
                                             :docstring "Establishes a parent/child relationship between parent and\ntag. Parent must be a namespace-qualified symbol or keyword and\nchild can be either a namespace-qualified symbol or keyword or a\nclass. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
                         "clojure.zip/zipper" {:ns "clojure.zip",
                                               :name "zipper",
                                               :signature ["[branch? children make-node root]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.zip_zipper",
                                               :source {:code "(defn zipper\n  [branch? children make-node root]\n    ^{:zip/branch? branch? :zip/children children :zip/make-node make-node}\n    [root nil])",
                                                        :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                        :lines [18 32],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L18-L32"},
                                               :full-name "clojure.zip/zipper",
                                               :clj-symbol "clojure.zip/zipper",
                                               :docstring "Creates a new zipper structure. \n\nbranch? is a fn that, given a node, returns true if can have\nchildren, even if it currently doesn't.\n\nchildren is a fn that, given a branch node, returns a seq of its\nchildren.\n\nmake-node is a fn that, given an existing node and a seq of\nchildren, returns a new branch node with the supplied children.\nroot is the root node."},
                         "clojure.zip/remove" {:ns "clojure.zip",
                                               :name "remove",
                                               :signature ["[loc]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.zip_remove",
                                               :source {:code "(defn remove\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]\n      (if (nil? path)\n        (throw \"Remove at top\")\n        (if (pos? (count l))\n          (loop [loc (with-meta [(peek l) (assoc path :l (pop l) :changed? true)] (meta loc))]\n            (if-let [child (and (branch? loc) (down loc))]\n              (recur (rightmost child))\n              loc))\n          (with-meta [(make-node loc (peek pnodes) rs) \n                      (and ppath (assoc ppath :changed? true))]\n                     (meta loc))))))",
                                                        :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                        :lines [237
                                                                251],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/zip.cljs#L237-L251"},
                                               :full-name "clojure.zip/remove",
                                               :clj-symbol "clojure.zip/remove",
                                               :docstring "Removes the node at loc, returning the loc that would have preceded\nit in a depth-first walk."},
                         "cljs.core/find" {:ns "cljs.core",
                                           :name "find",
                                           :signature ["[coll k]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_find",
                                           :source {:code "(defn find\n  [coll k]\n  (when (and coll\n             (associative? coll)\n             (contains? coll k))\n    [k (-lookup coll k)]))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [701 707],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L701-L707"},
                                           :full-name "cljs.core/find",
                                           :clj-symbol "clojure.core/find",
                                           :docstring "Returns the map entry for key, or nil if key not present."},
                         "cljs.core/*print-dup*" {:full-name "cljs.core/*print-dup*",
                                                  :ns "cljs.core",
                                                  :name "*print-dup*",
                                                  :type "var",
                                                  :source {:code "(def *print-dup* false)",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [3103
                                                                   3103],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3103-L3103"},
                                                  :full-name-encode "cljs.core__STAR_print-dup_STAR_",
                                                  :clj-symbol "clojure.core/*print-dup*",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/partial" {:ns "cljs.core",
                                              :name "partial",
                                              :signature ["[f arg1]"
                                                          "[f arg1 arg2]"
                                                          "[f arg1 arg2 arg3]"
                                                          "[f arg1 arg2 arg3 & more]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_partial",
                                              :source {:code "(defn partial\n  ([f arg1]\n   (fn [& args] (apply f arg1 args)))\n  ([f arg1 arg2]\n   (fn [& args] (apply f arg1 arg2 args)))\n  ([f arg1 arg2 arg3]\n   (fn [& args] (apply f arg1 arg2 arg3 args)))\n  ([f arg1 arg2 arg3 & more]\n   (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1529
                                                               1540],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1529-L1540"},
                                              :full-name "cljs.core/partial",
                                              :clj-symbol "clojure.core/partial",
                                              :docstring "Takes a function f and fewer than the normal arguments to f, and\nreturns a fn that takes a variable number of additional args. When\ncalled, the returned function calls f with args + additional args."},
                         "cljs.core/keyword?" {:full-name "cljs.core/keyword?",
                                               :ns "cljs.core",
                                               :name "keyword?",
                                               :type "function",
                                               :signature ["[x]"],
                                               :source {:code "(defn keyword? [x]\n  (and (goog/isString x)\n       (= (.charAt x 0) \\uFDD0)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [670
                                                                672],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L670-L672"},
                                               :full-name-encode "cljs.core_keyword_QMARK_",
                                               :clj-symbol "clojure.core/keyword?",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "clojure.browser.event/fire-listeners" {:full-name "clojure.browser.event/fire-listeners",
                                                                 :ns "clojure.browser.event",
                                                                 :name "fire-listeners",
                                                                 :type "function",
                                                                 :signature ["[obj type capture event]"],
                                                                 :source {:code "(defn fire-listeners\n  [obj type capture event])",
                                                                          :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                          :lines [82
                                                                                  83],
                                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/event.cljs#L82-L83"},
                                                                 :full-name-encode "clojure.browser.event_fire-listeners",
                                                                 :history [["+"
                                                                            "0.0-927"]]},
                         "cljs.core/interleave" {:ns "cljs.core",
                                                 :name "interleave",
                                                 :signature ["[c1 c2]"
                                                             "[c1 c2 & colls]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_interleave",
                                                 :source {:code "(defn interleave\n  ([c1 c2]\n     (lazy-seq\n      (let [s1 (seq c1) s2 (seq c2)]\n        (when (and s1 s2)\n          (cons (first s1) (cons (first s2)\n                                 (interleave (rest s1) (rest s2))))))))\n  ([c1 c2 & colls]\n     (lazy-seq\n      (let [ss (map seq (conj colls c2 c1))]\n        (when (every? identity ss)\n          (concat (map first ss) (apply interleave (map rest ss))))))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [1788
                                                                  1800],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1788-L1800"},
                                                 :full-name "cljs.core/interleave",
                                                 :clj-symbol "clojure.core/interleave",
                                                 :docstring "Returns a lazy seq of the first item in each coll, then the second etc."},
                         "cljs.core/*flush-on-newline*" {:full-name "cljs.core/*flush-on-newline*",
                                                         :ns "cljs.core",
                                                         :name "*flush-on-newline*",
                                                         :type "var",
                                                         :source {:code "(def *flush-on-newline* true)",
                                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                  :lines [3100
                                                                          3100],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3100-L3100"},
                                                         :full-name-encode "cljs.core__STAR_flush-on-newline_STAR_",
                                                         :clj-symbol "clojure.core/*flush-on-newline*",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "cljs.core/get-in" {:ns "cljs.core",
                                             :name "get-in",
                                             :signature ["[m ks]"
                                                         "[m ks not-found]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_get-in",
                                             :source {:code "(defn get-in\n  ([m ks]\n     (reduce get m ks))\n  ([m ks not-found]\n     (loop [sentinel lookup-sentinel\n            m m\n            ks (seq ks)]\n       (if ks\n         (let [m (get m (first ks) sentinel)]\n           (if (identical? sentinel m)\n             not-found\n             (recur sentinel m (next ks))))\n         m))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1896
                                                              1913],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1896-L1913"},
                                             :full-name "cljs.core/get-in",
                                             :clj-symbol "clojure.core/get-in",
                                             :docstring "Returns the value in a nested associative structure,\nwhere ks is a sequence of ke(ys. Returns nil if the key is not present,\nor the not-found value if supplied."},
                         "clojure.browser.dom/element" {:full-name "clojure.browser.dom/element",
                                                        :ns "clojure.browser.dom",
                                                        :name "element",
                                                        :type "function",
                                                        :signature ["[tag-or-text]"
                                                                    "[tag & children]"],
                                                        :source {:code "(defn element\n  ([tag-or-text]\n     (log \"(element \" tag-or-text \")\")\n     (-element tag-or-text))\n  ([tag & children]\n     (log \"(element \" tag \" \" children \")\")\n     (let [attrs (first children)]\n       (if (map? attrs)\n         (-element tag attrs (rest children))\n         (-element tag nil children)))))",
                                                                 :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                 :lines [79
                                                                         88],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/dom.cljs#L79-L88"},
                                                        :full-name-encode "clojure.browser.dom_element",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/prim-seq" {:full-name "cljs.core/prim-seq",
                                               :ns "cljs.core",
                                               :name "prim-seq",
                                               :type "function",
                                               :signature ["[prim i]"],
                                               :source {:code "(defn prim-seq [prim i]\n  (when-not (= 0 (.-length prim))\n    (IndexedSeq. prim i)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [368
                                                                370],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L368-L370"},
                                               :full-name-encode "cljs.core_prim-seq",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/<=" {:ns "cljs.core",
                                         :name "<=",
                                         :signature ["[x]"
                                                     "[x y]"
                                                     "[x y & more]"],
                                         :shadowed-sources ({:code "(defmacro <=\n  ([x] true)\n  ([x y] (list 'js* \"(~{} <= ~{})\" x y))\n  ([x y & more] `(and (<= ~x ~y) (<= ~y ~@more))))",
                                                             :filename "clojurescript/src/clj/cljs/core.clj",
                                                             :lines [93
                                                                     96],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L93-L96"}),
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core__LT__EQ_",
                                         :source {:code "(defn <=\n  ([x] true)\n  ([x y] (cljs.core/<= x y))\n  ([x y & more]\n   (if (cljs.core/<= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/<= y (first more)))\n     false)))",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [850 860],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L850-L860"},
                                         :full-name "cljs.core/<=",
                                         :clj-symbol "clojure.core/<=",
                                         :docstring "Returns non-nil if nums are in monotonically non-decreasing order,\notherwise false."},
                         "clojure.set/map-invert" {:ns "clojure.set",
                                                   :name "map-invert",
                                                   :signature ["[m]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.set_map-invert",
                                                   :source {:code "(defn map-invert\n  [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))",
                                                            :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                            :lines [98
                                                                    100],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/set.cljs#L98-L100"},
                                                   :full-name "clojure.set/map-invert",
                                                   :clj-symbol "clojure.set/map-invert",
                                                   :docstring "Returns the map with the vals mapped to the keys."},
                         "clojure.browser.event/listen" {:full-name "clojure.browser.event/listen",
                                                         :ns "clojure.browser.event",
                                                         :name "listen",
                                                         :type "function",
                                                         :signature ["[src type fn]"
                                                                     "[src type fn capture?]"],
                                                         :source {:code "(defn listen\n  ([src type fn]\n     (listen src type fn false))\n  ([src type fn capture?]\n     (goog.events/listen src\n                         (get (event-types src) type type)\n                         fn\n                         capture?)))",
                                                                  :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                  :lines [44
                                                                          51],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/event.cljs#L44-L51"},
                                                         :full-name-encode "clojure.browser.event_listen",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "cljs.core/neg?" {:ns "cljs.core",
                                           :name "neg?",
                                           :signature ["[x]"],
                                           :shadowed-sources ({:code "(defmacro neg? [x]\n  `(< ~x 0))",
                                                               :filename "clojurescript/src/clj/cljs/core.clj",
                                                               :lines [125
                                                                       126],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L125-L126"}),
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_neg_QMARK_",
                                           :source {:code "(defn neg?\n  [x] (cljs.core/neg? x))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1002 1004],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1002-L1004"},
                                           :full-name "cljs.core/neg?",
                                           :clj-symbol "clojure.core/neg?",
                                           :docstring "Returns true if num is less than zero, else false"},
                         "clojure.browser.dom/replace-node" {:full-name "clojure.browser.dom/replace-node",
                                                             :ns "clojure.browser.dom",
                                                             :name "replace-node",
                                                             :docstring "Replace old-node with new-node. old-node can be an element or a\nkeyword which is the id of the node to replace.  new-node can be an\nelement or an html string.",
                                                             :type "function",
                                                             :signature ["[old-node new-node]"],
                                                             :source {:code "(defn replace-node\n  [old-node new-node]\n  (let [old-node (ensure-element old-node)\n        new-node (ensure-element new-node)]\n    (gdom/replaceNode new-node old-node)\n    new-node))",
                                                                      :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                      :lines [112
                                                                              120],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/clojure/browser/dom.cljs#L112-L120"},
                                                             :full-name-encode "clojure.browser.dom_replace-node",
                                                             :history [["+"
                                                                        "0.0-927"]]},
                         "special/catch" {:ns "special",
                                          :name "catch",
                                          :signature ["[protoname name expr*]"],
                                          :history [["+" "0.0-927"]],
                                          :type "special form",
                                          :full-name-encode "special_catch",
                                          :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (list? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                                   :filename "clojurescript/src/clj/cljs/core.clj",
                                                   :lines [511 539],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/clj/cljs/core.clj#L511-L539"},
                                          :full-name "special/catch",
                                          :clj-symbol "clojure.core/catch",
                                          :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions."},
                         "cljs.core/reverse" {:ns "cljs.core",
                                              :name "reverse",
                                              :signature ["[coll]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_reverse",
                                              :source {:code "(defn reverse\n  [coll]\n  (reduce conj () coll))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1193
                                                               1196],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L1193-L1196"},
                                              :full-name "cljs.core/reverse",
                                              :clj-symbol "clojure.core/reverse",
                                              :docstring "Returns a seq of the items in coll in reverse order. Not lazy."},
                         "cljs.core/realized?" {:ns "cljs.core",
                                                :name "realized?",
                                                :signature ["[d]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_realized_QMARK_",
                                                :source {:code "(defn realized?\n  [d]\n  (-realized? d))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [3424
                                                                 3427],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L3424-L3427"},
                                                :full-name "cljs.core/realized?",
                                                :clj-symbol "clojure.core/realized?",
                                                :docstring "Returns true if a value has been produced for a promise, delay, future or lazy sequence."}},
               :changes [{:cljs-version "0.0-927",
                          :cljs-date "2012-01-18",
                          :clj-version "1.3.0",
                          :gclosure-lib "20110323-r790",
                          :added #{"cljs.core/keys"
                                   "cljs.core/reset!"
                                   "clojure.set/select"
                                   "cljs.core/delay"
                                   "cljs.core/bit-not"
                                   "cljs.core/partition"
                                   "cljs.core/parents"
                                   "cljs.core/aclone"
                                   "cljs.core/reset-meta!"
                                   "special/defrecord*"
                                   "cljs.reader/dispatch-macros"
                                   "cljs.core/ICollection"
                                   "cljs.core/every?"
                                   "clojure.zip/node"
                                   "cljs.core/IEmptyableCollection"
                                   "clojure.zip/right"
                                   "cljs.core/=="
                                   "special/."
                                   "clojure.browser.net/*timeout*"
                                   "cljs.core/remove-method"
                                   "cljs.core/frequencies"
                                   "cljs.core/pop"
                                   "cljs.core/not-every?"
                                   "cljs.core/some-fn"
                                   "clojure.browser.event/remove-all"
                                   "cljs.core/doto"
                                   "cljs.core/take-while"
                                   "cljs.reader/escape-char-map"
                                   "clojure.browser.event/all-listeners"
                                   "cljs.core/vals"
                                   "cljs.core/IDeref"
                                   "clojure.browser.dom/log-obj"
                                   "cljs.core/for"
                                   "cljs.core/instance?"
                                   "cljs.reader/read-comment"
                                   "cljs.reader/read-number"
                                   "cljs.core/ILookup"
                                   "cljs.core/when"
                                   "clojure.browser.dom/set-value"
                                   "cljs.reader/read-past"
                                   "cljs.core/to-array"
                                   "cljs.core/interpose"
                                   "clojure.browser.net/ICrossPageChannel"
                                   "special/finally"
                                   "cljs.core/Cons"
                                   "cljs.core/re-find"
                                   "cljs.core/IMeta"
                                   "cljs.core/assoc-in"
                                   "clojure.string/join"
                                   "clojure.zip/rights"
                                   "cljs.core/split-at"
                                   "clojure.zip/append-child"
                                   "cljs.core/binding"
                                   "cljs.core/Set"
                                   "cljs.reader/macro-terminating?"
                                   "cljs.core/prefers"
                                   "cljs.core/vary-meta"
                                   "cljs.core/when-let"
                                   "cljs.core/drop"
                                   "cljs.core/while"
                                   "cljs.core/import-macros"
                                   "cljs.core/string-print"
                                   "cljs.core/-"
                                   "clojure.zip/vector-zip"
                                   "cljs.core/js->clj"
                                   "cljs.core/List"
                                   "cljs.core/identical?"
                                   "cljs.core/*main-cli-fn*"
                                   "clojure.browser.dom/html->dom"
                                   "cljs.core/some"
                                   "cljs.core/doall"
                                   "cljs.core/condp"
                                   "clojure.zip/down"
                                   "cljs.core/IPending"
                                   "cljs.core/count"
                                   "cljs.core/bit-test"
                                   "cljs.core/fixture2"
                                   "cljs.core/loop"
                                   "cljs.core/subvec"
                                   "cljs.core/bit-clear"
                                   "cljs.core/gensym"
                                   "special/recur"
                                   "cljs.core/+"
                                   "cljs.core/comp"
                                   "cljs.reader/desugar-meta"
                                   "cljs.core/pr"
                                   "clojure.string/upper-case"
                                   "clojure.browser.event/expose"
                                   "clojure.browser.event/listen-once"
                                   "cljs.core/empty?"
                                   "cljs.core/newline"
                                   "cljs.core/replace"
                                   "cljs.core/rand"
                                   "cljs.core/add-watch"
                                   "clojure.string/capitalize"
                                   "cljs.core/replicate"
                                   "special/do"
                                   "cljs.core/sequential?"
                                   "cljs.core/underive"
                                   "cljs.core/get-method"
                                   "cljs.core/="
                                   "cljs.core/defn-"
                                   "cljs.reader/read-symbol"
                                   "cljs.reader/push-back-reader"
                                   "cljs.core/deftype"
                                   "cljs.core/Subvec"
                                   "special/ns"
                                   "cljs.core/extend-protocol"
                                   "cljs.reader/read"
                                   "cljs.core/EmptyList"
                                   "clojure.walk/postwalk"
                                   "clojure.zip/edit"
                                   "cljs.core/re-seq"
                                   "cljs.reader/read-list"
                                   "cljs.core/Atom"
                                   "cljs.core/IMap"
                                   "cljs.reader/read-vector"
                                   "clojure.set/join"
                                   "cljs.core/HashMap"
                                   "cljs.reader/int-pattern"
                                   "cljs.core/swap!"
                                   "cljs.core/dec"
                                   "clojure.browser.dom/remove-children"
                                   "cljs.core/get-validator"
                                   "cljs.core/coll?"
                                   "cljs.core/bit-or"
                                   "cljs.core/nfirst"
                                   "cljs.core/keep"
                                   "cljs.core/take"
                                   "cljs.core/cond"
                                   "cljs.core/bit-and"
                                   "clojure.browser.event/unique-event-id"
                                   "clojure.set/project"
                                   "special/js*"
                                   "clojure.string/trim-newline"
                                   "specialrepl/in-ns"
                                   "special/let*"
                                   "special/throw"
                                   "clojure.zip/insert-left"
                                   "cljs.core/true?"
                                   "clojure.browser.net/xpc-connection"
                                   "cljs.core/not"
                                   "cljs.core/js-obj"
                                   "cljs.core/complement"
                                   "cljs.core/spread"
                                   "cljs.core/keyword"
                                   "cljs.core/sort"
                                   "clojure.string/trim"
                                   "cljs.core/meta"
                                   "cljs.core/time"
                                   "cljs.core/boolean"
                                   "cljs.reader/read-token"
                                   "cljs.core/update-in"
                                   "cljs.core/map-indexed"
                                   "cljs.core/IStack"
                                   "cljs.core/IIndexed"
                                   "clojure.browser.repl/repl-print"
                                   "clojure.browser.net/xpc-config-fields"
                                   "cljs.core/nnext"
                                   "cljs.core/*print-meta*"
                                   "cljs.reader/read-dispatch"
                                   "cljs.core/distinct"
                                   "cljs.reader/wrapping-reader"
                                   "cljs.core/prn"
                                   "clojure.zip/leftmost"
                                   "cljs.core/>="
                                   "cljs.reader/macros"
                                   "cljs.core/doseq"
                                   "cljs.core/*"
                                   "cljs.core/into"
                                   "cljs.core/defmethod"
                                   "cljs.core/rest"
                                   "cljs.core/dotimes"
                                   "clojure.zip/lefts"
                                   "clojure.browser.dom/ensure-element"
                                   "cljs.core/defmacro"
                                   "cljs.core/remove"
                                   "cljs.core/if-not"
                                   "clojure.zip/path"
                                   "cljs.core/mapcat"
                                   "cljs.core/IWatchable"
                                   "clojure.zip/rightmost"
                                   "cljs.core/->"
                                   "cljs.core/remove-all-methods"
                                   "clojure.string/replace-first"
                                   "clojure.browser.dom/get-value"
                                   "cljs.nodejs/process"
                                   "cljs.core/not="
                                   "cljs.core/js-keys"
                                   "clojure.zip/seq-zip"
                                   "cljs.core/IVector"
                                   "cljs.core/empty"
                                   "cljs.core/re-matches"
                                   "clojure.browser.dom/DOMBuilder"
                                   "cljs.core/fixture1"
                                   "cljs.core/extend-type"
                                   "cljs.core/ISeqable"
                                   "cljs.core/assoc"
                                   "clojure.browser.repl/xpc-connection"
                                   "cljs.core/IDerefWithTimeout"
                                   "clojure.browser.repl/start-evaluator"
                                   "clojure.browser.event/unlisten"
                                   "cljs.core/fnil"
                                   "cljs.core/this-as"
                                   "cljs.core/PersistentQueueSeq"
                                   "cljs.core/counted?"
                                   "clojure.string/trimr"
                                   "cljs.core/force"
                                   "cljs.core/compare-and-set!"
                                   "cljs.core/set?"
                                   "clojure.string/escape"
                                   "cljs.core/remove-watch"
                                   "cljs.core/IMultiFn"
                                   "clojure.zip/end?"
                                   "clojure.set/superset?"
                                   "clojure.browser.net/IConnection"
                                   "cljs.core/let"
                                   "cljs.core/dorun"
                                   "cljs.core/pr-str"
                                   "cljs.core/IPrintable"
                                   "cljs.core/defprotocol"
                                   "cljs.core/assert"
                                   "cljs.core/declare"
                                   "cljs.core/fn?"
                                   "cljs.core/associative?"
                                   "cljs.core/list*"
                                   "cljs.core/reduce"
                                   "clojure.browser.event/has-listener"
                                   "cljs.core/compare"
                                   "cljs.core/contains?"
                                   "cljs.core/prefer-method"
                                   "cljs.core/array-seq"
                                   "cljs.core/PersistentQueue"
                                   "cljs.core/drop-last"
                                   "cljs.reader/read-string"
                                   "cljs.core/vector?"
                                   "cljs.core/defmulti"
                                   "clojure.browser.event/dispatch-event"
                                   "clojure.string/split-lines"
                                   "cljs.core/areduce"
                                   "cljs.core/disj"
                                   "clojure.browser.net/event-types"
                                   "clojure.string/lower-case"
                                   "cljs.core/*print-fn*"
                                   "cljs.core/str"
                                   "cljs.core/ISequential"
                                   "cljs.core/set"
                                   "special/def"
                                   "cljs.core/print"
                                   "clojure.string/blank?"
                                   "clojure.browser.dom/append"
                                   "cljs.core/take-last"
                                   "clojure.set/intersection"
                                   "cljs.core/fnext"
                                   "cljs.core/apply"
                                   "clojure.walk/prewalk"
                                   "cljs.core/flatten"
                                   "cljs.core/get"
                                   "cljs.core/.."
                                   "cljs.core/Range"
                                   "cljs.core/zero?"
                                   "cljs.core/identity"
                                   "cljs.core/first"
                                   "cljs.reader/ratio-pattern"
                                   "cljs.core/>"
                                   "cljs.core/juxt"
                                   "cljs.core/max"
                                   "cljs.core/*3"
                                   "cljs.core/number?"
                                   "cljs.core/array"
                                   "cljs.core/nthnext"
                                   "cljs.core/re-pattern"
                                   "cljs.core/missing-protocol"
                                   "clojure.browser.dom/set-text"
                                   "clojure.zip/up"
                                   "cljs.core/IWithMeta"
                                   "cljs.core/bit-and-not"
                                   "clojure.string/triml"
                                   "clojure.string/split"
                                   "cljs.core/hash-map"
                                   "cljs.core/rem"
                                   "cljs.core/IRecord"
                                   "cljs.core/constantly"
                                   "clojure.browser.dom/get-element"
                                   "cljs.core/and"
                                   "clojure.browser.repl/wrap-message"
                                   "clojure.browser.event/unlisten-by-key"
                                   "cljs.core/try"
                                   "cljs.core/iterate"
                                   "cljs.core/lazy-seq"
                                   "specialrepl/load-file"
                                   "cljs.core/IndexedSeq"
                                   "cljs.core/next"
                                   "cljs.core/*print-readably*"
                                   "cljs.core/last"
                                   "cljs.core/bit-shift-left"
                                   "clojure.string/reverse"
                                   "cljs.core/min"
                                   "cljs.reader/escape-char"
                                   "cljs.reader/read-map"
                                   "cljs.core/seq"
                                   "cljs.core/not-empty"
                                   "cljs.core/println"
                                   "clojure.browser.repl/connect"
                                   "clojure.browser.dom/insert-at"
                                   "cljs.core/quot"
                                   "clojure.browser.event/get-listener"
                                   "cljs.core/filter"
                                   "clojure.zip/branch?"
                                   "special/if"
                                   "cljs.core/ObjMap"
                                   "cljs.core/zipmap"
                                   "cljs.core/hash-combine"
                                   "cljs.core/max-key"
                                   "clojure.zip/insert-child"
                                   "cljs.core/defrecord"
                                   "cljs.core/butlast"
                                   "cljs.core/hash"
                                   "cljs.core/bit-set"
                                   "cljs.core/concat"
                                   "cljs.core/conj"
                                   "clojure.set/difference"
                                   "cljs.core/when-first"
                                   "cljs.core/distinct?"
                                   "cljs.core/pos?"
                                   "cljs.core/IHash"
                                   "cljs.core/is_proto_"
                                   "cljs.core/keep-indexed"
                                   "cljs.core/bit-shift-right"
                                   "clojure.zip/insert-right"
                                   "cljs.core/make-hierarchy"
                                   "cljs.core/repeat"
                                   "cljs.core/MultiFn"
                                   "cljs.core/not-any?"
                                   "cljs.reader/read-regex"
                                   "clojure.zip/next"
                                   "cljs.core/aget"
                                   "cljs.core/if-let"
                                   "cljs.core//"
                                   "cljs.core/min-key"
                                   "clojure.zip/root"
                                   "cljs.core/drop-while"
                                   "clojure.browser.repl/evaluate-javascript"
                                   "cljs.core/set-validator!"
                                   "cljs.core/<"
                                   "cljs.core/fn"
                                   "cljs.core/split-with"
                                   "cljs.core/IReduce"
                                   "cljs.reader/symbol-pattern"
                                   "cljs.core/repeatedly"
                                   "cljs.reader/read-delimited-list"
                                   "cljs.core/undefined?"
                                   "clojure.zip/prev"
                                   "cljs.core/seq?"
                                   "cljs.core/odd?"
                                   "cljs.core/cons"
                                   "special/deftype*"
                                   "cljs.reader/read-set"
                                   "cljs.core/descendants"
                                   "special/new"
                                   "cljs.core/take-nth"
                                   "cljs.reader/throwing-reader"
                                   "cljs.core/even?"
                                   "special/fn*"
                                   "clojure.set/subset?"
                                   "cljs.core/flush"
                                   "cljs.reader/reader-error"
                                   "clojure.walk/prewalk-replace"
                                   "cljs.core/*1"
                                   "cljs.reader/read-unicode-char"
                                   "cljs.core/dissoc"
                                   "cljs.core/ffirst"
                                   "clojure.zip/replace"
                                   "cljs.core/vec"
                                   "cljs.core/or"
                                   "cljs.core/mod"
                                   "cljs.core/aset"
                                   "cljs.core/second"
                                   "clojure.set/rename"
                                   "cljs.core/delay?"
                                   "clojure.zip/left"
                                   "cljs.reader/not-implemented"
                                   "cljs.core/IAssociative"
                                   "cljs.core/group-by"
                                   "cljs.core/symbol"
                                   "cljs.core/Delay"
                                   "cljs.core/methods"
                                   "cljs.core/vector"
                                   "cljs.core/rand-int"
                                   "cljs.core/letfn"
                                   "cljs.reader/read-discard"
                                   "cljs.core/inc"
                                   "cljs.core/name"
                                   "cljs.core/cycle"
                                   "cljs.core/map"
                                   "cljs.core/amap"
                                   "clojure.zip/children"
                                   "special/set!"
                                   "cljs.core/when-not"
                                   "clojure.set/index"
                                   "clojure.browser.dom/log"
                                   "cljs.core/partition-by"
                                   "cljs.core/sort-by"
                                   "cljs.core/with-meta"
                                   "cljs.core/NeverEquiv"
                                   "cljs.core/select-keys"
                                   "special/loop*"
                                   "cljs.core/ISeq"
                                   "clojure.walk/postwalk-replace"
                                   "cljs.core/pr-with-opts"
                                   "cljs.core/->>"
                                   "cljs.core/nil?"
                                   "clojure.walk/stringify-keys"
                                   "clojure.browser.repl/order"
                                   "cljs.core/memoize"
                                   "cljs.core/pr-sequential"
                                   "clojure.zip/make-node"
                                   "specialrepl/load-namespace"
                                   "cljs.reader/float-pattern"
                                   "cljs.core/ancestors"
                                   "cljs.core/integer?"
                                   "clojure.zip/xml-zip"
                                   "clojure.walk/walk"
                                   "cljs.core/bit-xor"
                                   "clojure.set/union"
                                   "cljs.reader/PushbackReader"
                                   "cljs.core/isa?"
                                   "clojure.browser.net/xhr-connection"
                                   "cljs.core/subs"
                                   "cljs.core/symbol?"
                                   "clojure.string/replace"
                                   "cljs.core/string?"
                                   "cljs.core/partition-all"
                                   "cljs.core/merge-with"
                                   "clojure.browser.dom/set-properties"
                                   "cljs.core/trampoline"
                                   "clojure.browser.repl/send-print"
                                   "cljs.core/ICounted"
                                   "cljs.core/IEquiv"
                                   "cljs.core/js-delete"
                                   "cljs.core/comment"
                                   "cljs.reader/special-symbols"
                                   "cljs.core/alength"
                                   "special/quote"
                                   "cljs.core/tree-seq"
                                   "cljs.reader/read-unmatched-delimiter"
                                   "cljs.core/every-pred"
                                   "clojure.set/rename-keys"
                                   "cljs.core/peek"
                                   "cljs.core/pr-str-with-opts"
                                   "cljs.core/map?"
                                   "cljs.reader/StringPushbackReader"
                                   "cljs.core/deref"
                                   "cljs.core/reductions"
                                   "cljs.core/false?"
                                   "cljs.core/bit-flip"
                                   "cljs.core/ISet"
                                   "cljs.core/LazySeq"
                                   "cljs.core/*2"
                                   "clojure.browser.event/total-listener-count"
                                   "cljs.core/alter-meta!"
                                   "clojure.browser.dom/click-element"
                                   "cljs.reader/read-meta"
                                   "special/try*"
                                   "cljs.core/range"
                                   "cljs.core/reify"
                                   "cljs.core/satisfies?"
                                   "cljs.core/nth"
                                   "cljs.core/list"
                                   "cljs.core/defn"
                                   "cljs.core/rand-nth"
                                   "cljs.core/atom"
                                   "cljs.reader/read-keyword"
                                   "cljs.core/Vector"
                                   "cljs.reader/skip-line"
                                   "cljs.core/namespace"
                                   "cljs.nodejs/require"
                                   "clojure.browser.event/EventType"
                                   "cljs.core/merge"
                                   "clojure.browser.repl/send-result"
                                   "clojure.walk/keywordize-keys"
                                   "cljs.core/derive"
                                   "clojure.zip/zipper"
                                   "clojure.zip/remove"
                                   "cljs.core/find"
                                   "cljs.core/*print-dup*"
                                   "cljs.core/partial"
                                   "cljs.core/keyword?"
                                   "clojure.browser.event/fire-listeners"
                                   "cljs.core/interleave"
                                   "cljs.core/*flush-on-newline*"
                                   "cljs.core/get-in"
                                   "clojure.browser.dom/element"
                                   "cljs.core/prim-seq"
                                   "cljs.core/<="
                                   "clojure.set/map-invert"
                                   "clojure.browser.event/listen"
                                   "cljs.core/neg?"
                                   "clojure.browser.dom/replace-node"
                                   "special/catch"
                                   "cljs.core/reverse"
                                   "cljs.core/realized?"}}
                         {:cljs-version "0.0-971",
                          :cljs-date "2012-01-27",
                          :clj-version "1.3.0",
                          :gclosure-lib "20110323-r790",
                          :added #{"cljs.core/type" "cljs.core/IFn"}}
                         {:cljs-version "0.0-993",
                          :cljs-date "2012-02-25",
                          :clj-version "1.3.0",
                          :gclosure-lib "20110323-r790"}
                         {:cljs-version "0.0-1006",
                          :cljs-date "2012-03-30",
                          :clj-version "1.3.0",
                          :gclosure-lib "20110323-r790",
                          :added #{"cljs.core/PersistentVector"}}
                         {:cljs-version "0.0-1011",
                          :cljs-date "2012-03-31",
                          :clj-version "1.3.0",
                          :gclosure-lib "20110323-r790",
                          :added #{"cljs.core/println-str"
                                   "cljs.core/print-str"
                                   "cljs.core/prn-str-with-opts"
                                   "cljs.core/prn-str"}}]},
 :compiler-api {:symbols {},
                :changes [{:cljs-version "0.0-927",
                           :cljs-date "2012-01-18",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-971",
                           :cljs-date "2012-01-27",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-993",
                           :cljs-date "2012-02-25",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-1006",
                           :cljs-date "2012-03-30",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-1011",
                           :cljs-date "2012-03-31",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}]}}
