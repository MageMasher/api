{:release {:cljs-version "0.0-1798",
           :cljs-tag "r1798",
           :cljs-date "2013-04-30",
           :clj-version "1.5.1",
           :clj-tag "clojure-1.5.1",
           :gclosure-lib "0.0-2029-2"},
 :clj-not-cljs #{"clojure.core/the-ns"
                 "clojure.core/create-struct"
                 "clojure.data/diff-similar"
                 "clojure.core/*in*"
                 "clojure.main/demunge"
                 "clojure.core.protocols/kv-reduce"
                 "clojure.core/release-pending-sends"
                 "clojure.reflect/flag-descriptors"
                 "clojure.core/shutdown-agents"
                 "clojure.core/restart-agent"
                 "clojure.java.io/input-stream"
                 "clojure.stacktrace/print-cause-trace"
                 "clojure.test/use-fixtures"
                 "clojure.java.io/file"
                 "clojure.test/*load-tests*"
                 "clojure.core/->Vec"
                 "clojure.test/deftest-"
                 "clojure.inspector/inspect-tree"
                 "clojure.core/remove-ns"
                 "clojure.repl/thread-stopper"
                 "clojure.core/+'"
                 "clojure.core/rationalize"
                 "clojure.main/repl"
                 "clojure.pprint/simple-dispatch"
                 "clojure.repl/dir-fn"
                 "clojure.pprint/write-out"
                 "clojure.core/proxy-super"
                 "clojure.core/refer"
                 "clojure.repl/apropos"
                 "clojure.stacktrace/print-trace-element"
                 "clojure.core.protocols/CollReduce"
                 "clojure.core/future-call"
                 "clojure.pprint/print-table"
                 "clojure.core/var?"
                 "clojure.core.protocols/InternalReduce"
                 "clojure.core/loaded-libs"
                 "clojure.core/commute"
                 "clojure.core/agent-errors"
                 "clojure.main/repl-caught"
                 "clojure.pprint/*print-base*"
                 "clojure.core/load-string"
                 "clojure.core/pmap"
                 "clojure.test/file-position"
                 "clojure.core.protocols/IKVReduce"
                 "clojure.test/do-report"
                 "clojure.core/send"
                 "clojure.test/testing"
                 "clojure.core/ref-history-count"
                 "clojure.core/iterator-seq"
                 "clojure.pprint/pprint-indent"
                 "clojure.reflect/map->Field"
                 "clojure.core/find-var"
                 "clojure.core/defstruct"
                 "clojure.core/-'"
                 "clojure.core/agent-error"
                 "clojure.core/ns-refers"
                 "clojure.core/num"
                 "clojure.core/*clojure-version*"
                 "clojure.reflect/do-reflect"
                 "clojure.core/future-cancelled?"
                 "clojure.java.io/make-writer"
                 "clojure.test/test-var"
                 "clojure.stacktrace/print-stack-trace"
                 "clojure.core/init-proxy"
                 "clojure.walk/postwalk-demo"
                 "clojure.core/read-line"
                 "clojure.core/alter-var-root"
                 "clojure.core/bases"
                 "clojure.repl/source-fn"
                 "clojure.core/class"
                 "clojure.reflect/ClassResolver"
                 "clojure.reflect/type-reflect"
                 "clojure.core/default-data-readers"
                 "clojure.test/testing-contexts-str"
                 "clojure.core/byte-array"
                 "clojure.pprint/print-length-loop"
                 "clojure.test/join-fixtures"
                 "clojure.java.shell/with-sh-dir"
                 "clojure.test/run-tests"
                 "clojure.core/*err*"
                 "clojure.pprint/*print-pretty*"
                 "clojure.test/successful?"
                 "clojure.core/await"
                 "clojure.test/testing-vars-str"
                 "clojure.core/supers"
                 "clojure.test/is"
                 "clojure.reflect/Field"
                 "clojure.core/sorted?"
                 "clojure.core/vector-of"
                 "clojure.core/accessor"
                 "clojure.inspector/inspect-table"
                 "clojure.core/class?"
                 "clojure.core/ns-map"
                 "clojure.instant/parse-timestamp"
                 "clojure.java.io/make-output-stream"
                 "clojure.core/import"
                 "clojure.pprint/fresh-line"
                 "clojure.core/aset-boolean"
                 "clojure.reflect/typename"
                 "clojure.walk/prewalk-demo"
                 "clojure.core/require"
                 "clojure.pprint/pprint-tab"
                 "clojure.reflect/reflect"
                 "clojure.core/with-bindings"
                 "clojure.core/sync"
                 "clojure.pprint/pprint-logical-block"
                 "clojure.java.javadoc/javadoc"
                 "clojure.repl/find-doc"
                 "clojure.reflect/->AsmReflector"
                 "clojure.core/ref-set"
                 "clojure.reflect/->Method"
                 "clojure.core/->ArrayChunk"
                 "clojure.test/run-all-tests"
                 "clojure.test.tap/with-tap-output"
                 "clojure.core/*print-length*"
                 "clojure.java.io/copy"
                 "clojure.pprint/write"
                 "clojure.core/*data-readers*"
                 "clojure.core/with-redefs"
                 "clojure.core/use"
                 "clojure.test.junit/with-junit-output"
                 "clojure.pprint/*print-right-margin*"
                 "clojure.core/future?"
                 "clojure.core/proxy-mappings"
                 "clojure.core/*read-eval*"
                 "clojure.template/do-template"
                 "clojure.core/spit"
                 "clojure.core/Vec"
                 "clojure.core/monitor-enter"
                 "clojure.core/alter"
                 "clojure.core/char?"
                 "clojure.java.io/resource"
                 "clojure.repl/root-cause"
                 "clojure.core/inc'"
                 "clojure.pprint/formatter"
                 "clojure.java.io/make-parents"
                 "clojure.reflect/->Constructor"
                 "clojure.core/ref-min-history"
                 "clojure.core/get-proxy-class"
                 "clojure.main/repl-requires"
                 "clojure.core/aset-double"
                 "clojure.pprint/formatter-out"
                 "clojure.pprint/*print-miser-width*"
                 "clojure.test/set-test"
                 "clojure.core/ref"
                 "clojure.core/future-cancel"
                 "clojure.core/nthrest"
                 "clojure.core/with-local-vars"
                 "clojure.core/agent"
                 "clojure.core/ns-name"
                 "clojure.pprint/pprint-newline"
                 "clojure.core/bean"
                 "clojure.test/compose-fixtures"
                 "clojure.core/aset-float"
                 "clojure.core/*file*"
                 "clojure.core/*out*"
                 "clojure.core/clojure-version"
                 "clojure.core/with-in-str"
                 "clojure.core/test"
                 "clojure.repl/pst"
                 "clojure.xml/parse"
                 "clojure.core/with-bindings*"
                 "clojure.test/test-ns"
                 "clojure.test/assert-predicate"
                 "clojure.instant/read-instant-timestamp"
                 "clojure.reflect/->Field"
                 "clojure.core/*default-data-reader-fn*"
                 "clojure.core/update-proxy"
                 "clojure.java.io/make-input-stream"
                 "clojure.core/promise"
                 "clojure.instant/validated"
                 "clojure.core/*compile-files*"
                 "clojure.pprint/set-pprint-dispatch"
                 "clojure.core/float?"
                 "clojure.core/eval"
                 "clojure.core/*compile-path*"
                 "clojure.core/gen-class"
                 "clojure.core/macroexpand-1"
                 "clojure.test.tap/print-tap-diagnostic"
                 "clojure.core/find-keyword"
                 "clojure.core/bound-fn*"
                 "clojure.core/find-ns"
                 "clojure.reflect/Constructor"
                 "clojure.test/*stack-trace-depth*"
                 "clojure.reflect/resolve-class"
                 "clojure.edn/read"
                 "clojure.java.io/as-file"
                 "clojure.core/ns-aliases"
                 "clojure.main/stack-element-str"
                 "clojure.core/extend"
                 "clojure.core/char-name-string"
                 "clojure.reflect/JavaReflector"
                 "clojure.inspector/inspect"
                 "clojure.core/send-via"
                 "clojure.core/set-agent-send-executor!"
                 "clojure.core/*e"
                 "clojure.core/defonce"
                 "clojure.core/create-ns"
                 "clojure.repl/doc"
                 "clojure.core/aset-int"
                 "clojure.edn/read-string"
                 "clojure.test/test-all-vars"
                 "clojure.stacktrace/print-throwable"
                 "clojure.pprint/*print-suppress-namespaces*"
                 "clojure.reflect/map->Method"
                 "clojure.pprint/code-dispatch"
                 "clojure.pprint/*print-radix*"
                 "clojure.main/repl-prompt"
                 "clojure.test/with-test"
                 "clojure.pprint/pp"
                 "clojure.core/struct-map"
                 "clojure.template/apply-template"
                 "clojure.core/set-agent-send-off-executor!"
                 "clojure.core/cast"
                 "clojure.core/load"
                 "clojure.java.shell/with-sh-env"
                 "clojure.main/repl-read"
                 "clojure.core/io!"
                 "clojure.repl/dir"
                 "clojure.core/ensure"
                 "clojure.string/re-quote-replacement"
                 "clojure.core/*print-level*"
                 "clojure.core/re-groups"
                 "clojure.core/pvalues"
                 "clojure.core/deliver"
                 "clojure.main/load-script"
                 "clojure.core/numerator"
                 "clojure.core/VecNode"
                 "clojure.core/VecSeq"
                 "clojure.core/var-get"
                 "clojure.core/clear-agent-errors"
                 "clojure.core/var-set"
                 "clojure.core/slurp"
                 "clojure.core/bound-fn"
                 "clojure.core/special-symbol?"
                 "clojure.core/push-thread-bindings"
                 "clojure.core/*unchecked-math*"
                 "clojure.core/aset-short"
                 "clojure.java.io/make-reader"
                 "clojure.core/ns-resolve"
                 "clojure.core/locking"
                 "clojure.core.protocols/coll-reduce"
                 "clojure.core/char-array"
                 "clojure.stacktrace/root-cause"
                 "clojure.core/ratio?"
                 "clojure.core/rational?"
                 "clojure.java.io/as-url"
                 "clojure.core/future"
                 "clojure.core/aset-byte"
                 "clojure.core/send-off"
                 "clojure.test/are"
                 "clojure.java.io/IOFactory"
                 "clojure.reflect/Method"
                 "clojure.core/float-array"
                 "clojure.core/thread-bound?"
                 "clojure.core/with-precision"
                 "clojure.core/proxy"
                 "clojure.core/macroexpand"
                 "clojure.core/aset-char"
                 "clojure.java.io/output-stream"
                 "clojure.test/inc-report-counter"
                 "clojure.java.io/delete-file"
                 "clojure.core/compile"
                 "clojure.repl/stack-element-str"
                 "clojure.core/->VecSeq"
                 "clojure.core/resolve"
                 "clojure.core/->VecNode"
                 "clojure.core/xml-seq"
                 "clojure.test/with-test-out"
                 "clojure.core/lazy-cat"
                 "clojure.core/file-seq"
                 "clojure.core/ns-interns"
                 "clojure.core/short-array"
                 "clojure.core/future-done?"
                 "clojure.core.reducers/->Cat"
                 "clojure.core/get-thread-bindings"
                 "clojure.core/var"
                 "clojure.stacktrace/e"
                 "clojure.pprint/cl-format"
                 "clojure.core/ns-unmap"
                 "clojure.core/struct"
                 "clojure.repl/set-break-handler!"
                 "clojure.core/&"
                 "clojure.instant/read-instant-date"
                 "clojure.java.javadoc/add-remote-javadoc"
                 "clojure.reflect/map->Constructor"
                 "clojure.test.tap/print-tap-pass"
                 "clojure.main/root-cause"
                 "clojure.core/extenders"
                 "clojure.core/construct-proxy"
                 "clojure.core/intern"
                 "clojure.pprint/with-pprint-dispatch"
                 "clojure.core/error-mode"
                 "clojure.core/all-ns"
                 "clojure.walk/macroexpand-all"
                 "clojure.core/*ns*"
                 "clojure.core/char-escape-string"
                 "clojure.repl/demunge"
                 "clojure.core/line-seq"
                 "clojure.core/enumeration-seq"
                 "clojure.core/bigdec"
                 "clojure.java.javadoc/add-local-javadoc"
                 "clojure.core/decimal?"
                 "clojure.core/definterface"
                 "clojure.core/pcalls"
                 "clojure.core/ns-unalias"
                 "clojure.core/error-handler"
                 "clojure.core/biginteger"
                 "clojure.pprint/get-pretty-writer"
                 "clojure.core/ref-max-history"
                 "clojure.reflect/TypeReference"
                 "clojure.test/function?"
                 "clojure.pprint/pprint"
                 "clojure.test/deftest"
                 "clojure.core/definline"
                 "clojure.core/namespace-munge"
                 "clojure.core/pop-thread-bindings"
                 "clojure.main/main"
                 "clojure.core/ns-imports"
                 "clojure.core/aset-long"
                 "clojure.core/dosync"
                 "clojure.core/*'"
                 "clojure.core/seque"
                 "clojure.test/try-expr"
                 "clojure.main/skip-whitespace"
                 "clojure.main/with-bindings"
                 "clojure.core/load-reader"
                 "clojure.core/await-for"
                 "clojure.test.tap/print-tap-plan"
                 "clojure.core/*command-line-args*"
                 "clojure.test/report"
                 "clojure.java.browse/browse-url"
                 "clojure.core/monitor-exit"
                 "clojure.core/re-matcher"
                 "clojure.java.io/as-relative-path"
                 "clojure.test/assert-any"
                 "clojure.core/gen-interface"
                 "clojure.core/with-redefs-fn"
                 "clojure.core/extends?"
                 "clojure.java.io/Coercions"
                 "clojure.core/set-error-mode!"
                 "clojure.core/*agent*"
                 "clojure.core/alias"
                 "clojure.core/ns-publics"
                 "clojure.core/bound?"
                 "clojure.instant/read-instant-calendar"
                 "clojure.java.io/writer"
                 "clojure.pprint/*print-pprint-dispatch*"
                 "clojure.core/with-open"
                 "clojure.core/set-error-handler!"
                 "clojure.repl/source"
                 "clojure.java.shell/sh"
                 "clojure.reflect/->JavaReflector"
                 "clojure.core/*compiler-options*"
                 "clojure.core/sequence"
                 "clojure.core/denominator"
                 "clojure.main/skip-if-eol"
                 "clojure.core/dec'"
                 "clojure.data/equality-partition"
                 "clojure.core/refer-clojure"
                 "clojure.main/with-read-known"
                 "clojure.java.io/reader"
                 "clojure.reflect/Reflector"
                 "clojure.main/repl-exception"
                 "clojure.test.tap/print-tap-fail"
                 "clojure.core/bigint"
                 "clojure.core/resultset-seq"
                 "clojure.test/get-possibly-unbound-var"
                 "clojure.core.protocols/internal-reduce"
                 "clojure.reflect/AsmReflector"
                 "clojure.core/boolean-array"
                 "clojure.core/add-classpath"
                 "clojure.core/*warn-on-reflection*"},
 :library-api {:symbols {"cljs.core/keys" {:ns "cljs.core",
                                           :name "keys",
                                           :signature ["[hash-map]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_keys",
                                           :source {:code "(defn keys\n  [hash-map]\n  (seq (map first hash-map)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [5562 5565],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5562-L5565"},
                                           :full-name "cljs.core/keys",
                                           :clj-symbol "clojure.core/keys",
                                           :docstring "Returns a sequence of the map's keys."},
                         "cljs.core/unchecked-negate" {:ns "cljs.core",
                                                       :name "unchecked-negate",
                                                       :signature ["[x]"],
                                                       :shadowed-sources ({:code "(defmacro unchecked-negate\n  ([x] `(- ~x)))",
                                                                           :filename "clojurescript/src/clj/cljs/core.clj",
                                                                           :lines [308
                                                                                   309],
                                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L308-L309"}),
                                                       :history [["+"
                                                                  "0.0-1798"]],
                                                       :type "function",
                                                       :full-name-encode "cljs.core_unchecked-negate",
                                                       :source {:code "(defn unchecked-negate [x]\n  (cljs.core/unchecked-negate x))",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [1476
                                                                        1477],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1476-L1477"},
                                                       :full-name "cljs.core/unchecked-negate",
                                                       :clj-symbol "clojure.core/unchecked-negate"},
                         "cljs.core/reset!" {:ns "cljs.core",
                                             :name "reset!",
                                             :signature ["[a new-value]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_reset_BANG_",
                                             :source {:code "(defn reset!\n  [a new-value]\n  (when-let [validate (.-validator a)]\n    (assert (validate new-value) \"Validator rejected reference state\"))\n  (let [old-value (.-state a)]\n    (set! (.-state a) new-value)\n    (-notify-watches a old-value new-value))\n  new-value)",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [6557
                                                              6566],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6557-L6566"},
                                             :full-name "cljs.core/reset!",
                                             :clj-symbol "clojure.core/reset!",
                                             :docstring "Sets the value of atom to newval without regard for the\ncurrent value. Returns newval."},
                         "cljs.core/ITransientCollection" {:ns "cljs.core",
                                                           :name "ITransientCollection",
                                                           :type "protocol",
                                                           :full-name-encode "cljs.core_ITransientCollection",
                                                           :source {:code "(defprotocol ITransientCollection\n  (-conj! [tcoll val])\n  (-persistent! [tcoll]))",
                                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                    :lines [295
                                                                            297],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L295-L297"},
                                                           :methods [{:name "-conj!",
                                                                      :signature ["[tcoll val]"],
                                                                      :docstring nil}
                                                                     {:name "-persistent!",
                                                                      :signature ["[tcoll]"],
                                                                      :docstring nil}],
                                                           :full-name "cljs.core/ITransientCollection",
                                                           :history [["+"
                                                                      "0.0-1211"]]},
                         "cljs.core/transient" {:full-name "cljs.core/transient",
                                                :ns "cljs.core",
                                                :name "transient",
                                                :type "function",
                                                :signature ["[coll]"],
                                                :source {:code "(defn transient [coll]\n  (-as-transient coll))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [2294
                                                                 2295],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2294-L2295"},
                                                :full-name-encode "cljs.core_transient",
                                                :clj-symbol "clojure.core/transient",
                                                :history [["+"
                                                           "0.0-1211"]]},
                         "cljs.core/Fn" {:ns "cljs.core",
                                         :name "Fn",
                                         :type "protocol",
                                         :full-name-encode "cljs.core_Fn",
                                         :source {:code "(defprotocol Fn\n  \"Marker protocol\")",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [150 151],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L150-L151"},
                                         :full-name "cljs.core/Fn",
                                         :docstring "Marker protocol",
                                         :history [["+" "0.0-1552"]]},
                         "clojure.data/EqualityPartition" {:ns "clojure.data",
                                                           :name "EqualityPartition",
                                                           :history [["+"
                                                                      "0.0-1503"]],
                                                           :type "protocol",
                                                           :full-name-encode "clojure.data_EqualityPartition",
                                                           :source {:code "(defprotocol EqualityPartition\n  \"Implementation detail. Subject to change.\"\n  (equality-partition [x] \"Implementation detail. Subject to change.\"))",
                                                                    :filename "clojurescript/src/cljs/clojure/data.cljs",
                                                                    :lines [75
                                                                            77],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/data.cljs#L75-L77"},
                                                           :methods [{:name "equality-partition",
                                                                      :signature ["[x]"],
                                                                      :docstring "Implementation detail. Subject to change."}],
                                                           :full-name "clojure.data/EqualityPartition",
                                                           :clj-symbol "clojure.data/EqualityPartition",
                                                           :docstring "Implementation detail. Subject to change."},
                         "cljs.core/ex-message" {:full-name "cljs.core/ex-message",
                                                 :ns "cljs.core",
                                                 :name "ex-message",
                                                 :docstring "Alpha - subject to change.\nReturns the message attached to the given Error / ExceptionInfo object.\nFor non-Errors returns nil.",
                                                 :type "function",
                                                 :signature ["[ex]"],
                                                 :source {:code "(defn ex-message\n  [ex]\n  (when (instance? js/Error ex)\n    (.-message ex)))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [7149
                                                                  7155],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L7149-L7155"},
                                                 :full-name-encode "cljs.core_ex-message",
                                                 :history [["+"
                                                            "0.0-1576"]]},
                         "clojure.set/select" {:ns "clojure.set",
                                               :name "select",
                                               :signature ["[pred xset]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.set_select",
                                               :source {:code "(defn select\n  [pred xset]\n    (reduce (fn [s k] (if (pred k) s (disj s k)))\n            xset xset))",
                                                        :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                        :lines [61 65],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/set.cljs#L61-L65"},
                                               :full-name "clojure.set/select",
                                               :clj-symbol "clojure.set/select",
                                               :docstring "Returns a set of the elements for which pred is true"},
                         "cljs.core/delay" {:full-name "cljs.core/delay",
                                            :ns "cljs.core",
                                            :name "delay",
                                            :type "macro",
                                            :signature ["[& body]"],
                                            :source {:code "(defmacro delay [& body]\n  \"Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls.\"\n  `(new cljs.core/Delay (atom {:done false, :value nil}) (fn [] ~@body)))",
                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                     :lines [858 863],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L858-L863"},
                                            :full-name-encode "cljs.core_delay",
                                            :clj-symbol "clojure.core/delay",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/float" {:ns "cljs.core",
                                            :name "float",
                                            :signature ["[x]"],
                                            :shadowed-sources ({:code "(defmacro float [x] x)",
                                                                :filename "clojurescript/src/clj/cljs/core.clj",
                                                                :lines [272
                                                                        272],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L272-L272"}),
                                            :history [["+" "0.0-1798"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_float",
                                            :source {:code "(defn float [x] x)",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [1420
                                                             1420],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1420-L1420"},
                                            :full-name "cljs.core/float",
                                            :clj-symbol "clojure.core/float"},
                         "cljs.core/bit-not" {:ns "cljs.core",
                                              :name "bit-not",
                                              :signature ["[x]"],
                                              :shadowed-sources ({:code "(defmacro bit-not [x]\n  (list 'js* \"(~ ~{})\" x))",
                                                                  :filename "clojurescript/src/clj/cljs/core.clj",
                                                                  :lines [397
                                                                          398],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L397-L398"}),
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_bit-not",
                                              :source {:code "(defn bit-not\n  [x] (cljs.core/bit-not x))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1592
                                                               1594],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1592-L1594"},
                                              :full-name "cljs.core/bit-not",
                                              :clj-symbol "clojure.core/bit-not",
                                              :docstring "Bitwise complement"},
                         "cljs.core/partition" {:ns "cljs.core",
                                                :name "partition",
                                                :signature ["[n coll]"
                                                            "[n step coll]"
                                                            "[n step pad coll]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_partition",
                                                :source {:code "(defn partition\n  ([n coll]\n     (partition n n coll))\n  ([n step coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (when (== n (count p))\n             (cons p (partition n step (drop step s))))))))\n  ([n step pad coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (if (== n (count p))\n             (cons p (partition n step pad (drop step s)))\n             (list (take n (concat p pad)))))))))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [2884
                                                                 2904],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2884-L2904"},
                                                :full-name "cljs.core/partition",
                                                :clj-symbol "clojure.core/partition",
                                                :docstring "Returns a lazy sequence of lists of n items each, at offsets step\napart. If step is not supplied, defaults to n, i.e. the partitions\ndo not overlap. If a pad collection is supplied, use its elements as\nnecessary to complete last partition upto n items. In case there are\nnot enough padding elements, return a partition with less than n items."},
                         "cljs.core/IEncodeJS" {:ns "cljs.core",
                                                :name "IEncodeJS",
                                                :type "protocol",
                                                :full-name-encode "cljs.core_IEncodeJS",
                                                :source {:code "(defprotocol IEncodeJS\n  (-clj->js [x] \"Recursively transforms clj values to JavaScript\")\n  (-key->js [x] \"Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)\"))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [6709
                                                                 6712],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6709-L6712"},
                                                :methods [{:name "-clj->js",
                                                           :signature ["[x]"],
                                                           :docstring "Recursively transforms clj values to JavaScript"}
                                                          {:name "-key->js",
                                                           :signature ["[x]"],
                                                           :docstring "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)"}],
                                                :full-name "cljs.core/IEncodeJS",
                                                :history [["+"
                                                           "0.0-1552"]]},
                         "cljs.core/parents" {:ns "cljs.core",
                                              :name "parents",
                                              :signature ["[tag]"
                                                          "[h tag]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_parents",
                                              :source {:code "(defn parents\n  ([tag] (parents @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:parents h) tag))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [6871
                                                               6877],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6871-L6877"},
                                              :full-name "cljs.core/parents",
                                              :clj-symbol "clojure.core/parents",
                                              :docstring "Returns the immediate parents of tag, either via a JavaScript type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
                         "cljs.core/aclone" {:ns "cljs.core",
                                             :name "aclone",
                                             :signature ["[array-like]"],
                                             :shadowed-sources ({:code "(defmacro aclone [a]\n  (list 'js* \"~{}.slice()\" a))",
                                                                 :filename "clojurescript/src/clj/cljs/core.clj",
                                                                 :lines [1175
                                                                         1176],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L1175-L1176"}),
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_aclone",
                                             :source {:code "(defn aclone\n  [array-like]\n  (.slice array-like))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [104 107],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L104-L107"},
                                             :full-name "cljs.core/aclone",
                                             :clj-symbol "clojure.core/aclone",
                                             :docstring "Returns a javascript array, cloned from the passed in array"},
                         "cljs.core/reset-meta!" {:ns "cljs.core",
                                                  :name "reset-meta!",
                                                  :signature ["[iref m]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_reset-meta_BANG_",
                                                  :source {:code "(defn reset-meta!\n  [iref m]\n  (set! (.-meta iref) m))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [6624
                                                                   6627],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6624-L6627"},
                                                  :full-name "cljs.core/reset-meta!",
                                                  :clj-symbol "clojure.core/reset-meta!",
                                                  :docstring "Atomically resets the metadata for an atom"},
                         "special/defrecord*" {:full-name "special/defrecord*",
                                               :ns "special",
                                               :name "defrecord*",
                                               :type "special form",
                                               :source {:code "(defmethod parse 'defrecord*\n  [_ env [_ tsym fields pmasks :as form] _]\n  (let [t (:name (resolve-var (dissoc env :locals) tsym))]\n    (swap! namespaces update-in [(-> env :ns :name) :defs tsym]\n           (fn [m]\n             (let [m (assoc (or m {}) :name t :type true)]\n               (merge m\n                 {:protocols (-> tsym meta :protocols)}\n                 (source-info tsym env)))))\n    {:env env :op :defrecord* :form form :t t :fields fields :pmasks pmasks}))",
                                                        :filename "clojurescript/src/clj/cljs/analyzer.clj",
                                                        :lines [739
                                                                748],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/analyzer.clj#L739-L748"},
                                               :full-name-encode "special_defrecord_STAR_",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/Box" {:full-name "cljs.core/Box",
                                          :ns "cljs.core",
                                          :name "Box",
                                          :type "type",
                                          :signature ["[val]"],
                                          :source {:code "(deftype Box [^:mutable val])",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [4079 4079],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L4079-L4079"},
                                          :full-name-encode "cljs.core_Box",
                                          :history [["+" "0.0-1424"]]},
                         "cljs.reader/dispatch-macros" {:full-name "cljs.reader/dispatch-macros",
                                                        :ns "cljs.reader",
                                                        :name "dispatch-macros",
                                                        :type "function",
                                                        :signature ["[s]"],
                                                        :source {:code "(defn dispatch-macros [s]\n  (cond\n   (identical? s \"{\") read-set\n   (identical? s \"<\") (throwing-reader \"Unreadable form\")\n   (identical? s \"\\\"\") read-regex\n   (identical? s\"!\") read-comment\n   (identical? s \"_\") read-discard\n   :else nil))",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [406
                                                                         413],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L406-L413"},
                                                        :full-name-encode "cljs.reader_dispatch-macros",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/ICollection" {:ns "cljs.core",
                                                  :name "ICollection",
                                                  :type "protocol",
                                                  :full-name-encode "cljs.core_ICollection",
                                                  :source {:code "(defprotocol ICollection\n  (-conj [coll o]))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [183
                                                                   184],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L183-L184"},
                                                  :methods [{:name "-conj",
                                                             :signature ["[coll o]"],
                                                             :docstring nil}],
                                                  :full-name "cljs.core/ICollection",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/every?" {:return-type boolean,
                                             :ns "cljs.core",
                                             :name "every?",
                                             :signature ["[pred coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_every_QMARK_",
                                             :source {:code "(defn ^boolean every?\n  [pred coll]\n  (cond\n   (nil? (seq coll)) true\n   (pred (first coll)) (recur pred (next coll))\n   :else false))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2388
                                                              2395],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2388-L2395"},
                                             :full-name "cljs.core/every?",
                                             :clj-symbol "clojure.core/every?",
                                             :docstring "Returns true if (pred x) is logical true for every x in coll, else\nfalse."},
                         "clojure.zip/node" {:ns "clojure.zip",
                                             :name "node",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_node",
                                             :source {:code "(defn node\n  [loc] (loc 0))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [60 62],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L60-L62"},
                                             :full-name "clojure.zip/node",
                                             :clj-symbol "clojure.zip/node",
                                             :docstring "Returns the node at loc"},
                         "cljs.core/IEmptyableCollection" {:ns "cljs.core",
                                                           :name "IEmptyableCollection",
                                                           :type "protocol",
                                                           :full-name-encode "cljs.core_IEmptyableCollection",
                                                           :source {:code "(defprotocol IEmptyableCollection\n  (-empty [coll]))",
                                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                    :lines [180
                                                                            181],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L180-L181"},
                                                           :methods [{:name "-empty",
                                                                      :signature ["[coll]"],
                                                                      :docstring nil}],
                                                           :full-name "cljs.core/IEmptyableCollection",
                                                           :history [["+"
                                                                      "0.0-927"]]},
                         "clojure.zip/right" {:ns "clojure.zip",
                                              :name "right",
                                              :signature ["[loc]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.zip_right",
                                              :source {:code "(defn right\n  [loc]\n    (let [[node {l :l  [r & rnext :as rs] :r :as path}] loc]\n      (when (and path rs)\n        (with-meta [r (assoc path :l (conj l node) :r rnext)] (meta loc)))))",
                                                       :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                       :lines [135
                                                               140],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L135-L140"},
                                              :full-name "clojure.zip/right",
                                              :clj-symbol "clojure.zip/right",
                                              :docstring "Returns the loc of the right sibling of the node at this loc, or nil"},
                         "cljs.core/int-array" {:full-name "cljs.core/int-array",
                                                :ns "cljs.core",
                                                :name "int-array",
                                                :type "function",
                                                :signature ["[size-or-seq]"
                                                            "[size init-val-or-seq]"],
                                                :source {:code "(defn int-array\n  ([size-or-seq]\n     (cond\n      (number? size-or-seq) (int-array size-or-seq nil)\n      (seq? size-or-seq) (into-array size-or-seq)\n      :else (throw (js/Error. \"int-array called with something other than size or ISeq\"))))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [2156
                                                                 2175],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2156-L2175"},
                                                :full-name-encode "cljs.core_int-array",
                                                :clj-symbol "clojure.core/int-array",
                                                :history [["+"
                                                           "0.0-1798"]]},
                         "cljs.core/==" {:return-type boolean,
                                         :ns "cljs.core",
                                         :name "==",
                                         :signature ["[x]"
                                                     "[x y]"
                                                     "[x y & more]"],
                                         :shadowed-sources ({:code "(defmacro ==\n  ([x] true)\n  ([x y] (bool-expr (list 'js* \"(~{} === ~{})\" x y)))\n  ([x y & more] `(and (== ~x ~y) (== ~y ~@more))))",
                                                             :filename "clojurescript/src/clj/cljs/core.clj",
                                                             :lines [364
                                                                     367],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L364-L367"}),
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core__EQ__EQ_",
                                         :source {:code "(defn ^boolean ==\n  ([x] true)\n  ([x y] (-equiv x y))\n  ([x y & more]\n   (if (== x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (== y (first more)))\n     false)))",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [1625 1636],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1625-L1636"},
                                         :full-name "cljs.core/==",
                                         :clj-symbol "clojure.core/==",
                                         :docstring "Returns non-nil if nums all have the equivalent\nvalue, otherwise false. Behavior on non nums is\nundefined."},
                         "cljs.core/dissoc!" {:full-name "cljs.core/dissoc!",
                                              :ns "cljs.core",
                                              :name "dissoc!",
                                              :type "function",
                                              :signature ["[tcoll key]"],
                                              :source {:code "(defn dissoc! [tcoll key]\n  (-dissoc! tcoll key))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2306
                                                               2307],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2306-L2307"},
                                              :full-name-encode "cljs.core_dissoc_BANG_",
                                              :clj-symbol "clojure.core/dissoc!",
                                              :history [["+"
                                                         "0.0-1211"]]},
                         "special/." {:full-name "special/.",
                                      :ns "special",
                                      :name ".",
                                      :type "special form",
                                      :source {:code "(defmethod parse '.\n  [_ env [_ target & [field & member+] :as form] _]\n  (disallowing-recur\n   (let [{:keys [dot-action target method field args]} (build-dot-form [target field member+])\n         enve        (assoc env :context :expr)\n         targetexpr  (analyze enve target)]\n     (case dot-action\n           ::access {:env env :op :dot :form form\n                     :target targetexpr\n                     :field field\n                     :children [targetexpr]\n                     :tag (-> form meta :tag)}\n           ::call   (let [argexprs (map #(analyze enve %) args)]\n                      {:env env :op :dot :form form\n                       :target targetexpr\n                       :method method\n                       :args argexprs\n                       :children (into [targetexpr] argexprs)\n                       :tag (-> form meta :tag)})))))",
                                               :filename "clojurescript/src/clj/cljs/analyzer.clj",
                                               :lines [806 824],
                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/analyzer.clj#L806-L824"},
                                      :full-name-encode "special__DOT_",
                                      :clj-symbol "clojure.core/.",
                                      :history [["+" "0.0-927"]]},
                         "clojure.reflect/meta" {:full-name "clojure.reflect/meta",
                                                 :ns "clojure.reflect",
                                                 :name "meta",
                                                 :docstring "Queries the reflection api with a fully qualified symbol, then calls\ncallback fn cb with the evaluated cljs map containing that symbol's\nmeta information.",
                                                 :type "function",
                                                 :signature ["[sym cb]"],
                                                 :source {:code "(defn meta\n  [sym cb]\n  (query-reflection (str \"var=\" (js/encodeURIComponent (str sym)))\n                    #(cb (evaluate-javascript %))))",
                                                          :filename "clojurescript/src/cljs/clojure/reflect.cljs",
                                                          :lines [24
                                                                  30],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/reflect.cljs#L24-L30"},
                                                 :full-name-encode "clojure.reflect_meta",
                                                 :history [["+"
                                                            "0.0-1503"]]},
                         "clojure.browser.net/*timeout*" {:full-name "clojure.browser.net/*timeout*",
                                                          :ns "clojure.browser.net",
                                                          :name "*timeout*",
                                                          :type "var",
                                                          :source {:code "(def *timeout* 10000)",
                                                                   :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                   :lines [21
                                                                           21],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/net.cljs#L21-L21"},
                                                          :full-name-encode "clojure.browser.net__STAR_timeout_STAR_",
                                                          :history [["+"
                                                                     "0.0-927"]]},
                         "cljs.core/remove-method" {:ns "cljs.core",
                                                    :name "remove-method",
                                                    :signature ["[multifn dispatch-val]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_remove-method",
                                                    :source {:code "(defn remove-method\n [multifn dispatch-val]\n (-remove-method multifn dispatch-val))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [7085
                                                                     7088],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L7085-L7088"},
                                                    :full-name "cljs.core/remove-method",
                                                    :clj-symbol "clojure.core/remove-method",
                                                    :docstring "Removes the method of multimethod associated with dispatch-value."},
                         "cljs.core/array-chunk" {:full-name "cljs.core/array-chunk",
                                                  :ns "cljs.core",
                                                  :name "array-chunk",
                                                  :type "function",
                                                  :signature ["[arr]"
                                                              "[arr off]"
                                                              "[arr off end]"],
                                                  :source {:code "(defn array-chunk\n  ([arr]\n     (ArrayChunk. arr 0 (alength arr)))\n  ([arr off]\n     (ArrayChunk. arr off (alength arr)))\n  ([arr off end]\n     (ArrayChunk. arr off end)))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [2055
                                                                   2061],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2055-L2061"},
                                                  :full-name-encode "cljs.core_array-chunk",
                                                  :history [["+"
                                                             "0.0-1424"]]},
                         "clojure.core.reducers/drop" {:ns "clojure.core.reducers",
                                                       :name "drop",
                                                       :signature ["[n]"
                                                                   "[n coll]"],
                                                       :history [["+"
                                                                  "0.0-1236"]],
                                                       :type "function",
                                                       :full-name-encode "clojure.core.reducers_drop",
                                                       :source {:code "(defcurried drop\n  \"Elides the first n values from the reduction of coll.\"\n  {}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (f1 ret k v)\n              ret)))))))",
                                                                :filename "clojurescript/src/cljs/clojure/core/reducers.cljs",
                                                                :lines [169
                                                                        181],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/core/reducers.cljs#L169-L181"},
                                                       :full-name "clojure.core.reducers/drop",
                                                       :clj-symbol "clojure.core.reducers/drop",
                                                       :docstring "Elides the first n values from the reduction of coll."},
                         "cljs.core/frequencies" {:ns "cljs.core",
                                                  :name "frequencies",
                                                  :signature ["[coll]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_frequencies",
                                                  :source {:code "(defn frequencies\n  [coll]\n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [6075
                                                                   6082],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6075-L6082"},
                                                  :full-name "cljs.core/frequencies",
                                                  :clj-symbol "clojure.core/frequencies",
                                                  :docstring "Returns a map from distinct items in coll to the number of times\nthey appear."},
                         "cljs.core/pop" {:ns "cljs.core",
                                          :name "pop",
                                          :signature ["[coll]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_pop",
                                          :source {:code "(defn pop\n  [coll]\n  (-pop coll))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [945 950],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L945-L950"},
                                          :full-name "cljs.core/pop",
                                          :clj-symbol "clojure.core/pop",
                                          :docstring "For a list or queue, returns a new list/queue without the first\nitem, for a vector, returns a new vector without the last item.\nNote - not the same as next/butlast."},
                         "cljs.core/not-every?" {:return-type boolean,
                                                 :ns "cljs.core",
                                                 :name "not-every?",
                                                 :signature ["[pred coll]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_not-every_QMARK_",
                                                 :source {:code "(defn ^boolean not-every?\n  [pred coll] (not (every? pred coll)))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2397
                                                                  2400],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2397-L2400"},
                                                 :full-name "cljs.core/not-every?",
                                                 :clj-symbol "clojure.core/not-every?",
                                                 :docstring "Returns false if (pred x) is logical true for every x in\ncoll, else true."},
                         "cljs.core/some-fn" {:ns "cljs.core",
                                              :name "some-fn",
                                              :signature ["[p]"
                                                          "[p1 p2]"
                                                          "[p1 p2 p3]"
                                                          "[p1 p2 p3 & ps]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_some-fn",
                                              :source {:code "(defn some-fn\n  ([p]\n     (fn sp1\n       ([] nil)\n       ([x] (p x))\n       ([x y] (or (p x) (p y)))\n       ([x y z] (or (p x) (p y) (p z)))\n       ([x y z & args] (or (sp1 x y z)\n                           (some p args)))))\n  ([p1 p2]\n     (fn sp2\n       ([] nil)\n       ([x] (or (p1 x) (p2 x)))\n       ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n       ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n       ([x y z & args] (or (sp2 x y z)\n                           (some #(or (p1 %) (p2 %)) args)))))\n  ([p1 p2 p3]\n     (fn sp3\n       ([] nil)\n       ([x] (or (p1 x) (p2 x) (p3 x)))\n       ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n       ([x y z] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z)))\n       ([x y z & args] (or (sp3 x y z)\n                           (some #(or (p1 %) (p2 %) (p3 %)) args)))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn spn\n         ([] nil)\n         ([x] (some #(% x) ps))\n         ([x y] (some #(or (% x) (% y)) ps))\n         ([x y z] (some #(or (% x) (% y) (% z)) ps))\n         ([x y z & args] (or (spn x y z)\n                             (some #(some % args) ps)))))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2609
                                                               2646],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2609-L2646"},
                                              :full-name "cljs.core/some-fn",
                                              :clj-symbol "clojure.core/some-fn",
                                              :docstring "Takes a set of predicates and returns a function f that returns the first logical true value\nreturned by one of its composing predicates against any of its arguments, else it returns\nlogical false. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical true result against the original predicates."},
                         "clojure.browser.event/remove-all" {:full-name "clojure.browser.event/remove-all",
                                                             :ns "clojure.browser.event",
                                                             :name "remove-all",
                                                             :type "function",
                                                             :signature ["[opt_obj opt_type opt_capt]"],
                                                             :source {:code "(defn remove-all [opt_obj opt_type opt_capt])",
                                                                      :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                      :lines [98
                                                                              98],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/event.cljs#L98-L98"},
                                                             :full-name-encode "clojure.browser.event_remove-all",
                                                             :history [["+"
                                                                        "0.0-927"]]},
                         "cljs.core/doto" {:ns "cljs.core",
                                           :name "doto",
                                           :signature ["[x & forms]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_doto",
                                           :source {:code "(defmacro doto\n  [x & forms]\n    (let [gx (gensym)]\n      `(let [~gx ~x]\n         ~@(map (fn [f]\n                  (if (seq? f)\n                    `(~(first f) ~gx ~@(next f))\n                    `(~f ~gx)))\n                forms)\n         ~gx)))",
                                                    :filename "clojure/src/clj/clojure/core.clj",
                                                    :lines [3463 3478],
                                                    :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L3463-L3478"},
                                           :full-name "cljs.core/doto",
                                           :clj-symbol "clojure.core/doto",
                                           :docstring "Evaluates x then calls all of the methods and functions with the\nvalue of x supplied at the front of the given arguments.  The forms\nare evaluated in order.  Returns x.\n\n(doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))"},
                         "cljs.core/take-while" {:ns "cljs.core",
                                                 :name "take-while",
                                                 :signature ["[pred coll]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_take-while",
                                                 :source {:code "(defn take-while\n  [pred coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (when (pred (first s))\n       (cons (first s) (take-while pred (rest s)))))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [5931
                                                                  5938],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5931-L5938"},
                                                 :full-name "cljs.core/take-while",
                                                 :clj-symbol "clojure.core/take-while",
                                                 :docstring "Returns a lazy sequence of successive items from coll while\n(pred item) returns true. pred must be free of side-effects."},
                         "cljs.reader/escape-char-map" {:full-name "cljs.reader/escape-char-map",
                                                        :ns "cljs.reader",
                                                        :name "escape-char-map",
                                                        :type "function",
                                                        :signature ["[c]"],
                                                        :source {:code "(defn escape-char-map [c]\n  (cond\n   (identical? c \\t) \"\\t\"\n   (identical? c \\r) \"\\r\"\n   (identical? c \\n) \"\\n\"\n   (identical? c \\\\) \\\\\n   (identical? c \\\") \\\"\n   (identical? c \\b) \"\\b\"\n   (identical? c \\f) \"\\f\"\n   :else nil))",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [160
                                                                         169],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L160-L169"},
                                                        :full-name-encode "cljs.reader_escape-char-map",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "clojure.browser.event/all-listeners" {:full-name "clojure.browser.event/all-listeners",
                                                                :ns "clojure.browser.event",
                                                                :name "all-listeners",
                                                                :type "function",
                                                                :signature ["[obj type capture]"],
                                                                :source {:code "(defn all-listeners [obj type capture])",
                                                                         :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                         :lines [90
                                                                                 90],
                                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/event.cljs#L90-L90"},
                                                                :full-name-encode "clojure.browser.event_all-listeners",
                                                                :history [["+"
                                                                           "0.0-927"]]},
                         "cljs.core/ITransientSet" {:ns "cljs.core",
                                                    :name "ITransientSet",
                                                    :type "protocol",
                                                    :full-name-encode "cljs.core_ITransientSet",
                                                    :source {:code "(defprotocol ITransientSet\n  (-disjoin! [tcoll v]))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [309
                                                                     310],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L309-L310"},
                                                    :methods [{:name "-disjoin!",
                                                               :signature ["[tcoll v]"],
                                                               :docstring nil}],
                                                    :full-name "cljs.core/ITransientSet",
                                                    :history [["+"
                                                               "0.0-1211"]]},
                         "cljs.core/vals" {:ns "cljs.core",
                                           :name "vals",
                                           :signature ["[hash-map]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_vals",
                                           :source {:code "(defn vals\n  [hash-map]\n  (seq (map second hash-map)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [5572 5575],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5572-L5575"},
                                           :full-name "cljs.core/vals",
                                           :clj-symbol "clojure.core/vals",
                                           :docstring "Returns a sequence of the map's values."},
                         "cljs.core/IDeref" {:ns "cljs.core",
                                             :name "IDeref",
                                             :type "protocol",
                                             :full-name-encode "cljs.core_IDeref",
                                             :source {:code "(defprotocol IDeref\n (-deref [o]))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [227 228],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L227-L228"},
                                             :methods [{:name "-deref",
                                                        :signature ["[o]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/IDeref",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/string-hash-cache" {:full-name "cljs.core/string-hash-cache",
                                                        :ns "cljs.core",
                                                        :name "string-hash-cache",
                                                        :type "var",
                                                        :source {:code "(def string-hash-cache (js-obj))",
                                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                 :lines [965
                                                                         965],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L965-L965"},
                                                        :full-name-encode "cljs.core_string-hash-cache",
                                                        :history [["+"
                                                                   "0.0-1424"]]},
                         "cljs.core/array-map" {:ns "cljs.core",
                                                :name "array-map",
                                                :signature ["[& keyvals]"],
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_array-map",
                                                :source {:code "(defn array-map\n  [& keyvals]\n  (PersistentArrayMap. nil (quot (count keyvals) 2) (apply array keyvals) nil))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [5524
                                                                 5528],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5524-L5528"},
                                                :full-name "cljs.core/array-map",
                                                :clj-symbol "clojure.core/array-map",
                                                :docstring "keyval => key val\nReturns a new array map with supplied mappings."},
                         "clojure.browser.dom/log-obj" {:full-name "clojure.browser.dom/log-obj",
                                                        :ns "clojure.browser.dom",
                                                        :name "log-obj",
                                                        :type "function",
                                                        :signature ["[obj]"],
                                                        :source {:code "(defn log-obj [obj]\n  (.log js/console obj))",
                                                                 :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                 :lines [23
                                                                         24],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/dom.cljs#L23-L24"},
                                                        :full-name-encode "clojure.browser.dom_log-obj",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/for" {:ns "cljs.core",
                                          :name "for",
                                          :signature ["[seq-exprs body-expr]"],
                                          :shadowed-sources ({:code "(defmacro for\n  [seq-exprs body-expr]\n  (assert-args\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [to-groups (fn [seq-exprs]\n                    (reduce1 (fn [groups [k v]]\n                              (if (keyword? k)\n                                (conj (pop groups) (conj (peek groups) [k v]))\n                                (conj groups [k v])))\n                            [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (IllegalArgumentException. ^String (apply str msg))))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (cond\n                                     (= k :let) `(let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(let [iterys# ~(emit-bind next-groups)\n                                             fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      (if next-groups\n                        #_\"not the inner-most loop\"\n                        `(fn ~giter [~gxs]\n                           (lazy-seq\n                             (loop [~gxs ~gxs]\n                               (when-first [~bind ~gxs]\n                                 ~(do-mod mod-pairs)))))\n                        #_\"inner-most loop\"\n                        (let [gi (gensym \"i__\")\n                              gb (gensym \"b__\")\n                              do-cmod (fn do-cmod [[[k v :as pair] & etc]]\n                                        (cond\n                                          (= k :let) `(let ~v ~(do-cmod etc))\n                                          (= k :while) `(when ~v ~(do-cmod etc))\n                                          (= k :when) `(if ~v\n                                                         ~(do-cmod etc)\n                                                         (recur\n                                                           (unchecked-inc ~gi)))\n                                          (keyword? k)\n                                            (err \"Invalid 'for' keyword \" k)\n                                          :else\n                                            `(do (chunk-append ~gb ~body-expr)\n                                                 (recur (unchecked-inc ~gi)))))]\n                          `(fn ~giter [~gxs]\n                             (lazy-seq\n                               (loop [~gxs ~gxs]\n                                 (when-let [~gxs (seq ~gxs)]\n                                   (if (chunked-seq? ~gxs)\n                                     (let [c# (chunk-first ~gxs)\n                                           size# (int (count c#))\n                                           ~gb (chunk-buffer size#)]\n                                       (if (loop [~gi (int 0)]\n                                             (if (< ~gi size#)\n                                               (let [~bind (.nth c# ~gi)]\n                                                 ~(do-cmod mod-pairs))\n                                               true))\n                                         (chunk-cons\n                                           (chunk ~gb)\n                                           (~giter (chunk-rest ~gxs)))\n                                         (chunk-cons (chunk ~gb) nil)))\n                                     (let [~bind (first ~gxs)]\n                                       ~(do-mod mod-pairs)))))))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n        (iter# ~(second seq-exprs)))))",
                                                              :filename "clojure/src/clj/clojure/core.clj",
                                                              :lines [4178
                                                                      4263],
                                                              :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L4178-L4263"}),
                                          :history [["+" "0.0-927"]],
                                          :type "macro",
                                          :full-name-encode "cljs.core_for",
                                          :source {:code "(defmacro for\n  [seq-exprs body-expr]\n  (assert-args for\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [to-groups (fn [seq-exprs]\n                    (reduce (fn [groups [k v]]\n                              (if (keyword? k)\n                                (conj (pop groups) (conj (peek groups) [k v]))\n                                (conj groups [k v])))\n                            [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (ex-info (apply core/str msg) {})))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (cond\n                                     (= k :let) `(let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(let [iterys# ~(emit-bind next-groups)\n                                             fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      (if next-groups\n                        #_ \"not the inner-most loop\"\n                        `(fn ~giter [~gxs]\n                           (lazy-seq\n                            (loop [~gxs ~gxs]\n                              (when-first [~bind ~gxs]\n                                ~(do-mod mod-pairs)))))\n                        #_\"inner-most loop\"\n                        (let [gi (gensym \"i__\")\n                              gb (gensym \"b__\")\n                              do-cmod (fn do-cmod [[[k v :as pair] & etc]]\n                                        (cond\n                                          (= k :let) `(let ~v ~(do-cmod etc))\n                                          (= k :while) `(when ~v ~(do-cmod etc))\n                                          (= k :when) `(if ~v\n                                                         ~(do-cmod etc)\n                                                         (recur\n                                                           (unchecked-inc ~gi)))\n                                          (keyword? k)\n                                            (err \"Invalid 'for' keyword \" k)\n                                          :else\n                                            `(do (chunk-append ~gb ~body-expr)\n                                                 (recur (unchecked-inc ~gi)))))]\n                          `(fn ~giter [~gxs]\n                             (lazy-seq\n                               (loop [~gxs ~gxs]\n                                 (when-let [~gxs (seq ~gxs)]\n                                   (if (chunked-seq? ~gxs)\n                                     (let [c# ^not-native (chunk-first ~gxs)\n                                           size# (count c#)\n                                           ~gb (chunk-buffer size#)]\n                                       (if (coercive-boolean\n                                            (loop [~gi 0]\n                                              (if (< ~gi size#)\n                                                (let [~bind (-nth c# ~gi)]\n                                                  ~(do-cmod mod-pairs))\n                                                true)))\n                                         (chunk-cons\n                                           (chunk ~gb)\n                                           (~giter (chunk-rest ~gxs)))\n                                         (chunk-cons (chunk ~gb) nil)))\n                                     (let [~bind (first ~gxs)]\n                                       ~(do-mod mod-pairs)))))))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n       (iter# ~(second seq-exprs)))))",
                                                   :filename "clojurescript/src/clj/cljs/core.clj",
                                                   :lines [1007 1092],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L1007-L1092"},
                                          :full-name "cljs.core/for",
                                          :clj-symbol "clojure.core/for",
                                          :docstring "List comprehension. Takes a vector of one or more\n binding-form/collection-expr pairs, each followed by zero or more\n modifiers, and yields a lazy sequence of evaluations of expr.\n Collections are iterated in a nested fashion, rightmost fastest,\n and nested coll-exprs can refer to bindings created in prior\n binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n :while test, :when test.\n\n(take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))"},
                         "cljs.core/unchecked-multiply-int" {:ns "cljs.core",
                                                             :name "unchecked-multiply-int",
                                                             :signature ["[]"
                                                                         "[x]"
                                                                         "[x y]"
                                                                         "[x y & more]"],
                                                             :shadowed-sources ({:code "(defmacro unchecked-multiply-int\n  ([& xs] `(* ~@xs)))",
                                                                                 :filename "clojurescript/src/clj/cljs/core.clj",
                                                                                 :lines [305
                                                                                         306],
                                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L305-L306"}),
                                                             :history [["+"
                                                                        "0.0-1798"]],
                                                             :type "function",
                                                             :full-name-encode "cljs.core_unchecked-multiply-int",
                                                             :source {:code "(defn unchecked-multiply-int\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-multiply-int x y))\n  ([x y & more] (reduce unchecked-multiply-int (cljs.core/unchecked-multiply-int x y) more)))",
                                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                      :lines [1469
                                                                              1474],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1469-L1474"},
                                                             :full-name "cljs.core/unchecked-multiply-int",
                                                             :clj-symbol "clojure.core/unchecked-multiply-int",
                                                             :docstring "Returns the product of nums. (*) returns 1."},
                         "cljs.core/cond->" {:ns "cljs.core",
                                             :name "cond->",
                                             :signature ["[expr & clauses]"],
                                             :history [["+"
                                                        "0.0-1798"]],
                                             :type "macro",
                                             :full-name-encode "cljs.core_cond-_GT_",
                                             :source {:code "(defmacro cond->\n  [expr & clauses]\n  (assert (even? (count clauses)))\n  (let [g (gensym)\n        pstep (fn [[test step]] `(if ~test (-> ~g ~step) ~g))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep (partition 2 clauses)))]\n       ~g)))",
                                                      :filename "clojure/src/clj/clojure/core.clj",
                                                      :lines [6775
                                                              6787],
                                                      :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L6775-L6787"},
                                             :full-name "cljs.core/cond->",
                                             :clj-symbol "clojure.core/cond->",
                                             :docstring "Takes an expression and a set of test/form pairs. Threads expr (via ->)\nthrough each form for which the corresponding test\nexpression is true. Note that, unlike cond branching, cond-> threading does\nnot short circuit after the first true test expression."},
                         "cljs.core/instance?" {:return-type boolean,
                                                :ns "cljs.core",
                                                :name "instance?",
                                                :signature ["[t o]"],
                                                :shadowed-sources ({:code "(defmacro instance? [t o]\n  (bool-expr (list 'js* \"(~{} instanceof ~{})\" o t)))",
                                                                    :filename "clojurescript/src/clj/cljs/core.clj",
                                                                    :lines [245
                                                                            246],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L245-L246"}),
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_instance_QMARK_",
                                                :source {:code "(defn ^boolean instance? [t o]\n  (cljs.core/instance? t o))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [447
                                                                 448],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L447-L448"},
                                                :full-name "cljs.core/instance?",
                                                :clj-symbol "clojure.core/instance?"},
                         "cljs.core/rseq" {:full-name "cljs.core/rseq",
                                           :ns "cljs.core",
                                           :name "rseq",
                                           :type "function",
                                           :signature ["[coll]"],
                                           :source {:code "(defn rseq [coll]\n  (-rseq coll))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1864 1865],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1864-L1865"},
                                           :full-name-encode "cljs.core_rseq",
                                           :clj-symbol "clojure.core/rseq",
                                           :history [["+" "0.0-1211"]]},
                         "cljs.reader/read-comment" {:full-name "cljs.reader/read-comment",
                                                     :ns "cljs.reader",
                                                     :name "read-comment",
                                                     :type "var",
                                                     :source {:code "(def read-comment skip-line)",
                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                              :lines [276
                                                                      276],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L276-L276"},
                                                     :full-name-encode "cljs.reader_read-comment",
                                                     :history [["+"
                                                                "0.0-927"]]},
                         "cljs.core/ITransientMap" {:ns "cljs.core",
                                                    :name "ITransientMap",
                                                    :type "protocol",
                                                    :full-name-encode "cljs.core_ITransientMap",
                                                    :source {:code "(defprotocol ITransientMap\n  (-dissoc! [tcoll key]))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [302
                                                                     303],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L302-L303"},
                                                    :methods [{:name "-dissoc!",
                                                               :signature ["[tcoll key]"],
                                                               :docstring nil}],
                                                    :full-name "cljs.core/ITransientMap",
                                                    :history [["+"
                                                               "0.0-1211"]]},
                         "cljs.reader/read-number" {:full-name "cljs.reader/read-number",
                                                    :ns "cljs.reader",
                                                    :name "read-number",
                                                    :type "function",
                                                    :signature ["[reader initch]"],
                                                    :source {:code "(defn read-number\n  [reader initch]\n  (loop [buffer (gstring/StringBuffer. initch)\n         ch (read-char reader)]\n    (if (or (nil? ch) (whitespace? ch) (macros ch))\n      (do\n        (unread reader ch)\n        (let [s (. buffer (toString))]\n          (or (match-number s)\n              (reader-error reader \"Invalid number format [\" s \"]\"))))\n      (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [289
                                                                     299],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L289-L299"},
                                                    :full-name-encode "cljs.reader_read-number",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "cljs.core/ILookup" {:ns "cljs.core",
                                              :name "ILookup",
                                              :type "protocol",
                                              :full-name-encode "cljs.core_ILookup",
                                              :source {:code "(defprotocol ILookup\n  (-lookup [o k] [o k not-found]))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [201
                                                               202],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L201-L202"},
                                              :methods [{:name "-lookup",
                                                         :signature ["[o k]"
                                                                     "[o k not-found]"],
                                                         :docstring nil}],
                                              :full-name "cljs.core/ILookup",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/when" {:ns "cljs.core",
                                           :name "when",
                                           :signature ["[test & body]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_when",
                                           :source {:code "(defmacro when\n  [test & body]\n  (list 'if test (cons 'do body)))",
                                                    :filename "clojure/src/clj/clojure/core.clj",
                                                    :lines [471 475],
                                                    :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L471-L475"},
                                           :full-name "cljs.core/when",
                                           :clj-symbol "clojure.core/when",
                                           :docstring "Evaluates test. If logical true, evaluates body in an implicit do."},
                         "cljs.core/ArrayNodeSeq" {:full-name "cljs.core/ArrayNodeSeq",
                                                   :ns "cljs.core",
                                                   :name "ArrayNodeSeq",
                                                   :type "type",
                                                   :signature ["[meta nodes i s __hash]"],
                                                   :source {:code "(deftype ArrayNodeSeq [meta nodes i s ^:mutable __hash]\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll meta] (ArrayNodeSeq. meta nodes i s __hash))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  ISeq\n  (-first [coll] (first s))\n  (-rest  [coll] (create-array-node-seq nil nodes i (next s)))\n\n  ISeqable\n  (-seq [this] this)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash)))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [4631
                                                                    4662],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L4631-L4662"},
                                                   :full-name-encode "cljs.core_ArrayNodeSeq",
                                                   :history [["+"
                                                              "0.0-1211"]]},
                         "cljs.core/list?" {:return-type boolean,
                                            :ns "cljs.core",
                                            :name "list?",
                                            :signature ["[x]"],
                                            :history [["+" "0.0-1211"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_list_QMARK_",
                                            :source {:code "(defn ^boolean list? [x]\n  (satisfies? IList x))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [1930
                                                             1931],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1930-L1931"},
                                            :full-name "cljs.core/list?",
                                            :clj-symbol "clojure.core/list?"},
                         "cljs.core/val" {:ns "cljs.core",
                                          :name "val",
                                          :signature ["[map-entry]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_val",
                                          :source {:code "(defn val\n  [map-entry]\n  (-val map-entry))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [5577 5580],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5577-L5580"},
                                          :full-name "cljs.core/val",
                                          :clj-symbol "clojure.core/val",
                                          :docstring "Returns the value in the map entry."},
                         "clojure.browser.dom/set-value" {:full-name "clojure.browser.dom/set-value",
                                                          :ns "clojure.browser.dom",
                                                          :name "set-value",
                                                          :docstring "Set the value property for an element.",
                                                          :type "function",
                                                          :signature ["[e v]"],
                                                          :source {:code "(defn set-value\n  [e v]\n  (set-properties e {\"value\" v}))",
                                                                   :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                   :lines [142
                                                                           145],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/dom.cljs#L142-L145"},
                                                          :full-name-encode "clojure.browser.dom_set-value",
                                                          :history [["+"
                                                                     "0.0-927"]]},
                         "cljs.core/BitmapIndexedNode" {:full-name "cljs.core/BitmapIndexedNode",
                                                        :ns "cljs.core",
                                                        :name "BitmapIndexedNode",
                                                        :type "type",
                                                        :signature ["[edit bitmap arr]"],
                                                        :source {:code "(deftype BitmapIndexedNode [edit ^:mutable bitmap ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (let [bit (bitpos hash shift)\n          idx (bitmap-indexed-node-index bitmap bit)]\n      (if (zero? (bit-and bitmap bit))\n        (let [n (bit-count bitmap)]\n          (if (>= n 16)\n            (let [nodes (make-array 32)\n                  jdx   (mask hash shift)]\n              (aset nodes jdx (.inode-assoc cljs.core.BitmapIndexedNode/EMPTY (+ shift 5) hash key val added-leaf?))\n              (loop [i 0 j 0]\n                (if (< i 32)\n                  (if (zero? (bit-and (bit-shift-right-zero-fill bitmap i) 1))\n                    (recur (inc i) j)\n                    (do (aset nodes i\n                              (if-not (nil? (aget arr j))\n                                (.inode-assoc cljs.core.BitmapIndexedNode/EMPTY\n                                              (+ shift 5) (cljs.core/hash (aget arr j)) (aget arr j) (aget arr (inc j)) added-leaf?)\n                                (aget arr (inc j))))\n                        (recur (inc i) (+ j 2))))))\n              (ArrayNode. nil (inc n) nodes))\n            (let [new-arr (make-array (* 2 (inc n)))]\n              (array-copy arr 0 new-arr 0 (* 2 idx))\n              (aset new-arr (* 2 idx) key)\n              (aset new-arr (inc (* 2 idx)) val)\n              (array-copy arr (* 2 idx) new-arr (* 2 (inc idx)) (* 2 (- n idx)))\n              (set! (.-val added-leaf?) true)\n              (BitmapIndexedNode. nil (bit-or bitmap bit) new-arr))))\n        (let [key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-assoc val-or-node (+ shift 5) hash key val added-leaf?)]\n                  (if (identical? n val-or-node)\n                    inode\n                    (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) n))))\n\n                (key-test key key-or-nil)\n                (if (identical? val val-or-node)\n                  inode\n                  (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) val)))\n\n                :else\n                (do (set! (.-val added-leaf?) true)\n                    (BitmapIndexedNode. nil bitmap\n                                        (clone-and-set arr (* 2 idx) nil (inc (* 2 idx))\n                                                       (create-node (+ shift 5) key-or-nil val-or-node hash key val)))))))))\n\n  (inode-without [inode shift hash key]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        inode\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-without val-or-node (+ shift 5) hash key)]\n                  (cond (identical? n val-or-node) inode\n                        (not (nil? n)) (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) n))\n                        (== bitmap bit) nil\n                        :else (BitmapIndexedNode. nil (bit-xor bitmap bit) (remove-pair arr idx))))\n                (key-test key key-or-nil)\n                (BitmapIndexedNode. nil (bit-xor bitmap bit) (remove-pair arr idx))\n                :else inode)))))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        not-found\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)  (.inode-lookup val-or-node (+ shift 5) hash key not-found)\n                (key-test key key-or-nil) val-or-node\n                :else not-found)))))\n\n  (inode-find [inode shift hash key not-found]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        not-found\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil) (.inode-find val-or-node (+ shift 5) hash key not-found)\n                (key-test key key-or-nil)          [key-or-nil val-or-node]\n                :else not-found)))))\n\n  (inode-seq [inode]\n    (create-inode-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (let [n       (bit-count bitmap)\n            new-arr (make-array (if (neg? n) 4 (* 2 (inc n))))]\n        (array-copy arr 0 new-arr 0 (* 2 n))\n        (BitmapIndexedNode. e bitmap new-arr))))\n\n  (edit-and-remove-pair [inode e bit i]\n    (if (== bitmap bit)\n      nil\n      (let [editable (.ensure-editable inode e)\n            earr     (.-arr editable)\n            len      (alength earr)]\n        (set! (.-bitmap editable) (bit-xor bit (.-bitmap editable)))\n        (array-copy earr (* 2 (inc i))\n                    earr (* 2 i)\n                    (- len (* 2 (inc i))))\n        (aset earr (- len 2) nil)\n        (aset earr (dec len) nil)\n        editable)))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (let [bit (bitpos hash shift)\n          idx (bitmap-indexed-node-index bitmap bit)]\n      (if (zero? (bit-and bitmap bit))\n        (let [n (bit-count bitmap)]\n          (cond\n            (< (* 2 n) (alength arr))\n            (let [editable (.ensure-editable inode edit)\n                  earr     (.-arr editable)]\n              (set! (.-val added-leaf?) true)\n              (array-copy-downward earr (* 2 idx)\n                                   earr (* 2 (inc idx))\n                                   (* 2 (- n idx)))\n              (aset earr (* 2 idx) key)\n              (aset earr (inc (* 2 idx)) val)\n              (set! (.-bitmap editable) (bit-or (.-bitmap editable) bit))\n              editable)\n\n            (>= n 16)\n            (let [nodes (make-array 32)\n                  jdx   (mask hash shift)]\n              (aset nodes jdx (.inode-assoc! cljs.core.BitmapIndexedNode/EMPTY edit (+ shift 5) hash key val added-leaf?))\n              (loop [i 0 j 0]\n                (if (< i 32)\n                  (if (zero? (bit-and (bit-shift-right-zero-fill bitmap i) 1))\n                    (recur (inc i) j)\n                    (do (aset nodes i\n                              (if-not (nil? (aget arr j))\n                                (.inode-assoc! cljs.core.BitmapIndexedNode/EMPTY\n                                               edit (+ shift 5) (cljs.core/hash (aget arr j)) (aget arr j) (aget arr (inc j)) added-leaf?)\n                                (aget arr (inc j))))\n                        (recur (inc i) (+ j 2))))))\n              (ArrayNode. edit (inc n) nodes))\n\n            :else\n            (let [new-arr (make-array (* 2 (+ n 4)))]\n              (array-copy arr 0 new-arr 0 (* 2 idx))\n              (aset new-arr (* 2 idx) key)\n              (aset new-arr (inc (* 2 idx)) val)\n              (array-copy arr (* 2 idx) new-arr (* 2 (inc idx)) (* 2 (- n idx)))\n              (set! (.-val added-leaf?) true)\n              (let [editable (.ensure-editable inode edit)]\n                (set! (.-arr editable) new-arr)\n                (set! (.-bitmap editable) (bit-or (.-bitmap editable) bit))\n                editable))))\n        (let [key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-assoc! val-or-node edit (+ shift 5) hash key val added-leaf?)]\n                  (if (identical? n val-or-node)\n                    inode\n                    (edit-and-set inode edit (inc (* 2 idx)) n)))\n\n                (key-test key key-or-nil)\n                (if (identical? val val-or-node)\n                  inode\n                  (edit-and-set inode edit (inc (* 2 idx)) val))\n\n                :else\n                (do (set! (.-val added-leaf?) true)\n                    (edit-and-set inode edit (* 2 idx) nil (inc (* 2 idx))\n                                  (create-node edit (+ shift 5) key-or-nil val-or-node hash key val))))))))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        inode\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-without! val-or-node edit (+ shift 5) hash key removed-leaf?)]\n                  (cond (identical? n val-or-node) inode\n                        (not (nil? n)) (edit-and-set inode edit (inc (* 2 idx)) n)\n                        (== bitmap bit) nil\n                        :else (.edit-and-remove-pair inode edit bit idx)))\n                (key-test key key-or-nil)\n                (do (aset removed-leaf? 0 true)\n                    (.edit-and-remove-pair inode edit bit idx))\n                :else inode)))))\n\n  (kv-reduce [inode f init]\n    (inode-kv-reduce arr f init)))",
                                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                 :lines [4141
                                                                         4335],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L4141-L4335"},
                                                        :full-name-encode "cljs.core_BitmapIndexedNode",
                                                        :history [["+"
                                                                   "0.0-1211"]]},
                         "cljs.reader/read-past" {:full-name "cljs.reader/read-past",
                                                  :ns "cljs.reader",
                                                  :name "read-past",
                                                  :docstring "Read until first character that doesn't match pred, returning\nchar.",
                                                  :type "function",
                                                  :signature ["[pred rdr]"],
                                                  :source {:code "(defn read-past\n  [pred rdr]\n  (loop [ch (read-char rdr)]\n    (if (pred ch)\n      (recur (read-char rdr))\n      ch)))",
                                                           :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                           :lines [224
                                                                   231],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L224-L231"},
                                                  :full-name-encode "cljs.reader_read-past",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/to-array" {:ns "cljs.core",
                                               :name "to-array",
                                               :signature ["[s]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_to-array",
                                               :source {:code "(defn to-array\n  [s]\n  (let [ary (array)]\n    (loop [s s]\n      (if (seq s)\n        (do (. ary push (first s))\n            (recur (next s)))\n        ary))))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [2135
                                                                2143],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2135-L2143"},
                                               :full-name "cljs.core/to-array",
                                               :clj-symbol "clojure.core/to-array",
                                               :docstring "Naive impl of to-array as a start."},
                         "cljs.core/interpose" {:ns "cljs.core",
                                                :name "interpose",
                                                :signature ["[sep coll]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_interpose",
                                                :source {:code "(defn interpose\n  [sep coll] (drop 1 (interleave (repeat sep) coll)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [2775
                                                                 2777],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2775-L2777"},
                                                :full-name "cljs.core/interpose",
                                                :clj-symbol "clojure.core/interpose",
                                                :docstring "Returns a lazy seq of the elements of coll separated by sep"},
                         "cljs.core/IMapEntry" {:ns "cljs.core",
                                                :name "IMapEntry",
                                                :type "protocol",
                                                :full-name-encode "cljs.core_IMapEntry",
                                                :source {:code "(defprotocol IMapEntry\n  (-key [coll])\n  (-val [coll]))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [213
                                                                 215],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L213-L215"},
                                                :methods [{:name "-key",
                                                           :signature ["[coll]"],
                                                           :docstring nil}
                                                          {:name "-val",
                                                           :signature ["[coll]"],
                                                           :docstring nil}],
                                                :full-name "cljs.core/IMapEntry",
                                                :history [["+"
                                                           "0.0-1211"]]},
                         "clojure.browser.net/ICrossPageChannel" {:ns "clojure.browser.net",
                                                                  :name "ICrossPageChannel",
                                                                  :type "protocol",
                                                                  :full-name-encode "clojure.browser.net_ICrossPageChannel",
                                                                  :source {:code "(defprotocol ICrossPageChannel\n  (register-service [this service-name fn] [this service-name fn encode-json?]))",
                                                                           :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                           :lines [88
                                                                                   89],
                                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/net.cljs#L88-L89"},
                                                                  :methods [{:name "register-service",
                                                                             :signature ["[this service-name fn]"
                                                                                         "[this service-name fn encode-json?]"],
                                                                             :docstring nil}],
                                                                  :full-name "clojure.browser.net/ICrossPageChannel",
                                                                  :history [["+"
                                                                             "0.0-927"]]},
                         "special/finally" {:ns "special",
                                            :name "finally",
                                            :signature ["[expr*]"],
                                            :history [["+" "0.0-927"]],
                                            :type "special form",
                                            :full-name-encode "special_finally",
                                            :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (seq? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                     :lines [963 991],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L963-L991"},
                                            :full-name "special/finally",
                                            :clj-symbol "clojure.core/finally",
                                            :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions."},
                         "cljs.core/Cons" {:full-name "cljs.core/Cons",
                                           :ns "cljs.core",
                                           :name "Cons",
                                           :type "type",
                                           :signature ["[meta first rest __hash]"],
                                           :source {:code "(deftype Cons [meta first rest ^:mutable __hash]\n  IList\n\n  IWithMeta\n  (-with-meta [coll meta] (Cons. meta first rest __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ASeq\n  ISeq\n  (-first [coll] first)\n  (-rest [coll] (if (nil? rest) () rest))\n\n  INext\n  (-next [coll] (if (nil? rest) nil (-seq rest)))\n\n  ICollection\n  (-conj [coll o] (Cons. nil o coll __hash))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1889 1920],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1889-L1920"},
                                           :full-name-encode "cljs.core_Cons",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/re-find" {:ns "cljs.core",
                                              :name "re-find",
                                              :signature ["[re s]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_re-find",
                                              :source {:code "(defn re-find\n  [re s]\n  (let [matches (.exec re s)]\n    (when-not (nil? matches)\n      (if (== (count matches) 1)\n        (first matches)\n        (vec matches)))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [6175
                                                               6185],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6175-L6185"},
                                              :full-name "cljs.core/re-find",
                                              :clj-symbol "clojure.core/re-find",
                                              :docstring "Returns the first regex match, if any, of s to re, using\nre.exec(s). Returns a vector, containing first the matching\nsubstring, then any capturing groups if the regular expression contains\ncapturing groups."},
                         "cljs.core/IMeta" {:ns "cljs.core",
                                            :name "IMeta",
                                            :type "protocol",
                                            :full-name-encode "cljs.core_IMeta",
                                            :source {:code "(defprotocol IMeta\n  (-meta [o]))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [233 234],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L233-L234"},
                                            :methods [{:name "-meta",
                                                       :signature ["[o]"],
                                                       :docstring nil}],
                                            :full-name "cljs.core/IMeta",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/assoc-in" {:ns "cljs.core",
                                               :name "assoc-in",
                                               :signature ["[m [k & ks] v]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_assoc-in",
                                               :source {:code "(defn assoc-in\n  [m [k & ks] v]\n  (if ks\n    (assoc m k (assoc-in (get m k) ks v))\n    (assoc m k v)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [2927
                                                                2934],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2927-L2934"},
                                               :full-name "cljs.core/assoc-in",
                                               :clj-symbol "clojure.core/assoc-in",
                                               :docstring "Associates a value in a nested associative structure, where ks is a\nsequence of keys and v is the new value and returns a new nested structure.\nIf any levels do not exist, hash-maps will be created."},
                         "special/letfn*" {:full-name "special/letfn*",
                                           :ns "special",
                                           :name "letfn*",
                                           :type "special form",
                                           :source {:code "(defmethod parse 'letfn*\n  [op env [_ bindings & exprs :as form] name]\n  (assert (and (vector? bindings) (even? (count bindings))) \"bindings must be vector of even number of elements\")\n  (let [n->fexpr (into {} (map (juxt first second) (partition 2 bindings)))\n        names    (keys n->fexpr)\n        context  (:context env)\n        [meth-env bes]\n        (reduce (fn [[{:keys [locals] :as env} bes] n]\n                  (let [be {:name   n\n                            :line (get-line n env)\n                            :column (get-col n env)\n                            :tag    (-> n meta :tag)\n                            :local  true\n                            :shadow (locals n)}]\n                    [(assoc-in env [:locals n] be)\n                     (conj bes be)]))\n                [env []] names)\n        meth-env (assoc meth-env :context :expr)\n        bes (vec (map (fn [{:keys [name shadow] :as be}]\n                        (let [env (assoc-in meth-env [:locals name] shadow)]\n                          (assoc be :init (analyze env (n->fexpr name)))))\n                      bes))\n        expr (analyze (assoc meth-env :context (if (= :expr context) :return context)) `(do ~@exprs))]\n    {:env env :op :letfn :bindings bes :expr expr :form form\n     :children (conj (vec (map :init bes)) expr)}))",
                                                    :filename "clojurescript/src/clj/cljs/analyzer.clj",
                                                    :lines [444 468],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/analyzer.clj#L444-L468"},
                                           :full-name-encode "special_letfn_STAR_",
                                           :history [["+" "0.0-1236"]]},
                         "clojure.string/join" {:ns "clojure.string",
                                                :name "join",
                                                :signature ["[coll]"
                                                            "[separator coll]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.string_join",
                                                :source {:code "(defn join\n  ([coll]\n     (apply str coll))\n  ([separator coll]\n     (apply str (interpose separator coll))))",
                                                         :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                         :lines [45
                                                                 51],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/string.cljs#L45-L51"},
                                                :full-name "clojure.string/join",
                                                :clj-symbol "clojure.string/join",
                                                :docstring "Returns a string of all elements in coll, as returned by (seq coll),\nseparated by an optional separator."},
                         "cljs.core/*unchecked-if*" {:full-name "cljs.core/*unchecked-if*",
                                                     :ns "cljs.core",
                                                     :name "*unchecked-if*",
                                                     :type "var",
                                                     :source {:code "(def *unchecked-if* false)",
                                                              :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                              :lines [16
                                                                      16],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L16-L16"},
                                                     :full-name-encode "cljs.core__STAR_unchecked-if_STAR_",
                                                     :history [["+"
                                                                "0.0-1211"]]},
                         "cljs.core/seqable?" {:return-type boolean,
                                               :ns "cljs.core",
                                               :name "seqable?",
                                               :signature ["[s]"],
                                               :history [["+"
                                                          "0.0-1211"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_seqable_QMARK_",
                                               :source {:code "(defn ^boolean seqable?\n  [s]\n  (satisfies? ISeqable s))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [1095
                                                                1098],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1095-L1098"},
                                               :full-name "cljs.core/seqable?",
                                               :docstring "Return true if s satisfies ISeqable"},
                         "clojure.zip/rights" {:ns "clojure.zip",
                                               :name "rights",
                                               :signature ["[loc]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.zip_rights",
                                               :source {:code "(defn rights\n  [loc]\n    (:r (loc 1)))",
                                                        :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                        :lines [92 95],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L92-L95"},
                                               :full-name "clojure.zip/rights",
                                               :clj-symbol "clojure.zip/rights",
                                               :docstring "Returns a seq of the right siblings of this loc"},
                         "cljs.core/split-at" {:ns "cljs.core",
                                               :name "split-at",
                                               :signature ["[n coll]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_split-at",
                                               :source {:code "(defn split-at\n  [n coll]\n  [(take n coll) (drop n coll)])",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [2735
                                                                2738],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2735-L2738"},
                                               :full-name "cljs.core/split-at",
                                               :clj-symbol "clojure.core/split-at",
                                               :docstring "Returns a vector of [(take n coll) (drop n coll)]"},
                         "clojure.zip/append-child" {:ns "clojure.zip",
                                                     :name "append-child",
                                                     :signature ["[loc item]"],
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "clojure.zip_append-child",
                                                     :source {:code "(defn append-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (concat (children loc) [item]))))",
                                                              :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                              :lines [200
                                                                      204],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L200-L204"},
                                                     :full-name "clojure.zip/append-child",
                                                     :clj-symbol "clojure.zip/append-child",
                                                     :docstring "Inserts the item as the rightmost child of the node at this loc,\nwithout moving"},
                         "cljs.core/binding" {:ns "cljs.core",
                                              :name "binding",
                                              :signature ["[bindings & body]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "macro",
                                              :full-name-encode "cljs.core_binding",
                                              :source {:code "(defmacro binding\n  [bindings & body]\n  (let [names (take-nth 2 bindings)\n        vals (take-nth 2 (drop 1 bindings))\n        tempnames (map (comp gensym name) names)\n        binds (map vector names vals)\n        resets (reverse (map vector names tempnames))]\n    (cljs.analyzer/confirm-bindings &env names)\n    `(let [~@(interleave tempnames names)]\n       (try\n        ~@(map\n           (fn [[k v]] (list 'set! k v))\n           binds)\n        ~@body\n        (finally\n         ~@(map\n            (fn [[k v]] (list 'set! k v))\n            resets))))))",
                                                       :filename "clojurescript/src/clj/cljs/core.clj",
                                                       :lines [865
                                                               889],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L865-L889"},
                                              :full-name "cljs.core/binding",
                                              :clj-symbol "clojure.core/binding",
                                              :docstring "binding => var-symbol init-expr\n\nCreates new bindings for the (already-existing) vars, with the\nsupplied initial values, executes the exprs in an implicit do, then\nre-establishes the bindings that existed before.  The new bindings\nare made in parallel (unlike let); all init-exprs are evaluated\nbefore the vars are bound to their new values."},
                         "cljs.core/Set" {:full-name "cljs.core/Set",
                                          :ns "cljs.core",
                                          :name "Set",
                                          :type "type",
                                          :signature ["[meta hash-map]"],
                                          :source {:code "(deftype Set [meta hash-map]\n  IWithMeta\n  (-with-meta [coll meta] (Set. meta hash-map))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (Set. meta (assoc hash-map o nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Set/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (= (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (count (seq coll)))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if (-contains-key? hash-map v)\n      v\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (Set. meta (dissoc hash-map v)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [2659 2706],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1011/src/cljs/cljs/core.cljs#L2659-L2706"},
                                          :full-name-encode "cljs.core_Set",
                                          :history [["+" "0.0-927"]
                                                    ["-" "0.0-1211"]],
                                          :removed {:in "0.0-1211",
                                                    :last-seen "0.0-1011"}},
                         "cljs.core/sorted-map" {:ns "cljs.core",
                                                 :name "sorted-map",
                                                 :signature ["[& keyvals]"],
                                                 :history [["+"
                                                            "0.0-1211"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_sorted-map",
                                                 :source {:code "(defn sorted-map\n  ([& keyvals]\n     (loop [in (seq keyvals) out cljs.core.PersistentTreeMap/EMPTY]\n       (if in\n         (recur (nnext in) (assoc out (first in) (second in)))\n         out))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [5543
                                                                  5550],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5543-L5550"},
                                                 :full-name "cljs.core/sorted-map",
                                                 :clj-symbol "clojure.core/sorted-map",
                                                 :docstring "keyval => key val\nReturns a new sorted map with supplied mappings."},
                         "cljs.reader/macro-terminating?" {:full-name "cljs.reader/macro-terminating?",
                                                           :ns "cljs.reader",
                                                           :name "macro-terminating?",
                                                           :type "function",
                                                           :signature ["[ch]"],
                                                           :return-type boolean,
                                                           :source {:code "(defn ^boolean macro-terminating? [ch]\n  (and (not (identical? ch \"#\"))\n       (not (identical? ch \\'))\n       (not (identical? ch \":\"))\n       (macros ch)))",
                                                                    :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                    :lines [74
                                                                            78],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L74-L78"},
                                                           :full-name-encode "cljs.reader_macro-terminating_QMARK_",
                                                           :history [["+"
                                                                      "0.0-927"]]},
                         "cljs.core/prefers" {:ns "cljs.core",
                                              :name "prefers",
                                              :signature ["[multifn]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_prefers",
                                              :source {:code "(defn prefers\n  [multifn] (-prefers multifn))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [7105
                                                               7107],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L7105-L7107"},
                                              :full-name "cljs.core/prefers",
                                              :clj-symbol "clojure.core/prefers",
                                              :docstring "Given a multimethod, returns a map of preferred value -> set of other values"},
                         "cljs.core/vary-meta" {:ns "cljs.core",
                                                :name "vary-meta",
                                                :signature ["[obj f & args]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_vary-meta",
                                                :source {:code "(defn vary-meta\n [obj f & args]\n (with-meta obj (apply f (meta obj) args)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [2371
                                                                 2375],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2371-L2375"},
                                                :full-name "cljs.core/vary-meta",
                                                :clj-symbol "clojure.core/vary-meta",
                                                :docstring "Returns an object of the same type and value as obj, with\n(apply f (meta obj) args) as its metadata."},
                         "cljs.core/unchecked-add" {:ns "cljs.core",
                                                    :name "unchecked-add",
                                                    :signature ["[]"
                                                                "[x]"
                                                                "[x y]"
                                                                "[x y & more]"],
                                                    :shadowed-sources ({:code "(defmacro unchecked-add\n  ([& xs] `(+ ~@xs)))",
                                                                        :filename "clojurescript/src/clj/cljs/core.clj",
                                                                        :lines [281
                                                                                282],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L281-L282"}),
                                                    :history [["+"
                                                               "0.0-1798"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_unchecked-add",
                                                    :source {:code "(defn unchecked-add\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-add x y))\n  ([x y & more] (reduce unchecked-add (cljs.core/unchecked-add x y) more)))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [1429
                                                                     1434],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1429-L1434"},
                                                    :full-name "cljs.core/unchecked-add",
                                                    :clj-symbol "clojure.core/unchecked-add",
                                                    :docstring "Returns the sum of nums. (+) returns 0."},
                         "cljs.core/when-let" {:ns "cljs.core",
                                               :name "when-let",
                                               :signature ["[bindings & body]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "macro",
                                               :full-name-encode "cljs.core_when-let",
                                               :source {:code "(defmacro when-let\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n    `(let [temp# ~tst]\n       (when temp#\n         (let [~form temp#]\n           ~@body)))))",
                                                        :filename "clojure/src/clj/clojure/core.clj",
                                                        :lines [1704
                                                                1717],
                                                        :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L1704-L1717"},
                                               :full-name "cljs.core/when-let",
                                               :clj-symbol "clojure.core/when-let",
                                               :docstring "bindings => binding-form test\n\nWhen test is true, evaluates body with binding-form bound to the value of test"},
                         "clojure.core.reducers/folder" {:ns "clojure.core.reducers",
                                                         :name "folder",
                                                         :signature ["[coll xf]"],
                                                         :history [["+"
                                                                    "0.0-1236"]],
                                                         :type "function",
                                                         :full-name-encode "clojure.core.reducers_folder",
                                                         :source {:code "(defn folder\n  ([coll xf]\n     (reify\n       cljs.core/IReduce\n       (-reduce [_ f1]\n         (-reduce coll (xf f1) (f1)))\n       (-reduce [_ f1 init]\n         (-reduce coll (xf f1) init))\n\n       #_\n       CollFold\n       #_\n       (coll-fold [_ n combinef reducef]\n         (coll-fold coll n combinef (xf reducef))))))",
                                                                  :filename "clojurescript/src/cljs/clojure/core/reducers.cljs",
                                                                  :lines [68
                                                                          85],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/core/reducers.cljs#L68-L85"},
                                                         :full-name "clojure.core.reducers/folder",
                                                         :clj-symbol "clojure.core.reducers/folder",
                                                         :docstring "Given a foldable collection, and a transformation function xf,\nreturns a foldable collection, where any supplied reducing\nfn will be transformed by xf. xf is a function of reducing fn to\nreducing fn."},
                         "cljs.core/ASeq" {:ns "cljs.core",
                                           :name "ASeq",
                                           :type "protocol",
                                           :full-name-encode "cljs.core_ASeq",
                                           :source {:code "(defprotocol ASeq)",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [192 192],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L192-L192"},
                                           :full-name "cljs.core/ASeq",
                                           :history [["+" "0.0-1211"]]},
                         "cljs.core/drop" {:ns "cljs.core",
                                           :name "drop",
                                           :signature ["[n coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_drop",
                                           :source {:code "(defn drop\n  [n coll]\n  (let [step (fn [n coll]\n               (let [s (seq coll)]\n                 (if (and (pos? n) s)\n                   (recur (dec n) (rest s))\n                   s)))]\n    (lazy-seq (step n coll))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2694 2702],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2694-L2702"},
                                           :full-name "cljs.core/drop",
                                           :clj-symbol "clojure.core/drop",
                                           :docstring "Returns a lazy sequence of all but the first n items in coll."},
                         "cljs.core/reduceable?" {:return-type boolean,
                                                  :ns "cljs.core",
                                                  :name "reduceable?",
                                                  :signature ["[x]"],
                                                  :history [["+"
                                                             "0.0-1211"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_reduceable_QMARK_",
                                                  :source {:code "(defn ^boolean reduceable?\n  [x] (satisfies? IReduce x))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [1020
                                                                   1022],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1020-L1022"},
                                                  :full-name "cljs.core/reduceable?",
                                                  :docstring "Returns true if coll satisfies IReduce"},
                         "cljs.core/while" {:ns "cljs.core",
                                            :name "while",
                                            :signature ["[test & body]"],
                                            :history [["+" "0.0-927"]],
                                            :type "macro",
                                            :full-name-encode "cljs.core_while",
                                            :source {:code "(defmacro while\n  [test & body]\n  `(loop []\n     (when ~test\n       ~@body\n       (recur))))",
                                                     :filename "clojure/src/clj/clojure/core.clj",
                                                     :lines [5713
                                                             5721],
                                                     :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L5713-L5721"},
                                            :full-name "cljs.core/while",
                                            :clj-symbol "clojure.core/while",
                                            :docstring "Repeatedly executes body while test expression is true. Presumes\nsome side-effect will cause test to become false/nil. Returns nil"},
                         "cljs.core/import-macros" {:full-name "cljs.core/import-macros",
                                                    :ns "cljs.core",
                                                    :name "import-macros",
                                                    :type "macro",
                                                    :signature ["[ns [& vars]]"],
                                                    :source {:code "(defmacro import-macros [ns [& vars]]\n  (core/let [ns (find-ns ns)\n             vars (map #(ns-resolve ns %) vars)\n             syms (map (core/fn [^clojure.lang.Var v] (core/-> v .sym (with-meta {:macro true}))) vars)\n             defs (map (core/fn [sym var]\n                                `(def ~sym (deref ~var))) syms vars)]\n            `(do ~@defs\n                 :imported)))",
                                                             :filename "clojurescript/src/clj/cljs/core.clj",
                                                             :lines [39
                                                                     46],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L39-L46"},
                                                    :full-name-encode "cljs.core_import-macros",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "cljs.core/string-print" {:full-name "cljs.core/string-print",
                                                   :ns "cljs.core",
                                                   :name "string-print",
                                                   :type "function",
                                                   :signature ["[x]"],
                                                   :source {:code "(defn string-print [x]\n  (*print-fn* x)\n  nil)",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [6217
                                                                    6219],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6217-L6219"},
                                                   :full-name-encode "cljs.core_string-print",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "cljs.core/-" {:ns "cljs.core",
                                        :name "-",
                                        :signature ["[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :shadowed-sources ({:code "(defmacro -\n  ([x] (list 'js* \"(- ~{})\" x))\n  ([x y] (list 'js* \"(~{} - ~{})\" x y))\n  ([x y & more] `(- (- ~x ~y) ~@more)))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [323
                                                                    326],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L323-L326"}),
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core_-",
                                        :source {:code "(defn -\n  ([x] (cljs.core/- x))\n  ([x y] (cljs.core/- x y))\n  ([x y & more] (reduce - (cljs.core/- x y) more)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [1322 1327],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1322-L1327"},
                                        :full-name "cljs.core/-",
                                        :clj-symbol "clojure.core/-",
                                        :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
                         "cljs.core/vector-seq" {:full-name "cljs.core/vector-seq",
                                                 :ns "cljs.core",
                                                 :name "vector-seq",
                                                 :type "function",
                                                 :signature ["[v offset]"],
                                                 :source {:code "(defn vector-seq [v offset]\n  (let [c (-count v)]\n    (when (pos? c)\n      (reify\n        IPrintable\n        (-pr-seq [vseq opts] (pr-sequential pr-seq \"(\" \" \" \")\" opts vseq))\n        ISequential\n        IEquiv\n        (-equiv [vseq other] (equiv-sequential vseq other))\n        ASeq\n        ISeq\n        (-first [_] (-nth v offset))\n        (-rest [_]\n          (let [offset (inc offset)]\n            (if (< offset c)\n              (vector-seq v offset)\n              ())))\n        ISeqable\n        (-seq [vseq] vseq)))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2522
                                                                  2540],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1236/src/cljs/cljs/core.cljs#L2522-L2540"},
                                                 :full-name-encode "cljs.core_vector-seq",
                                                 :history [["+"
                                                            "0.0-1211"]
                                                           ["-"
                                                            "0.0-1424"]],
                                                 :removed {:in "0.0-1424",
                                                           :last-seen "0.0-1236"}},
                         "clojure.zip/vector-zip" {:ns "clojure.zip",
                                                   :name "vector-zip",
                                                   :signature ["[root]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.zip_vector-zip",
                                                   :source {:code "(defn vector-zip\n  [root]\n    (zipper vector?\n            seq\n            (fn [node children] (with-meta (vec children) (meta node)))\n            root))",
                                                            :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                            :lines [42
                                                                    48],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L42-L48"},
                                                   :full-name "clojure.zip/vector-zip",
                                                   :clj-symbol "clojure.zip/vector-zip",
                                                   :docstring "Returns a zipper for nested vectors, given a root vector"},
                         "cljs.reader/read-2-chars" {:full-name "cljs.reader/read-2-chars",
                                                     :ns "cljs.reader",
                                                     :name "read-2-chars",
                                                     :type "function",
                                                     :signature ["[reader]"],
                                                     :source {:code "(defn read-2-chars [reader]\n  (.toString\n    (gstring/StringBuffer.\n      (read-char reader)\n      (read-char reader))))",
                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                              :lines [175
                                                                      179],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L175-L179"},
                                                     :full-name-encode "cljs.reader_read-2-chars",
                                                     :history [["+"
                                                                "0.0-1424"]]},
                         "cljs.core/chunk" {:full-name "cljs.core/chunk",
                                            :ns "cljs.core",
                                            :name "chunk",
                                            :type "function",
                                            :signature ["[b]"],
                                            :source {:code "(defn chunk [b]\n  (.chunk b))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2119
                                                             2120],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2119-L2120"},
                                            :full-name-encode "cljs.core_chunk",
                                            :history [["+" "0.0-1424"]]},
                         "cljs.core/conj!" {:full-name "cljs.core/conj!",
                                            :ns "cljs.core",
                                            :name "conj!",
                                            :type "function",
                                            :signature ["[tcoll val]"],
                                            :source {:code "(defn conj! [tcoll val]\n  (-conj! tcoll val))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2300
                                                             2301],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2300-L2301"},
                                            :full-name-encode "cljs.core_conj_BANG_",
                                            :clj-symbol "clojure.core/conj!",
                                            :history [["+" "0.0-1211"]]},
                         "cljs.core/js->clj" {:full-name "cljs.core/js->clj",
                                              :ns "cljs.core",
                                              :name "js->clj",
                                              :docstring "Recursively transforms JavaScript arrays into ClojureScript\nvectors, and JavaScript objects into ClojureScript maps.  With\noption ':keywordize-keys true' will convert object fields from\nstrings to keywords.",
                                              :type "function",
                                              :signature ["[x]"
                                                          "[x & opts]"],
                                              :source {:code "(defn js->clj\n  ([x] (js->clj x {:keywordize-keys false}))\n  ([x & opts]\n    (cond\n      (satisfies? x IEncodeClojure)\n      (-js->clj x (apply array-map opts))\n\n      (seq opts)\n      (let [{:keys [keywordize-keys]} opts\n            keyfn (if keywordize-keys keyword str)\n            f (fn thisfn [x]\n                (cond\n                  (seq? x)\n                  (doall (map thisfn x))\n\n                  (coll? x)\n                  (into (empty x) (map thisfn x))\n\n                  (array? x)\n                  (vec (map thisfn x))\n                   \n                  (identical? (type x) js/Object)\n                  (into {} (for [k (js-keys x)]\n                             [(keyfn k) (thisfn (aget x k))]))\n\n                  :else x))]\n        (f x)))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [6747
                                                               6777],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6747-L6777"},
                                              :full-name-encode "cljs.core_js-_GT_clj",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/List" {:full-name "cljs.core/List",
                                           :ns "cljs.core",
                                           :name "List",
                                           :type "type",
                                           :signature ["[meta first rest count __hash]"],
                                           :source {:code "(deftype List [meta first rest count ^:mutable __hash]\n  IList\n\n  IWithMeta\n  (-with-meta [coll meta] (List. meta first rest count __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ASeq\n  ISeq\n  (-first [coll] first)\n  (-rest [coll]\n    (if (== count 1)\n      ()\n      rest))\n\n  INext\n  (-next [coll]\n    (if (== count 1)\n      nil\n      rest))\n\n  IStack\n  (-peek [coll] first)\n  (-pop [coll] (-rest coll))\n\n  ICollection\n  (-conj [coll o] (List. meta o coll (inc count) nil))\n\n  IEmptyableCollection\n  (-empty [coll] cljs.core.List/EMPTY)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ICounted\n  (-count [coll] count))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1774 1818],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1774-L1818"},
                                           :full-name-encode "cljs.core_List",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/identical?" {:return-type boolean,
                                                 :ns "cljs.core",
                                                 :name "identical?",
                                                 :signature ["[x y]"],
                                                 :shadowed-sources ({:code "(defmacro identical? [a b]\n  (bool-expr (list 'js* \"(~{} === ~{})\" a b)))",
                                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                                     :lines [242
                                                                             243],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L242-L243"}),
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_identical_QMARK_",
                                                 :source {:code "(defn ^boolean identical?\n  [x y]\n  (cljs.core/identical? x y))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [49
                                                                  52],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L49-L52"},
                                                 :full-name "cljs.core/identical?",
                                                 :clj-symbol "clojure.core/identical?",
                                                 :docstring "Tests if 2 arguments are the same object"},
                         "cljs.core/*main-cli-fn*" {:full-name "cljs.core/*main-cli-fn*",
                                                    :ns "cljs.core",
                                                    :name "*main-cli-fn*",
                                                    :docstring "When compiled for a command-line target, whatever\nfunction *main-fn* is set to will be called with the command-line\nargv as arguments",
                                                    :type "var",
                                                    :source {:code "(def\n  ^{:doc \"When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments\"}\n  *main-cli-fn* nil)",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [81
                                                                     85],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L81-L85"},
                                                    :full-name-encode "cljs.core__STAR_main-cli-fn_STAR_",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "clojure.browser.dom/html->dom" {:full-name "clojure.browser.dom/html->dom",
                                                          :ns "clojure.browser.dom",
                                                          :name "html->dom",
                                                          :type "function",
                                                          :signature ["[s]"],
                                                          :source {:code "(defn html->dom [s]\n  (gdom/htmlToDocumentFragment s))",
                                                                   :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                   :lines [101
                                                                           102],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/dom.cljs#L101-L102"},
                                                          :full-name-encode "clojure.browser.dom_html-_GT_dom",
                                                          :history [["+"
                                                                     "0.0-927"]]},
                         "cljs.core/chunk-next" {:full-name "cljs.core/chunk-next",
                                                 :ns "cljs.core",
                                                 :name "chunk-next",
                                                 :type "function",
                                                 :signature ["[s]"],
                                                 :source {:code "(defn chunk-next [s]\n  (if (satisfies? IChunkedNext s false)\n    (-chunked-next s)\n    (seq (-chunked-rest s))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2128
                                                                  2131],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2128-L2131"},
                                                 :full-name-encode "cljs.core_chunk-next",
                                                 :history [["+"
                                                            "0.0-1424"]]},
                         "cljs.core/some" {:ns "cljs.core",
                                           :name "some",
                                           :signature ["[pred coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_some",
                                           :source {:code "(defn some\n  [pred coll]\n    (when (seq coll)\n      (or (pred (first coll)) (recur pred (next coll)))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2402 2409],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2402-L2409"},
                                           :full-name "cljs.core/some",
                                           :clj-symbol "clojure.core/some",
                                           :docstring "Returns the first logical true value of (pred x) for any x in coll,\nelse nil.  One common idiom is to use a set as pred, for example\nthis will return :fred if :fred is in the sequence, otherwise nil:\n(some #{:fred} coll)"},
                         "cljs.reader/make-unicode-char" {:full-name "cljs.reader/make-unicode-char",
                                                          :ns "cljs.reader",
                                                          :name "make-unicode-char",
                                                          :type "function",
                                                          :signature ["[code-str]"],
                                                          :source {:code "(defn make-unicode-char [code-str]\n    (let [code (js/parseInt code-str 16)]\n      (.fromCharCode js/String code)))",
                                                                   :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                   :lines [197
                                                                           199],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L197-L199"},
                                                          :full-name-encode "cljs.reader_make-unicode-char",
                                                          :history [["+"
                                                                     "0.0-1424"]]},
                         "clojure.core.reducers/Cat" {:full-name "clojure.core.reducers/Cat",
                                                      :ns "clojure.core.reducers",
                                                      :name "Cat",
                                                      :type "type",
                                                      :signature ["[cnt left right]"],
                                                      :source {:code "(deftype Cat [cnt left right]\n  cljs.core/ICounted\n  (-count [_] cnt)\n\n  cljs.core/ISeqable\n  (-seq [_] (concat (seq left) (seq right)))\n  \n  cljs.core/IReduce\n  (-reduce [this f1] (-reduce this f1 (f1)))\n  (-reduce\n    [_  f1 init]\n    (-reduce\n     right f1\n     (-reduce left f1 init)))\n\n  #_\n  CollFold\n  #_\n  (coll-fold\n    [this n combinef reducef]\n    (-reduce this reducef)))",
                                                               :filename "clojurescript/src/cljs/clojure/core/reducers.cljs",
                                                               :lines [184
                                                                       204],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/core/reducers.cljs#L184-L204"},
                                                      :full-name-encode "clojure.core.reducers_Cat",
                                                      :clj-symbol "clojure.core.reducers/Cat",
                                                      :history [["+"
                                                                 "0.0-1236"]]},
                         "cljs.core/write-all" {:full-name "cljs.core/write-all",
                                                :ns "cljs.core",
                                                :name "write-all",
                                                :type "function",
                                                :signature ["[writer & ss]"],
                                                :source {:code "(defn write-all [writer & ss]\n  (doseq [s ss]\n    (-write writer s)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [6213
                                                                 6215],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6213-L6215"},
                                                :full-name-encode "cljs.core_write-all",
                                                :history [["+"
                                                           "0.0-1503"]]},
                         "cljs.core/doall" {:ns "cljs.core",
                                            :name "doall",
                                            :signature ["[coll]"
                                                        "[n coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_doall",
                                            :source {:code "(defn doall\n  ([coll]\n   (dorun coll)\n   coll)\n  ([n coll]\n   (dorun n coll)\n   coll))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [6147
                                                             6159],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6147-L6159"},
                                            :full-name "cljs.core/doall",
                                            :clj-symbol "clojure.core/doall",
                                            :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. doall can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, retains the head and returns it, thus causing the entire\nseq to reside in memory at one time."},
                         "cljs.core/condp" {:ns "cljs.core",
                                            :name "condp",
                                            :signature ["[pred expr & clauses]"],
                                            :history [["+" "0.0-927"]],
                                            :type "macro",
                                            :full-name-encode "cljs.core_condp",
                                            :source {:code "(defmacro condp\n  [pred expr & clauses]\n  (let [gpred (gensym \"pred__\")\n        gexpr (gensym \"expr__\")\n        emit (fn emit [pred expr args]\n               (let [[[a b c :as clause] more]\n                       (split-at (if (= :>> (second args)) 3 2) args)\n                       n (count clause)]\n                 (cond\n                  (= 0 n) `(throw (js/Error. (core/str \"No matching clause: \" ~expr)))\n                  (= 1 n) a\n                  (= 2 n) `(if (~pred ~a ~expr)\n                             ~b\n                             ~(emit pred expr more))\n                  :else `(if-let [p# (~pred ~a ~expr)]\n                           (~c p#)\n                           ~(emit pred expr more)))))\n        gres (gensym \"res__\")]\n    `(let [~gpred ~pred\n           ~gexpr ~expr]\n       ~(emit gpred gexpr clauses))))",
                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                     :lines [891 931],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L891-L931"},
                                            :full-name "cljs.core/condp",
                                            :clj-symbol "clojure.core/condp",
                                            :docstring "Takes a binary predicate, an expression, and a set of clauses.\nEach clause can take the form of either:\n\ntest-expr result-expr\n\ntest-expr :>> result-fn\n\nNote :>> is an ordinary keyword.\n\nFor each clause, (pred test-expr expr) is evaluated. If it returns\nlogical true, the clause is a match. If a binary clause matches, the\nresult-expr is returned, if a ternary clause matches, its result-fn,\nwhich must be a unary function, is called with the result of the\npredicate as its argument, the result of that call being the return\nvalue of condp. A single default expression can follow the clauses,\nand its value will be returned if no clause matches. If no default\nexpression is provided and no clause matches, an\nIllegalArgumentException is thrown."},
                         "clojure.zip/down" {:ns "clojure.zip",
                                             :name "down",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_down",
                                             :source {:code "(defn down\n  [loc]\n    (when (branch? loc)\n      (let [[node path] loc\n            [c & cnext :as cs] (children loc)]\n        (when cs\n          (with-meta [c {:l [] \n                         :pnodes (if path (conj (:pnodes path) node) [node]) \n                         :ppath path \n                         :r cnext}] (meta loc))))))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [98 109],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L98-L109"},
                                             :full-name "clojure.zip/down",
                                             :clj-symbol "clojure.zip/down",
                                             :docstring "Returns the loc of the leftmost child of the node at this loc, or\nnil if no children"},
                         "cljs.core/IPending" {:ns "cljs.core",
                                               :name "IPending",
                                               :type "protocol",
                                               :full-name-encode "cljs.core_IPending",
                                               :source {:code "(defprotocol IPending\n  (-realized? [d]))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [284
                                                                285],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L284-L285"},
                                               :methods [{:name "-realized?",
                                                          :signature ["[d]"],
                                                          :docstring nil}],
                                               :full-name "cljs.core/IPending",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/count" {:ns "cljs.core",
                                            :name "count",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_count",
                                            :source {:code "(defn count\n  [coll]\n  (if (counted? coll)\n    (-count coll)\n    (accumulating-seq-count coll)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [785 791],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L785-L791"},
                                            :full-name "cljs.core/count",
                                            :clj-symbol "clojure.core/count",
                                            :docstring "Returns the number of items in the collection. (count nil) returns\n0.  Also works on strings, arrays, and Maps"},
                         "cljs.core/bit-test" {:ns "cljs.core",
                                               :name "bit-test",
                                               :signature ["[x n]"],
                                               :shadowed-sources ({:code "(defmacro bit-test [x n]\n  (list 'js* \"((~{} & (1 << ~{})) != 0)\" x n))",
                                                                   :filename "clojurescript/src/clj/cljs/core.clj",
                                                                   :lines [430
                                                                           431],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L430-L431"}),
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_bit-test",
                                               :source {:code "(defn bit-test\n  [x n]\n  (cljs.core/bit-test x n))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [1601
                                                                1604],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1601-L1604"},
                                               :full-name "cljs.core/bit-test",
                                               :clj-symbol "clojure.core/bit-test",
                                               :docstring "Test bit at index n"},
                         "cljs.core/fixture2" {:full-name "cljs.core/fixture2",
                                               :ns "cljs.core",
                                               :name "fixture2",
                                               :type "var",
                                               :source {:code "(def fixture2 2)",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [6677
                                                                6677],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6677-L6677"},
                                               :full-name-encode "cljs.core_fixture2",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/js-mod" {:ns "cljs.core",
                                             :name "js-mod",
                                             :signature ["[n d]"],
                                             :shadowed-sources ({:code "(defmacro js-mod [num div]\n  (list 'js* \"(~{} % ~{})\" num div))",
                                                                 :filename "clojurescript/src/clj/cljs/core.clj",
                                                                 :lines [394
                                                                         395],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L394-L395"}),
                                             :history [["+"
                                                        "0.0-1552"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_js-mod",
                                             :source {:code "(defn js-mod\n  [n d]\n  (cljs.core/js-mod n d))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1535
                                                              1538],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1535-L1538"},
                                             :full-name "cljs.core/js-mod",
                                             :docstring "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers"},
                         "cljs.core/loop" {:ns "cljs.core",
                                           :name "loop",
                                           :signature ["[bindings & body]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_loop",
                                           :source {:code "(defmacro loop\n  [bindings & body]\n    (assert-args\n      (vector? bindings) \"a vector for its binding\"\n      (even? (count bindings)) \"an even number of forms in binding vector\")\n    (let [db (destructure bindings)]\n      (if (= db bindings)\n        `(loop* ~bindings ~@body)\n        (let [vs (take-nth 2 (drop 1 bindings))\n              bs (take-nth 2 bindings)\n              gs (map (fn [b] (if (core/symbol? b) b (gensym))) bs)\n              bfs (reduce (fn [ret [b v g]]\n                            (if (core/symbol? b)\n                              (conj ret g v)\n                              (conj ret g v b g)))\n                          [] (map vector bs vs gs))]\n          `(let ~bfs\n             (loop* ~(vec (interleave gs gs))\n               (let ~(vec (interleave bs gs))\n                 ~@body)))))))",
                                                    :filename "clojurescript/src/clj/cljs/core.clj",
                                                    :lines [139 161],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L139-L161"},
                                           :full-name "cljs.core/loop",
                                           :clj-symbol "clojure.core/loop",
                                           :docstring "Evaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein. Acts as a recur target."},
                         "cljs.core/subvec" {:ns "cljs.core",
                                             :name "subvec",
                                             :signature ["[v start]"
                                                         "[v start end]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_subvec",
                                             :source {:code "(defn subvec\n  ([v start]\n     (subvec v start (count v)))\n  ([v start end]\n     (build-subvec nil v start end nil)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [3369
                                                              3378],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L3369-L3378"},
                                             :full-name "cljs.core/subvec",
                                             :clj-symbol "clojure.core/subvec",
                                             :docstring "Returns a persistent vector of the items in vector from\nstart (inclusive) to end (exclusive).  If end is not supplied,\ndefaults to (count vector). This operation is O(1) and very fast, as\nthe resulting vector shares structure with the original and no\ntrimming is done."},
                         "cljs.core/bit-clear" {:ns "cljs.core",
                                                :name "bit-clear",
                                                :signature ["[x n]"],
                                                :shadowed-sources ({:code "(defmacro bit-clear [x n]\n  (list 'js* \"(~{} & ~(1 << ~{}))\" x n))",
                                                                    :filename "clojurescript/src/clj/cljs/core.clj",
                                                                    :lines [424
                                                                            425],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L424-L425"}),
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_bit-clear",
                                                :source {:code "(defn bit-clear\n  [x n]\n  (cljs.core/bit-clear x n))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1582
                                                                 1585],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1582-L1585"},
                                                :full-name "cljs.core/bit-clear",
                                                :clj-symbol "clojure.core/bit-clear",
                                                :docstring "Clear bit at index n"},
                         "cljs.core/gensym" {:ns "cljs.core",
                                             :name "gensym",
                                             :signature ["[]"
                                                         "[prefix-string]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_gensym",
                                             :source {:code "(defn gensym\n  ([] (gensym \"G__\"))\n  ([prefix-string]\n     (when (nil? gensym_counter)\n       (set! gensym_counter (atom 0)))\n     (symbol (str prefix-string (swap! gensym_counter inc)))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [6664
                                                              6672],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6664-L6672"},
                                             :full-name "cljs.core/gensym",
                                             :clj-symbol "clojure.core/gensym",
                                             :docstring "Returns a new symbol with a unique name. If a prefix string is\nsupplied, the name is prefix# where # is some unique number. If\nprefix is not supplied, the prefix is 'G__'."},
                         "special/recur" {:full-name "special/recur",
                                          :ns "special",
                                          :name "recur",
                                          :type "special form",
                                          :source {:code "(defmethod parse 'recur\n  [op env [_ & exprs :as form] _]\n  (let [context (:context env)\n        frame (first *recur-frames*)\n        exprs (disallowing-recur (vec (map #(analyze (assoc env :context :expr) %) exprs)))]\n    (assert frame \"Can't recur here\")\n    (assert (= (count exprs) (count (:params frame))) \"recur argument count mismatch\")\n    (reset! (:flag frame) true)\n    (assoc {:env env :op :recur :form form}\n      :frame frame\n      :exprs exprs\n      :children exprs)))",
                                                   :filename "clojurescript/src/clj/cljs/analyzer.clj",
                                                   :lines [534 545],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/analyzer.clj#L534-L545"},
                                          :full-name-encode "special_recur",
                                          :clj-symbol "clojure.core/recur",
                                          :history [["+" "0.0-927"]]},
                         "cljs.core/Symbol" {:full-name "cljs.core/Symbol",
                                             :ns "cljs.core",
                                             :name "Symbol",
                                             :type "type",
                                             :signature ["[ns name str _hash _meta]"],
                                             :source {:code "(deftype Symbol [ns name str ^:mutable _hash _meta]\n  Object\n  (toString [_] str)\n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Symbol other)\n      (identical? str (.-str other))\n      false))\n  IFn\n  (-invoke [sym coll]\n    (-lookup coll sym nil))\n  (-invoke [sym coll not-found]\n    (-lookup coll sym not-found))\n  IMeta\n  (-meta [_] _meta)\n  IWithMeta\n  (-with-meta [_ new-meta] (Symbol. ns name str _hash new-meta))\n  IHash\n  (-hash [_]\n    (if (== _hash -1)\n      (do\n        (set! _hash (hash-combine (hash ns) (hash name)))\n        _hash)\n      _hash))\n  INamed\n  (-name [_] name)\n  (-namespace [_] ns)\n  IPrintWithWriter\n  (-pr-writer [o writer _] (-write writer str)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [333 361],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L333-L361"},
                                             :full-name-encode "cljs.core_Symbol",
                                             :history [["+"
                                                        "0.0-1798"]]},
                         "cljs.core/shuffle" {:ns "cljs.core",
                                              :name "shuffle",
                                              :signature ["[coll]"],
                                              :history [["+"
                                                         "0.0-1424"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_shuffle",
                                              :source {:code "(defn shuffle\n  [coll]\n  (let [a (to-array coll)]\n    (garray/shuffle a)\n    (vec a)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1257
                                                               1262],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1257-L1262"},
                                              :full-name "cljs.core/shuffle",
                                              :clj-symbol "clojure.core/shuffle",
                                              :docstring "Return a random permutation of coll"},
                         "cljs.core/+" {:ns "cljs.core",
                                        :name "+",
                                        :signature ["[]"
                                                    "[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :shadowed-sources ({:code "(defmacro +\n  ([] 0)\n  ([x] x)\n  ([x y] (list 'js* \"(~{} + ~{})\" x y))\n  ([x y & more] `(+ (+ ~x ~y) ~@more)))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [264
                                                                    268],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L264-L268"}),
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core__PLUS_",
                                        :source {:code "(defn +\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/+ x y))\n  ([x y & more]\n    (reduce + (cljs.core/+ x y) more)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [1314 1320],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1314-L1320"},
                                        :full-name "cljs.core/+",
                                        :clj-symbol "clojure.core/+",
                                        :docstring "Returns the sum of nums. (+) returns 0."},
                         "cljs.core/comp" {:ns "cljs.core",
                                           :name "comp",
                                           :signature ["[]"
                                                       "[f]"
                                                       "[f g]"
                                                       "[f g h]"
                                                       "[f1 f2 f3 & fs]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_comp",
                                           :source {:code "(defn comp\n  ([] identity)\n  ([f] f)\n  ([f g]\n     (fn\n       ([] (f (g)))\n       ([x] (f (g x)))\n       ([x y] (f (g x y)))\n       ([x y z] (f (g x y z)))\n       ([x y z & args] (f (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (f (g (h))))\n       ([x] (f (g (h x))))\n       ([x y] (f (g (h x y))))\n       ([x y z] (f (g (h x y z))))\n       ([x y z & args] (f (g (apply h x y z args))))))\n  ([f1 f2 f3 & fs]\n    (let [fs (reverse (list* f1 f2 f3 fs))]\n      (fn [& args]\n        (loop [ret (apply (first fs) args) fs (next fs)]\n          (if fs\n            (recur ((first fs) ret) (next fs))\n            ret))))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2442 2469],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2442-L2469"},
                                           :full-name "cljs.core/comp",
                                           :clj-symbol "clojure.core/comp",
                                           :docstring "Takes a set of functions and returns a fn that is the composition\nof those fns.  The returned fn takes a variable number of args,\napplies the rightmost of fns to the args, the next\nfn (right-to-left) to the result, etc."},
                         "cljs.reader/desugar-meta" {:full-name "cljs.reader/desugar-meta",
                                                     :ns "cljs.reader",
                                                     :name "desugar-meta",
                                                     :type "function",
                                                     :signature ["[f]"],
                                                     :source {:code "(defn desugar-meta\n  [f]\n  (cond\n   (symbol? f) {:tag f}\n   (string? f) {:tag f}\n   (keyword? f) {f true}\n   :else f))",
                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                              :lines [343
                                                                      349],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L343-L349"},
                                                     :full-name-encode "cljs.reader_desugar-meta",
                                                     :history [["+"
                                                                "0.0-927"]]},
                         "cljs.core/pr" {:ns "cljs.core",
                                         :name "pr",
                                         :signature ["[& objs]"],
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core_pr",
                                         :source {:code "(defn pr\n  [& objs]\n  (pr-with-opts objs (pr-opts)))",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [6381 6387],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6381-L6387"},
                                         :full-name "cljs.core/pr",
                                         :clj-symbol "clojure.core/pr",
                                         :docstring "Prints the object(s) using string-print.  Prints the\nobject(s), separated by spaces if there is more than one.\nBy default, pr and prn print in a way that objects can be\nread by the reader"},
                         "clojure.string/upper-case" {:ns "clojure.string",
                                                      :name "upper-case",
                                                      :signature ["[s]"],
                                                      :history [["+"
                                                                 "0.0-927"]],
                                                      :type "function",
                                                      :full-name-encode "clojure.string_upper-case",
                                                      :source {:code "(defn upper-case\n  [s]\n  (.toUpperCase s))",
                                                               :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                               :lines [53
                                                                       56],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/string.cljs#L53-L56"},
                                                      :full-name "clojure.string/upper-case",
                                                      :clj-symbol "clojure.string/upper-case",
                                                      :docstring "Converts string to all upper-case."},
                         "cljs.core/chars" {:full-name "cljs.core/chars",
                                            :ns "cljs.core",
                                            :name "chars",
                                            :type "function",
                                            :signature ["[x]"],
                                            :source {:code "(defn chars [x] x)",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [1528
                                                             1528],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1528-L1528"},
                                            :full-name-encode "cljs.core_chars",
                                            :clj-symbol "clojure.core/chars",
                                            :history [["+" "0.0-1798"]]},
                         "clojure.browser.event/expose" {:full-name "clojure.browser.event/expose",
                                                         :ns "clojure.browser.event",
                                                         :name "expose",
                                                         :type "function",
                                                         :signature ["[e]"],
                                                         :source {:code "(defn expose [e]\n  (goog.events/expose e))",
                                                                  :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                  :lines [79
                                                                          80],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/event.cljs#L79-L80"},
                                                         :full-name-encode "clojure.browser.event_expose",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "clojure.browser.event/listen-once" {:full-name "clojure.browser.event/listen-once",
                                                              :ns "clojure.browser.event",
                                                              :name "listen-once",
                                                              :type "function",
                                                              :signature ["[src type fn]"
                                                                          "[src type fn capture?]"],
                                                              :source {:code "(defn listen-once\n  ([src type fn]\n     (listen-once src type fn false))\n  ([src type fn capture?]\n     (goog.events/listenOnce src\n                             (get (event-types src) type type)\n                             fn\n                             capture?)))",
                                                                       :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                       :lines [53
                                                                               60],
                                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/event.cljs#L53-L60"},
                                                              :full-name-encode "clojure.browser.event_listen-once",
                                                              :history [["+"
                                                                         "0.0-927"]]},
                         "cljs.core/empty?" {:return-type boolean,
                                             :ns "cljs.core",
                                             :name "empty?",
                                             :signature ["[coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_empty_QMARK_",
                                             :source {:code "(defn ^boolean empty?\n  [coll] (or (nil? coll)\n             (not (seq coll))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [992 996],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L992-L996"},
                                             :full-name "cljs.core/empty?",
                                             :clj-symbol "clojure.core/empty?",
                                             :docstring "Returns true if coll has no items - same as (not (seq coll)).\nPlease use the idiom (seq x) rather than (not (empty? x))"},
                         "cljs.core/newline" {:full-name "cljs.core/newline",
                                              :ns "cljs.core",
                                              :name "newline",
                                              :type "function",
                                              :signature ["[opts]"],
                                              :source {:code "(defn newline [opts]\n  (string-print \"\\n\")\n  (when (get opts :flush-on-newline)\n    (flush)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [6355
                                                               6358],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6355-L6358"},
                                              :full-name-encode "cljs.core_newline",
                                              :clj-symbol "clojure.core/newline",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/PersistentHashMap" {:full-name "cljs.core/PersistentHashMap",
                                                        :ns "cljs.core",
                                                        :name "PersistentHashMap",
                                                        :type "type",
                                                        :signature ["[meta cnt root has-nil? nil-val __hash]"],
                                                        :source {:code "(deftype PersistentHashMap [meta cnt root ^boolean has-nil? nil-val ^:mutable __hash]\n  IWithMeta\n  (-with-meta [coll meta] (PersistentHashMap. meta cnt root has-nil? nil-val __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj coll entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta cljs.core.PersistentHashMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? cnt)\n      (let [s (if-not (nil? root) (.inode-seq root))]\n        (if has-nil?\n          (cons [nil nil-val] s)\n          s))))\n\n  ICounted\n  (-count [coll] cnt)\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (cond (nil? k)    (if has-nil?\n                        nil-val\n                        not-found)\n          (nil? root) not-found\n          :else       (.inode-lookup root 0 (hash k) k not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (nil? k)\n      (if (and has-nil? (identical? v nil-val))\n        coll\n        (PersistentHashMap. meta (if has-nil? cnt (inc cnt)) root true v nil))\n      (let [added-leaf? (Box. false)\n            new-root    (-> (if (nil? root)\n                              cljs.core.BitmapIndexedNode/EMPTY\n                              root)\n                            (.inode-assoc 0 (hash k) k v added-leaf?))]\n        (if (identical? new-root root)\n          coll\n          (PersistentHashMap. meta (if ^boolean (.-val added-leaf?) (inc cnt) cnt) new-root has-nil? nil-val nil)))))\n\n  (-contains-key? [coll k]\n    (cond (nil? k)    has-nil?\n          (nil? root) false\n          :else       (not (identical? (.inode-lookup root 0 (hash k) k lookup-sentinel)\n                                       lookup-sentinel))))\n\n  IMap\n  (-dissoc [coll k]\n    (cond (nil? k)    (if has-nil?\n                        (PersistentHashMap. meta (dec cnt) root false nil nil)\n                        coll)\n          (nil? root) coll\n          :else\n          (let [new-root (.inode-without root 0 (hash k) k)]\n            (if (identical? new-root root)\n              coll\n              (PersistentHashMap. meta (dec cnt) new-root has-nil? nil-val nil)))))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [init (if has-nil? (f init nil nil-val) init)]\n      (cond\n        (reduced? init)          @init\n        (not (nil? root)) (.kv-reduce root f init)\n        :else                    init)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientHashMap. (js-obj) root cnt has-nil? nil-val)))",
                                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                 :lines [4680
                                                                         4774],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L4680-L4774"},
                                                        :full-name-encode "cljs.core_PersistentHashMap",
                                                        :history [["+"
                                                                   "0.0-1211"]]},
                         "cljs.core/replace" {:ns "cljs.core",
                                              :name "replace",
                                              :signature ["[smap coll]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_replace",
                                              :source {:code "(defn replace\n  [smap coll]\n  (if (vector? coll)\n    (let [n (count coll)]\n      (reduce (fn [v i]\n                (if-let [e (find smap (nth v i))]\n                  (assoc v i (second e))\n                  v))\n              coll (take n (iterate inc 0))))\n    (map #(if-let [e (find smap %)] (second e) %) coll)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [5836
                                                               5848],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5836-L5848"},
                                              :full-name "cljs.core/replace",
                                              :clj-symbol "clojure.core/replace",
                                              :docstring "Given a map of replacement pairs and a vector/collection, returns a\nvector/seq with any elements = a key in smap replaced with the\ncorresponding val in smap"},
                         "cljs.core/rand" {:ns "cljs.core",
                                           :name "rand",
                                           :signature ["[]" "[n]"],
                                           :shadowed-sources ({:code "(defn rand\n  ([]  (Math/random))\n  ([n] (* n (rand))))",
                                                               :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                               :lines [1557
                                                                       1560],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1557-L1560"}),
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_rand",
                                           :source {:code "(defn rand\n  ([] (rand 1))\n  ([n] (* (Math/random) n)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [6809 6813],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6809-L6813"},
                                           :full-name "cljs.core/rand",
                                           :clj-symbol "clojure.core/rand",
                                           :docstring "Returns a random floating point number between 0 (inclusive) and\nn (default 1) (exclusive)."},
                         "cljs.core/add-watch" {:ns "cljs.core",
                                                :name "add-watch",
                                                :signature ["[iref key f]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_add-watch",
                                                :source {:code "(defn add-watch\n  [iref key f]\n  (-add-watch iref key f))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [6629
                                                                 6651],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6629-L6651"},
                                                :full-name "cljs.core/add-watch",
                                                :clj-symbol "clojure.core/add-watch",
                                                :docstring "Alpha - subject to change.\n\nAdds a watch function to an atom reference. The watch fn must be a\nfn of 4 args: a key, the reference, its old-state, its\nnew-state. Whenever the reference's state might have been changed,\nany registered watches will have their functions called. The watch\nfn will be called synchronously. Note that an atom's state\nmay have changed again prior to the fn call, so use old/new-state\nrather than derefing the reference. Keys must be unique per\nreference, and can be used to remove the watch with remove-watch,\nbut are otherwise considered opaque by the watch mechanism.  Bear in\nmind that regardless of the result or action of the watch fns the\natom's value will change.  Example:\n\n    (def a (atom 0))\n    (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n    (swap! a inc)\n    ;; Assertion Error\n    (deref a)\n    ;=> 1"},
                         "clojure.string/capitalize" {:ns "clojure.string",
                                                      :name "capitalize",
                                                      :signature ["[s]"],
                                                      :history [["+"
                                                                 "0.0-927"]],
                                                      :type "function",
                                                      :full-name-encode "clojure.string_capitalize",
                                                      :source {:code "(defn capitalize\n  [s]\n  (if (< (count s) 2)\n    (upper-case s)\n    (str (upper-case (subs s 0 1))\n         (lower-case (subs s 1)))))",
                                                               :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                               :lines [63
                                                                       70],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/string.cljs#L63-L70"},
                                                      :full-name "clojure.string/capitalize",
                                                      :clj-symbol "clojure.string/capitalize",
                                                      :docstring "Converts first character of the string to upper-case, all other\ncharacters to lower-case."},
                         "cljs.core/short" {:ns "cljs.core",
                                            :name "short",
                                            :signature ["[x]"],
                                            :shadowed-sources ({:code "(defmacro short [x] x)",
                                                                :filename "clojurescript/src/clj/cljs/core.clj",
                                                                :lines [271
                                                                        271],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L271-L271"}),
                                            :history [["+" "0.0-1798"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_short",
                                            :source {:code "(defn short [x] x)",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [1419
                                                             1419],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1419-L1419"},
                                            :full-name "cljs.core/short",
                                            :clj-symbol "clojure.core/short"},
                         "cljs.core/replicate" {:ns "cljs.core",
                                                :name "replicate",
                                                :signature ["[n x]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_replicate",
                                                :source {:code "(defn replicate\n  [n x] (take n (repeat x)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [2745
                                                                 2747],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2745-L2747"},
                                                :full-name "cljs.core/replicate",
                                                :clj-symbol "clojure.core/replicate",
                                                :docstring "Returns a lazy seq of n xs."},
                         "special/do" {:full-name "special/do",
                                       :ns "special",
                                       :name "do",
                                       :type "special form",
                                       :source {:code "(defmethod parse 'do\n  [op env [_ & exprs :as form] _]\n  (let [statements (disallowing-recur\n                     (seq (map #(analyze (assoc env :context :statement) %) (butlast exprs))))\n        ret (if (<= (count exprs) 1)\n              (analyze env (first exprs))\n              (analyze (assoc env :context (if (= :statement (:context env)) :statement :return)) (last exprs)))]\n    {:env env :op :do :form form\n     :statements statements :ret ret\n     :children (conj (vec statements) ret)}))",
                                                :filename "clojurescript/src/clj/cljs/analyzer.clj",
                                                :lines [470 479],
                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/analyzer.clj#L470-L479"},
                                       :full-name-encode "special_do",
                                       :clj-symbol "clojure.core/do",
                                       :history [["+" "0.0-927"]]},
                         "cljs.core/ArrayChunk" {:full-name "cljs.core/ArrayChunk",
                                                 :ns "cljs.core",
                                                 :name "ArrayChunk",
                                                 :type "type",
                                                 :signature ["[arr off end]"],
                                                 :source {:code "(deftype ArrayChunk [arr off end]\n  ICounted\n  (-count [_] (- end off))\n\n  IIndexed\n  (-nth [coll i]\n    (aget arr (+ off i)))\n  (-nth [coll i not-found]\n    (if (and (>= i 0) (< i (- end off)))\n      (aget arr (+ off i))\n      not-found))\n\n  IChunk\n  (-drop-first [coll]\n    (if (== off end)\n      (throw (js/Error. \"-drop-first of empty chunk\"))\n      (ArrayChunk. arr (inc off) end)))\n\n  IReduce\n  (-reduce [coll f]\n    (array-reduce arr f (aget arr off) (inc off)))\n  (-reduce [coll f start]\n    (array-reduce arr f start off)))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2031
                                                                  2053],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2031-L2053"},
                                                 :full-name-encode "cljs.core_ArrayChunk",
                                                 :clj-symbol "clojure.core/ArrayChunk",
                                                 :history [["+"
                                                            "0.0-1424"]]},
                         "cljs.core/sequential?" {:return-type boolean,
                                                  :ns "cljs.core",
                                                  :name "sequential?",
                                                  :signature ["[x]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_sequential_QMARK_",
                                                  :source {:code "(defn ^boolean sequential?\n  [x] (satisfies? ISequential x))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [1016
                                                                   1018],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1016-L1018"},
                                                  :full-name "cljs.core/sequential?",
                                                  :clj-symbol "clojure.core/sequential?",
                                                  :docstring "Returns true if coll satisfies ISequential"},
                         "cljs.core/underive" {:ns "cljs.core",
                                               :name "underive",
                                               :signature ["[tag parent]"
                                                           "[h tag parent]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_underive",
                                               :source {:code "(defn underive\n  ([tag parent]\n    (swap-global-hierarchy! underive tag parent)\n    nil)\n  ([h tag parent]\n    (let [parentMap (:parents h)\n          childsParents (if (parentMap tag)\n                          (disj (parentMap tag) parent) #{})\n          newParents (if (not-empty childsParents)\n                      (assoc parentMap tag childsParents)\n                      (dissoc parentMap tag))\n          deriv-seq (flatten (map #(cons (first %) (interpose (first %) (second %)))\n                                  (seq newParents)))]\n      (if (contains? (parentMap tag) parent)\n        (reduce #(apply derive %1 %2) (make-hierarchy)\n                (partition 2 deriv-seq))\n        h))))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [6930
                                                                6949],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6930-L6949"},
                                               :full-name "cljs.core/underive",
                                               :clj-symbol "clojure.core/underive",
                                               :docstring "Removes a parent/child relationship between parent and\ntag. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
                         "cljs.core/get-method" {:ns "cljs.core",
                                                 :name "get-method",
                                                 :signature ["[multifn dispatch-val]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_get-method",
                                                 :source {:code "(defn get-method\n  [multifn dispatch-val] (-get-method multifn dispatch-val))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [7100
                                                                  7103],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L7100-L7103"},
                                                 :full-name "cljs.core/get-method",
                                                 :clj-symbol "clojure.core/get-method",
                                                 :docstring "Given a multimethod and a dispatch value, returns the dispatch fn\nthat would apply to that value, or nil if none apply and no default"},
                         "cljs.core/=" {:return-type boolean,
                                        :ns "cljs.core",
                                        :name "=",
                                        :signature ["[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core__EQ_",
                                        :source {:code "(defn ^boolean =\n  ([x] true)\n  ([x y] (or (identical? x y) (-equiv x y)))\n  ([x y & more]\n     (if (= x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (= y (first more)))\n       false)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [433 445],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L433-L445"},
                                        :full-name "cljs.core/=",
                                        :clj-symbol "clojure.core/=",
                                        :docstring "Equality. Returns true if x equals y, false if not. Compares\nnumbers and collections in a type-independent manner.  Clojure's immutable data\nstructures define -equiv (and thus =) as a value, not an identity,\ncomparison."},
                         "cljs.reader/deregister-default-tag-parser!" {:full-name "cljs.reader/deregister-default-tag-parser!",
                                                                       :ns "cljs.reader",
                                                                       :name "deregister-default-tag-parser!",
                                                                       :type "function",
                                                                       :signature ["[]"],
                                                                       :source {:code "(defn deregister-default-tag-parser!\n  []\n  (let [old-parser @*default-data-reader-fn*]\n    (swap! *default-data-reader-fn* (fn [_] nil))\n    old-parser))",
                                                                                :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                                :lines [565
                                                                                        569],
                                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L565-L569"},
                                                                       :full-name-encode "cljs.reader_deregister-default-tag-parser_BANG_",
                                                                       :history [["+"
                                                                                  "0.0-1576"]]},
                         "cljs.core/defn-" {:ns "cljs.core",
                                            :name "defn-",
                                            :signature ["[name & decls]"],
                                            :history [["+" "0.0-927"]],
                                            :type "macro",
                                            :full-name-encode "cljs.core_defn-",
                                            :source {:code "(defmacro defn-\n  [name & decls]\n    (list* `defn (with-meta name (assoc (meta name) :private true)) decls))",
                                                     :filename "clojure/src/clj/clojure/core.clj",
                                                     :lines [4455
                                                             4459],
                                                     :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L4455-L4459"},
                                            :full-name "cljs.core/defn-",
                                            :clj-symbol "clojure.core/defn-",
                                            :docstring "same as defn, yielding non-public def"},
                         "cljs.reader/read-symbol" {:full-name "cljs.reader/read-symbol",
                                                    :ns "cljs.reader",
                                                    :name "read-symbol",
                                                    :type "function",
                                                    :signature ["[reader initch]"],
                                                    :source {:code "(defn read-symbol\n  [reader initch]\n  (let [token (read-token reader initch)]\n    (if (gstring/contains token \"/\")\n      (symbol (subs token 0 (.indexOf token \"/\"))\n              (subs token (inc (.indexOf token \"/\")) (.-length token)))\n      (special-symbols token (symbol token)))))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [319
                                                                     325],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L319-L325"},
                                                    :full-name-encode "cljs.reader_read-symbol",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "cljs.reader/push-back-reader" {:full-name "cljs.reader/push-back-reader",
                                                         :ns "cljs.reader",
                                                         :name "push-back-reader",
                                                         :type "function",
                                                         :signature ["[s]"],
                                                         :source {:code "(defn push-back-reader [s]\n  \"Creates a StringPushbackReader from a given string\"\n  (StringPushbackReader. s (atom 0) (atom nil)))",
                                                                  :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                  :lines [30
                                                                          32],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L30-L32"},
                                                         :full-name-encode "cljs.reader_push-back-reader",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "cljs.core/deftype" {:full-name "cljs.core/deftype",
                                              :ns "cljs.core",
                                              :name "deftype",
                                              :type "macro",
                                              :signature ["[t fields & impls]"],
                                              :source {:code "(defmacro deftype [t fields & impls]\n  (let [r (:name (cljs.analyzer/resolve-var (dissoc &env :locals) t))\n        [fpps pmasks] (prepare-protocol-masks &env t impls)\n        protocols (collect-protocols impls &env)\n        t (vary-meta t assoc\n            :protocols protocols\n            :skip-protocol-flag fpps) ]\n    (if (seq impls)\n      `(do\n         (deftype* ~t ~fields ~pmasks)\n         (set! (.-cljs$lang$type ~t) true)\n         (set! (.-cljs$lang$ctorStr ~t) ~(core/str r))\n         (set! (.-cljs$lang$ctorPrWriter ~t) (fn [this# writer# opt#] (-write writer# ~(core/str r))))\n         (extend-type ~t ~@(dt->et t impls fields true))\n         ~t)\n      `(do\n         (deftype* ~t ~fields ~pmasks)\n         (set! (.-cljs$lang$type ~t) true)\n         (set! (.-cljs$lang$ctorStr ~t) ~(core/str r))\n         (set! (.-cljs$lang$ctorPrWriter ~t) (fn [this# writer# opts#] (-write writer# ~(core/str r))))\n         ~t))))",
                                                       :filename "clojurescript/src/clj/cljs/core.clj",
                                                       :lines [670
                                                               690],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L670-L690"},
                                              :full-name-encode "cljs.core_deftype",
                                              :clj-symbol "clojure.core/deftype",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/longs" {:full-name "cljs.core/longs",
                                            :ns "cljs.core",
                                            :name "longs",
                                            :type "function",
                                            :signature ["[x]"],
                                            :source {:code "(defn longs [x] x)",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [1533
                                                             1533],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1533-L1533"},
                                            :full-name-encode "cljs.core_longs",
                                            :clj-symbol "clojure.core/longs",
                                            :history [["+" "0.0-1798"]]},
                         "cljs.core/Subvec" {:full-name "cljs.core/Subvec",
                                             :ns "cljs.core",
                                             :name "Subvec",
                                             :type "type",
                                             :signature ["[meta v start end __hash]"],
                                             :source {:code "(deftype Subvec [meta v start end ^:mutable __hash]\n  IWithMeta\n  (-with-meta [coll meta] (build-subvec meta v start end __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (-nth v (dec end)))\n  (-pop [coll]\n    (if (== start end)\n      (throw (js/Error. \"Can't pop empty vector\"))\n      (build-subvec meta v start (dec end) nil)))\n\n  ICollection\n  (-conj [coll o]\n    (build-subvec meta (-assoc-n v end o) start (inc end) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.PersistentVector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (let [subvec-seq (fn subvec-seq [i]\n                       (when-not (== i end)\n                         (cons (-nth v i)\n                               (lazy-seq\n                                (subvec-seq (inc i))))))]\n      (subvec-seq start)))\n\n  ICounted\n  (-count [coll] (- end start))\n\n  IIndexed\n  (-nth [coll n]\n    (-nth v (+ start n)))\n  (-nth [coll n not-found]\n    (-nth v (+ start n) not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll key val]\n    (let [v-pos (+ start key)]\n      (build-subvec meta (assoc v v-pos val)\n               start (max end (inc v-pos))\n               nil)))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [coll f]\n    (ci-reduce coll f))\n  (-reduce [coll f start]\n    (ci-reduce coll f start))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [3285
                                                              3356],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L3285-L3356"},
                                             :full-name-encode "cljs.core_Subvec",
                                             :history [["+" "0.0-927"]]},
                         "special/ns" {:full-name "special/ns",
                                       :ns "special",
                                       :name "ns",
                                       :type "special form",
                                       :source {:code "(defmethod parse 'ns\n  [_ env [_ name & args :as form] _]\n  (assert (symbol? name) \"Namespaces must be named by a symbol.\")\n  (let [docstring (if (string? (first args)) (first args) nil)\n        args      (if docstring (next args) args)\n        excludes\n        (reduce (fn [s [k exclude xs]]\n                  (if (= k :refer-clojure)\n                    (do\n                      (assert (= exclude :exclude) \"Only [:refer-clojure :exclude (names)] form supported\")\n                      (assert (not (seq s)) \"Only one :refer-clojure form is allowed per namespace definition\")\n                      (into s xs))\n                    s))\n                #{} args)\n        deps (atom #{})\n        aliases (atom {:fns #{} :macros #{}})\n        valid-forms (atom #{:use :use-macros :require :require-macros :import})\n        error-msg (fn [spec msg] (str msg \"; offending spec: \" (pr-str spec)))\n        parse-require-spec (fn parse-require-spec [macros? spec]\n                             (assert (or (symbol? spec) (vector? spec))\n                                     (error-msg spec \"Only [lib.ns & options] and lib.ns specs supported in :require / :require-macros\"))\n                             (when (vector? spec)\n                               (assert (symbol? (first spec))\n                                       (error-msg spec \"Library name must be specified as a symbol in :require / :require-macros\"))\n                               (assert (odd? (count spec))\n                                       (error-msg spec \"Only :as alias and :refer (names) options supported in :require\"))\n                               (assert (every? #{:as :refer} (map first (partition 2 (next spec))))\n                                       (error-msg spec \"Only :as and :refer options supported in :require / :require-macros\"))\n                               (assert (let [fs (frequencies (next spec))]\n                                         (and (<= (fs :as 0) 1)\n                                              (<= (fs :refer 0) 1)))\n                                       (error-msg spec \"Each of :as and :refer options may only be specified once in :require / :require-macros\")))\n                             (if (symbol? spec)\n                               (recur macros? [spec])\n                               (let [[lib & opts] spec\n                                     {alias :as referred :refer :or {alias lib}} (apply hash-map opts)\n                                     [rk uk] (if macros? [:require-macros :use-macros] [:require :use])]\n                                 (when alias\n                                   ;; we need to create a fake namespace so the reader knows about aliases\n                                   ;; for resolving keywords like ::f/bar\n                                   (binding [*ns* (create-ns name)]\n                                     (let [^clojure.lang.Namespace ns (create-ns lib)]\n                                       (clojure.core/alias alias (.name ns))))\n                                   (let [alias-type (if macros? :macros :fns)]\n                                     (assert (not (contains? (alias-type @aliases)\n                                                             alias))\n                                             (error-msg spec \":as alias must be unique\"))\n                                     (swap! aliases\n                                            update-in [alias-type]\n                                            conj alias)))\n                                 (assert (or (symbol? alias) (nil? alias))\n                                         (error-msg spec \":as must be followed by a symbol in :require / :require-macros\"))\n                                 (assert (or (and (sequential? referred) (every? symbol? referred))\n                                             (nil? referred))\n                                         (error-msg spec \":refer must be followed by a sequence of symbols in :require / :require-macros\"))\n                                 (when-not macros?\n                                   (swap! deps conj lib))\n                                 (merge (when alias {rk {alias lib}})\n                                        (when referred {uk (apply hash-map (interleave referred (repeat lib)))})))))\n        use->require (fn use->require [[lib kw referred :as spec]]\n                       (assert (and (symbol? lib) (= :only kw) (sequential? referred) (every? symbol? referred))\n                               (error-msg spec \"Only [lib.ns :only (names)] specs supported in :use / :use-macros\"))\n                       [lib :refer referred])\n        parse-import-spec (fn parse-import-spec [spec]\n                            (assert (and (symbol? spec) (nil? (namespace spec)))\n                                    (error-msg spec \"Only lib.Ctor specs supported in :import\"))\n                            (swap! deps conj spec)\n                            (let [ctor-sym (symbol (last (string/split (str spec) #\"\\.\")))]\n                              {:import  {ctor-sym spec}\n                               :require {ctor-sym spec}}))\n        spec-parsers {:require        (partial parse-require-spec false)\n                      :require-macros (partial parse-require-spec true)\n                      :use            (comp (partial parse-require-spec false) use->require)\n                      :use-macros     (comp (partial parse-require-spec true) use->require)\n                      :import         parse-import-spec}\n        {uses :use requires :require uses-macros :use-macros requires-macros :require-macros imports :import :as params}\n        (reduce (fn [m [k & libs]]\n                  (assert (#{:use :use-macros :require :require-macros :import} k)\n                          \"Only :refer-clojure, :require, :require-macros, :use and :use-macros libspecs supported\")\n                  (assert (@valid-forms k)\n                          (str \"Only one \" k \" form is allowed per namespace definition\"))\n                  (swap! valid-forms disj k)\n                  (apply merge-with merge m (map (spec-parsers k) libs)))\n                {} (remove (fn [[r]] (= r :refer-clojure)) args))]\n    (when (seq @deps)\n      (analyze-deps @deps))\n    (set! *cljs-ns* name)\n    (load-core)\n    (doseq [nsym (concat (vals requires-macros) (vals uses-macros))]\n      (clojure.core/require nsym))\n    (swap! namespaces #(-> %\n                           (assoc-in [name :name] name)\n                           (assoc-in [name :doc] docstring)\n                           (assoc-in [name :excludes] excludes)\n                           (assoc-in [name :uses] uses)\n                           (assoc-in [name :requires] requires)\n                           (assoc-in [name :uses-macros] uses-macros)\n                           (assoc-in [name :requires-macros]\n                                     (into {} (map (fn [[alias nsym]]\n                                                     [alias (find-ns nsym)])\n                                                   requires-macros)))\n                           (assoc-in [name :imports] imports)))\n    {:env env :op :ns :form form :name name :doc docstring :uses uses :requires requires :imports imports\n     :uses-macros uses-macros :requires-macros requires-macros :excludes excludes}))",
                                                :filename "clojurescript/src/clj/cljs/analyzer.clj",
                                                :lines [620 723],
                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/analyzer.clj#L620-L723"},
                                       :full-name-encode "special_ns",
                                       :clj-symbol "clojure.core/ns",
                                       :history [["+" "0.0-927"]]},
                         "cljs.core/IReversible" {:ns "cljs.core",
                                                  :name "IReversible",
                                                  :type "protocol",
                                                  :full-name-encode "cljs.core_IReversible",
                                                  :source {:code "(defprotocol IReversible\n  (-rseq [coll]))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [263
                                                                   264],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L263-L264"},
                                                  :methods [{:name "-rseq",
                                                             :signature ["[coll]"],
                                                             :docstring nil}],
                                                  :full-name "cljs.core/IReversible",
                                                  :history [["+"
                                                             "0.0-1211"]]},
                         "cljs.core/extend-protocol" {:ns "cljs.core",
                                                      :name "extend-protocol",
                                                      :signature ["[p & specs]"],
                                                      :history [["+"
                                                                 "0.0-927"]],
                                                      :type "macro",
                                                      :full-name-encode "cljs.core_extend-protocol",
                                                      :source {:code "(defmacro extend-protocol \n  [p & specs]\n  (emit-extend-protocol p specs))",
                                                               :filename "clojure/src/clj/clojure/core_deftype.clj",
                                                               :lines [802
                                                                       840],
                                                               :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core_deftype.clj#L802-L840"},
                                                      :full-name "cljs.core/extend-protocol",
                                                      :clj-symbol "clojure.core/extend-protocol",
                                                      :docstring "Useful when you want to provide several implementations of the same\nprotocol all at once. Takes a single protocol and the implementation\nof that protocol for one or more types. Expands into calls to\nextend-type:\n\n(extend-protocol Protocol\n  AType\n    (foo [x] ...)\n    (bar [x y] ...)\n  BType\n    (foo [x] ...)\n    (bar [x y] ...)\n  AClass\n    (foo [x] ...)\n    (bar [x y] ...)\n  nil\n    (foo [x] ...)\n    (bar [x y] ...))\n\nexpands into:\n\n(do\n (clojure.core/extend-type AType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type BType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type AClass Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type nil Protocol \n   (foo [x] ...) \n   (bar [x y] ...)))"},
                         "cljs.reader/read" {:ns "cljs.reader",
                                             :name "read",
                                             :signature ["[reader eof-is-error sentinel is-recursive]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.reader_read",
                                             :source {:code "(defn read\n  [reader eof-is-error sentinel is-recursive]\n  (let [ch (read-char reader)]\n    (cond\n     (nil? ch) (if eof-is-error (reader-error reader \"EOF while reading\") sentinel)\n     (whitespace? ch) (recur reader eof-is-error sentinel is-recursive)\n     (comment-prefix? ch) (recur (read-comment reader ch) eof-is-error sentinel is-recursive)\n     :else (let [f (macros ch)\n                 res\n                 (cond\n                  f (f reader ch)\n                  (number-literal? reader ch) (read-number reader ch)\n                  :else (read-symbol reader ch))]\n     (if (identical? res reader)\n       (recur reader eof-is-error sentinel is-recursive)\n       res)))))",
                                                      :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                      :lines [415 432],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L415-L432"},
                                             :full-name "cljs.reader/read",
                                             :clj-symbol "clojure.core/read",
                                             :docstring "Reads the first object from a PushbackReader. Returns the object read.\nIf EOF, throws if eof-is-error is true. Otherwise returns sentinel."},
                         "cljs.core/EmptyList" {:full-name "cljs.core/EmptyList",
                                                :ns "cljs.core",
                                                :name "EmptyList",
                                                :type "type",
                                                :signature ["[meta]"],
                                                :source {:code "(deftype EmptyList [meta]\n  IList\n\n  IWithMeta\n  (-with-meta [coll meta] (EmptyList. meta))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] nil)\n  (-rest [coll] ())\n\n  INext\n  (-next [coll] nil)\n\n  IStack\n  (-peek [coll] nil)\n  (-pop [coll] (throw (js/Error. \"Can't pop empty list\")))\n\n  ICollection\n  (-conj [coll o] (List. meta o nil 1 nil))\n\n  IEmptyableCollection\n  (-empty [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] 0)\n\n  ISeqable\n  (-seq [coll] nil)\n\n  ICounted\n  (-count [coll] 0))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1820
                                                                 1857],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1820-L1857"},
                                                :full-name-encode "cljs.core_EmptyList",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "clojure.walk/postwalk" {:ns "clojure.walk",
                                                  :name "postwalk",
                                                  :signature ["[f form]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.walk_postwalk",
                                                  :source {:code "(defn postwalk\n  [f form]\n  (walk (partial postwalk f) f form))",
                                                           :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                           :lines [50
                                                                   56],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/walk.cljs#L50-L56"},
                                                  :full-name "clojure.walk/postwalk",
                                                  :clj-symbol "clojure.walk/postwalk",
                                                  :docstring "Performs a depth-first, post-order traversal of form.  Calls f on\neach sub-form, uses f's return value in place of the original.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
                         "clojure.zip/edit" {:ns "clojure.zip",
                                             :name "edit",
                                             :signature ["[loc f & args]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_edit",
                                             :source {:code "(defn edit\n  [loc f & args]\n    (replace loc (apply f (node loc) args)))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [189 192],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L189-L192"},
                                             :full-name "clojure.zip/edit",
                                             :clj-symbol "clojure.zip/edit",
                                             :docstring "Replaces the node at this loc with the value of (f node args)"},
                         "cljs.core/re-seq" {:ns "cljs.core",
                                             :name "re-seq",
                                             :signature ["[re s]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_re-seq",
                                             :source {:code "(defn re-seq\n  [re s]\n  (let [match-data (re-find re s)\n        match-idx (.search s re)\n        match-str (if (coll? match-data) (first match-data) match-data)\n        post-match (subs s (+ match-idx (count match-str)))]\n    (when match-data (lazy-seq (cons match-data (re-seq re post-match))))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [6187
                                                              6194],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6187-L6194"},
                                             :full-name "cljs.core/re-seq",
                                             :clj-symbol "clojure.core/re-seq",
                                             :docstring "Returns a lazy sequence of successive matches of re in s."},
                         "cljs.reader/read-list" {:full-name "cljs.reader/read-list",
                                                  :ns "cljs.reader",
                                                  :name "read-list",
                                                  :type "function",
                                                  :signature ["[rdr _]"],
                                                  :source {:code "(defn read-list\n  [rdr _]\n  (apply list (read-delimited-list \")\" rdr true)))",
                                                           :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                           :lines [272
                                                                   274],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L272-L274"},
                                                  :full-name-encode "cljs.reader_read-list",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/IKVReduce" {:ns "cljs.core",
                                                :name "IKVReduce",
                                                :type "protocol",
                                                :full-name-encode "cljs.core_IKVReduce",
                                                :source {:code "(defprotocol IKVReduce\n  (-kv-reduce [coll f init]))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [242
                                                                 243],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L242-L243"},
                                                :methods [{:name "-kv-reduce",
                                                           :signature ["[coll f init]"],
                                                           :docstring nil}],
                                                :full-name "cljs.core/IKVReduce",
                                                :history [["+"
                                                           "0.0-1211"]]},
                         "cljs.core/Atom" {:full-name "cljs.core/Atom",
                                           :ns "cljs.core",
                                           :name "Atom",
                                           :type "type",
                                           :signature ["[state meta validator watches]"],
                                           :source {:code "(deftype Atom [state meta validator watches]\n  IEquiv\n  (-equiv [o other] (identical? o other))\n\n  IDeref\n  (-deref [_] state)\n\n  IMeta\n  (-meta [_] meta)\n\n  IPrintWithWriter\n  (-pr-writer [a writer opts]\n    (-write writer \"#<Atom: \")\n    (pr-writer state writer opts)\n    (-write writer \">\"))\n\n  IWatchable\n  (-notify-watches [this oldval newval]\n    (doseq [[key f] watches]\n      (f key this oldval newval)))\n  (-add-watch [this key f]\n    (set! (.-watches this) (assoc watches key f)))\n  (-remove-watch [this key]\n    (set! (.-watches this) (dissoc watches key)))\n\n  IHash\n  (-hash [this] (goog/getUid this)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [6512 6538],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6512-L6538"},
                                           :full-name-encode "cljs.core_Atom",
                                           :history [["+" "0.0-927"]]},
                         "clojure.core.reducers/foldcat" {:ns "clojure.core.reducers",
                                                          :name "foldcat",
                                                          :signature ["[coll]"],
                                                          :history [["+"
                                                                     "0.0-1236"]],
                                                          :type "function",
                                                          :full-name-encode "clojure.core.reducers_foldcat",
                                                          :source {:code "(defn foldcat\n  [coll]\n  (fold cat append! coll))",
                                                                   :filename "clojurescript/src/cljs/clojure/core/reducers.cljs",
                                                                   :lines [230
                                                                           233],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/core/reducers.cljs#L230-L233"},
                                                          :full-name "clojure.core.reducers/foldcat",
                                                          :clj-symbol "clojure.core.reducers/foldcat",
                                                          :docstring "Equivalent to (fold cat append! coll)"},
                         "cljs.core/IMap" {:ns "cljs.core",
                                           :name "IMap",
                                           :type "protocol",
                                           :full-name-encode "cljs.core_IMap",
                                           :source {:code "(defprotocol IMap\n  #_(-assoc-ex [coll k v])\n  (-dissoc [coll k]))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [209 211],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L209-L211"},
                                           :methods [{:name "-dissoc",
                                                      :signature ["[coll k]"],
                                                      :docstring nil}],
                                           :full-name "cljs.core/IMap",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/pr-sequential-writer" {:full-name "cljs.core/pr-sequential-writer",
                                                           :ns "cljs.core",
                                                           :name "pr-sequential-writer",
                                                           :type "function",
                                                           :signature ["[writer print-one begin sep end opts coll]"],
                                                           :source {:code "(defn pr-sequential-writer [writer print-one begin sep end opts coll]\n  (-write writer begin)\n  (when (seq coll)\n    (print-one (first coll) writer opts))\n  (doseq [o (next coll)]\n    (-write writer sep)\n    (print-one o writer opts))\n  (-write writer end))",
                                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                    :lines [6204
                                                                            6211],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6204-L6211"},
                                                           :full-name-encode "cljs.core_pr-sequential-writer",
                                                           :history [["+"
                                                                      "0.0-1503"]]},
                         "cljs.core/unchecked-multiply" {:ns "cljs.core",
                                                         :name "unchecked-multiply",
                                                         :signature ["[]"
                                                                     "[x]"
                                                                     "[x y]"
                                                                     "[x y & more]"],
                                                         :shadowed-sources ({:code "(defmacro unchecked-multiply\n  ([& xs] `(* ~@xs)))",
                                                                             :filename "clojurescript/src/clj/cljs/core.clj",
                                                                             :lines [302
                                                                                     303],
                                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L302-L303"}),
                                                         :history [["+"
                                                                    "0.0-1798"]],
                                                         :type "function",
                                                         :full-name-encode "cljs.core_unchecked-multiply",
                                                         :source {:code "(defn unchecked-multiply\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-multiply x y))\n  ([x y & more] (reduce unchecked-multiply (cljs.core/unchecked-multiply x y) more)))",
                                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                  :lines [1462
                                                                          1467],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1462-L1467"},
                                                         :full-name "cljs.core/unchecked-multiply",
                                                         :clj-symbol "clojure.core/unchecked-multiply",
                                                         :docstring "Returns the product of nums. (*) returns 1."},
                         "cljs.reader/read-vector" {:full-name "cljs.reader/read-vector",
                                                    :ns "cljs.reader",
                                                    :name "read-vector",
                                                    :type "function",
                                                    :signature ["[rdr _]"],
                                                    :source {:code "(defn read-vector\n  [rdr _]\n  (read-delimited-list \"]\" rdr true))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [278
                                                                     280],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L278-L280"},
                                                    :full-name-encode "cljs.reader_read-vector",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "clojure.set/join" {:ns "clojure.set",
                                             :name "join",
                                             :signature ["[xrel yrel]"
                                                         "[xrel yrel km]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.set_join",
                                             :source {:code "(defn join\n  ([xrel yrel] ;natural join\n   (if (and (seq xrel) (seq yrel))\n     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n           [r s] (if (<= (count xrel) (count yrel))\n                   [xrel yrel]\n                   [yrel xrel])\n           idx (index r ks)]\n       (reduce (fn [ret x]\n                 (let [found (idx (select-keys x ks))]\n                   (if found\n                     (reduce #(conj %1 (merge %2 x)) ret found)\n                     ret)))\n               #{} s))\n     #{}))\n  ([xrel yrel km] ;arbitrary key mapping\n   (let [[r s k] (if (<= (count xrel) (count yrel))\n                   [xrel yrel (map-invert km)]\n                   [yrel xrel km])\n         idx (index r (vals k))]\n     (reduce (fn [ret x]\n               (let [found (idx (rename-keys (select-keys x (keys k)) k))]\n                 (if found\n                   (reduce #(conj %1 (merge %2 x)) ret found)\n                   ret)))\n             #{} s))))",
                                                      :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                      :lines [102 130],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/set.cljs#L102-L130"},
                                             :full-name "clojure.set/join",
                                             :clj-symbol "clojure.set/join",
                                             :docstring "When passed 2 rels, returns the rel corresponding to the natural\njoin. When passed an additional keymap, joins on the corresponding\nkeys."},
                         "cljs.core/HashMap" {:full-name "cljs.core/HashMap",
                                              :ns "cljs.core",
                                              :name "HashMap",
                                              :type "type",
                                              :signature ["[meta count hashobj __hash]"],
                                              :source {:code "(deftype HashMap [meta count hashobj ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (HashMap. meta count hashobj __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.HashMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? count)\n      (let [hashes (.sort (js-keys hashobj))]\n        (mapcat #(map vec (partition 2 (aget hashobj %)))\n                hashes))))\n\n  ICounted\n  (-count [coll] count)\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        (aget bucket (inc i))\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [h (hash k)\n          bucket (aget hashobj h)]\n      (if bucket\n        (let [new-bucket (aclone bucket)\n              new-hashobj (goog.object/clone hashobj)]\n          (aset new-hashobj h new-bucket)\n          (if-let [i (scan-array 2 k new-bucket)]\n            (do                         ; found key, replace\n              (aset new-bucket (inc i) v)\n              (HashMap. meta count new-hashobj nil))\n            (do                         ; did not find key, append\n              (.push new-bucket k v)\n              (HashMap. meta (inc count) new-hashobj nil))))\n        (let [new-hashobj (goog.object/clone hashobj)] ; did not find bucket\n          (aset new-hashobj h (array k v))\n          (HashMap. meta (inc count) new-hashobj nil)))))\n  (-contains-key? [coll k]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        true\n        false)))\n\n  IMap\n  (-dissoc [coll k]\n    (let [h (hash k)\n          bucket (aget hashobj h)\n          i (when bucket (scan-array 2 k bucket))]\n      (if (not i)\n        coll ; key not found, return coll unchanged\n        (let [new-hashobj (goog.object/clone hashobj)]\n          (if (> 3 (alength bucket))\n            (js-delete new-hashobj h)\n            (let [new-bucket (aclone bucket)]\n              (.splice new-bucket i 2)\n              (aset new-hashobj h new-bucket)))\n          (HashMap. meta (dec count) new-hashobj nil)))))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [3737
                                                               3828],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1586/src/cljs/cljs/core.cljs#L3737-L3828"},
                                              :full-name-encode "cljs.core_HashMap",
                                              :history [["+"
                                                         "0.0-927"]
                                                        ["-"
                                                         "0.0-1798"]],
                                              :removed {:in "0.0-1798",
                                                        :last-seen "0.0-1586"}},
                         "cljs.reader/int-pattern" {:full-name "cljs.reader/int-pattern",
                                                    :ns "cljs.reader",
                                                    :name "int-pattern",
                                                    :type "var",
                                                    :source {:code "(def int-pattern (re-pattern \"([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?\"))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [99
                                                                     99],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L99-L99"},
                                                    :full-name-encode "cljs.reader_int-pattern",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "cljs.core/swap!" {:ns "cljs.core",
                                            :name "swap!",
                                            :signature ["[a f]"
                                                        "[a f x]"
                                                        "[a f x y]"
                                                        "[a f x y z]"
                                                        "[a f x y z & more]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_swap_BANG_",
                                            :source {:code "(defn swap!\n  ([a f]\n     (reset! a (f (.-state a))))\n  ([a f x]\n     (reset! a (f (.-state a) x)))\n  ([a f x y]\n     (reset! a (f (.-state a) x y)))\n  ([a f x y z]\n     (reset! a (f (.-state a) x y z)))\n  ([a f x y z & more]\n     (reset! a (apply f (.-state a) x y z more))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [6568
                                                             6582],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6568-L6582"},
                                            :full-name "cljs.core/swap!",
                                            :clj-symbol "clojure.core/swap!",
                                            :docstring "Atomically swaps the value of atom to be:\n(apply f current-value-of-atom args). Note that f may be called\nmultiple times, and thus should be free of side effects.  Returns\nthe value that was swapped in."},
                         "cljs.core/dec" {:ns "cljs.core",
                                          :name "dec",
                                          :signature ["[x]"],
                                          :shadowed-sources ({:code "(defmacro dec [x]\n  `(- ~x 1))",
                                                              :filename "clojurescript/src/clj/cljs/core.clj",
                                                              :lines [369
                                                                      370],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L369-L370"}),
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_dec",
                                          :source {:code "(defn dec\n  [x] (- x 1))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [1391 1393],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1391-L1393"},
                                          :full-name "cljs.core/dec",
                                          :clj-symbol "clojure.core/dec",
                                          :docstring "Returns a number one less than num."},
                         "clojure.core.reducers/fold" {:full-name "clojure.core.reducers/fold",
                                                       :ns "clojure.core.reducers",
                                                       :name "fold",
                                                       :type "var",
                                                       :source {:code "(def fold reduce)",
                                                                :filename "clojurescript/src/cljs/clojure/core/reducers.cljs",
                                                                :lines [53
                                                                        53],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/core/reducers.cljs#L53-L53"},
                                                       :full-name-encode "clojure.core.reducers_fold",
                                                       :clj-symbol "clojure.core.reducers/fold",
                                                       :history [["+"
                                                                  "0.0-1236"]]},
                         "cljs.core/StringBufferWriter" {:full-name "cljs.core/StringBufferWriter",
                                                         :ns "cljs.core",
                                                         :name "StringBufferWriter",
                                                         :type "type",
                                                         :signature ["[sb]"],
                                                         :source {:code "(deftype StringBufferWriter [sb]\n  IWriter\n  (-write [_ s] (.append sb s))\n  (-flush [_] nil))",
                                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                  :lines [6241
                                                                          6244],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6241-L6244"},
                                                         :full-name-encode "cljs.core_StringBufferWriter",
                                                         :history [["+"
                                                                    "0.0-1503"]]},
                         "clojure.browser.dom/remove-children" {:full-name "clojure.browser.dom/remove-children",
                                                                :ns "clojure.browser.dom",
                                                                :name "remove-children",
                                                                :docstring "Remove all children from the element with the passed id.",
                                                                :type "function",
                                                                :signature ["[id]"],
                                                                :source {:code "(defn remove-children\n  [id]\n  (let [parent (gdom/getElement (name id))]\n    (do (gdom/removeChildren parent))))",
                                                                         :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                         :lines [92
                                                                                 96],
                                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/dom.cljs#L92-L96"},
                                                                :full-name-encode "clojure.browser.dom_remove-children",
                                                                :history [["+"
                                                                           "0.0-927"]]},
                         "cljs.core/BlackNode" {:full-name "cljs.core/BlackNode",
                                                :ns "cljs.core",
                                                :name "BlackNode",
                                                :type "type",
                                                :signature ["[key val left right __hash]"],
                                                :source {:code "(deftype BlackNode [key val left right ^:mutable __hash]\n  Object\n  (add-left [node ins]\n    (.balance-left ins node))\n\n  (add-right [node ins]\n    (.balance-right ins node))\n\n  (remove-left [node del]\n    (balance-left-del key val del right))\n\n  (remove-right [node del]\n    (balance-right-del key val left del))\n\n  (blacken [node] node)\n\n  (redden [node] (RedNode. key val left right nil))\n\n  (balance-left [node parent]\n    (BlackNode. (.-key parent) (.-val parent) node (.-right parent) nil))\n\n  (balance-right [node parent]\n    (BlackNode. (.-key parent) (.-val parent) (.-left parent) node nil))\n\n  (replace [node key val left right]\n    (BlackNode. key val left right nil))\n\n  (kv-reduce [node f init]\n    (tree-map-kv-reduce node f init))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] [])\n\n  ISequential\n  ISeqable\n  (-seq [node] (list key val))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    nil))\n\n  (-nth [node n not-found]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-lookup node k))\n\n  (-invoke [node k not-found]\n    (-lookup node k not-found)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [5045
                                                                 5145],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5045-L5145"},
                                                :full-name-encode "cljs.core_BlackNode",
                                                :history [["+"
                                                           "0.0-1211"]]},
                         "cljs.core/some->" {:ns "cljs.core",
                                             :name "some->",
                                             :signature ["[expr & forms]"],
                                             :history [["+"
                                                        "0.0-1798"]],
                                             :type "macro",
                                             :full-name-encode "cljs.core_some-_GT_",
                                             :source {:code "(defmacro some->\n  [expr & forms]\n  (let [g (gensym)\n        pstep (fn [step] `(if (nil? ~g) nil (-> ~g ~step)))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep forms))]\n       ~g)))",
                                                      :filename "clojure/src/clj/clojure/core.clj",
                                                      :lines [6813
                                                              6822],
                                                      :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L6813-L6822"},
                                             :full-name "cljs.core/some->",
                                             :clj-symbol "clojure.core/some->",
                                             :docstring "When expr is not nil, threads it into the first form (via ->),\nand when that result is not nil, through the next etc"},
                         "cljs.core/get-validator" {:ns "cljs.core",
                                                    :name "get-validator",
                                                    :signature ["[iref]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_get-validator",
                                                    :source {:code "(defn get-validator\n  [iref]\n  (.-validator iref))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [6610
                                                                     6613],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6610-L6613"},
                                                    :full-name "cljs.core/get-validator",
                                                    :clj-symbol "clojure.core/get-validator",
                                                    :docstring "Gets the validator-fn for a var/ref/agent/atom."},
                         "cljs.core/coll?" {:return-type boolean,
                                            :ns "cljs.core",
                                            :name "coll?",
                                            :signature ["[x]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_coll_QMARK_",
                                            :source {:code "(defn ^boolean coll?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ICollection x)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [998 1003],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L998-L1003"},
                                            :full-name "cljs.core/coll?",
                                            :clj-symbol "clojure.core/coll?",
                                            :docstring "Returns true if x satisfies ICollection"},
                         "cljs.core/unchecked-negate-int" {:ns "cljs.core",
                                                           :name "unchecked-negate-int",
                                                           :signature ["[x]"],
                                                           :shadowed-sources ({:code "(defmacro unchecked-negate-int\n  ([x] `(- ~x)))",
                                                                               :filename "clojurescript/src/clj/cljs/core.clj",
                                                                               :lines [311
                                                                                       312],
                                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L311-L312"}),
                                                           :history [["+"
                                                                      "0.0-1798"]],
                                                           :type "function",
                                                           :full-name-encode "cljs.core_unchecked-negate-int",
                                                           :source {:code "(defn unchecked-negate-int [x]\n  (cljs.core/unchecked-negate-int x))",
                                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                    :lines [1479
                                                                            1480],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1479-L1480"},
                                                           :full-name "cljs.core/unchecked-negate-int",
                                                           :clj-symbol "clojure.core/unchecked-negate-int"},
                         "cljs.core/bit-or" {:ns "cljs.core",
                                             :name "bit-or",
                                             :signature ["[x y]"],
                                             :shadowed-sources ({:code "(defmacro bit-or\n  ([x y] (list 'js* \"(~{} | ~{})\" x y))\n  ([x y & more] `(bit-or (bit-or ~x ~y) ~@more)))",
                                                                 :filename "clojurescript/src/clj/cljs/core.clj",
                                                                 :lines [409
                                                                         411],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L409-L411"}),
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_bit-or",
                                             :source {:code "(defn bit-or\n  [x y] (cljs.core/bit-or x y))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1574
                                                              1576],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1574-L1576"},
                                             :full-name "cljs.core/bit-or",
                                             :clj-symbol "clojure.core/bit-or",
                                             :docstring "Bitwise or"},
                         "cljs.core/nfirst" {:ns "cljs.core",
                                             :name "nfirst",
                                             :signature ["[coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_nfirst",
                                             :source {:code "(defn nfirst\n  [coll]\n  (next (first coll)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [734 737],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L734-L737"},
                                             :full-name "cljs.core/nfirst",
                                             :clj-symbol "clojure.core/nfirst",
                                             :docstring "Same as (next (first x))"},
                         "cljs.core/keep" {:ns "cljs.core",
                                           :name "keep",
                                           :signature ["[f coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_keep",
                                           :source {:code "(defn keep\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n            (let [x (f (-nth c i))]\n              (when-not (nil? x)\n                (chunk-append b x))))\n          (chunk-cons (chunk b) (keep f (chunk-rest s))))\n        (let [x (f (first s))]\n          (if (nil? x)\n            (keep f (rest s))\n            (cons x (keep f (rest s))))))))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2526 2545],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2526-L2545"},
                                           :full-name "cljs.core/keep",
                                           :clj-symbol "clojure.core/keep",
                                           :docstring "Returns a lazy sequence of the non-nil results of (f item). Note,\nthis means false return values will be included.  f must be free of\nside-effects."},
                         "cljs.core/take" {:ns "cljs.core",
                                           :name "take",
                                           :signature ["[n coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_take",
                                           :source {:code "(defn take\n  [n coll]\n  (lazy-seq\n   (when (pos? n)\n     (when-let [s (seq coll)]\n      (cons (first s) (take (dec n) (rest s)))))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2685 2692],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2685-L2692"},
                                           :full-name "cljs.core/take",
                                           :clj-symbol "clojure.core/take",
                                           :docstring "Returns a lazy sequence of the first n items in coll, or all items if\nthere are fewer than n."},
                         "cljs.core/cond" {:ns "cljs.core",
                                           :name "cond",
                                           :signature ["[& clauses]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_cond",
                                           :source {:code "(defmacro cond\n  [& clauses]\n    (when clauses\n      (list 'if (first clauses)\n            (if (next clauses)\n                (second clauses)\n                (throw (IllegalArgumentException.\n                         \"cond requires an even number of forms\")))\n            (cons 'clojure.core/cond (next (next clauses))))))",
                                                    :filename "clojure/src/clj/clojure/core.clj",
                                                    :lines [551 564],
                                                    :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L551-L564"},
                                           :full-name "cljs.core/cond",
                                           :clj-symbol "clojure.core/cond",
                                           :docstring "Takes a set of test/expr pairs. It evaluates each test one at a\ntime.  If a test returns logical true, cond evaluates and returns\nthe value of the corresponding expr and doesn't evaluate any of the\nother tests or exprs. (cond) returns nil."},
                         "cljs.core/bit-and" {:ns "cljs.core",
                                              :name "bit-and",
                                              :signature ["[x y]"],
                                              :shadowed-sources ({:code "(defmacro bit-and\n  ([x y] (list 'js* \"(~{} & ~{})\" x y))\n  ([x y & more] `(bit-and (bit-and ~x ~y) ~@more)))",
                                                                  :filename "clojurescript/src/clj/cljs/core.clj",
                                                                  :lines [400
                                                                          402],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L400-L402"}),
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_bit-and",
                                              :source {:code "(defn bit-and\n  [x y] (cljs.core/bit-and x y))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1570
                                                               1572],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1570-L1572"},
                                              :full-name "cljs.core/bit-and",
                                              :clj-symbol "clojure.core/bit-and",
                                              :docstring "Bitwise and"},
                         "cljs.core/PersistentArrayMap" {:full-name "cljs.core/PersistentArrayMap",
                                                         :ns "cljs.core",
                                                         :name "PersistentArrayMap",
                                                         :type "type",
                                                         :signature ["[meta cnt arr __hash]"],
                                                         :source {:code "(deftype PersistentArrayMap [meta cnt arr ^:mutable __hash]\n  IWithMeta\n  (-with-meta [coll meta] (PersistentArrayMap. meta cnt arr __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj coll entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta cljs.core.PersistentArrayMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? cnt)\n      (let [len (alength arr)\n            array-map-seq\n            (fn array-map-seq [i]\n              (lazy-seq\n               (when (< i len)\n                 (cons [(aget arr i) (aget arr (inc i))]\n                       (array-map-seq (+ i 2))))))]\n        (array-map-seq 0))))\n\n  ICounted\n  (-count [coll] cnt)\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (let [idx (array-map-index-of coll k)]\n      (if (== idx -1)\n        not-found\n        (aget arr (inc idx)))))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [idx (array-map-index-of coll k)]\n      (cond\n        (== idx -1)\n        (if (< cnt cljs.core.PersistentArrayMap/HASHMAP_THRESHOLD)\n          (let [arr (array-map-extend-kv coll k v)]\n            (PersistentArrayMap. meta (inc cnt) arr nil))\n          (-> (into cljs.core.PersistentHashMap/EMPTY coll)\n            (-assoc k v)\n            (-with-meta meta)))\n\n        (identical? v (aget arr (inc idx)))\n        coll\n\n        :else\n        (let [arr (doto (aclone arr)\n                    (aset (inc idx) v))]\n          (PersistentArrayMap. meta cnt arr nil)))))\n\n  (-contains-key? [coll k]\n    (not (== (array-map-index-of coll k) -1)))\n\n  IMap\n  (-dissoc [coll k]\n    (let [idx (array-map-index-of coll k)]\n      (if (>= idx 0)\n        (let [len     (alength arr)\n              new-len (- len 2)]\n          (if (zero? new-len)\n            (-empty coll)\n            (let [new-arr (make-array new-len)]\n              (loop [s 0 d 0]\n                (cond\n                  (>= s len) (PersistentArrayMap. meta (dec cnt) new-arr nil)\n                  (= k (aget arr s)) (recur (+ s 2) d)\n                  :else (do (aset new-arr d (aget arr s))\n                            (aset new-arr (inc d) (aget arr (inc s)))\n                            (recur (+ s 2) (+ d 2))))))))\n        coll)))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [len (alength arr)]\n      (loop [i 0 init init]\n        (if (< i len)\n          (let [init (f init (aget arr i) (aget arr (inc i)))]\n            (if (reduced? init)\n              @init\n              (recur (+ i 2) init)))\n          init))))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientArrayMap. (js-obj) (alength arr) (aclone arr))))",
                                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                  :lines [3878
                                                                          3986],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L3878-L3986"},
                                                         :full-name-encode "cljs.core_PersistentArrayMap",
                                                         :history [["+"
                                                                    "0.0-1211"]]},
                         "clojure.browser.event/unique-event-id" {:full-name "clojure.browser.event/unique-event-id",
                                                                  :ns "clojure.browser.event",
                                                                  :name "unique-event-id",
                                                                  :type "function",
                                                                  :signature ["[event-type]"],
                                                                  :source {:code "(defn unique-event-id [event-type])",
                                                                           :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                           :lines [92
                                                                                   92],
                                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/event.cljs#L92-L92"},
                                                                  :full-name-encode "clojure.browser.event_unique-event-id",
                                                                  :history [["+"
                                                                             "0.0-927"]]},
                         "clojure.set/project" {:ns "clojure.set",
                                                :name "project",
                                                :signature ["[xrel ks]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.set_project",
                                                :source {:code "(defn project\n  [xrel ks]\n    (set (map #(select-keys % ks) xrel)))",
                                                         :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                         :lines [67
                                                                 70],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/set.cljs#L67-L70"},
                                                :full-name "clojure.set/project",
                                                :clj-symbol "clojure.set/project",
                                                :docstring "Returns a rel of the elements of xrel with only the keys in ks"},
                         "cljs.core/int" {:ns "cljs.core",
                                          :name "int",
                                          :signature ["[x]"],
                                          :shadowed-sources ({:code "(defmacro int [x]\n  `(bit-or ~x 0))",
                                                              :filename "clojurescript/src/clj/cljs/core.clj",
                                                              :lines [413
                                                                      414],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L413-L414"}),
                                          :history [["+" "0.0-1211"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_int",
                                          :source {:code "(defn int\n  [x]\n  (bit-or x 0))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [1506 1509],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1506-L1509"},
                                          :full-name "cljs.core/int",
                                          :clj-symbol "clojure.core/int",
                                          :docstring "Coerce to int by stripping decimal places."},
                         "special/js*" {:full-name "special/js*",
                                        :ns "special",
                                        :name "js*",
                                        :type "special form",
                                        :source {:code "(defmethod parse 'js*\n  [op env [_ jsform & args :as form] _]\n  (assert (string? jsform))\n  (if args\n    (disallowing-recur\n     (let [seg (fn seg [^String s]\n                 (let [idx (.indexOf s \"~{\")]\n                   (if (= -1 idx)\n                     (list s)\n                     (let [end (.indexOf s \"}\" idx)]\n                       (cons (subs s 0 idx) (seg (subs s (inc end))))))))\n           enve (assoc env :context :expr)\n           argexprs (vec (map #(analyze enve %) args))]\n       {:env env :op :js :segs (seg jsform) :args argexprs\n        :tag (-> form meta :tag) :form form :children argexprs}))\n    (let [interp (fn interp [^String s]\n                   (let [idx (.indexOf s \"~{\")]\n                     (if (= -1 idx)\n                       (list s)\n                       (let [end (.indexOf s \"}\" idx)\n                             inner (:name (resolve-existing-var env (symbol (subs s (+ 2 idx) end))))]\n                         (cons (subs s 0 idx) (cons inner (interp (subs s (inc end)))))))))]\n      {:env env :op :js :form form :code (apply str (interp jsform))\n       :tag (-> form meta :tag)})))",
                                                 :filename "clojurescript/src/clj/cljs/analyzer.clj",
                                                 :lines [826 849],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/analyzer.clj#L826-L849"},
                                        :full-name-encode "special_js_STAR_",
                                        :history [["+" "0.0-927"]]},
                         "clojure.reflect/macroexpand" {:full-name "clojure.reflect/macroexpand",
                                                        :ns "clojure.reflect",
                                                        :name "macroexpand",
                                                        :docstring "Queries the reflection api with a quoted macro form, then calls the\ncallback function with the macroexpanded form, as a string.",
                                                        :type "function",
                                                        :signature ["[form]"],
                                                        :source {:code "(defn macroexpand\n  [form]\n  (query-reflection (str \"macroform=\" (js/encodeURIComponent (str form))) println))",
                                                                 :filename "clojurescript/src/cljs/clojure/reflect.cljs",
                                                                 :lines [32
                                                                         36],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/reflect.cljs#L32-L36"},
                                                        :full-name-encode "clojure.reflect_macroexpand",
                                                        :history [["+"
                                                                   "0.0-1503"]]},
                         "clojure.string/trim-newline" {:ns "clojure.string",
                                                        :name "trim-newline",
                                                        :signature ["[s]"],
                                                        :history [["+"
                                                                   "0.0-927"]],
                                                        :type "function",
                                                        :full-name-encode "clojure.string_trim-newline",
                                                        :source {:code "(defn trim-newline\n  [s]\n  (loop [index (.-length s)]\n    (if (zero? index)\n      \"\"\n      (let [ch (get s (dec index))]\n        (if (or (= ch \\newline) (= ch \\return))\n          (recur (dec index))\n          (.substring s 0 index))))))",
                                                                 :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                                 :lines [121
                                                                         131],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/string.cljs#L121-L131"},
                                                        :full-name "clojure.string/trim-newline",
                                                        :clj-symbol "clojure.string/trim-newline",
                                                        :docstring "Removes all trailing newline \\n or return \\r characters from\nstring.  Similar to Perl's chomp."},
                         "specialrepl/in-ns" {:full-name "specialrepl/in-ns",
                                              :ns "specialrepl",
                                              :name "in-ns",
                                              :type "special form (repl)",
                                              :source {:code "(def default-special-fns\n  (let [load-file-fn (fn [repl-env file] (load-file repl-env file))]\n    {'in-ns (fn [_ quoted-ns]\n              (let [ns-name (second quoted-ns)]\n                (when-not (ana/get-namespace ns-name)\n                  (ana/set-namespace ns-name {:name ns-name}))\n                (set! ana/*cljs-ns* ns-name)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace (fn [repl-env ns] (load-namespace repl-env ns))}))",
                                                       :filename "clojurescript/src/clj/cljs/repl.clj",
                                                       :lines [142
                                                               151],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/repl.clj#L142-L151"},
                                              :full-name-encode "specialrepl_in-ns",
                                              :clj-symbol "clojure.core/in-ns",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "special/let*" {:full-name "special/let*",
                                         :ns "special",
                                         :name "let*",
                                         :type "special form",
                                         :source {:code "(defmethod parse 'let*\n  [op encl-env form _]\n  (analyze-let encl-env form false))",
                                                  :filename "clojurescript/src/clj/cljs/analyzer.clj",
                                                  :lines [526 528],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/analyzer.clj#L526-L528"},
                                         :full-name-encode "special_let_STAR_",
                                         :history [["+" "0.0-927"]]},
                         "cljs.core/pr-seq-writer" {:full-name "cljs.core/pr-seq-writer",
                                                    :ns "cljs.core",
                                                    :name "pr-seq-writer",
                                                    :type "function",
                                                    :signature ["[objs writer opts]"],
                                                    :source {:code "(defn pr-seq-writer [objs writer opts]\n  (pr-writer (first objs) writer opts)\n  (doseq [obj (next objs)]\n    (-write writer \" \")\n    (pr-writer obj writer opts)))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [6319
                                                                     6323],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6319-L6323"},
                                                    :full-name-encode "cljs.core_pr-seq-writer",
                                                    :history [["+"
                                                               "0.0-1503"]]},
                         "special/throw" {:full-name "special/throw",
                                          :ns "special",
                                          :name "throw",
                                          :type "special form",
                                          :source {:code "(defmethod parse 'throw\n  [op env [_ throw :as form] name]\n  (let [throw-expr (disallowing-recur (analyze (assoc env :context :expr) throw))]\n    {:env env :op :throw :form form\n     :throw throw-expr\n     :children [throw-expr]}))",
                                                   :filename "clojurescript/src/clj/cljs/analyzer.clj",
                                                   :lines [255 260],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/analyzer.clj#L255-L260"},
                                          :full-name-encode "special_throw",
                                          :clj-symbol "clojure.core/throw",
                                          :history [["+" "0.0-927"]]},
                         "cljs.core/chunk-cons" {:full-name "cljs.core/chunk-cons",
                                                 :ns "cljs.core",
                                                 :name "chunk-cons",
                                                 :type "function",
                                                 :signature ["[chunk rest]"],
                                                 :source {:code "(defn chunk-cons [chunk rest]\n  (if (zero? (-count chunk))\n    rest\n    (ChunkedCons. chunk rest nil nil)))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2111
                                                                  2114],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2111-L2114"},
                                                 :full-name-encode "cljs.core_chunk-cons",
                                                 :history [["+"
                                                            "0.0-1424"]]},
                         "clojure.zip/insert-left" {:ns "clojure.zip",
                                                    :name "insert-left",
                                                    :signature ["[loc item]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "clojure.zip_insert-left",
                                                    :source {:code "(defn insert-left\n  [loc item]\n    (let [[node {l :l :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :l (conj l item) :changed? true)] (meta loc)))))",
                                                             :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                             :lines [165
                                                                     172],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L165-L172"},
                                                    :full-name "clojure.zip/insert-left",
                                                    :clj-symbol "clojure.zip/insert-left",
                                                    :docstring "Inserts the item as the left sibling of the node at this loc,\nwithout moving"},
                         "cljs.core/true?" {:return-type boolean,
                                            :ns "cljs.core",
                                            :name "true?",
                                            :signature ["[x]"],
                                            :shadowed-sources ({:code "(defmacro true? [x]\n  (bool-expr (list 'js* \"~{} === true\" x)))",
                                                                :filename "clojurescript/src/clj/cljs/core.clj",
                                                                :lines [227
                                                                        228],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L227-L228"}),
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_true_QMARK_",
                                            :source {:code "(defn ^boolean true?\n  [x] (cljs.core/true? x))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [1081
                                                             1083],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1081-L1083"},
                                            :full-name "cljs.core/true?",
                                            :clj-symbol "clojure.core/true?",
                                            :docstring "Returns true if x is the value true, false otherwise."},
                         "cljs.core/unchecked-substract-int" {:full-name "cljs.core/unchecked-substract-int",
                                                              :ns "cljs.core",
                                                              :name "unchecked-substract-int",
                                                              :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result.",
                                                              :type "function",
                                                              :signature ["[x]"
                                                                          "[x y]"
                                                                          "[x y & more]"],
                                                              :source {:code "(defn unchecked-substract-int\n  ([x] (cljs.core/unchecked-subtract-int x))\n  ([x y] (cljs.core/unchecked-subtract-int x y))\n  ([x y & more] (reduce unchecked-substract-int (cljs.core/unchecked-subtract-int x y) more)))",
                                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                       :lines [1494
                                                                               1499],
                                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1494-L1499"},
                                                              :full-name-encode "cljs.core_unchecked-substract-int",
                                                              :history [["+"
                                                                         "0.0-1798"]]},
                         "clojure.browser.net/xpc-connection" {:full-name "clojure.browser.net/xpc-connection",
                                                               :ns "clojure.browser.net",
                                                               :name "xpc-connection",
                                                               :docstring "When passed with a config hash-map, returns a parent\nCrossPageChannel object. Keys in the config hash map are downcased\nversions of the goog.net.xpc.CfgFields enum keys,\ne.g. goog.net.xpc.CfgFields.PEER_URI becomes :peer_uri in the config\nhash.\n\nWhen passed with no args, creates a child CrossPageChannel object,\nand the config is automatically taken from the URL param 'xpc', as\nper the CrossPageChannel API.",
                                                               :type "function",
                                                               :signature ["[]"
                                                                           "[config]"],
                                                               :source {:code "(defn xpc-connection\n  ([]\n     (when-let [config (.getParameterValue\n                        (goog.Uri. (.-href (.-location js/window)))\n                        \"xpc\")]\n       (goog.net.xpc.CrossPageChannel. (gjson/parse config))))\n  ([config]\n     (goog.net.xpc.CrossPageChannel.\n      (reduce (fn [sum [k v]]\n                (if-let [field (get xpc-config-fields k)]\n                  (doto sum (aset field v))\n                  sum))\n              (js-obj)\n              config))))",
                                                                        :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                        :lines [118
                                                                                140],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/net.cljs#L118-L140"},
                                                               :full-name-encode "clojure.browser.net_xpc-connection",
                                                               :history [["+"
                                                                          "0.0-927"]]},
                         "cljs.core/not" {:return-type boolean,
                                          :ns "cljs.core",
                                          :name "not",
                                          :signature ["[x]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_not",
                                          :source {:code "(defn ^boolean not\n  [x] (if x false true))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [62 64],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L62-L64"},
                                          :full-name "cljs.core/not",
                                          :clj-symbol "clojure.core/not",
                                          :docstring "Returns true if x is logical false, false otherwise."},
                         "cljs.core/js-obj" {:full-name "cljs.core/js-obj",
                                             :ns "cljs.core",
                                             :name "js-obj",
                                             :type "function",
                                             :signature ["[]"
                                                         "[& keyvals]"],
                                             :source {:code "(defn js-obj\n  ([]\n     (cljs.core/js-obj))\n  ([& keyvals]\n     (apply gobject/create keyvals)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1043
                                                              1047],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1043-L1047"},
                                             :full-name-encode "cljs.core_js-obj",
                                             :shadowed-sources ({:code "(defmacro js-obj [& rest]\n  (let [kvs-str (->> (repeat \"~{}:~{}\")\n                     (take (quot (count rest) 2))\n                     (interpose \",\")\n                     (apply core/str))]\n    (concat\n     (list 'js* (core/str \"{\" kvs-str \"}\"))\n     rest)))",
                                                                 :filename "clojurescript/src/clj/cljs/core.clj",
                                                                 :lines [1163
                                                                         1170],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L1163-L1170"}),
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/complement" {:return-type boolean,
                                                 :ns "cljs.core",
                                                 :name "complement",
                                                 :signature ["[f]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_complement",
                                                 :source {:code "(defn ^boolean complement\n  [f]\n  (fn\n    ([] (not (f)))\n    ([x] (not (f x)))\n    ([x y] (not (f x y)))\n    ([x y & zs] (not (apply f x y zs)))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2428
                                                                  2436],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2428-L2436"},
                                                 :full-name "cljs.core/complement",
                                                 :clj-symbol "clojure.core/complement",
                                                 :docstring "Takes a fn f and returns a fn that takes the same arguments as f,\nhas the same effects, if any, and returns the opposite truth value."},
                         "cljs.core/spread" {:full-name "cljs.core/spread",
                                             :ns "cljs.core",
                                             :name "spread",
                                             :type "function",
                                             :signature ["[arglist]"],
                                             :source {:code "(defn spread\n  [arglist]\n  (cond\n   (nil? arglist) nil\n   (nil? (next arglist)) (seq (first arglist))\n   :else (cons (first arglist)\n               (spread (next arglist)))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2248
                                                              2254],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2248-L2254"},
                                             :full-name-encode "cljs.core_spread",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/unchecked-double" {:ns "cljs.core",
                                                       :name "unchecked-double",
                                                       :signature ["[x]"],
                                                       :shadowed-sources ({:code "(defmacro unchecked-double [x] x)",
                                                                           :filename "clojurescript/src/clj/cljs/core.clj",
                                                                           :lines [279
                                                                                   279],
                                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L279-L279"}),
                                                       :history [["+"
                                                                  "0.0-1798"]],
                                                       :type "function",
                                                       :full-name-encode "cljs.core_unchecked-double",
                                                       :source {:code "(defn unchecked-double [x] x)",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [1427
                                                                        1427],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1427-L1427"},
                                                       :full-name "cljs.core/unchecked-double",
                                                       :clj-symbol "clojure.core/unchecked-double"},
                         "cljs.core/keyword" {:ns "cljs.core",
                                              :name "keyword",
                                              :signature ["[name]"
                                                          "[ns name]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_keyword",
                                              :source {:code "(defn keyword\n  ([name] (cond (keyword? name) name\n                (symbol? name) (str* \"\\uFDD0\" \":\" (subs name 2))\n                :else (str* \"\\uFDD0\" \":\" name)))\n  ([ns name] (keyword (str* ns \"/\" name))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1708
                                                               1714],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1708-L1714"},
                                              :full-name "cljs.core/keyword",
                                              :clj-symbol "clojure.core/keyword",
                                              :docstring "Returns a Keyword with the given namespace and name.  Do not use :\nin the keyword strings, it will be added automatically."},
                         "cljs.core/sort" {:ns "cljs.core",
                                           :name "sort",
                                           :signature ["[coll]"
                                                       "[comp coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_sort",
                                           :source {:code "(defn sort\n  ([coll]\n   (sort compare coll))\n  ([comp coll]\n   (if (seq coll)\n     (let [a (to-array coll)]\n       ;; matching Clojure's stable sort, though docs don't promise it\n       (garray/stableSort a (fn->comparator comp))\n       (seq a))\n     ())))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1216 1228],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1216-L1228"},
                                           :full-name "cljs.core/sort",
                                           :clj-symbol "clojure.core/sort",
                                           :docstring "Returns a sorted sequence of the items in coll. Comp can be\nboolean-valued comparison funcion, or a -/0/+ valued comparator.\nComp defaults to compare."},
                         "clojure.string/trim" {:ns "clojure.string",
                                                :name "trim",
                                                :signature ["[s]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.string_trim",
                                                :source {:code "(defn trim\n    [s]\n    (gstring/trim s))",
                                                         :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                         :lines [106
                                                                 109],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/string.cljs#L106-L109"},
                                                :full-name "clojure.string/trim",
                                                :clj-symbol "clojure.string/trim",
                                                :docstring "Removes whitespace from both ends of string."},
                         "cljs.core/meta" {:ns "cljs.core",
                                           :name "meta",
                                           :signature ["[o]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_meta",
                                           :source {:code "(defn meta\n  [o]\n  (when (satisfies? IMeta o)\n    (-meta o)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [933 937],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L933-L937"},
                                           :full-name "cljs.core/meta",
                                           :clj-symbol "clojure.core/meta",
                                           :docstring "Returns the metadata of obj, returns nil if there is no metadata."},
                         "clojure.core.reducers/monoid" {:ns "clojure.core.reducers",
                                                         :name "monoid",
                                                         :signature ["[op ctor]"],
                                                         :history [["+"
                                                                    "0.0-1236"]],
                                                         :type "function",
                                                         :full-name-encode "clojure.core.reducers_monoid",
                                                         :source {:code "(defn monoid\n  [op ctor]\n  (fn m\n    ([] (ctor))\n    ([a b] (op a b))))",
                                                                  :filename "clojurescript/src/cljs/clojure/core/reducers.cljs",
                                                                  :lines [235
                                                                          242],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/core/reducers.cljs#L235-L242"},
                                                         :full-name "clojure.core.reducers/monoid",
                                                         :clj-symbol "clojure.core.reducers/monoid",
                                                         :docstring "Builds a combining fn out of the supplied operator and identity\nconstructor. op must be associative and ctor called with no args\nmust return an identity value for it."},
                         "cljs.core/time" {:ns "cljs.core",
                                           :name "time",
                                           :signature ["[expr]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_time",
                                           :source {:code "(defmacro time\n  [expr]\n  `(let [start# (.getTime (js/Date.))\n         ret# ~expr]\n     (prn (core/str \"Elapsed time: \" (- (.getTime (js/Date.)) start#) \" msecs\"))\n     ret#))",
                                                    :filename "clojurescript/src/clj/cljs/core.clj",
                                                    :lines [1276 1282],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L1276-L1282"},
                                           :full-name "cljs.core/time",
                                           :clj-symbol "clojure.core/time",
                                           :docstring "Evaluates expr and prints the time it took. Returns the value of expr."},
                         "cljs.core/boolean" {:return-type boolean,
                                              :ns "cljs.core",
                                              :name "boolean",
                                              :signature ["[x]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_boolean",
                                              :source {:code "(defn ^boolean boolean [x]\n  (if x true false))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1100
                                                               1101],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1100-L1101"},
                                              :full-name "cljs.core/boolean",
                                              :clj-symbol "clojure.core/boolean"},
                         "cljs.reader/read-token" {:full-name "cljs.reader/read-token",
                                                   :ns "cljs.reader",
                                                   :name "read-token",
                                                   :type "function",
                                                   :signature ["[rdr initch]"],
                                                   :source {:code "(defn read-token\n  [rdr initch]\n  (loop [sb (gstring/StringBuffer. initch)\n         ch (read-char rdr)]\n    (if (or (nil? ch)\n            (whitespace? ch)\n            (macro-terminating? ch))\n      (do (unread rdr ch) (. sb (toString)))\n      (recur (do (.append sb ch) sb) (read-char rdr)))))",
                                                            :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                            :lines [80
                                                                    88],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L80-L88"},
                                                   :full-name-encode "cljs.reader_read-token",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "cljs.core/update-in" {:ns "cljs.core",
                                                :name "update-in",
                                                :signature ["[m [k & ks] f]"
                                                            "[m [k & ks] f a]"
                                                            "[m [k & ks] f a b]"
                                                            "[m [k & ks] f a b c]"
                                                            "[m [k & ks] f a b c & args]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_update-in",
                                                :source {:code "(defn update-in\n  ([m [k & ks] f]\n   (if ks\n     (assoc m k (update-in (get m k) ks f))\n     (assoc m k (f (get m k)))))\n  ([m [k & ks] f a]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a))\n     (assoc m k (f (get m k) a))))\n  ([m [k & ks] f a b]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a b))\n     (assoc m k (f (get m k) a b))))\n  ([m [k & ks] f a b c]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a b c))\n     (assoc m k (f (get m k) a b c))))\n  ([m [k & ks] f a b c & args]\n   (if ks\n     (assoc m k (apply update-in (get m k) ks f a b c args))\n     (assoc m k (apply f (get m k) a b c args)))))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [2936
                                                                 2961],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2936-L2961"},
                                                :full-name "cljs.core/update-in",
                                                :clj-symbol "clojure.core/update-in",
                                                :docstring "'Updates' a value in a nested associative structure, where ks is a\nsequence of keys and f is a function that will take the old value\nand any supplied args and return the new value, and returns a new\nnested structure.  If any levels do not exist, hash-maps will be\ncreated."},
                         "cljs.core/map-indexed" {:ns "cljs.core",
                                                  :name "map-indexed",
                                                  :signature ["[f coll]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_map-indexed",
                                                  :source {:code "(defn map-indexed\n  [f coll]\n  (letfn [(mapi [idx coll]\n            (lazy-seq\n             (when-let [s (seq coll)]\n               (if (chunked-seq? s)\n                 (let [c (chunk-first s)\n                       size (count c)\n                       b (chunk-buffer size)]\n                   (dotimes [i size]\n                     (chunk-append b (f (+ idx i) (-nth c i))))\n                   (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))\n                 (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]\n    (mapi 0 coll)))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [2507
                                                                   2524],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2507-L2524"},
                                                  :full-name "cljs.core/map-indexed",
                                                  :clj-symbol "clojure.core/map-indexed",
                                                  :docstring "Returns a lazy sequence consisting of the result of applying f to 0\nand the first item of coll, followed by applying f to 1 and the second\nitem in coll, etc, until coll is exhausted. Thus function f should\naccept 2 arguments, index and item."},
                         "cljs.core/printf" {:ns "cljs.core",
                                             :name "printf",
                                             :signature ["[fmt & args]"],
                                             :history [["+"
                                                        "0.0-1443"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_printf",
                                             :source {:code "(defn printf\n  [fmt & args]\n  (print (apply format fmt args)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [6418
                                                              6421],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6418-L6421"},
                                             :full-name "cljs.core/printf",
                                             :clj-symbol "clojure.core/printf",
                                             :docstring "Prints formatted output, as per format"},
                         "clojure.core.reducers/map" {:ns "clojure.core.reducers",
                                                      :name "map",
                                                      :signature ["[f]"
                                                                  "[f coll]"],
                                                      :history [["+"
                                                                 "0.0-1236"]],
                                                      :type "function",
                                                      :full-name-encode "clojure.core.reducers_map",
                                                      :source {:code "(defcurried map\n  \"Applies f to every value in the reduction of coll. Foldable.\"\n  {}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (f1 ret (f k v)))))))",
                                                               :filename "clojurescript/src/cljs/clojure/core/reducers.cljs",
                                                               :lines [87
                                                                       95],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/core/reducers.cljs#L87-L95"},
                                                      :full-name "clojure.core.reducers/map",
                                                      :clj-symbol "clojure.core.reducers/map",
                                                      :docstring "Applies f to every value in the reduction of coll. Foldable."},
                         "cljs.core/IStack" {:ns "cljs.core",
                                             :name "IStack",
                                             :type "protocol",
                                             :full-name-encode "cljs.core_IStack",
                                             :source {:code "(defprotocol IStack\n  (-peek [coll])\n  (-pop [coll]))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [220 222],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L220-L222"},
                                             :methods [{:name "-peek",
                                                        :signature ["[coll]"],
                                                        :docstring nil}
                                                       {:name "-pop",
                                                        :signature ["[coll]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/IStack",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/ISorted" {:ns "cljs.core",
                                              :name "ISorted",
                                              :type "protocol",
                                              :full-name-encode "cljs.core_ISorted",
                                              :source {:code "(defprotocol ISorted\n  (-sorted-seq [coll ascending?])\n  (-sorted-seq-from [coll k ascending?])\n  (-entry-key [coll entry])\n  (-comparator [coll]))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [266
                                                               270],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L266-L270"},
                                              :methods [{:name "-sorted-seq",
                                                         :signature ["[coll ascending?]"],
                                                         :docstring nil}
                                                        {:name "-sorted-seq-from",
                                                         :signature ["[coll k ascending?]"],
                                                         :docstring nil}
                                                        {:name "-entry-key",
                                                         :signature ["[coll entry]"],
                                                         :docstring nil}
                                                        {:name "-comparator",
                                                         :signature ["[coll]"],
                                                         :docstring nil}],
                                              :full-name "cljs.core/ISorted",
                                              :history [["+"
                                                         "0.0-1211"]]},
                         "cljs.core/IIndexed" {:ns "cljs.core",
                                               :name "IIndexed",
                                               :type "protocol",
                                               :full-name-encode "cljs.core_IIndexed",
                                               :source {:code "(defprotocol IIndexed\n  (-nth [coll n] [coll n not-found]))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [189
                                                                190],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L189-L190"},
                                               :methods [{:name "-nth",
                                                          :signature ["[coll n]"
                                                                      "[coll n not-found]"],
                                                          :docstring nil}],
                                               :full-name "cljs.core/IIndexed",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "clojure.browser.repl/repl-print" {:full-name "clojure.browser.repl/repl-print",
                                                            :ns "clojure.browser.repl",
                                                            :name "repl-print",
                                                            :type "function",
                                                            :signature ["[data]"],
                                                            :source {:code "(defn repl-print [data]\n  (if-let [conn @xpc-connection]\n    (net/transmit conn :print (pr-str data))))",
                                                                     :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                     :lines [23
                                                                             25],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/repl.cljs#L23-L25"},
                                                            :full-name-encode "clojure.browser.repl_repl-print",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "clojure.browser.net/xpc-config-fields" {:full-name "clojure.browser.net/xpc-config-fields",
                                                                  :ns "clojure.browser.net",
                                                                  :name "xpc-config-fields",
                                                                  :type "var",
                                                                  :source {:code "(def xpc-config-fields\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (. k (toLowerCase)))\n            v])\n         (js->clj goog.net.xpc.CfgFields))))",
                                                                           :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                           :lines [75
                                                                                   81],
                                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/net.cljs#L75-L81"},
                                                                  :full-name-encode "clojure.browser.net_xpc-config-fields",
                                                                  :history [["+"
                                                                             "0.0-927"]]},
                         "cljs.core/nnext" {:ns "cljs.core",
                                            :name "nnext",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_nnext",
                                            :source {:code "(defn nnext\n  [coll]\n  (next (next coll)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [744 747],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L744-L747"},
                                            :full-name "cljs.core/nnext",
                                            :clj-symbol "clojure.core/nnext",
                                            :docstring "Same as (next (next x))"},
                         "cljs.core/*print-meta*" {:full-name "cljs.core/*print-meta*",
                                                   :ns "cljs.core",
                                                   :name "*print-meta*",
                                                   :type "var",
                                                   :source {:code "(def *print-meta* false)",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [6362
                                                                    6362],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6362-L6362"},
                                                   :full-name-encode "cljs.core__STAR_print-meta_STAR_",
                                                   :clj-symbol "clojure.core/*print-meta*",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "cljs.reader/read-dispatch" {:full-name "cljs.reader/read-dispatch",
                                                      :ns "cljs.reader",
                                                      :name "read-dispatch",
                                                      :type "function",
                                                      :signature ["[rdr _]"],
                                                      :source {:code "(defn read-dispatch\n  [rdr _]\n  (let [ch (read-char rdr)\n        dm (dispatch-macros ch)]\n    (if dm\n      (dm rdr _)\n      (if-let [obj (maybe-read-tagged-type rdr ch)]\n        obj\n        (reader-error rdr \"No dispatch macro for \" ch)))))",
                                                               :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                               :lines [258
                                                                       266],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L258-L266"},
                                                      :full-name-encode "cljs.reader_read-dispatch",
                                                      :history [["+"
                                                                 "0.0-927"]]},
                         "cljs.core/distinct" {:ns "cljs.core",
                                               :name "distinct",
                                               :signature ["[coll]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_distinct",
                                               :source {:code "(defn distinct\n  [coll]\n  (let [step (fn step [xs seen]\n               (lazy-seq\n                ((fn [[f :as xs] seen]\n                   (when-let [s (seq xs)]\n                     (if (contains? seen f)\n                       (recur (rest s) seen)\n                       (cons f (step (rest s) (conj seen f))))))\n                 xs seen)))]\n    (step coll #{})))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [5850
                                                                5861],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5850-L5861"},
                                               :full-name "cljs.core/distinct",
                                               :clj-symbol "clojure.core/distinct",
                                               :docstring "Returns a lazy sequence of the elements of coll with duplicates removed"},
                         "cljs.reader/wrapping-reader" {:full-name "cljs.reader/wrapping-reader",
                                                        :ns "cljs.reader",
                                                        :name "wrapping-reader",
                                                        :type "function",
                                                        :signature ["[sym]"],
                                                        :source {:code "(defn wrapping-reader\n  [sym]\n  (fn [rdr _]\n    (list sym (read rdr true nil true))))",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [351
                                                                         354],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L351-L354"},
                                                        :full-name-encode "cljs.reader_wrapping-reader",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/double-array" {:full-name "cljs.core/double-array",
                                                   :ns "cljs.core",
                                                   :name "double-array",
                                                   :type "function",
                                                   :signature ["[size-or-seq]"
                                                               "[size init-val-or-seq]"],
                                                   :source {:code "(defn double-array\n  ([size-or-seq]\n     (cond\n      (number? size-or-seq) (double-array size-or-seq nil)\n      (seq? size-or-seq) (into-array size-or-seq)\n      :else (throw (js/Error. \"double-array called with something other than size or ISeq\"))))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [2198
                                                                    2217],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2198-L2217"},
                                                   :full-name-encode "cljs.core_double-array",
                                                   :clj-symbol "clojure.core/double-array",
                                                   :history [["+"
                                                              "0.0-1211"]]},
                         "cljs.core/prn" {:ns "cljs.core",
                                          :name "prn",
                                          :signature ["[& objs]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_prn",
                                          :source {:code "(defn prn\n  [& objs]\n  (pr-with-opts objs (pr-opts))\n  (newline (pr-opts)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [6412 6416],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6412-L6416"},
                                          :full-name "cljs.core/prn",
                                          :clj-symbol "clojure.core/prn",
                                          :docstring "Same as pr followed by (newline)."},
                         "cljs.core/chunked-seq" {:full-name "cljs.core/chunked-seq",
                                                  :ns "cljs.core",
                                                  :name "chunked-seq",
                                                  :type "function",
                                                  :signature ["[vec i off]"
                                                              "[vec node i off]"
                                                              "[vec node i off meta]"],
                                                  :source {:code "(defn chunked-seq\n  ([vec i off] (ChunkedSeq. vec (array-for vec i) i off nil nil))\n  ([vec node i off] (ChunkedSeq. vec node i off nil nil))\n  ([vec node i off meta]\n     (ChunkedSeq. vec node i off meta nil)))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [3277
                                                                   3281],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L3277-L3281"},
                                                  :full-name-encode "cljs.core_chunked-seq",
                                                  :history [["+"
                                                             "0.0-1424"]]},
                         "clojure.zip/leftmost" {:ns "clojure.zip",
                                                 :name "leftmost",
                                                 :signature ["[loc]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.zip_leftmost",
                                                 :source {:code "(defn leftmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path (seq l))\n        (with-meta [(first l) (assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))\n        loc)))",
                                                          :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                          :lines [157
                                                                  163],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L157-L163"},
                                                 :full-name "clojure.zip/leftmost",
                                                 :clj-symbol "clojure.zip/leftmost",
                                                 :docstring "Returns the loc of the leftmost sibling of the node at this loc, or self"},
                         "cljs.core/>=" {:return-type boolean,
                                         :ns "cljs.core",
                                         :name ">=",
                                         :signature ["[x]"
                                                     "[x y]"
                                                     "[x y & more]"],
                                         :shadowed-sources ({:code "(defmacro >=\n  ([x] true)\n  ([x y] (bool-expr (list 'js* \"(~{} >= ~{})\" x y)))\n  ([x y & more] `(and (>= ~x ~y) (>= ~y ~@more))))",
                                                             :filename "clojurescript/src/clj/cljs/core.clj",
                                                             :lines [359
                                                                     362],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L359-L362"}),
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core__GT__EQ_",
                                         :source {:code "(defn ^boolean >=\n  ([x] true)\n  ([x y] (cljs.core/>= x y))\n  ([x y & more]\n   (if (cljs.core/>= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/>= y (first more)))\n     false)))",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [1379 1389],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1379-L1389"},
                                         :full-name "cljs.core/>=",
                                         :clj-symbol "clojure.core/>=",
                                         :docstring "Returns non-nil if nums are in monotonically non-increasing order,\notherwise false."},
                         "cljs.reader/macros" {:full-name "cljs.reader/macros",
                                               :ns "cljs.reader",
                                               :name "macros",
                                               :type "function",
                                               :signature ["[c]"],
                                               :source {:code "(defn macros [c]\n  (cond\n   (identical? c \\\") read-string*\n   (identical? c \\:) read-keyword\n   (identical? c \\;) not-implemented ;; never hit this\n   (identical? c \\') (wrapping-reader 'quote)\n   (identical? c \\@) (wrapping-reader 'deref)\n   (identical? c \\^) read-meta\n   (identical? c \\`) not-implemented\n   (identical? c \\~) not-implemented\n   (identical? c \\() read-list\n   (identical? c \\)) read-unmatched-delimiter\n   (identical? c \\[) read-vector\n   (identical? c \\]) read-unmatched-delimiter\n   (identical? c \\{) read-map\n   (identical? c \\}) read-unmatched-delimiter\n   (identical? c \\\\) read-char\n   (identical? c \\%) not-implemented\n   (identical? c \\#) read-dispatch\n   :else nil))",
                                                        :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                        :lines [384
                                                                403],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L384-L403"},
                                               :full-name-encode "cljs.reader_macros",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/doseq" {:ns "cljs.core",
                                            :name "doseq",
                                            :signature ["[seq-exprs & body]"],
                                            :history [["+" "0.0-927"]],
                                            :type "macro",
                                            :full-name-encode "cljs.core_doseq",
                                            :source {:code "(defmacro doseq\n  [seq-exprs & body]\n  (assert-args doseq\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [err (fn [& msg] (throw (ex-info (apply core/str msg) {})))\n        step (fn step [recform exprs]\n               (if-not exprs\n                 [true `(do ~@body)]\n                 (let [k (first exprs)\n                       v (second exprs)\n\n                       seqsym (gensym \"seq__\")\n                       recform (if (keyword? k) recform `(recur (next ~seqsym) nil 0 0))\n                       steppair (step recform (nnext exprs))\n                       needrec (steppair 0)\n                       subform (steppair 1)]\n                   (cond\n                     (= k :let) [needrec `(let ~v ~subform)]\n                     (= k :while) [false `(when ~v\n                                            ~subform\n                                            ~@(when needrec [recform]))]\n                     (= k :when) [false `(if ~v\n                                           (do\n                                             ~subform\n                                             ~@(when needrec [recform]))\n                                           ~recform)]\n                     (keyword? k) (err \"Invalid 'doseq' keyword\" k)\n                     :else (let [chunksym (with-meta (gensym \"chunk__\")\n                                            {:tag 'not-native})\n                                 countsym (gensym \"count__\")\n                                 isym     (gensym \"i__\")\n                                 recform-chunk  `(recur ~seqsym ~chunksym ~countsym (unchecked-inc ~isym))\n                                 steppair-chunk (step recform-chunk (nnext exprs))\n                                 subform-chunk  (steppair-chunk 1)]\n                             [true `(loop [~seqsym   (seq ~v)\n                                           ~chunksym nil\n                                           ~countsym 0\n                                           ~isym     0]\n                                      (if (coercive-boolean (< ~isym ~countsym))\n                                        (let [~k (-nth ~chunksym ~isym)]\n                                          ~subform-chunk\n                                          ~@(when needrec [recform-chunk]))\n                                        (when-let [~seqsym (seq ~seqsym)]\n                                          (if (chunked-seq? ~seqsym)\n                                            (let [c# (chunk-first ~seqsym)]\n                                              (recur (chunk-rest ~seqsym) c#\n                                                     (count c#) 0))\n                                            (let [~k (first ~seqsym)]\n                                              ~subform\n                                              ~@(when needrec [recform]))))))])))))]\n    (nth (step nil (seq seq-exprs)) 1)))",
                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                     :lines [1094
                                                             1148],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L1094-L1148"},
                                            :full-name "cljs.core/doseq",
                                            :clj-symbol "clojure.core/doseq",
                                            :docstring "Repeatedly executes body (presumably for side-effects) with\nbindings and filtering as provided by \"for\".  Does not retain\nthe head of the sequence. Returns nil."},
                         "cljs.core/*" {:ns "cljs.core",
                                        :name "*",
                                        :signature ["[]"
                                                    "[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :shadowed-sources ({:code "(defmacro *\n  ([] 1)\n  ([x] x)\n  ([x y] (list 'js* \"(~{} * ~{})\" x y))\n  ([x y & more] `(* (* ~x ~y) ~@more)))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [328
                                                                    332],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L328-L332"}),
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core__STAR_",
                                        :source {:code "(defn *\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/* x y))\n  ([x y & more] (reduce * (cljs.core/* x y) more)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [1329 1334],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1329-L1334"},
                                        :full-name "cljs.core/*",
                                        :clj-symbol "clojure.core/*",
                                        :docstring "Returns the product of nums. (*) returns 1."},
                         "cljs.core/into" {:ns "cljs.core",
                                           :name "into",
                                           :signature ["[to from]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_into",
                                           :source {:code "(defn into\n  [to from]\n  (if-not (nil? to)\n    (if (satisfies? IEditableCollection to false)\n      (persistent! (reduce -conj! (transient to) from))\n      (reduce -conj to from))\n    (reduce conj () from)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2849 2857],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2849-L2857"},
                                           :full-name "cljs.core/into",
                                           :clj-symbol "clojure.core/into",
                                           :docstring "Returns a new coll consisting of to-coll with all of the items of\nfrom-coll conjoined."},
                         "cljs.core/defmethod" {:ns "cljs.core",
                                                :name "defmethod",
                                                :signature ["[multifn dispatch-val & fn-tail]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "macro",
                                                :full-name-encode "cljs.core_defmethod",
                                                :source {:code "(defmacro defmethod\n  [multifn dispatch-val & fn-tail]\n  `(-add-method ~(with-meta multifn {:tag 'cljs.core/MultiFn}) ~dispatch-val (fn ~@fn-tail)))",
                                                         :filename "clojurescript/src/clj/cljs/core.clj",
                                                         :lines [1271
                                                                 1274],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L1271-L1274"},
                                                :full-name "cljs.core/defmethod",
                                                :clj-symbol "clojure.core/defmethod",
                                                :docstring "Creates and installs a new method of multimethod associated with dispatch-value. "},
                         "cljs.core/rest" {:return-type seq,
                                           :ns "cljs.core",
                                           :name "rest",
                                           :signature ["[coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_rest",
                                           :source {:code "(defn ^seq rest\n  [coll]\n  (if-not (nil? coll)\n    (if (satisfies? ISeq coll false)\n      (-rest ^not-native coll)\n      (let [s (seq coll)]\n        (if-not (nil? s)\n          (-rest s)\n          ())))\n    ()))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [411 422],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L411-L422"},
                                           :full-name "cljs.core/rest",
                                           :clj-symbol "clojure.core/rest",
                                           :docstring "Returns a possibly empty seq of the items after the first. Calls seq on its\nargument."},
                         "cljs.reader/unicode-4-pattern" {:full-name "cljs.reader/unicode-4-pattern",
                                                          :ns "cljs.reader",
                                                          :name "unicode-4-pattern",
                                                          :type "var",
                                                          :source {:code "(def unicode-4-pattern (re-pattern \"[0-9A-Fa-f]{4}\"))",
                                                                   :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                   :lines [190
                                                                           190],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L190-L190"},
                                                          :full-name-encode "cljs.reader_unicode-4-pattern",
                                                          :history [["+"
                                                                     "0.0-1424"]]},
                         "cljs.core/dotimes" {:ns "cljs.core",
                                              :name "dotimes",
                                              :signature ["[bindings & body]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "macro",
                                              :full-name-encode "cljs.core_dotimes",
                                              :source {:code "(defmacro dotimes\n  [bindings & body]\n  (let [i (first bindings)\n        n (second bindings)]\n    `(let [n# ~n]\n       (loop [~i 0]\n         (when (< ~i n#)\n           ~@body\n           (recur (inc ~i)))))))",
                                                       :filename "clojurescript/src/clj/cljs/core.clj",
                                                       :lines [1204
                                                               1216],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L1204-L1216"},
                                              :full-name "cljs.core/dotimes",
                                              :clj-symbol "clojure.core/dotimes",
                                              :docstring "bindings => name n\n\nRepeatedly executes body (presumably for side-effects) with name\nbound to integers from 0 through n-1."},
                         "clojure.zip/lefts" {:ns "clojure.zip",
                                              :name "lefts",
                                              :signature ["[loc]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.zip_lefts",
                                              :source {:code "(defn lefts\n  [loc]\n    (seq (:l (loc 1))))",
                                                       :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                       :lines [87 90],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L87-L90"},
                                              :full-name "clojure.zip/lefts",
                                              :clj-symbol "clojure.zip/lefts",
                                              :docstring "Returns a seq of the left siblings of this loc"},
                         "clojure.browser.dom/ensure-element" {:full-name "clojure.browser.dom/ensure-element",
                                                               :ns "clojure.browser.dom",
                                                               :name "ensure-element",
                                                               :docstring "Coerce the argument to a dom element if possible.",
                                                               :type "function",
                                                               :signature ["[e]"],
                                                               :source {:code "(defn ensure-element\n  [e]\n  (cond (keyword? e) (get-element e)\n        (string? e) (html->dom e)\n        :else e))",
                                                                        :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                        :lines [107
                                                                                112],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/dom.cljs#L107-L112"},
                                                               :full-name-encode "clojure.browser.dom_ensure-element",
                                                               :history [["+"
                                                                          "0.0-927"]]},
                         "cljs.core/defmacro" {:ns "cljs.core",
                                               :name "defmacro",
                                               :signature ["[name doc-string? attr-map? [params*] body]"
                                                           "[name doc-string? attr-map? ([params*] body) + attr-map?]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "macro",
                                               :full-name-encode "cljs.core_defmacro",
                                               :source {:code "(def\n\n ^{:doc \"Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.\"\n   :arglists '([name doc-string? attr-map? [params*] body]\n                 [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :added \"1.0\"}\n defmacro (fn [&form &env \n                name & args]\n             (let [prefix (loop [p (list name) args args]\n                            (let [f (first args)]\n                              (if (string? f)\n                                (recur (cons f p) (next args))\n                                (if (map? f)\n                                  (recur (cons f p) (next args))\n                                  p))))\n                   fdecl (loop [fd args]\n                           (if (string? (first fd))\n                             (recur (next fd))\n                             (if (map? (first fd))\n                               (recur (next fd))\n                               fd)))\n                   fdecl (if (vector? (first fdecl))\n                           (list fdecl)\n                           fdecl)\n                   add-implicit-args (fn [fd]\n                             (let [args (first fd)]\n                               (cons (vec (cons '&form (cons '&env args))) (next fd))))\n                   add-args (fn [acc ds]\n                              (if (nil? ds)\n                                acc\n                                (let [d (first ds)]\n                                  (if (map? d)\n                                    (conj acc d)\n                                    (recur (conj acc (add-implicit-args d)) (next ds))))))\n                   fdecl (seq (add-args [] fdecl))\n                   decl (loop [p prefix d fdecl]\n                          (if p\n                            (recur (next p) (cons (first p) d))\n                            d))]\n               (list 'do\n                     (cons `defn decl)\n                     (list '. (list 'var name) '(setMacro))\n                     (list 'var name)))))",
                                                        :filename "clojure/src/clj/clojure/core.clj",
                                                        :lines [422
                                                                466],
                                                        :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L422-L466"},
                                               :full-name "cljs.core/defmacro",
                                               :clj-symbol "clojure.core/defmacro",
                                               :docstring "Like defn, but the resulting function name is declared as a\nmacro and will be used as a macro by the compiler when it is\ncalled."},
                         "cljs.core/remove" {:ns "cljs.core",
                                             :name "remove",
                                             :signature ["[pred coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_remove",
                                             :source {:code "(defn remove\n  [pred coll]\n  (filter (complement pred) coll))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2820
                                                              2824],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2820-L2824"},
                                             :full-name "cljs.core/remove",
                                             :clj-symbol "clojure.core/remove",
                                             :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns false. pred must be free of side-effects."},
                         "cljs.core/set-print-fn!" {:full-name "cljs.core/set-print-fn!",
                                                    :ns "cljs.core",
                                                    :name "set-print-fn!",
                                                    :docstring "Set *print-fn* to f.",
                                                    :type "function",
                                                    :signature ["[f]"],
                                                    :source {:code "(defn ^:export set-print-fn!\n  [f] (set! *print-fn* f))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [26
                                                                     28],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L26-L28"},
                                                    :full-name-encode "cljs.core_set-print-fn_BANG_",
                                                    :history [["+"
                                                               "0.0-1798"]]},
                         "cljs.core/if-not" {:ns "cljs.core",
                                             :name "if-not",
                                             :signature ["[test then]"
                                                         "[test then else]"],
                                             :history [["+" "0.0-927"]],
                                             :type "macro",
                                             :full-name-encode "cljs.core_if-not",
                                             :source {:code "(defmacro if-not\n  ([test then] `(if-not ~test ~then nil))\n  ([test then else]\n   `(if (not ~test) ~then ~else)))",
                                                      :filename "clojure/src/clj/clojure/core.clj",
                                                      :lines [719 725],
                                                      :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L719-L725"},
                                             :full-name "cljs.core/if-not",
                                             :clj-symbol "clojure.core/if-not",
                                             :docstring "Evaluates test. If logical false, evaluates and returns then expr, \notherwise else expr, if supplied, else nil."},
                         "clojure.zip/path" {:ns "clojure.zip",
                                             :name "path",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_path",
                                             :source {:code "(defn path\n  [loc]\n    (:pnodes (loc 1)))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [82 85],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L82-L85"},
                                             :full-name "clojure.zip/path",
                                             :clj-symbol "clojure.zip/path",
                                             :docstring "Returns a seq of nodes leading to this loc"},
                         "cljs.core/mapcat" {:ns "cljs.core",
                                             :name "mapcat",
                                             :signature ["[f coll]"
                                                         "[f coll & colls]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_mapcat",
                                             :source {:code "(defn mapcat\n  ([f coll]\n    (flatten1 (map f coll)))\n  ([f coll & colls]\n    (flatten1 (apply map f coll colls))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2793
                                                              2799],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2793-L2799"},
                                             :full-name "cljs.core/mapcat",
                                             :clj-symbol "clojure.core/mapcat",
                                             :docstring "Returns the result of applying concat to the result of applying map\nto f and colls.  Thus function f should return a collection."},
                         "cljs.core/IWatchable" {:ns "cljs.core",
                                                 :name "IWatchable",
                                                 :type "protocol",
                                                 :full-name-encode "cljs.core_IWatchable",
                                                 :source {:code "(defprotocol IWatchable\n  (-notify-watches [this oldval newval])\n  (-add-watch [this key f])\n  (-remove-watch [this key]))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [287
                                                                  290],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L287-L290"},
                                                 :methods [{:name "-notify-watches",
                                                            :signature ["[this oldval newval]"],
                                                            :docstring nil}
                                                           {:name "-add-watch",
                                                            :signature ["[this key f]"],
                                                            :docstring nil}
                                                           {:name "-remove-watch",
                                                            :signature ["[this key]"],
                                                            :docstring nil}],
                                                 :full-name "cljs.core/IWatchable",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "cljs.core/unchecked-inc-int" {:ns "cljs.core",
                                                        :name "unchecked-inc-int",
                                                        :signature ["[x]"],
                                                        :shadowed-sources ({:code "(defmacro unchecked-inc-int\n  ([x] `(inc ~x)))",
                                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                                            :lines [299
                                                                                    300],
                                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L299-L300"}),
                                                        :history [["+"
                                                                   "0.0-1798"]],
                                                        :type "function",
                                                        :full-name-encode "cljs.core_unchecked-inc-int",
                                                        :source {:code "(defn unchecked-inc-int [x]\n  (cljs.core/unchecked-inc-int x))",
                                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                 :lines [1459
                                                                         1460],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1459-L1460"},
                                                        :full-name "cljs.core/unchecked-inc-int",
                                                        :clj-symbol "clojure.core/unchecked-inc-int"},
                         "clojure.zip/rightmost" {:ns "clojure.zip",
                                                  :name "rightmost",
                                                  :signature ["[loc]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.zip_rightmost",
                                                  :source {:code "(defn rightmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path r)\n        (with-meta [(last r) (assoc path :l (apply conj l node (butlast r)) :r nil)] (meta loc))\n        loc)))",
                                                           :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                           :lines [142
                                                                   148],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L142-L148"},
                                                  :full-name "clojure.zip/rightmost",
                                                  :clj-symbol "clojure.zip/rightmost",
                                                  :docstring "Returns the loc of the rightmost sibling of the node at this loc, or self"},
                         "cljs.core/unchecked-subtract" {:full-name "cljs.core/unchecked-subtract",
                                                         :ns "cljs.core",
                                                         :name "unchecked-subtract",
                                                         :type "macro",
                                                         :signature ["[& xs]"],
                                                         :source {:code "(defmacro unchecked-subtract\n  ([& xs] `(- ~@xs)))",
                                                                  :filename "clojurescript/src/clj/cljs/core.clj",
                                                                  :lines [317
                                                                          318],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L317-L318"},
                                                         :full-name-encode "cljs.core_unchecked-subtract",
                                                         :clj-symbol "clojure.core/unchecked-subtract",
                                                         :history [["+"
                                                                    "0.0-1798"]]},
                         "cljs.core/->" {:ns "cljs.core",
                                         :name "->",
                                         :signature ["[x]"
                                                     "[x form]"
                                                     "[x form & more]"],
                                         :history [["+" "0.0-927"]],
                                         :type "macro",
                                         :full-name-encode "cljs.core_-_GT_",
                                         :source {:code "(defmacro ->\n  ([x] x)\n  ([x form] (if (seq? form)\n              (with-meta `(~(first form) ~x ~@(next form)) (meta form))\n              (list form x)))\n  ([x form & more] `(-> (-> ~x ~form) ~@more)))",
                                                  :filename "clojure/src/clj/clojure/core.clj",
                                                  :lines [1545 1555],
                                                  :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L1545-L1555"},
                                         :full-name "cljs.core/->",
                                         :clj-symbol "clojure.core/->",
                                         :docstring "Threads the expr through the forms. Inserts x as the\nsecond item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nsecond item in second form, etc."},
                         "cljs.core/remove-all-methods" {:ns "cljs.core",
                                                         :name "remove-all-methods",
                                                         :signature ["[multifn]"],
                                                         :history [["+"
                                                                    "0.0-927"]],
                                                         :type "function",
                                                         :full-name-encode "cljs.core_remove-all-methods",
                                                         :source {:code "(defn remove-all-methods\n [multifn]\n (-reset multifn))",
                                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                  :lines [7080
                                                                          7083],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L7080-L7083"},
                                                         :full-name "cljs.core/remove-all-methods",
                                                         :clj-symbol "clojure.core/remove-all-methods",
                                                         :docstring "Removes all of the methods of multimethod."},
                         "cljs.core/unchecked-add-int" {:ns "cljs.core",
                                                        :name "unchecked-add-int",
                                                        :signature ["[]"
                                                                    "[x]"
                                                                    "[x y]"
                                                                    "[x y & more]"],
                                                        :shadowed-sources ({:code "(defmacro unchecked-add-int\n  ([& xs] `(+ ~@xs)))",
                                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                                            :lines [284
                                                                                    285],
                                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L284-L285"}),
                                                        :history [["+"
                                                                   "0.0-1798"]],
                                                        :type "function",
                                                        :full-name-encode "cljs.core_unchecked-add-int",
                                                        :source {:code "(defn unchecked-add-int\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-add-int x y))\n  ([x y & more] (reduce unchecked-add-int (cljs.core/unchecked-add-int x y) more)))",
                                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                 :lines [1436
                                                                         1441],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1436-L1441"},
                                                        :full-name "cljs.core/unchecked-add-int",
                                                        :clj-symbol "clojure.core/unchecked-add-int",
                                                        :docstring "Returns the sum of nums. (+) returns 0."},
                         "clojure.string/replace-first" {:ns "clojure.string",
                                                         :name "replace-first",
                                                         :signature ["[s match replacement]"],
                                                         :history [["+"
                                                                    "0.0-927"]],
                                                         :type "function",
                                                         :full-name-encode "clojure.string_replace-first",
                                                         :source {:code "(defn replace-first\n  [s match replacement]\n  (.replace s match replacement))",
                                                                  :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                                  :lines [36
                                                                          43],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/string.cljs#L36-L43"},
                                                         :full-name "clojure.string/replace-first",
                                                         :clj-symbol "clojure.string/replace-first",
                                                         :docstring "Replaces the first instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
                         "cljs.core/reduced?" {:return-type boolean,
                                               :ns "cljs.core",
                                               :name "reduced?",
                                               :signature ["[r]"],
                                               :history [["+"
                                                          "0.0-1211"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_reduced_QMARK_",
                                               :source {:code "(defn ^boolean reduced?\n  [r]\n  (instance? Reduced r))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [535
                                                                538],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L535-L538"},
                                               :full-name "cljs.core/reduced?",
                                               :clj-symbol "clojure.core/reduced?",
                                               :docstring "Returns true if x is the result of a call to reduced"},
                         "clojure.browser.dom/get-value" {:full-name "clojure.browser.dom/get-value",
                                                          :ns "clojure.browser.dom",
                                                          :name "get-value",
                                                          :docstring "Get the value of an element.",
                                                          :type "function",
                                                          :signature ["[e]"],
                                                          :source {:code "(defn get-value\n  [e]\n  (.-value (ensure-element e)))",
                                                                   :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                   :lines [131
                                                                           134],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/dom.cljs#L131-L134"},
                                                          :full-name-encode "clojure.browser.dom_get-value",
                                                          :history [["+"
                                                                     "0.0-927"]]},
                         "cljs.nodejs/process" {:full-name "cljs.nodejs/process",
                                                :ns "cljs.nodejs",
                                                :name "process",
                                                :type "var",
                                                :source {:code "(def process (js* \"process\"))",
                                                         :filename "clojurescript/src/cljs/cljs/nodejs.cljs",
                                                         :lines [8 8],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/nodejs.cljs#L8-L8"},
                                                :full-name-encode "cljs.nodejs_process",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/some->>" {:ns "cljs.core",
                                              :name "some->>",
                                              :signature ["[expr & forms]"],
                                              :history [["+"
                                                         "0.0-1798"]],
                                              :type "macro",
                                              :full-name-encode "cljs.core_some-_GT__GT_",
                                              :source {:code "(defmacro some->>\n  [expr & forms]\n  (let [g (gensym)\n        pstep (fn [step] `(if (nil? ~g) nil (->> ~g ~step)))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep forms))]\n       ~g)))",
                                                       :filename "clojure/src/clj/clojure/core.clj",
                                                       :lines [6824
                                                               6833],
                                                       :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L6824-L6833"},
                                              :full-name "cljs.core/some->>",
                                              :clj-symbol "clojure.core/some->>",
                                              :docstring "When expr is not nil, threads it into the first form (via ->>),\nand when that result is not nil, through the next etc"},
                         "cljs.core/unchecked-inc" {:ns "cljs.core",
                                                    :name "unchecked-inc",
                                                    :signature ["[x]"],
                                                    :shadowed-sources ({:code "(defmacro unchecked-inc\n  ([x] `(inc ~x)))",
                                                                        :filename "clojurescript/src/clj/cljs/core.clj",
                                                                        :lines [296
                                                                                297],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L296-L297"}),
                                                    :history [["+"
                                                               "0.0-1798"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_unchecked-inc",
                                                    :source {:code "(defn unchecked-inc [x]\n  (cljs.core/unchecked-inc x))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [1456
                                                                     1457],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1456-L1457"},
                                                    :full-name "cljs.core/unchecked-inc",
                                                    :clj-symbol "clojure.core/unchecked-inc"},
                         "cljs.core/not=" {:return-type boolean,
                                           :ns "cljs.core",
                                           :name "not=",
                                           :signature ["[x]"
                                                       "[x y]"
                                                       "[x y & more]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_not_EQ_",
                                           :source {:code "(defn ^boolean not=\n  ([x] false)\n  ([x y] (not (= x y)))\n  ([x y & more]\n   (not (apply = x y more))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2377 2382],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2377-L2382"},
                                           :full-name "cljs.core/not=",
                                           :clj-symbol "clojure.core/not=",
                                           :docstring "Same as (not (= obj1 obj2))"},
                         "cljs.core/unchecked-subtract-int" {:full-name "cljs.core/unchecked-subtract-int",
                                                             :ns "cljs.core",
                                                             :name "unchecked-subtract-int",
                                                             :type "macro",
                                                             :signature ["[& xs]"],
                                                             :source {:code "(defmacro unchecked-subtract-int\n  ([& xs] `(- ~@xs)))",
                                                                      :filename "clojurescript/src/clj/cljs/core.clj",
                                                                      :lines [320
                                                                              321],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L320-L321"},
                                                             :full-name-encode "cljs.core_unchecked-subtract-int",
                                                             :clj-symbol "clojure.core/unchecked-subtract-int",
                                                             :history [["+"
                                                                        "0.0-1798"]]},
                         "cljs.core/ex-data" {:ns "cljs.core",
                                              :name "ex-data",
                                              :signature ["[ex]"],
                                              :history [["+"
                                                         "0.0-1576"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_ex-data",
                                              :source {:code "(defn ex-data\n  [ex]\n  (when (instance? ExceptionInfo ex)\n    (.-data ex)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [7141
                                                               7147],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L7141-L7147"},
                                              :full-name "cljs.core/ex-data",
                                              :clj-symbol "clojure.core/ex-data",
                                              :docstring "Alpha - subject to change.\nReturns exception data (a map) if ex is an ExceptionInfo.\nOtherwise returns nil."},
                         "cljs.core/PersistentTreeMapSeq" {:full-name "cljs.core/PersistentTreeMapSeq",
                                                           :ns "cljs.core",
                                                           :name "PersistentTreeMapSeq",
                                                           :type "type",
                                                           :signature ["[meta stack ascending? cnt __hash]"],
                                                           :source {:code "(deftype PersistentTreeMapSeq [meta stack ^boolean ascending? cnt ^:mutable __hash]\n  ISeqable\n  (-seq [this] this)\n\n  ISequential\n  ISeq\n  (-first [this] (peek stack))\n  (-rest [this]\n    (let [t (first stack)\n          next-stack (tree-map-seq-push (if ascending? (.-right t) (.-left t))\n                                        (next stack)\n                                        ascending?)]\n      (if-not (nil? next-stack)\n        (PersistentTreeMapSeq. nil next-stack ascending? (dec cnt) nil)\n        ())))\n\n  ICounted\n  (-count [coll]\n    (if (neg? cnt)\n      (inc (count (next coll)))\n      cnt))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll meta]\n    (PersistentTreeMapSeq. meta stack ascending? cnt __hash)))",
                                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                    :lines [4898
                                                                            4937],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L4898-L4937"},
                                                           :full-name-encode "cljs.core_PersistentTreeMapSeq",
                                                           :history [["+"
                                                                      "0.0-1211"]]},
                         "cljs.core/js-keys" {:full-name "cljs.core/js-keys",
                                              :ns "cljs.core",
                                              :name "js-keys",
                                              :type "function",
                                              :signature ["[obj]"],
                                              :source {:code "(defn js-keys [obj]\n  (let [keys (array)]\n    (goog.object/forEach obj (fn [val key obj] (.push keys key)))\n    keys))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1049
                                                               1052],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1049-L1052"},
                                              :full-name-encode "cljs.core_js-keys",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "clojure.zip/seq-zip" {:ns "clojure.zip",
                                                :name "seq-zip",
                                                :signature ["[root]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.zip_seq-zip",
                                                :source {:code "(defn seq-zip\n  [root]\n    (zipper seq?\n            identity\n            (fn [node children] (with-meta children (meta node)))\n            root))",
                                                         :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                         :lines [34
                                                                 40],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L34-L40"},
                                                :full-name "clojure.zip/seq-zip",
                                                :clj-symbol "clojure.zip/seq-zip",
                                                :docstring "Returns a zipper for nested sequences, given a root sequence"},
                         "cljs.core/IVector" {:ns "cljs.core",
                                              :name "IVector",
                                              :type "protocol",
                                              :full-name-encode "cljs.core_IVector",
                                              :source {:code "(defprotocol IVector\n  (-assoc-n [coll n val]))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [224
                                                               225],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L224-L225"},
                                              :methods [{:name "-assoc-n",
                                                         :signature ["[coll n val]"],
                                                         :docstring nil}],
                                              :full-name "cljs.core/IVector",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/persistent!" {:full-name "cljs.core/persistent!",
                                                  :ns "cljs.core",
                                                  :name "persistent!",
                                                  :type "function",
                                                  :signature ["[tcoll]"],
                                                  :source {:code "(defn persistent! [tcoll]\n  (-persistent! tcoll))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [2297
                                                                   2298],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2297-L2298"},
                                                  :full-name-encode "cljs.core_persistent_BANG_",
                                                  :clj-symbol "clojure.core/persistent!",
                                                  :history [["+"
                                                             "0.0-1211"]]},
                         "cljs.core/empty" {:ns "cljs.core",
                                            :name "empty",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_empty",
                                            :source {:code "(defn empty\n  [coll]\n  (-empty coll))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [774 777],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L774-L777"},
                                            :full-name "cljs.core/empty",
                                            :clj-symbol "clojure.core/empty",
                                            :docstring "Returns an empty collection of the same category as coll, or nil"},
                         "cljs.core/re-matches" {:ns "cljs.core",
                                                 :name "re-matches",
                                                 :signature ["[re s]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_re-matches",
                                                 :source {:code "(defn re-matches\n  [re s]\n  (let [matches (.exec re s)]\n    (when (= (first matches) s)\n      (if (== (count matches) 1)\n        (first matches)\n        (vec matches)))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [6166
                                                                  6173],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6166-L6173"},
                                                 :full-name "cljs.core/re-matches",
                                                 :clj-symbol "clojure.core/re-matches",
                                                 :docstring "Returns the result of (re-find re s) if re fully matches s."},
                         "clojure.browser.dom/DOMBuilder" {:ns "clojure.browser.dom",
                                                           :name "DOMBuilder",
                                                           :type "protocol",
                                                           :full-name-encode "clojure.browser.dom_DOMBuilder",
                                                           :source {:code "(defprotocol DOMBuilder\n  (-element [this] [this attrs-or-children] [this attrs children]))",
                                                                    :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                    :lines [17
                                                                            18],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/dom.cljs#L17-L18"},
                                                           :methods [{:name "-element",
                                                                      :signature ["[this]"
                                                                                  "[this attrs-or-children]"
                                                                                  "[this attrs children]"],
                                                                      :docstring nil}],
                                                           :full-name "clojure.browser.dom/DOMBuilder",
                                                           :history [["+"
                                                                      "0.0-927"]]},
                         "cljs.core/fixture1" {:full-name "cljs.core/fixture1",
                                               :ns "cljs.core",
                                               :name "fixture1",
                                               :type "var",
                                               :source {:code "(def fixture1 1)",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [6676
                                                                6676],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6676-L6676"},
                                               :full-name-encode "cljs.core_fixture1",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/extend-type" {:full-name "cljs.core/extend-type",
                                                  :ns "cljs.core",
                                                  :name "extend-type",
                                                  :type "macro",
                                                  :signature ["[tsym & impls]"],
                                                  :source {:code "(defmacro extend-type [tsym & impls]\n  (let [resolve #(let [ret (:name (cljs.analyzer/resolve-var (dissoc &env :locals) %))]\n                   (assert ret (core/str \"Can't resolve: \" %))\n                   ret)\n        impl-map (loop [ret {} s impls]\n                   (if (seq s)\n                     (recur (assoc ret (first s) (take-while seq? (next s)))\n                            (drop-while seq? (next s)))\n                     ret))\n        warn-if-not-protocol #(when-not (= 'Object %)\n                                (if cljs.analyzer/*cljs-warn-on-undeclared*\n                                  (if-let [var (cljs.analyzer/resolve-existing-var (dissoc &env :locals) %)]\n                                    (do\n                                     (when-not (:protocol-symbol var)\n                                       (cljs.analyzer/warning &env\n                                         (core/str \"WARNING: Symbol \" % \" is not a protocol\")))\n                                     (when (and cljs.analyzer/*cljs-warn-protocol-deprecated*\n                                                (-> var :deprecated)\n                                                (not (-> % meta :deprecation-nowarn)))\n                                       (cljs.analyzer/warning &env\n                                         (core/str \"WARNING: Protocol \" % \" is deprecated\"))))\n                                    (cljs.analyzer/warning &env\n                                      (core/str \"WARNING: Can't resolve protocol symbol \" %)))))\n        skip-flag (set (-> tsym meta :skip-protocol-flag))]\n    (if (base-type tsym)\n      (let [t (base-type tsym)\n            assign-impls (fn [[p sigs]]\n                           (warn-if-not-protocol p)\n                           (let [psym (resolve p)\n                                 pfn-prefix (subs (core/str psym) 0 (clojure.core/inc (.indexOf (core/str psym) \"/\")))]\n                             (cons `(aset ~psym ~t true)\n                                   (map (fn [[f & meths :as form]]\n                                          `(aset ~(symbol (core/str pfn-prefix f)) ~t ~(with-meta `(fn ~@meths) (meta form))))\n                                        sigs))))]\n        `(do ~@(mapcat assign-impls impl-map)))\n      (let [t (resolve tsym)\n            prototype-prefix (fn [sym]\n                               `(.. ~tsym -prototype ~(to-property sym)))\n            assign-impls (fn [[p sigs]]\n                           (warn-if-not-protocol p)\n                           (let [psym (resolve p)\n                                 pprefix (protocol-prefix psym)]\n                             (if (= p 'Object)\n                               (let [adapt-params (fn [[sig & body]]\n                                                    (let [[tname & args] sig]\n                                                      (list (vec args) (list* 'this-as (vary-meta tname assoc :tag t) body))))]\n                                 (map (fn [[f & meths :as form]]\n                                        `(set! ~(prototype-prefix f)\n                                               ~(with-meta `(fn ~@(map adapt-params meths)) (meta form))))\n                                      sigs))\n                               (concat (when-not (skip-flag psym)\n                                         [`(set! ~(prototype-prefix pprefix) true)])\n                                       (mapcat (fn [[f & meths :as form]]\n                                                 (if (= psym 'cljs.core/IFn)\n                                                   (let [adapt-params (fn [[[targ & args :as sig] & body]]\n                                                                        (let [this-sym (with-meta 'self__ {:tag t})]\n                                                                          `(~(vec (cons this-sym args))\n                                                                            (this-as ~this-sym\n                                                                                     (let [~targ ~this-sym]\n                                                                                       ~@body)))))\n                                                         meths (map adapt-params meths)\n                                                         this-sym (with-meta 'self__ {:tag t})\n                                                         argsym (gensym \"args\")]\n                                                     [`(set! ~(prototype-prefix 'call) ~(with-meta `(fn ~@meths) (meta form)))\n                                                      `(set! ~(prototype-prefix 'apply)\n                                                             ~(with-meta\n                                                                `(fn ~[this-sym argsym]\n                                                                   (.apply (.-call ~this-sym) ~this-sym\n                                                                           (.concat (array ~this-sym) (aclone ~argsym))))\n                                                                (meta form)))])\n                                                   (let [pf (core/str pprefix f)\n                                                         adapt-params (fn [[[targ & args :as sig] & body]]\n                                                                        (cons (vec (cons (vary-meta targ assoc :tag t) args))\n                                                                              body))]\n                                                     (if (vector? (first meths))\n                                                       [`(set! ~(prototype-prefix (core/str pf \"$arity$\" (count (first meths)))) ~(with-meta `(fn ~@(adapt-params meths)) (meta form)))]\n                                                       (map (fn [[sig & body :as meth]]\n                                                              `(set! ~(prototype-prefix (core/str pf \"$arity$\" (count sig)))\n                                                                     ~(with-meta `(fn ~(adapt-params meth)) (meta form))))\n                                                            meths)))))\n                                               sigs)))))]\n        `(do ~@(mapcat assign-impls impl-map))))))",
                                                           :filename "clojurescript/src/clj/cljs/core.clj",
                                                           :lines [536
                                                                   617],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L536-L617"},
                                                  :full-name-encode "cljs.core_extend-type",
                                                  :clj-symbol "clojure.core/extend-type",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/ISeqable" {:ns "cljs.core",
                                               :name "ISeqable",
                                               :type "protocol",
                                               :full-name-encode "cljs.core_ISeqable",
                                               :source {:code "(defprotocol ISeqable\n  (-seq [o]))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [251
                                                                252],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L251-L252"},
                                               :methods [{:name "-seq",
                                                          :signature ["[o]"],
                                                          :docstring nil}],
                                               :full-name "cljs.core/ISeqable",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/assoc" {:ns "cljs.core",
                                            :name "assoc",
                                            :signature ["[coll k v]"
                                                        "[coll k v & kvs]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_assoc",
                                            :source {:code "(defn assoc\n  ([coll k v]\n    (if-not (nil? coll)\n      (-assoc coll k v)\n      (hash-map k v)))\n  ([coll k v & kvs]\n     (let [ret (assoc coll k v)]\n       (if kvs\n         (recur ret (first kvs) (second kvs) (nnext kvs))\n         ret))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [890 903],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L890-L903"},
                                            :full-name "cljs.core/assoc",
                                            :clj-symbol "clojure.core/assoc",
                                            :docstring "assoc[iate]. When applied to a map, returns a new map of the\nsame (hashed/sorted) type, that contains the mapping of key(s) to\nval(s). When applied to a vector, returns a new vector that\ncontains val at index."},
                         "clojure.browser.repl/xpc-connection" {:full-name "clojure.browser.repl/xpc-connection",
                                                                :ns "clojure.browser.repl",
                                                                :name "xpc-connection",
                                                                :type "var",
                                                                :source {:code "(def xpc-connection (atom nil))",
                                                                         :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                         :lines [21
                                                                                 21],
                                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/repl.cljs#L21-L21"},
                                                                :full-name-encode "clojure.browser.repl_xpc-connection",
                                                                :history [["+"
                                                                           "0.0-927"]]},
                         "cljs.core/IDerefWithTimeout" {:ns "cljs.core",
                                                        :name "IDerefWithTimeout",
                                                        :type "protocol",
                                                        :full-name-encode "cljs.core_IDerefWithTimeout",
                                                        :source {:code "(defprotocol IDerefWithTimeout\n  (-deref-with-timeout [o msec timeout-val]))",
                                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                 :lines [230
                                                                         231],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L230-L231"},
                                                        :methods [{:name "-deref-with-timeout",
                                                                   :signature ["[o msec timeout-val]"],
                                                                   :docstring nil}],
                                                        :full-name "cljs.core/IDerefWithTimeout",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "clojure.core.reducers/cat" {:ns "clojure.core.reducers",
                                                      :name "cat",
                                                      :signature ["[]"
                                                                  "[ctor]"
                                                                  "[left right]"],
                                                      :history [["+"
                                                                 "0.0-1236"]],
                                                      :type "function",
                                                      :full-name-encode "clojure.core.reducers_cat",
                                                      :source {:code "(defn cat\n  ([] (array))\n  ([ctor]\n     (fn\n       ([] (ctor))\n       ([left right] (cat left right))))\n  ([left right]\n     (cond\n       (zero? (count left)) right\n       (zero? (count right)) left\n       :else\n       (Cat. (+ (count left) (count right)) left right))))",
                                                               :filename "clojurescript/src/cljs/clojure/core/reducers.cljs",
                                                               :lines [206
                                                                       223],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/core/reducers.cljs#L206-L223"},
                                                      :full-name "clojure.core.reducers/cat",
                                                      :clj-symbol "clojure.core.reducers/cat",
                                                      :docstring "A high-performance combining fn that yields the catenation of the\nreduced values. The result is reducible, foldable, seqable and\ncounted, providing the identity collections are reducible, seqable\nand counted. The single argument version will build a combining fn\nwith the supplied identity constructor. Tests for identity\nwith (zero? (count x)). See also foldcat."},
                         "cljs.core/unchecked-substract" {:full-name "cljs.core/unchecked-substract",
                                                          :ns "cljs.core",
                                                          :name "unchecked-substract",
                                                          :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result.",
                                                          :type "function",
                                                          :signature ["[x]"
                                                                      "[x y]"
                                                                      "[x y & more]"],
                                                          :source {:code "(defn unchecked-substract\n  ([x] (cljs.core/unchecked-subtract x))\n  ([x y] (cljs.core/unchecked-subtract x y))\n  ([x y & more] (reduce unchecked-substract (cljs.core/unchecked-subtract x y) more)))",
                                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                   :lines [1487
                                                                           1492],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1487-L1492"},
                                                          :full-name-encode "cljs.core_unchecked-substract",
                                                          :history [["+"
                                                                     "0.0-1798"]]},
                         "clojure.browser.repl/start-evaluator" {:full-name "clojure.browser.repl/start-evaluator",
                                                                 :ns "clojure.browser.repl",
                                                                 :name "start-evaluator",
                                                                 :docstring "Start the REPL server connection.",
                                                                 :type "function",
                                                                 :signature ["[url]"],
                                                                 :source {:code "(defn start-evaluator\n  [url]\n  (if-let [repl-connection (net/xpc-connection)]\n    (let [connection (net/xhr-connection)]\n      (event/listen connection\n                    :success\n                    (fn [e]\n                      (net/transmit\n                       repl-connection\n                       :evaluate-javascript\n                       (.getResponseText e/currentTarget\n                                         ()))))\n\n      (net/register-service repl-connection\n                            :send-result\n                            (fn [data]\n                              (send-result connection url (wrap-message :result data))))\n\n      (net/register-service repl-connection\n                            :print\n                            (fn [data]\n                              (send-print url (wrap-message :print data))))\n      \n      (net/connect repl-connection\n                   (constantly nil))\n\n      (js/setTimeout #(send-result connection url (wrap-message :ready \"ready\")) 50))\n    (js/alert \"No 'xpc' param provided to child iframe.\")))",
                                                                          :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                          :lines [60
                                                                                  88],
                                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/repl.cljs#L60-L88"},
                                                                 :full-name-encode "clojure.browser.repl_start-evaluator",
                                                                 :history [["+"
                                                                            "0.0-927"]]},
                         "clojure.browser.event/unlisten" {:full-name "clojure.browser.event/unlisten",
                                                           :ns "clojure.browser.event",
                                                           :name "unlisten",
                                                           :type "function",
                                                           :signature ["[src type fn]"
                                                                       "[src type fn capture?]"],
                                                           :source {:code "(defn unlisten\n  ([src type fn]\n     (unlisten src type fn false))\n  ([src type fn capture?]\n     (goog.events/unlisten src\n                           (get (event-types src) type type)\n                           fn\n                           capture?)))",
                                                                    :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                    :lines [62
                                                                            69],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/event.cljs#L62-L69"},
                                                           :full-name-encode "clojure.browser.event_unlisten",
                                                           :history [["+"
                                                                      "0.0-927"]]},
                         "cljs.core/format" {:ns "cljs.core",
                                             :name "format",
                                             :signature ["[fmt & args]"],
                                             :history [["+"
                                                        "0.0-1443"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_format",
                                             :source {:code "(defn format\n  [fmt & args]\n  (let [args (map (fn [x]\n                    (if (or (keyword? x) (symbol? x))\n                      (str x)\n                      x))\n                args)]\n    (apply gstring/format fmt args)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1698
                                                              1706],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1698-L1706"},
                                             :full-name "cljs.core/format",
                                             :clj-symbol "clojure.core/format",
                                             :docstring "Formats a string using goog.string.format."},
                         "cljs.core/sorted-set" {:ns "cljs.core",
                                                 :name "sorted-set",
                                                 :signature ["[& keys]"],
                                                 :history [["+"
                                                            "0.0-1211"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_sorted-set",
                                                 :source {:code "(defn sorted-set\n  ([& keys]\n   (reduce -conj cljs.core.PersistentTreeSet/EMPTY keys)))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [5824
                                                                  5827],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5824-L5827"},
                                                 :full-name "cljs.core/sorted-set",
                                                 :clj-symbol "clojure.core/sorted-set",
                                                 :docstring "Returns a new sorted set with supplied keys."},
                         "cljs.core/fnil" {:ns "cljs.core",
                                           :name "fnil",
                                           :signature ["[f x]"
                                                       "[f x y]"
                                                       "[f x y z]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_fnil",
                                           :source {:code "(defn fnil\n  ([f x]\n   (fn\n     ([a] (f (if (nil? a) x a)))\n     ([a b] (f (if (nil? a) x a) b))\n     ([a b c] (f (if (nil? a) x a) b c))\n     ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n  ([f x y]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n  ([f x y z]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2484 2505],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2484-L2505"},
                                           :full-name "cljs.core/fnil",
                                           :clj-symbol "clojure.core/fnil",
                                           :docstring "Takes a function f, and returns a function that calls f, replacing\na nil first argument to f with the supplied value x. Higher arity\nversions can replace arguments in the second and third\npositions (y, z). Note that the function f can take any number of\narguments, not just the one(s) being nil-patched."},
                         "cljs.core/this-as" {:full-name "cljs.core/this-as",
                                              :ns "cljs.core",
                                              :name "this-as",
                                              :docstring "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided.",
                                              :type "macro",
                                              :signature ["[name & body]"],
                                              :source {:code "(defmacro this-as\n  [name & body]\n  `(let [~name (~'js* \"this\")]\n     ~@body))",
                                                       :filename "clojurescript/src/clj/cljs/core.clj",
                                                       :lines [527
                                                               531],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L527-L531"},
                                              :full-name-encode "cljs.core_this-as",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/PersistentQueueSeq" {:full-name "cljs.core/PersistentQueueSeq",
                                                         :ns "cljs.core",
                                                         :name "PersistentQueueSeq",
                                                         :type "type",
                                                         :signature ["[meta front rear __hash]"],
                                                         :source {:code "(deftype PersistentQueueSeq [meta front rear ^:mutable __hash]\n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueueSeq. meta front rear __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest  [coll]\n    (if-let [f1 (next front)]\n      (PersistentQueueSeq. meta f1 rear nil)\n      (if (nil? rear)\n        (-empty coll)\n        (PersistentQueueSeq. meta rear nil nil))))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll))",
                                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                  :lines [3565
                                                                          3595],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L3565-L3595"},
                                                         :full-name-encode "cljs.core_PersistentQueueSeq",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "cljs.core/counted?" {:return-type boolean,
                                               :ns "cljs.core",
                                               :name "counted?",
                                               :signature ["[x]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_counted_QMARK_",
                                               :source {:code "(defn ^boolean counted?\n  [x] (satisfies? ICounted x))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [606
                                                                608],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L606-L608"},
                                               :full-name "cljs.core/counted?",
                                               :clj-symbol "clojure.core/counted?",
                                               :docstring "Returns true if coll implements count in constant time"},
                         "clojure.string/trimr" {:ns "clojure.string",
                                                 :name "trimr",
                                                 :signature ["[s]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.string_trimr",
                                                 :source {:code "(defn trimr\n    [s]\n    (gstring/trimRight s))",
                                                          :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                          :lines [116
                                                                  119],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/string.cljs#L116-L119"},
                                                 :full-name "clojure.string/trimr",
                                                 :clj-symbol "clojure.string/trimr",
                                                 :docstring "Removes whitespace from the right side of string."},
                         "clojure.core.reducers/take" {:ns "clojure.core.reducers",
                                                       :name "take",
                                                       :signature ["[n]"
                                                                   "[n coll]"],
                                                       :history [["+"
                                                                  "0.0-1236"]],
                                                       :type "function",
                                                       :full-name-encode "clojure.core.reducers_take",
                                                       :source {:code "(defcurried take\n  \"Ends the reduction of coll after consuming n values.\"\n  {}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (reduced ret)\n              (f1 ret k v))))))))",
                                                                :filename "clojurescript/src/cljs/clojure/core/reducers.cljs",
                                                                :lines [155
                                                                        167],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/core/reducers.cljs#L155-L167"},
                                                       :full-name "clojure.core.reducers/take",
                                                       :clj-symbol "clojure.core.reducers/take",
                                                       :docstring "Ends the reduction of coll after consuming n values."},
                         "cljs.core/force" {:ns "cljs.core",
                                            :name "force",
                                            :signature ["[x]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_force",
                                            :source {:code "(defn force\n  [x]\n  (if (delay? x)\n    (deref x)\n    x))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [6697
                                                             6702],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6697-L6702"},
                                            :full-name "cljs.core/force",
                                            :clj-symbol "clojure.core/force",
                                            :docstring "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"},
                         "cljs.core/compare-and-set!" {:ns "cljs.core",
                                                       :name "compare-and-set!",
                                                       :signature ["[a oldval newval]"],
                                                       :history [["+"
                                                                  "0.0-927"]],
                                                       :type "function",
                                                       :full-name-encode "cljs.core_compare-and-set_BANG_",
                                                       :source {:code "(defn compare-and-set!\n  [a oldval newval]\n  (if (= (.-state a) oldval)\n    (do (reset! a newval) true)\n    false))",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [6584
                                                                        6591],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6584-L6591"},
                                                       :full-name "cljs.core/compare-and-set!",
                                                       :clj-symbol "clojure.core/compare-and-set!",
                                                       :docstring "Atomically sets the value of atom to newval if and only if the\ncurrent value of the atom is identical to oldval. Returns true if\nset happened, else false."},
                         "cljs.core/set?" {:return-type boolean,
                                           :ns "cljs.core",
                                           :name "set?",
                                           :signature ["[x]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_set_QMARK_",
                                           :source {:code "(defn ^boolean set?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ISet x)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1005 1010],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1005-L1010"},
                                           :full-name "cljs.core/set?",
                                           :clj-symbol "clojure.core/set?",
                                           :docstring "Returns true if x satisfies ISet"},
                         "cljs.core/unchecked-dec" {:ns "cljs.core",
                                                    :name "unchecked-dec",
                                                    :signature ["[x]"],
                                                    :shadowed-sources ({:code "(defmacro unchecked-dec\n  ([x] `(dec ~x)))",
                                                                        :filename "clojurescript/src/clj/cljs/core.clj",
                                                                        :lines [287
                                                                                288],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L287-L288"}),
                                                    :history [["+"
                                                               "0.0-1798"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_unchecked-dec",
                                                    :source {:code "(defn unchecked-dec [x]\n  (cljs.core/unchecked-dec x))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [1443
                                                                     1444],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1443-L1444"},
                                                    :full-name "cljs.core/unchecked-dec",
                                                    :clj-symbol "clojure.core/unchecked-dec"},
                         "clojure.string/escape" {:ns "clojure.string",
                                                  :name "escape",
                                                  :signature ["[s cmap]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.string_escape",
                                                  :source {:code "(defn escape\n  [s cmap]\n  (let [buffer (gstring/StringBuffer.)\n        length (.-length s)]\n    (loop [index 0]\n      (if (= length index)\n        (. buffer (toString))\n        (let [ch (.charAt s index)]\n          (if-let [replacement (get cmap ch)]\n            (.append buffer (str replacement))\n            (.append buffer ch))\n          (recur (inc index)))))))",
                                                           :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                           :lines [138
                                                                   154],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/string.cljs#L138-L154"},
                                                  :full-name "clojure.string/escape",
                                                  :clj-symbol "clojure.string/escape",
                                                  :docstring "Return a new string, using cmap to escape each character ch\nfrom s as follows:\n\nIf (cmap ch) is nil, append ch to the new string.\nIf (cmap ch) is non-nil, append (str (cmap ch)) instead."},
                         "cljs.core/remove-watch" {:ns "cljs.core",
                                                   :name "remove-watch",
                                                   :signature ["[iref key]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.core_remove-watch",
                                                   :source {:code "(defn remove-watch\n  [iref key]\n  (-remove-watch iref key))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [6653
                                                                    6658],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6653-L6658"},
                                                   :full-name "cljs.core/remove-watch",
                                                   :clj-symbol "clojure.core/remove-watch",
                                                   :docstring "Alpha - subject to change.\n\nRemoves a watch (set by add-watch) from a reference"},
                         "cljs.core/IMultiFn" {:ns "cljs.core",
                                               :name "IMultiFn",
                                               :type "protocol",
                                               :full-name-encode "cljs.core_IMultiFn",
                                               :source {:code "(defprotocol IMultiFn\n  (-reset [mf])\n  (-add-method [mf dispatch-val method])\n  (-remove-method [mf dispatch-val])\n  (-prefer-method [mf dispatch-val dispatch-val-y])\n  (-get-method [mf dispatch-val])\n  (-methods [mf])\n  (-prefers [mf])\n  (-dispatch [mf args]))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [7003
                                                                7011],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L7003-L7011"},
                                               :methods [{:name "-reset",
                                                          :signature ["[mf]"],
                                                          :docstring nil}
                                                         {:name "-add-method",
                                                          :signature ["[mf dispatch-val method]"],
                                                          :docstring nil}
                                                         {:name "-remove-method",
                                                          :signature ["[mf dispatch-val]"],
                                                          :docstring nil}
                                                         {:name "-prefer-method",
                                                          :signature ["[mf dispatch-val dispatch-val-y]"],
                                                          :docstring nil}
                                                         {:name "-get-method",
                                                          :signature ["[mf dispatch-val]"],
                                                          :docstring nil}
                                                         {:name "-methods",
                                                          :signature ["[mf]"],
                                                          :docstring nil}
                                                         {:name "-prefers",
                                                          :signature ["[mf]"],
                                                          :docstring nil}
                                                         {:name "-dispatch",
                                                          :signature ["[mf args]"],
                                                          :docstring nil}],
                                               :full-name "cljs.core/IMultiFn",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "clojure.zip/end?" {:ns "clojure.zip",
                                             :name "end?",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_end_QMARK_",
                                             :source {:code "(defn end?\n  [loc]\n    (= :end (loc 1)))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [232 235],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L232-L235"},
                                             :full-name "clojure.zip/end?",
                                             :clj-symbol "clojure.zip/end?",
                                             :docstring "Returns true if loc represents the end of a depth-first walk"},
                         "clojure.set/superset?" {:ns "clojure.set",
                                                  :name "superset?",
                                                  :signature ["[set1 set2]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.set_superset_QMARK_",
                                                  :source {:code "(defn superset? \n  [set1 set2]\n  (and (>= (count set1) (count set2))\n       (every? #(contains? set1 %) set2)))",
                                                           :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                           :lines [138
                                                                   142],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/set.cljs#L138-L142"},
                                                  :full-name "clojure.set/superset?",
                                                  :clj-symbol "clojure.set/superset?",
                                                  :docstring "Is set1 a superset of set2?"},
                         "clojure.browser.net/IConnection" {:ns "clojure.browser.net",
                                                            :name "IConnection",
                                                            :type "protocol",
                                                            :full-name-encode "clojure.browser.net_IConnection",
                                                            :source {:code "(defprotocol IConnection\n  (connect\n    [this]\n    [this opt1]\n    [this opt1 opt2]\n    [this opt1 opt2 opt3])\n  (transmit\n    [this opt]\n    [this opt opt2]\n    [this opt opt2 opt3]\n    [this opt opt2 opt3 opt4]\n    [this opt opt2 opt3 opt4 opt5])\n  (close [this]))",
                                                                     :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                     :lines [32
                                                                             44],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/net.cljs#L32-L44"},
                                                            :methods [{:name "connect",
                                                                       :signature ["[this]"
                                                                                   "[this opt1]"
                                                                                   "[this opt1 opt2]"
                                                                                   "[this opt1 opt2 opt3]"],
                                                                       :docstring nil}
                                                                      {:name "transmit",
                                                                       :signature ["[this opt]"
                                                                                   "[this opt opt2]"
                                                                                   "[this opt opt2 opt3]"
                                                                                   "[this opt opt2 opt3 opt4]"
                                                                                   "[this opt opt2 opt3 opt4 opt5]"],
                                                                       :docstring nil}
                                                                      {:name "close",
                                                                       :signature ["[this]"],
                                                                       :docstring nil}],
                                                            :full-name "clojure.browser.net/IConnection",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "cljs.core/let" {:ns "cljs.core",
                                          :name "let",
                                          :signature ["[bindings & body]"],
                                          :history [["+" "0.0-927"]],
                                          :type "macro",
                                          :full-name-encode "cljs.core_let",
                                          :source {:code "(defmacro let\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (even? (count bindings)) \"an even number of forms in binding vector\")\n  `(let* ~(destructure bindings) ~@body))",
                                                   :filename "clojurescript/src/clj/cljs/core.clj",
                                                   :lines [127 137],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L127-L137"},
                                          :full-name "cljs.core/let",
                                          :clj-symbol "clojure.core/let",
                                          :docstring "binding => binding-form init-expr\n\nEvaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein."},
                         "cljs.core/unchecked-divide-int" {:ns "cljs.core",
                                                           :name "unchecked-divide-int",
                                                           :signature ["[x]"
                                                                       "[x y]"
                                                                       "[x y & more]"],
                                                           :shadowed-sources ({:code "(defmacro unchecked-divide-int\n  ([& xs] `(/ ~@xs)))",
                                                                               :filename "clojurescript/src/clj/cljs/core.clj",
                                                                               :lines [293
                                                                                       294],
                                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L293-L294"}),
                                                           :history [["+"
                                                                      "0.0-1798"]],
                                                           :type "function",
                                                           :full-name-encode "cljs.core_unchecked-divide-int",
                                                           :source {:code "(defn unchecked-divide-int\n  ([x] (unchecked-divide-int 1 x))\n  ([x y] (cljs.core/divide x y)) ;; FIXME: waiting on cljs.core//\n  ([x y & more] (reduce unchecked-divide-int (unchecked-divide-int x y) more)))",
                                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                    :lines [1449
                                                                            1454],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1449-L1454"},
                                                           :full-name "cljs.core/unchecked-divide-int",
                                                           :clj-symbol "clojure.core/unchecked-divide-int",
                                                           :docstring "If no denominators are supplied, returns 1/numerator,\nelse returns numerator divided by all of the denominators."},
                         "cljs.core/dorun" {:ns "cljs.core",
                                            :name "dorun",
                                            :signature ["[coll]"
                                                        "[n coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_dorun",
                                            :source {:code "(defn dorun\n  ([coll]\n   (when (seq coll)\n     (recur (next coll))))\n  ([n coll]\n   (when (and (seq coll) (pos? n))\n     (recur (dec n) (next coll)))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [6134
                                                             6145],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6134-L6145"},
                                            :full-name "cljs.core/dorun",
                                            :clj-symbol "clojure.core/dorun",
                                            :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. dorun can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, does not retain the head and returns nil."},
                         "cljs.core/pr-str" {:ns "cljs.core",
                                             :name "pr-str",
                                             :signature ["[& objs]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_pr-str",
                                             :source {:code "(defn pr-str\n  [& objs]\n  (pr-str-with-opts objs (pr-opts)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [6371
                                                              6374],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6371-L6374"},
                                             :full-name "cljs.core/pr-str",
                                             :clj-symbol "clojure.core/pr-str",
                                             :docstring "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter."},
                         "cljs.core/IPrintable" {:ns "cljs.core",
                                                 :name "IPrintable",
                                                 :history [["+"
                                                            "0.0-927"]
                                                           ["-"
                                                            "0.0-1798"]],
                                                 :type "protocol",
                                                 :full-name-encode "cljs.core_IPrintable",
                                                 :source {:code "(defprotocol ^:deprecated IPrintable\n  \"Do not use this.  It is kept for backwards compatibility with existing\n   user code that depends on it, but it has been superceded by IPrintWithWriter\n   User code that depends on this should be changed to use -pr-writer instead.\"\n  (-pr-seq [o opts]))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [253
                                                                  257],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1586/src/cljs/cljs/core.cljs#L253-L257"},
                                                 :methods [{:name "-pr-seq",
                                                            :signature ["[o opts]"],
                                                            :docstring nil}],
                                                 :full-name "cljs.core/IPrintable",
                                                 :docstring "Do not use this.  It is kept for backwards compatibility with existing\n   user code that depends on it, but it has been superceded by IPrintWithWriter\n   User code that depends on this should be changed to use -pr-writer instead.",
                                                 :removed {:in "0.0-1798",
                                                           :last-seen "0.0-1586"}},
                         "cljs.core/defprotocol" {:full-name "cljs.core/defprotocol",
                                                  :ns "cljs.core",
                                                  :name "defprotocol",
                                                  :type "macro",
                                                  :signature ["[psym & doc+methods]"],
                                                  :source {:code "(defmacro defprotocol [psym & doc+methods]\n  (let [p (:name (cljs.analyzer/resolve-var (dissoc &env :locals) psym))\n        psym (vary-meta psym assoc :protocol-symbol true)\n        ns-name (-> &env :ns :name)\n        fqn (fn [n] (symbol (core/str ns-name \".\" n)))\n        prefix (protocol-prefix p)\n        methods (if (core/string? (first doc+methods)) (next doc+methods) doc+methods)\n        expand-sig (fn [fname slot sig]\n                     `(~sig\n                       (if (and ~(first sig) (. ~(first sig) ~(symbol (core/str \"-\" slot)))) ;; Property access needed here.\n                         (. ~(first sig) ~slot ~@sig)\n                         (let [x# (if (nil? ~(first sig)) nil ~(first sig))]\n                           ((or\n                             (aget ~(fqn fname) (goog.typeOf x#))\n                             (aget ~(fqn fname) \"_\")\n                             (throw (missing-protocol\n                                     ~(core/str psym \".\" fname) ~(first sig))))\n                            ~@sig)))))\n        method (fn [[fname & sigs]]\n                 (let [sigs (take-while vector? sigs)\n                       slot (symbol (core/str prefix (name fname)))\n                       fname (vary-meta fname assoc :protocol p)]\n                   `(defn ~fname ~@(map (fn [sig]\n                                          (expand-sig fname\n                                                      (symbol (core/str slot \"$arity$\" (count sig)))\n                                                      sig))\n                                        sigs))))]\n    `(do\n       (set! ~'*unchecked-if* true)\n       (def ~psym (~'js* \"{}\"))\n       ~@(map method methods)\n       (set! ~'*unchecked-if* false))))",
                                                           :filename "clojurescript/src/clj/cljs/core.clj",
                                                           :lines [796
                                                                   827],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L796-L827"},
                                                  :full-name-encode "cljs.core_defprotocol",
                                                  :clj-symbol "clojure.core/defprotocol",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/ints" {:full-name "cljs.core/ints",
                                           :ns "cljs.core",
                                           :name "ints",
                                           :type "function",
                                           :signature ["[x]"],
                                           :source {:code "(defn ints [x] x)",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1530 1530],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1530-L1530"},
                                           :full-name-encode "cljs.core_ints",
                                           :clj-symbol "clojure.core/ints",
                                           :history [["+" "0.0-1798"]]},
                         "cljs.core/assert" {:ns "cljs.core",
                                             :name "assert",
                                             :signature ["[x]"
                                                         "[x message]"],
                                             :shadowed-sources ({:code "(defmacro assert\n  ([x]\n     (when *assert*\n       `(when-not ~x\n          (throw (new AssertionError (str \"Assert failed: \" (pr-str '~x)))))))\n  ([x message]\n     (when *assert*\n       `(when-not ~x\n          (throw (new AssertionError (str \"Assert failed: \" ~message \"\\n\" (pr-str '~x))))))))",
                                                                 :filename "clojure/src/clj/clojure/core.clj",
                                                                 :lines [4346
                                                                         4357],
                                                                 :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L4346-L4357"}),
                                             :history [["+" "0.0-927"]],
                                             :type "macro",
                                             :full-name-encode "cljs.core_assert",
                                             :source {:code "(defmacro assert\n  ([x]\n     (when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" (cljs.core/pr-str '~x)))))))\n  ([x message]\n     (when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" ~message \"\\n\" (cljs.core/pr-str '~x))))))))",
                                                      :filename "clojurescript/src/clj/cljs/core.clj",
                                                      :lines [993
                                                              1005],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L993-L1005"},
                                             :full-name "cljs.core/assert",
                                             :clj-symbol "clojure.core/assert",
                                             :docstring "Evaluates expr and throws an exception if it does not evaluate to\nlogical true."},
                         "cljs.core/declare" {:ns "cljs.core",
                                              :name "declare",
                                              :signature ["[& names]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "macro",
                                              :full-name-encode "cljs.core_declare",
                                              :source {:code "(defmacro declare\n  [& names] `(do ~@(map #(list 'def (vary-meta % assoc :declared true)) names)))",
                                                       :filename "clojure/src/clj/clojure/core.clj",
                                                       :lines [2720
                                                               2723],
                                                       :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L2720-L2723"},
                                              :full-name "cljs.core/declare",
                                              :clj-symbol "clojure.core/declare",
                                              :docstring "defs the supplied var names with no bindings, useful for making forward declarations."},
                         "cljs.core/fn?" {:return-type boolean,
                                          :ns "cljs.core",
                                          :name "fn?",
                                          :signature ["[f]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_fn_QMARK_",
                                          :source {:code "(defn ^boolean fn? [f]\n  (or ^boolean (goog/isFunction f) (satisfies? Fn f)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [1113 1114],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1113-L1114"},
                                          :full-name "cljs.core/fn?",
                                          :clj-symbol "clojure.core/fn?"},
                         "cljs.core/associative?" {:return-type boolean,
                                                   :ns "cljs.core",
                                                   :name "associative?",
                                                   :signature ["[x]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.core_associative_QMARK_",
                                                   :source {:code "(defn ^boolean associative?\n  [x] (satisfies? IAssociative x))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [1012
                                                                    1014],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1012-L1014"},
                                                   :full-name "cljs.core/associative?",
                                                   :clj-symbol "clojure.core/associative?",
                                                   :docstring "Returns true if coll implements Associative"},
                         "cljs.core/IList" {:ns "cljs.core",
                                            :name "IList",
                                            :type "protocol",
                                            :full-name-encode "cljs.core_IList",
                                            :source {:code "(defprotocol IList\n  \"Marker interface indicating a persistent list\")",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [257 258],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L257-L258"},
                                            :full-name "cljs.core/IList",
                                            :docstring "Marker interface indicating a persistent list",
                                            :history [["+" "0.0-1211"]]},
                         "cljs.core/list*" {:ns "cljs.core",
                                            :name "list*",
                                            :signature ["[args]"
                                                        "[a args]"
                                                        "[a b args]"
                                                        "[a b c args]"
                                                        "[a b c d & more]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_list_STAR_",
                                            :source {:code "(defn list*\n  ([args] (seq args))\n  ([a args] (cons a args))\n  ([a b args] (cons a (cons b args)))\n  ([a b c args] (cons a (cons b (cons c args))))\n  ([a b c d & more]\n     (cons a (cons b (cons c (cons d (spread more)))))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2281
                                                             2289],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2281-L2289"},
                                            :full-name "cljs.core/list*",
                                            :clj-symbol "clojure.core/list*",
                                            :docstring "Creates a new list containing the items prepended to the rest, the\nlast of which will be treated as a sequence."},
                         "cljs.core/reduce" {:ns "cljs.core",
                                             :name "reduce",
                                             :signature ["[f coll]"
                                                         "[f val coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_reduce",
                                             :source {:code "(defn reduce\n  ([f coll]\n     (cond\n       (satisfies? IReduce coll false)\n       (-reduce ^not-native coll f)\n\n       (array? coll)\n       (array-reduce coll f)\n\n       (string? coll)\n       (array-reduce coll f)\n       \n       :else\n       (seq-reduce f coll)))\n  ([f val coll]\n     (cond\n       (satisfies? IReduce coll false)\n       (-reduce ^not-native coll f val)\n\n       (array? coll)\n       (array-reduce coll f val)\n      \n       (string? coll)\n       (array-reduce coll f val)\n       \n       :else\n       (seq-reduce f val coll))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1264
                                                              1299],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1264-L1299"},
                                             :full-name "cljs.core/reduce",
                                             :clj-symbol "clojure.core/reduce",
                                             :docstring "f should be a function of 2 arguments. If val is not supplied,\nreturns the result of applying f to the first 2 items in coll, then\napplying f to that result and the 3rd item, etc. If coll contains no\nitems, f must accept no arguments as well, and reduce returns the\nresult of calling f with no arguments.  If coll has only 1 item, it\nis returned and f is not called.  If val is supplied, returns the\nresult of applying f to val and the first item in coll, then\napplying f to that result and the 2nd item, etc. If coll contains no\nitems, returns val and f is not called."},
                         "clojure.browser.event/has-listener" {:full-name "clojure.browser.event/has-listener",
                                                               :ns "clojure.browser.event",
                                                               :name "has-listener",
                                                               :type "function",
                                                               :signature ["[obj opt_type opt_capture]"],
                                                               :source {:code "(defn has-listener [obj opt_type opt_capture])",
                                                                        :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                        :lines [94
                                                                                94],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/event.cljs#L94-L94"},
                                                               :full-name-encode "clojure.browser.event_has-listener",
                                                               :history [["+"
                                                                          "0.0-927"]]},
                         "cljs.core/unchecked-dec-int" {:ns "cljs.core",
                                                        :name "unchecked-dec-int",
                                                        :signature ["[x]"],
                                                        :shadowed-sources ({:code "(defmacro unchecked-dec-int\n  ([x] `(dec ~x)))",
                                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                                            :lines [290
                                                                                    291],
                                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L290-L291"}),
                                                        :history [["+"
                                                                   "0.0-1798"]],
                                                        :type "function",
                                                        :full-name-encode "cljs.core_unchecked-dec-int",
                                                        :source {:code "(defn unchecked-dec-int [x]\n  (cljs.core/unchecked-dec-int x))",
                                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                 :lines [1446
                                                                         1447],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1446-L1447"},
                                                        :full-name "cljs.core/unchecked-dec-int",
                                                        :clj-symbol "clojure.core/unchecked-dec-int"},
                         "cljs.core/compare" {:ns "cljs.core",
                                              :name "compare",
                                              :signature ["[x y]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_compare",
                                              :source {:code "(defn compare\n  [x y]\n  (cond\n   (identical? x y) 0\n\n   (nil? x) -1\n\n   (nil? y) 1\n\n   (identical? (type x) (type y))\n   (if (satisfies? IComparable x false)\n     (-compare ^not-native x y)\n     (garray/defaultCompare x y))\n\n   :else\n   (throw (js/Error. \"compare on non-nil objects of different types\"))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1164
                                                               1183],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1164-L1183"},
                                              :full-name "cljs.core/compare",
                                              :clj-symbol "clojure.core/compare",
                                              :docstring "Comparator. Returns a negative number, zero, or a positive number\n when x is logically 'less than', 'equal to', or 'greater than'\n y. Uses IComparable if available and google.array.defaultCompare for objects\nof the same type and special-cases nil to be less than any other object."},
                         "cljs.core/contains?" {:return-type boolean,
                                                :ns "cljs.core",
                                                :name "contains?",
                                                :signature ["[coll v]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_contains_QMARK_",
                                                :source {:code "(defn ^boolean contains?\n  [coll v]\n  (if (identical? (get coll v lookup-sentinel) lookup-sentinel)\n    false\n    true))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1127
                                                                 1136],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1127-L1136"},
                                                :full-name "cljs.core/contains?",
                                                :clj-symbol "clojure.core/contains?",
                                                :docstring "Returns true if key is present in the given collection, otherwise\nreturns false.  Note that for numerically indexed collections like\nvectors and arrays, this tests if the numeric key is within the\nrange of indexes. 'contains?' operates constant or logarithmic time;\nit will not perform a linear search for a value.  See also 'some'."},
                         "cljs.core/prefer-method" {:ns "cljs.core",
                                                    :name "prefer-method",
                                                    :signature ["[multifn dispatch-val-x dispatch-val-y]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_prefer-method",
                                                    :source {:code "(defn prefer-method\n  [multifn dispatch-val-x dispatch-val-y]\n  (-prefer-method multifn dispatch-val-x dispatch-val-y))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [7090
                                                                     7094],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L7090-L7094"},
                                                    :full-name "cljs.core/prefer-method",
                                                    :clj-symbol "clojure.core/prefer-method",
                                                    :docstring "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\nwhen there is a conflict"},
                         "cljs.core/array-seq" {:full-name "cljs.core/array-seq",
                                                :ns "cljs.core",
                                                :name "array-seq",
                                                :type "function",
                                                :signature ["[array]"
                                                            "[array i]"],
                                                :source {:code "(defn array-seq\n  ([array]\n     (prim-seq array 0))\n  ([array i]\n     (prim-seq array i)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [677
                                                                 681],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L677-L681"},
                                                :full-name-encode "cljs.core_array-seq",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/to-array-2d" {:ns "cljs.core",
                                                  :name "to-array-2d",
                                                  :signature ["[coll]"],
                                                  :history [["+"
                                                             "0.0-1211"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_to-array-2d",
                                                  :source {:code "(defn to-array-2d\n  [coll]\n    (let [ret (make-array (count coll))]\n      (loop [i 0 xs (seq coll)]\n        (when xs\n          (aset ret i (to-array (first xs)))\n          (recur (inc i) (next xs))))\n      ret))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [2145
                                                                   2154],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2145-L2154"},
                                                  :full-name "cljs.core/to-array-2d",
                                                  :clj-symbol "clojure.core/to-array-2d",
                                                  :docstring "Returns a (potentially-ragged) 2-dimensional array\ncontaining the contents of coll."},
                         "cljs.core/PersistentQueue" {:full-name "cljs.core/PersistentQueue",
                                                      :ns "cljs.core",
                                                      :name "PersistentQueue",
                                                      :type "type",
                                                      :signature ["[meta count front rear __hash]"],
                                                      :source {:code "(deftype PersistentQueue [meta count front rear ^:mutable __hash]\n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueue. meta count front rear __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest [coll] (rest (seq coll)))\n\n  IStack\n  (-peek [coll] (first front))\n  (-pop [coll]\n    (if front\n      (if-let [f1 (next front)]\n        (PersistentQueue. meta (dec count) f1 rear nil)\n        (PersistentQueue. meta (dec count) (seq rear) [] nil))\n      coll))\n\n  ICollection\n  (-conj [coll o]\n    (if front\n      (PersistentQueue. meta (inc count) front (conj (or rear []) o) nil)\n      (PersistentQueue. meta (inc count) (conj front o) [] nil)))\n\n  IEmptyableCollection\n  (-empty [coll] cljs.core.PersistentQueue/EMPTY)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (let [rear (seq rear)]\n      (if (or front rear)\n        (PersistentQueueSeq. nil front (seq rear) nil))))\n\n  ICounted\n  (-count [coll] count))",
                                                               :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                               :lines [3597
                                                                       3640],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L3597-L3640"},
                                                      :full-name-encode "cljs.core_PersistentQueue",
                                                      :history [["+"
                                                                 "0.0-927"]]},
                         "cljs.core/drop-last" {:ns "cljs.core",
                                                :name "drop-last",
                                                :signature ["[s]"
                                                            "[n s]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_drop-last",
                                                :source {:code "(defn drop-last\n  ([s] (drop-last 1 s))\n  ([n s] (map (fn [x _] x) s (drop n s))))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [2704
                                                                 2707],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2704-L2707"},
                                                :full-name "cljs.core/drop-last",
                                                :clj-symbol "clojure.core/drop-last",
                                                :docstring "Return a lazy sequence of all but the last n (default 1) items in coll"},
                         "cljs.core/array?" {:return-type boolean,
                                             :ns "cljs.core",
                                             :name "array?",
                                             :signature ["[x]"],
                                             :shadowed-sources ({:code "(defmacro array? [x]\n  (bool-expr (list 'js* \"~{} instanceof Array\" x)))",
                                                                 :filename "clojurescript/src/clj/cljs/core.clj",
                                                                 :lines [233
                                                                         234],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L233-L234"}),
                                             :history [["+"
                                                        "0.0-1798"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_array_QMARK_",
                                             :source {:code "(defn ^boolean array? [x]\n  (cljs.core/array? x))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [59 60],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L59-L60"},
                                             :full-name "cljs.core/array?"},
                         "cljs.core/filterv" {:ns "cljs.core",
                                              :name "filterv",
                                              :signature ["[pred coll]"],
                                              :history [["+"
                                                         "0.0-1211"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_filterv",
                                              :source {:code "(defn filterv\n  [pred coll]\n  (-> (reduce (fn [v o] (if (pred o) (conj! v o) v))\n              (transient [])\n              coll)\n      persistent!))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2875
                                                               2882],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2875-L2882"},
                                              :full-name "cljs.core/filterv",
                                              :clj-symbol "clojure.core/filterv",
                                              :docstring "Returns a vector of the items in coll for which\n(pred item) returns true. pred must be free of side-effects."},
                         "cljs.core/IComparable" {:ns "cljs.core",
                                                  :name "IComparable",
                                                  :type "protocol",
                                                  :full-name-encode "cljs.core_IComparable",
                                                  :source {:code "(defprotocol IComparable\n  (-compare [x y]))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [312
                                                                   313],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L312-L313"},
                                                  :methods [{:name "-compare",
                                                             :signature ["[x y]"],
                                                             :docstring nil}],
                                                  :full-name "cljs.core/IComparable",
                                                  :history [["+"
                                                             "0.0-1424"]]},
                         "cljs.reader/read-string" {:ns "cljs.reader",
                                                    :name "read-string",
                                                    :signature ["[s]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.reader_read-string",
                                                    :source {:code "(defn read-string\n  [s]\n  (let [r (push-back-reader s)]\n    (read r true nil false)))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [434
                                                                     438],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L434-L438"},
                                                    :full-name "cljs.reader/read-string",
                                                    :clj-symbol "clojure.core/read-string",
                                                    :docstring "Reads one object from the string s"},
                         "cljs.reader/unicode-2-pattern" {:full-name "cljs.reader/unicode-2-pattern",
                                                          :ns "cljs.reader",
                                                          :name "unicode-2-pattern",
                                                          :type "var",
                                                          :source {:code "(def unicode-2-pattern (re-pattern \"[0-9A-Fa-f]{2}\"))",
                                                                   :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                   :lines [189
                                                                           189],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L189-L189"},
                                                          :full-name-encode "cljs.reader_unicode-2-pattern",
                                                          :history [["+"
                                                                     "0.0-1424"]]},
                         "cljs.core/check-string-hash-cache" {:full-name "cljs.core/check-string-hash-cache",
                                                              :ns "cljs.core",
                                                              :name "check-string-hash-cache",
                                                              :type "function",
                                                              :signature ["[k]"],
                                                              :source {:code "(defn check-string-hash-cache [k]\n  (when (> string-hash-cache-count 255)\n    (set! string-hash-cache (js-obj))\n    (set! string-hash-cache-count 0))\n  (let [h (aget string-hash-cache k)]\n    (if (number? h)\n      h\n      (add-to-string-hash-cache k))))",
                                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                       :lines [976
                                                                               983],
                                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L976-L983"},
                                                              :full-name-encode "cljs.core_check-string-hash-cache",
                                                              :history [["+"
                                                                         "0.0-1424"]]},
                         "cljs.core/vector?" {:return-type boolean,
                                              :ns "cljs.core",
                                              :name "vector?",
                                              :signature ["[x]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_vector_QMARK_",
                                              :source {:code "(defn ^boolean vector?\n  [x] (satisfies? IVector x))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1031
                                                               1033],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1031-L1033"},
                                              :full-name "cljs.core/vector?",
                                              :clj-symbol "clojure.core/vector?",
                                              :docstring "Return true if x satisfies IVector"},
                         "cljs.core/defmulti" {:ns "cljs.core",
                                               :name "defmulti",
                                               :signature ["[mm-name & options]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "macro",
                                               :full-name-encode "cljs.core_defmulti",
                                               :source {:code "(defmacro defmulti\n  [mm-name & options]\n  (let [docstring   (if (core/string? (first options))\n                      (first options)\n                      nil)\n        options     (if (core/string? (first options))\n                      (next options)\n                      options)\n        m           (if (map? (first options))\n                      (first options)\n                      {})\n        options     (if (map? (first options))\n                      (next options)\n                      options)\n        dispatch-fn (first options)\n        options     (next options)\n        m           (if docstring\n                      (assoc m :doc docstring)\n                      m)\n        m           (if (meta mm-name)\n                      (conj (meta mm-name) m)\n                      m)]\n    (when (= (count options) 1)\n      (throw (Exception. \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\")))\n    (let [options   (apply hash-map options)\n          default   (core/get options :default :default)]\n      (check-valid-options options :default :hierarchy)\n      `(def ~(with-meta mm-name m)\n         (let [method-table# (atom {})\n               prefer-table# (atom {})\n               method-cache# (atom {})\n               cached-hierarchy# (atom {})\n               hierarchy# (get ~options :hierarchy (cljs.core/get-global-hierarchy))]\n           (cljs.core/MultiFn. ~(name mm-name) ~dispatch-fn ~default hierarchy#\n                               method-table# prefer-table# method-cache# cached-hierarchy#))))))",
                                                        :filename "clojurescript/src/clj/cljs/core.clj",
                                                        :lines [1228
                                                                1269],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L1228-L1269"},
                                               :full-name "cljs.core/defmulti",
                                               :clj-symbol "clojure.core/defmulti",
                                               :docstring "Creates a new multimethod with the associated dispatch function.\nThe docstring and attribute-map are optional.\n\nOptions are key-value pairs and may be one of:\n  :default    the default dispatch value, defaults to :default\n  :hierarchy  the isa? hierarchy to use for dispatching\n              defaults to the global hierarchy"},
                         "cljs.core/Keyword" {:full-name "cljs.core/Keyword",
                                              :ns "cljs.core",
                                              :name "Keyword",
                                              :type "type",
                                              :signature ["[k]"],
                                              :source {:code "(deftype Keyword [k]\n  IFn\n  (invoke [_ coll]\n    (when-not (nil? coll)\n      (let [strobj (.-strobj coll)]\n        (if (nil? strobj)\n          (-lookup coll k nil)\n          (aget strobj k)))))\n  (invoke [_ coll not-found]\n    (if (nil? coll)\n      not-found\n      (-lookup coll k not-found))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1940
                                                               1951],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1940-L1951"},
                                              :full-name-encode "cljs.core_Keyword",
                                              :history [["+"
                                                         "0.0-1424"]]},
                         "clojure.browser.event/dispatch-event" {:full-name "clojure.browser.event/dispatch-event",
                                                                 :ns "clojure.browser.event",
                                                                 :name "dispatch-event",
                                                                 :type "function",
                                                                 :signature ["[src event]"],
                                                                 :source {:code "(defn dispatch-event\n  [src event]\n  (goog.events/dispatchEvent src event))",
                                                                          :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                          :lines [75
                                                                                  77],
                                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/event.cljs#L75-L77"},
                                                                 :full-name-encode "clojure.browser.event_dispatch-event",
                                                                 :history [["+"
                                                                            "0.0-927"]]},
                         "clojure.string/split-lines" {:ns "clojure.string",
                                                       :name "split-lines",
                                                       :signature ["[s]"],
                                                       :history [["+"
                                                                  "0.0-927"]],
                                                       :type "function",
                                                       :full-name-encode "clojure.string_split-lines",
                                                       :source {:code "(defn split-lines\n  [s]\n  (split s #\"\\n|\\r\\n\"))",
                                                                :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                                :lines [101
                                                                        104],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/string.cljs#L101-L104"},
                                                       :full-name "clojure.string/split-lines",
                                                       :clj-symbol "clojure.string/split-lines",
                                                       :docstring "Splits s on \n or \r\n."},
                         "cljs.core/areduce" {:ns "cljs.core",
                                              :name "areduce",
                                              :signature ["[a idx ret init expr]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "macro",
                                              :full-name-encode "cljs.core_areduce",
                                              :source {:code "(defmacro areduce\n  [a idx ret init expr]\n  `(let [a# ~a]\n     (loop  [~idx 0 ~ret ~init]\n       (if (< ~idx  (alength a#))\n         (recur (inc ~idx) ~expr)\n         ~ret))))",
                                                       :filename "clojurescript/src/clj/cljs/core.clj",
                                                       :lines [1193
                                                               1202],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L1193-L1202"},
                                              :full-name "cljs.core/areduce",
                                              :clj-symbol "clojure.core/areduce",
                                              :docstring "Reduces an expression across an array a, using an index named idx,\nand return value named ret, initialized to init, setting ret to the\nevaluation of expr at each step, returning ret."},
                         "cljs.core/disj" {:ns "cljs.core",
                                           :name "disj",
                                           :signature ["[coll]"
                                                       "[coll k]"
                                                       "[coll k & ks]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_disj",
                                           :source {:code "(defn disj\n  ([coll] coll)\n  ([coll k]\n     (-disjoin coll k))\n  ([coll k & ks]\n     (let [ret (disj coll k)]\n       (if ks\n         (recur ret (first ks) (next ks))\n         ret))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [952 962],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L952-L962"},
                                           :full-name "cljs.core/disj",
                                           :clj-symbol "clojure.core/disj",
                                           :docstring "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\ndoes not contain key(s)."},
                         "cljs.core/IEditableCollection" {:ns "cljs.core",
                                                          :name "IEditableCollection",
                                                          :type "protocol",
                                                          :full-name-encode "cljs.core_IEditableCollection",
                                                          :source {:code "(defprotocol IEditableCollection\n  (-as-transient [coll]))",
                                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                   :lines [292
                                                                           293],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L292-L293"},
                                                          :methods [{:name "-as-transient",
                                                                     :signature ["[coll]"],
                                                                     :docstring nil}],
                                                          :full-name "cljs.core/IEditableCollection",
                                                          :history [["+"
                                                                     "0.0-1211"]]},
                         "cljs.core/unchecked-char" {:ns "cljs.core",
                                                     :name "unchecked-char",
                                                     :signature ["[x]"],
                                                     :shadowed-sources ({:code "(defmacro unchecked-char [x] x)",
                                                                         :filename "clojurescript/src/clj/cljs/core.clj",
                                                                         :lines [276
                                                                                 276],
                                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L276-L276"}),
                                                     :history [["+"
                                                                "0.0-1798"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.core_unchecked-char",
                                                     :source {:code "(defn unchecked-char [x] x)",
                                                              :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                              :lines [1424
                                                                      1424],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1424-L1424"},
                                                     :full-name "cljs.core/unchecked-char",
                                                     :clj-symbol "clojure.core/unchecked-char"},
                         "clojure.browser.net/event-types" {:full-name "clojure.browser.net/event-types",
                                                            :ns "clojure.browser.net",
                                                            :name "event-types",
                                                            :type "var",
                                                            :source {:code "(def event-types\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (. k (toLowerCase)))\n            v])\n         (merge\n          (js->clj goog.net.EventType)))))",
                                                                     :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                     :lines [23
                                                                             30],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/net.cljs#L23-L30"},
                                                            :full-name-encode "clojure.browser.net_event-types",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "clojure.string/lower-case" {:ns "clojure.string",
                                                      :name "lower-case",
                                                      :signature ["[s]"],
                                                      :history [["+"
                                                                 "0.0-927"]],
                                                      :type "function",
                                                      :full-name-encode "clojure.string_lower-case",
                                                      :source {:code "(defn lower-case\n  [s]\n  (.toLowerCase s))",
                                                               :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                               :lines [58
                                                                       61],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/string.cljs#L58-L61"},
                                                      :full-name "clojure.string/lower-case",
                                                      :clj-symbol "clojure.string/lower-case",
                                                      :docstring "Converts string to all lower-case."},
                         "cljs.core/*print-fn*" {:full-name "cljs.core/*print-fn*",
                                                 :ns "cljs.core",
                                                 :name "*print-fn*",
                                                 :docstring "Each runtime environment provides a diffenent way to print output.\nWhatever function *print-fn* is bound to will be passed any\nStrings which should be printed.",
                                                 :type "dynamic var",
                                                 :source {:code "(def\n  ^{:doc \"Each runtime environment provides a diffenent way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.\" :dynamic true}\n  *print-fn*\n  (fn [_]\n    (throw (js/Error. \"No *print-fn* fn set for evaluation environment\"))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [18
                                                                  24],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L18-L24"},
                                                 :full-name-encode "cljs.core__STAR_print-fn_STAR_",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "cljs.core/str" {:ns "cljs.core",
                                          :name "str",
                                          :signature ["[]"
                                                      "[x]"
                                                      "[x & ys]"],
                                          :shadowed-sources ({:code "(defmacro str [& xs]\n  (let [strs (->> (repeat (count xs) \"cljs.core.str(~{})\")\n                  (interpose \",\")\n                  (apply core/str))]\n   (concat (list 'js* (core/str \"[\" strs \"].join('')\")) xs)))",
                                                              :filename "clojurescript/src/clj/cljs/core.clj",
                                                              :lines [187
                                                                      191],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L187-L191"}),
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_str",
                                          :source {:code "(defn str\n  ([] \"\")\n  ([x] (cond\n        (keyword? x) (str* \":\" (. x (substring 2 (alength x))))\n        (nil? x) \"\"\n        :else (. x (toString))))\n  ([x & ys]\n     ((fn [sb more]\n        (if more\n          (recur (. sb  (append (str (first more)))) (next more))\n          (str* sb)))\n      (gstring/StringBuffer. (str x)) ys)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [1674 1688],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1674-L1688"},
                                          :full-name "cljs.core/str",
                                          :clj-symbol "clojure.core/str",
                                          :docstring "With no args, returns the empty string. With one arg x, returns\nx.toString().  (str nil) returns the empty string. With more than\none arg, returns the concatenation of the str values of the args."},
                         "cljs.core/ISequential" {:ns "cljs.core",
                                                  :name "ISequential",
                                                  :type "protocol",
                                                  :full-name-encode "cljs.core_ISequential",
                                                  :source {:code "(defprotocol ISequential\n  \"Marker interface indicating a persistent collection of sequential items\")",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [254
                                                                   255],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L254-L255"},
                                                  :full-name "cljs.core/ISequential",
                                                  :docstring "Marker interface indicating a persistent collection of sequential items",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/key-test" {:full-name "cljs.core/key-test",
                                               :ns "cljs.core",
                                               :name "key-test",
                                               :type "function",
                                               :signature ["[key other]"],
                                               :return-type boolean,
                                               :source {:code "(defn ^boolean key-test [key other]\n  (if ^boolean (goog/isString key)\n    (identical? key other)\n    (= key other)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [4083
                                                                4086],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L4083-L4086"},
                                               :full-name-encode "cljs.core_key-test",
                                               :history [["+"
                                                          "0.0-1424"]]},
                         "cljs.core/set" {:ns "cljs.core",
                                          :name "set",
                                          :signature ["[coll]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_set",
                                          :source {:code "(defn set\n  [coll]\n  (apply hash-set coll))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [5819 5822],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5819-L5822"},
                                          :full-name "cljs.core/set",
                                          :clj-symbol "clojure.core/set",
                                          :docstring "Returns a set of the distinct elements of coll."},
                         "cljs.core/obj-map" {:full-name "cljs.core/obj-map",
                                              :ns "cljs.core",
                                              :name "obj-map",
                                              :docstring "keyval => key val\nReturns a new object map with supplied mappings.",
                                              :type "function",
                                              :signature ["[& keyvals]"],
                                              :source {:code "(defn obj-map\n  [& keyvals]\n  (let [ks  (array)\n        obj (js-obj)]\n    (loop [kvs (seq keyvals)]\n      (if kvs\n        (do (.push ks (first kvs))\n            (aset obj (first kvs) (second kvs))\n            (recur (nnext kvs)))\n        (cljs.core.ObjMap/fromObject ks obj)))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [5530
                                                               5541],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5530-L5541"},
                                              :full-name-encode "cljs.core_obj-map",
                                              :history [["+"
                                                         "0.0-1443"]]},
                         "special/def" {:full-name "special/def",
                                        :ns "special",
                                        :name "def",
                                        :type "special form",
                                        :source {:code "(defmethod parse 'def\n  [op env form name]\n  (let [pfn (fn\n              ([_ sym] {:sym sym})\n              ([_ sym init] {:sym sym :init init})\n              ([_ sym doc init] {:sym sym :doc doc :init init}))\n        args (apply pfn form)\n        sym (:sym args)\n        sym-meta (meta sym)\n        tag (-> sym meta :tag)\n        protocol (-> sym meta :protocol)\n        dynamic (-> sym meta :dynamic)\n        ns-name (-> env :ns :name)]\n    (assert (not (namespace sym)) \"Can't def ns-qualified name\")\n    (let [env (if (or (and (not= ns-name 'cljs.core)\n                           (core-name? env sym))\n                      (get-in @namespaces [ns-name :uses sym]))\n                (let [ev (resolve-existing-var (dissoc env :locals) sym)]\n                  (when *cljs-warn-on-redef*\n                    (warning env\n                      (str \"WARNING: \" sym \" already refers to: \" (symbol (str (:ns ev)) (str sym))\n                           \" being replaced by: \" (symbol (str ns-name) (str sym)))))\n                  (swap! namespaces update-in [ns-name :excludes] conj sym)\n                  (update-in env [:ns :excludes] conj sym))\n                env)\n          name (:name (resolve-var (dissoc env :locals) sym))\n          var-expr (assoc (analyze (-> env (dissoc :locals)\n                                       (assoc :context :expr)\n                                       (assoc :def-var true))\n                                   sym)\n                     :op :var)\n          init-expr (when (contains? args :init)\n                      (disallowing-recur\n                        (analyze (assoc env :context :expr) (:init args) sym)))\n          fn-var? (and init-expr (= (:op init-expr) :fn))\n          export-as (when-let [export-val (-> sym meta :export)]\n                      (if (= true export-val) name export-val))\n          doc (or (:doc args) (-> sym meta :doc))]\n      (when-let [v (get-in @namespaces [ns-name :defs sym])]\n        (when (and *cljs-warn-on-fn-var*\n                   (not (-> sym meta :declared))\n                   (and (:fn-var v) (not fn-var?)))\n          (warning env\n            (str \"WARNING: \" (symbol (str ns-name) (str sym))\n                 \" no longer fn, references are stale\"))))\n      (swap! namespaces assoc-in [ns-name :defs sym]\n                 (merge \n                   {:name name}\n                   sym-meta\n                   (when doc {:doc doc})\n                   (when dynamic {:dynamic true})\n                   (source-info name env)\n                   ;; the protocol a protocol fn belongs to\n                   (when protocol\n                     {:protocol protocol})\n                   ;; symbol for reified protocol\n                   (when-let [protocol-symbol (-> sym meta :protocol-symbol)]\n                     {:protocol-symbol protocol-symbol})\n                   (when fn-var?\n                     {:fn-var true\n                      ;; protocol implementation context\n                      :protocol-impl (:protocol-impl init-expr)\n                      ;; inline protocol implementation context\n                      :protocol-inline (:protocol-inline init-expr)\n                      :variadic (:variadic init-expr)\n                      :max-fixed-arity (:max-fixed-arity init-expr)\n                      :method-params (map :params (:methods init-expr))})))\n      (merge {:env env :op :def :form form\n              :name name :var var-expr :doc doc :init init-expr}\n             (when tag {:tag tag})\n             (when dynamic {:dynamic true})\n             (when export-as {:export export-as})\n             (when init-expr {:children [init-expr]})))))",
                                                 :filename "clojurescript/src/clj/cljs/analyzer.clj",
                                                 :lines [296 368],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/analyzer.clj#L296-L368"},
                                        :full-name-encode "special_def",
                                        :clj-symbol "clojure.core/def",
                                        :history [["+" "0.0-927"]]},
                         "cljs.core/print" {:full-name "cljs.core/print",
                                            :ns "cljs.core",
                                            :name "print",
                                            :docstring "Prints the object(s) using string-print.\nprint and println produce output for human consumption.",
                                            :type "function",
                                            :source {:code "(def ^{:doc\n  \"Prints the object(s) using string-print.\n  print and println produce output for human consumption.\"}\n  print\n  (fn cljs-core-print [& objs]\n    (pr-with-opts objs (assoc (pr-opts) :readably false))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [6389
                                                             6394],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6389-L6394"},
                                            :full-name-encode "cljs.core_print",
                                            :clj-symbol "clojure.core/print",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/ArrayNode" {:full-name "cljs.core/ArrayNode",
                                                :ns "cljs.core",
                                                :name "ArrayNode",
                                                :type "type",
                                                :signature ["[edit cnt arr]"],
                                                :source {:code "(deftype ArrayNode [edit ^:mutable cnt ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        (ArrayNode. nil (inc cnt) (clone-and-set arr idx (.inode-assoc cljs.core.BitmapIndexedNode/EMPTY (+ shift 5) hash key val added-leaf?)))\n        (let [n (.inode-assoc node (+ shift 5) hash key val added-leaf?)]\n          (if (identical? n node)\n            inode\n            (ArrayNode. nil cnt (clone-and-set arr idx n)))))))\n\n  (inode-without [inode shift hash key]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (let [n (.inode-without node (+ shift 5) hash key)]\n          (cond\n            (identical? n node)\n            inode\n\n            (nil? n)\n            (if (<= cnt 8)\n              (pack-array-node inode nil idx)\n              (ArrayNode. nil (dec cnt) (clone-and-set arr idx n)))\n\n            :else\n            (ArrayNode. nil cnt (clone-and-set arr idx n))))\n        inode)))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (.inode-lookup node (+ shift 5) hash key not-found)\n        not-found)))\n\n  (inode-find [inode shift hash key not-found]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (.inode-find node (+ shift 5) hash key not-found)\n        not-found)))\n\n  (inode-seq [inode]\n    (create-array-node-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (ArrayNode. e cnt (aclone arr))))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        (let [editable (edit-and-set inode edit idx (.inode-assoc! cljs.core.BitmapIndexedNode/EMPTY edit (+ shift 5) hash key val added-leaf?))]\n          (set! (.-cnt editable) (inc (.-cnt editable)))\n          editable)\n        (let [n (.inode-assoc! node edit (+ shift 5) hash key val added-leaf?)]\n          (if (identical? n node)\n            inode\n            (edit-and-set inode edit idx n))))))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        inode\n        (let [n (.inode-without! node edit (+ shift 5) hash key removed-leaf?)]\n          (cond\n            (identical? n node)\n            inode\n\n            (nil? n)\n            (if (<= cnt 8)\n              (pack-array-node inode edit idx)\n              (let [editable (edit-and-set inode edit idx n)]\n                (set! (.-cnt editable) (dec (.-cnt editable)))\n                editable))\n\n            :else\n            (edit-and-set inode edit idx n))))))\n\n  (kv-reduce [inode f init]\n    (let [len (alength arr)]           ; actually 32\n      (loop [i 0 init init]\n        (if (< i len)\n          (let [node (aget arr i)]\n            (if-not (nil? node)\n              (let [init (.kv-reduce node f init)]\n                (if (reduced? init)\n                  @init\n                  (recur (inc i) init)))\n              (recur (inc i) init)))\n          init)))))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [4352
                                                                 4447],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L4352-L4447"},
                                                :full-name-encode "cljs.core_ArrayNode",
                                                :history [["+"
                                                           "0.0-1211"]]},
                         "cljs.core/type" {:full-name "cljs.core/type",
                                           :ns "cljs.core",
                                           :name "type",
                                           :type "function",
                                           :signature ["[x]"],
                                           :source {:code "(defn type [x]\n  (when-not (nil? x)\n    (.-constructor x)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [89 91],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L89-L91"},
                                           :full-name-encode "cljs.core_type",
                                           :clj-symbol "clojure.core/type",
                                           :history [["+" "0.0-971"]]},
                         "clojure.string/blank?" {:ns "clojure.string",
                                                  :name "blank?",
                                                  :signature ["[s]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.string_blank_QMARK_",
                                                  :source {:code "(defn blank?\n  [s]\n  (gstring/isEmptySafe s))",
                                                           :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                           :lines [133
                                                                   136],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/string.cljs#L133-L136"},
                                                  :full-name "clojure.string/blank?",
                                                  :clj-symbol "clojure.string/blank?",
                                                  :docstring "True is s is nil, empty, or contains only whitespace."},
                         "cljs.reader/maybe-read-tagged-type" {:full-name "cljs.reader/maybe-read-tagged-type",
                                                               :ns "cljs.reader",
                                                               :name "maybe-read-tagged-type",
                                                               :type "function",
                                                               :signature ["[rdr initch]"],
                                                               :source {:code "(defn maybe-read-tagged-type\n  [rdr initch]\n  (let [tag (read-symbol rdr initch)\n        pfn (get @*tag-table* (str tag))\n        dfn @*default-data-reader-fn*]\n    (cond\n     pfn (pfn (read rdr true nil false))\n     dfn (dfn tag (read rdr true nil false))\n     :else (reader-error rdr\n                         \"Could not find tag parser for \" (str tag)\n                         \" in \" (pr-str (keys @*tag-table*))))))",
                                                                        :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                        :lines [533
                                                                                543],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L533-L543"},
                                                               :full-name-encode "cljs.reader_maybe-read-tagged-type",
                                                               :history [["+"
                                                                          "0.0-1236"]]},
                         "cljs.core/IChunkedSeq" {:ns "cljs.core",
                                                  :name "IChunkedSeq",
                                                  :type "protocol",
                                                  :full-name-encode "cljs.core_IChunkedSeq",
                                                  :source {:code "(defprotocol IChunkedSeq\n  (-chunked-first [coll])\n  (-chunked-rest [coll]))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [318
                                                                   320],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L318-L320"},
                                                  :methods [{:name "-chunked-first",
                                                             :signature ["[coll]"],
                                                             :docstring nil}
                                                            {:name "-chunked-rest",
                                                             :signature ["[coll]"],
                                                             :docstring nil}],
                                                  :full-name "cljs.core/IChunkedSeq",
                                                  :history [["+"
                                                             "0.0-1424"]]},
                         "clojure.browser.dom/append" {:full-name "clojure.browser.dom/append",
                                                       :ns "clojure.browser.dom",
                                                       :name "append",
                                                       :type "function",
                                                       :signature ["[parent & children]"],
                                                       :source {:code "(defn append [parent & children]\n  (apply gdom/append parent children)\n  parent)",
                                                                :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                :lines [13
                                                                        15],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/dom.cljs#L13-L15"},
                                                       :full-name-encode "clojure.browser.dom_append",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.core/take-last" {:ns "cljs.core",
                                                :name "take-last",
                                                :signature ["[n coll]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_take-last",
                                                :source {:code "(defn take-last\n  [n coll]\n  (loop [s (seq coll), lead (seq (drop n coll))]\n    (if lead\n      (recur (next s) (next lead))\n      s)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [2709
                                                                 2716],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2709-L2716"},
                                                :full-name "cljs.core/take-last",
                                                :clj-symbol "clojure.core/take-last",
                                                :docstring "Returns a seq of the last n items in coll.  Depending on the type\nof coll may be no better than linear time.  For vectors, see also subvec."},
                         "cljs.core/key->js" {:full-name "cljs.core/key->js",
                                              :ns "cljs.core",
                                              :name "key->js",
                                              :type "function",
                                              :signature ["[k]"],
                                              :source {:code "(defn key->js [k]\n  (if (satisfies? IEncodeJS k)\n    (-clj->js k)\n    (if (or (string? k)\n            (number? k)\n            (keyword? k)\n            (symbol? k))\n      (clj->js k)\n      (pr-str k))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [6716
                                                               6724],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6716-L6724"},
                                              :full-name-encode "cljs.core_key-_GT_js",
                                              :history [["+"
                                                         "0.0-1798"]]},
                         "cljs.core/TransientHashMap" {:full-name "cljs.core/TransientHashMap",
                                                       :ns "cljs.core",
                                                       :name "TransientHashMap",
                                                       :type "type",
                                                       :signature ["[edit root count has-nil? nil-val]"],
                                                       :source {:code "(deftype TransientHashMap [^:mutable ^boolean edit\n                           ^:mutable root\n                           ^:mutable count\n                           ^:mutable ^boolean has-nil?\n                           ^:mutable nil-val]\n  Object\n  (conj! [tcoll o]\n    (if edit\n      (if (satisfies? IMapEntry o)\n        (.assoc! tcoll (key o) (val o))\n        (loop [es (seq o) tcoll tcoll]\n          (if-let [e (first es)]\n            (recur (next es)\n                   (.assoc! tcoll (key e) (val e)))\n            tcoll)))\n      (throw (js/Error. \"conj! after persistent\"))))\n\n  (assoc! [tcoll k v]\n    (if edit\n      (if (nil? k)\n        (do (if (identical? nil-val v)\n              nil\n              (set! nil-val v))\n            (if has-nil?\n              nil\n              (do (set! count (inc count))\n                  (set! has-nil? true)))\n            tcoll)\n        (let [added-leaf? (Box. false)\n              node        (-> (if (nil? root)\n                                cljs.core.BitmapIndexedNode/EMPTY\n                                root)\n                              (.inode-assoc! edit 0 (hash k) k v added-leaf?))]\n          (if (identical? node root)\n            nil\n            (set! root node))\n          (if ^boolean (.-val added-leaf?)\n            (set! count (inc count)))\n          tcoll))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  (without! [tcoll k]\n    (if edit\n      (if (nil? k)\n        (if has-nil?\n          (do (set! has-nil? false)\n              (set! nil-val nil)\n              (set! count (dec count))\n              tcoll)\n          tcoll)\n        (if (nil? root)\n          tcoll\n          (let [removed-leaf? (Box. false)\n                node (.inode-without! root edit 0 (hash k) k removed-leaf?)]\n            (if (identical? node root)\n              nil\n              (set! root node))\n            (if (aget removed-leaf? 0)\n              (set! count (dec count)))\n            tcoll)))\n      (throw (js/Error. \"dissoc! after persistent!\"))))\n\n  (persistent! [tcoll]\n    (if edit\n      (do (set! edit nil)\n          (PersistentHashMap. nil count root has-nil? nil-val nil))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ICounted\n  (-count [coll]\n    (if edit\n      count\n      (throw (js/Error. \"count after persistent!\"))))\n\n  ILookup\n  (-lookup [tcoll k]\n    (if (nil? k)\n      (if has-nil?\n        nil-val)\n      (if (nil? root)\n        nil\n        (.inode-lookup root 0 (hash k) k))))\n\n  (-lookup [tcoll k not-found]\n    (if (nil? k)\n      (if has-nil?\n        nil-val\n        not-found)\n      (if (nil? root)\n        not-found\n        (.inode-lookup root 0 (hash k) k not-found))))\n\n  ITransientCollection\n  (-conj! [tcoll val] (.conj! tcoll val))\n\n  (-persistent! [tcoll] (.persistent! tcoll))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val] (.assoc! tcoll key val))\n\n  ITransientMap\n  (-dissoc! [tcoll key] (.without! tcoll key)))",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [4786
                                                                        4887],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L4786-L4887"},
                                                       :full-name-encode "cljs.core_TransientHashMap",
                                                       :history [["+"
                                                                  "0.0-1211"]]},
                         "clojure.set/intersection" {:ns "clojure.set",
                                                     :name "intersection",
                                                     :signature ["[s1]"
                                                                 "[s1 s2]"
                                                                 "[s1 s2 & sets]"],
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "clojure.set_intersection",
                                                     :source {:code "(defn intersection\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s2) (count s1))\n       (recur s2 s1)\n       (reduce (fn [result item]\n                   (if (contains? s2 item)\n\t\t     result\n                     (disj result item)))\n\t       s1 s1)))\n  ([s1 s2 & sets] \n     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]\n       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))",
                                                              :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                              :lines [31
                                                                      44],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/set.cljs#L31-L44"},
                                                     :full-name "clojure.set/intersection",
                                                     :clj-symbol "clojure.set/intersection",
                                                     :docstring "Return a set that is the intersection of the input sets"},
                         "cljs.core/fnext" {:ns "cljs.core",
                                            :name "fnext",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_fnext",
                                            :source {:code "(defn fnext\n  [coll]\n  (first (next coll)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [739 742],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L739-L742"},
                                            :full-name "cljs.core/fnext",
                                            :clj-symbol "clojure.core/fnext",
                                            :docstring "Same as (first (next x))"},
                         "cljs.core/apply" {:ns "cljs.core",
                                            :name "apply",
                                            :signature ["[f args]"
                                                        "[f x args]"
                                                        "[f x y args]"
                                                        "[f x y z args]"
                                                        "[f a b c d & args]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_apply",
                                            :source {:code "(defn apply\n  ([f args]\n     (let [fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count args (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc args)\n            (.cljs$lang$applyTo f args)))\n         (.apply f f (to-array args)))))\n  ([f x args]\n     (let [arglist (list* x args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist)))))\n  ([f x y args]\n     (let [arglist (list* x y args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist)))))\n  ([f x y z args]\n     (let [arglist (list* x y z args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist)))))\n  ([f a b c d & args]\n     (let [arglist (cons a (cons b (cons c (cons d (spread args)))))\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist))))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2322
                                                             2368],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2322-L2368"},
                                            :full-name "cljs.core/apply",
                                            :clj-symbol "clojure.core/apply",
                                            :docstring "Applies fn f to the argument list formed by prepending intervening arguments to args.\nFirst cut.  Not lazy.  Needs to use emitted toApply."},
                         "clojure.walk/prewalk" {:ns "clojure.walk",
                                                 :name "prewalk",
                                                 :signature ["[f form]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.walk_prewalk",
                                                 :source {:code "(defn prewalk\n  [f form]\n  (walk (partial prewalk f) identity (f form)))",
                                                          :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                          :lines [58
                                                                  62],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/walk.cljs#L58-L62"},
                                                 :full-name "clojure.walk/prewalk",
                                                 :clj-symbol "clojure.walk/prewalk",
                                                 :docstring "Like postwalk, but does pre-order traversal."},
                         "cljs.core/flatten" {:ns "cljs.core",
                                              :name "flatten",
                                              :signature ["[x]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_flatten",
                                              :source {:code "(defn flatten\n  [x]\n  (filter #(not (sequential? %))\n          (rest (tree-seq sequential? seq x))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2841
                                                               2847],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2841-L2847"},
                                              :full-name "cljs.core/flatten",
                                              :clj-symbol "clojure.core/flatten",
                                              :docstring "Takes any nested combination of sequential things (lists, vectors,\netc.) and returns their contents as a single, flat sequence.\n(flatten nil) returns nil."},
                         "cljs.core/get" {:ns "cljs.core",
                                          :name "get",
                                          :signature ["[o k]"
                                                      "[o k not-found]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_get",
                                          :source {:code "(defn get\n  ([o k]\n    (when-not (nil? o)\n      (cond\n        (satisfies? ILookup o false)\n        (-lookup ^not-native o k)\n\n        (array? o)\n        (when (< k (.-length o))\n          (aget o k))\n        \n        (string? o)\n        (when (< k (.-length o))\n          (aget o k))\n        \n        :else nil)))\n  ([o k not-found]\n    (if-not (nil? o)\n      (cond\n        (satisfies? ILookup o false)\n        (-lookup ^not-native o k not-found)\n\n        (array? o)\n        (if (< k (.-length o))\n          (aget o k)\n          not-found)\n        \n        (string? o)\n        (if (< k (.-length o))\n          (aget o k)\n          not-found)\n\n        :else not-found)\n      not-found)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [854 888],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L854-L888"},
                                          :full-name "cljs.core/get",
                                          :clj-symbol "clojure.core/get",
                                          :docstring "Returns the value mapped to key, not-found or nil if key not present."},
                         "cljs.core/char" {:ns "cljs.core",
                                           :name "char",
                                           :signature ["[x]"],
                                           :history [["+" "0.0-1798"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_char",
                                           :source {:code "(defn char\n  [x]\n  (cond\n    (number? x) (.fromCharCode js/String x)\n    (and (string? x) (== (.-length x) 1)) x\n    :else (throw (js/Error. \"Argument to char must be a character or number\"))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1411 1417],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1411-L1417"},
                                           :full-name "cljs.core/char",
                                           :clj-symbol "clojure.core/char",
                                           :docstring "Coerce to char"},
                         "cljs.core/.." {:ns "cljs.core",
                                         :name "..",
                                         :signature ["[x form]"
                                                     "[x form & more]"],
                                         :history [["+" "0.0-927"]],
                                         :type "macro",
                                         :full-name-encode "cljs.core__DOT__DOT_",
                                         :source {:code "(defmacro ..\n  ([x form] `(. ~x ~form))\n  ([x form & more] `(.. (. ~x ~form) ~@more)))",
                                                  :filename "clojure/src/clj/clojure/core.clj",
                                                  :lines [1527 1543],
                                                  :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L1527-L1543"},
                                         :full-name "cljs.core/..",
                                         :clj-symbol "clojure.core/..",
                                         :docstring "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\nExpands into a member access (.) of the first member on the first\nargument, followed by the next member on the result, etc. For\ninstance:\n\n(.. System (getProperties) (get \"os.name\"))\n\nexpands to:\n\n(. (. System (getProperties)) (get \"os.name\"))\n\nbut is easier to write, read, and understand."},
                         "cljs.core/floats" {:full-name "cljs.core/floats",
                                             :ns "cljs.core",
                                             :name "floats",
                                             :type "function",
                                             :signature ["[x]"],
                                             :source {:code "(defn floats [x] x)",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1531
                                                              1531],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1531-L1531"},
                                             :full-name-encode "cljs.core_floats",
                                             :clj-symbol "clojure.core/floats",
                                             :history [["+"
                                                        "0.0-1798"]]},
                         "cljs.core/Range" {:full-name "cljs.core/Range",
                                            :ns "cljs.core",
                                            :name "Range",
                                            :type "type",
                                            :signature ["[meta start end step __hash]"],
                                            :source {:code "(deftype Range [meta start end step ^:mutable __hash]\n  IWithMeta\n  (-with-meta [rng meta] (Range. meta start end step __hash))\n\n  IMeta\n  (-meta [rng] meta)\n\n  ISeqable\n  (-seq [rng]\n    (if (pos? step)\n      (when (< start end)\n        rng)\n      (when (> start end)\n        rng)))\n\n  ISeq\n  (-first [rng] start)\n  (-rest [rng]\n    (if-not (nil? (-seq rng))\n      (Range. meta (+ start step) end step nil)\n      ()))\n\n  INext\n  (-next [rng]\n    (if (pos? step)\n      (when (< (+ start step) end)\n        (Range. meta (+ start step) end step nil))\n      (when (> (+ start step) end)\n        (Range. meta (+ start step) end step nil))))\n\n  ICollection\n  (-conj [rng o] (cons o rng))\n\n  IEmptyableCollection\n  (-empty [rng] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [rng other] (equiv-sequential rng other))\n\n  IHash\n  (-hash [rng] (caching-hash rng hash-coll __hash))\n\n  ICounted\n  (-count [rng]\n    (if-not (-seq rng)\n      0\n      (js/Math.ceil (/ (- end start) step))))\n\n  IIndexed\n  (-nth [rng n]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (zero? step))\n        start\n        (throw (js/Error. \"Index out of bounds\")))))\n  (-nth [rng n not-found]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (zero? step))\n        start\n        not-found)))\n\n  IReduce\n  (-reduce [rng f] (ci-reduce rng f))\n  (-reduce [rng f s] (ci-reduce rng f s)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [5976
                                                             6041],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5976-L6041"},
                                            :full-name-encode "cljs.core_Range",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/zero?" {:return-type boolean,
                                            :ns "cljs.core",
                                            :name "zero?",
                                            :signature ["[n]"],
                                            :shadowed-sources ({:code "(defmacro zero? [x]\n  `(== ~x 0))",
                                                                :filename "clojurescript/src/clj/cljs/core.clj",
                                                                :lines [375
                                                                        376],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L375-L376"}),
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_zero_QMARK_",
                                            :source {:code "(defn ^boolean zero? [n]\n  (cljs.core/zero? n))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [1642
                                                             1643],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1642-L1643"},
                                            :full-name "cljs.core/zero?",
                                            :clj-symbol "clojure.core/zero?"},
                         "cljs.core/identity" {:full-name "cljs.core/identity",
                                               :ns "cljs.core",
                                               :name "identity",
                                               :type "function",
                                               :signature ["[x]"],
                                               :source {:code "(defn identity [x] x)",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [2426
                                                                2426],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2426-L2426"},
                                               :full-name-encode "cljs.core_identity",
                                               :clj-symbol "clojure.core/identity",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/first" {:ns "cljs.core",
                                            :name "first",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_first",
                                            :source {:code "(defn first\n  [coll]\n  (when-not (nil? coll)\n    (if (satisfies? ISeq coll false)\n      (-first ^not-native coll)\n      (let [s (seq coll)]\n        (when-not (nil? s)\n          (-first s))))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [400 409],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L400-L409"},
                                            :full-name "cljs.core/first",
                                            :clj-symbol "clojure.core/first",
                                            :docstring "Returns the first item in the collection. Calls seq on its\nargument. If coll is nil, returns nil."},
                         "cljs.reader/ratio-pattern" {:full-name "cljs.reader/ratio-pattern",
                                                      :ns "cljs.reader",
                                                      :name "ratio-pattern",
                                                      :type "var",
                                                      :source {:code "(def ratio-pattern (re-pattern \"([-+]?[0-9]+)/([0-9]+)\"))",
                                                               :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                               :lines [100
                                                                       100],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L100-L100"},
                                                      :full-name-encode "cljs.reader_ratio-pattern",
                                                      :history [["+"
                                                                 "0.0-927"]]},
                         "cljs.core/println-str" {:ns "cljs.core",
                                                  :name "println-str",
                                                  :signature ["[& objs]"],
                                                  :history [["+"
                                                             "0.0-1011"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_println-str",
                                                  :source {:code "(defn println-str\n  [& objs]\n  (prn-str-with-opts objs (assoc (pr-opts) :readably false)))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [6407
                                                                   6410],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6407-L6410"},
                                                  :full-name "cljs.core/println-str",
                                                  :clj-symbol "clojure.core/println-str",
                                                  :docstring "println to a string, returning it"},
                         "cljs.core/>" {:return-type boolean,
                                        :ns "cljs.core",
                                        :name ">",
                                        :signature ["[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :shadowed-sources ({:code "(defmacro >\n  ([x] true)\n  ([x y] (bool-expr (list 'js* \"(~{} > ~{})\" x y)))\n  ([x y & more] `(and (> ~x ~y) (> ~y ~@more))))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [354
                                                                    357],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L354-L357"}),
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core__GT_",
                                        :source {:code "(defn ^boolean >\n  ([x] true)\n  ([x y] (cljs.core/> x y))\n  ([x y & more]\n   (if (cljs.core/> x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/> y (first more)))\n     false)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [1367 1377],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1367-L1377"},
                                        :full-name "cljs.core/>",
                                        :clj-symbol "clojure.core/>",
                                        :docstring "Returns non-nil if nums are in monotonically decreasing order,\notherwise false."},
                         "cljs.core/juxt" {:ns "cljs.core",
                                           :name "juxt",
                                           :signature ["[f]"
                                                       "[f g]"
                                                       "[f g h]"
                                                       "[f g h & fs]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_juxt",
                                           :source {:code "(defn juxt\n  ([f]\n     (fn\n       ([] (vector (f)))\n       ([x] (vector (f x)))\n       ([x y] (vector (f x y)))\n       ([x y z] (vector (f x y z)))\n       ([x y z & args] (vector (apply f x y z args)))))\n  ([f g]\n     (fn\n       ([] (vector (f) (g)))\n       ([x] (vector (f x) (g x)))\n       ([x y] (vector (f x y) (g x y)))\n       ([x y z] (vector (f x y z) (g x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (vector (f) (g) (h)))\n       ([x] (vector (f x) (g x) (h x)))\n       ([x y] (vector (f x y) (g x y) (h x y)))\n       ([x y z] (vector (f x y z) (g x y z) (h x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args) (apply h x y z args)))))\n  ([f g h & fs]\n     (let [fs (list* f g h fs)]\n       (fn\n         ([] (reduce #(conj %1 (%2)) [] fs))\n         ([x] (reduce #(conj %1 (%2 x)) [] fs))\n         ([x y] (reduce #(conj %1 (%2 x y)) [] fs))\n         ([x y z] (reduce #(conj %1 (%2 x y z)) [] fs))\n         ([x y z & args] (reduce #(conj %1 (apply %2 x y z args)) [] fs))))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [6098 6132],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6098-L6132"},
                                           :full-name "cljs.core/juxt",
                                           :clj-symbol "clojure.core/juxt",
                                           :docstring "Takes a set of functions and returns a fn that is the juxtaposition\nof those fns.  The returned fn takes a variable number of args, and\nreturns a vector containing the result of applying each fn to the\nargs (left-to-right).\n((juxt a b c) x) => [(a x) (b x) (c x)]"},
                         "cljs.core/max" {:ns "cljs.core",
                                          :name "max",
                                          :signature ["[x]"
                                                      "[x y]"
                                                      "[x y & more]"],
                                          :shadowed-sources ({:code "(defmacro max\n  ([x] x)\n  ([x y] (list 'js* \"((~{} > ~{}) ? ~{} : ~{})\" x y x y))\n  ([x y & more] `(max (max ~x ~y) ~@more)))",
                                                              :filename "clojurescript/src/clj/cljs/core.clj",
                                                              :lines [384
                                                                      387],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L384-L387"}),
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_max",
                                          :source {:code "(defn max\n  ([x] x)\n  ([x y] (cljs.core/max x y))\n  ([x y & more]\n   (reduce max (cljs.core/max x y) more)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [1395 1400],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1395-L1400"},
                                          :full-name "cljs.core/max",
                                          :clj-symbol "clojure.core/max",
                                          :docstring "Returns the greatest of the nums."},
                         "cljs.core/with-out-str" {:ns "cljs.core",
                                                   :name "with-out-str",
                                                   :signature ["[& body]"],
                                                   :history [["+"
                                                              "0.0-1535"]],
                                                   :type "macro",
                                                   :full-name-encode "cljs.core_with-out-str",
                                                   :source {:code "(defmacro with-out-str\n  [& body]\n  `(let [sb# (goog.string/StringBuffer.)]\n     (binding [cljs.core/*print-fn* (fn [x#] (.append sb# x#))]\n       ~@body)\n     (cljs.core/str sb#)))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [1329
                                                                    1337],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L1329-L1337"},
                                                   :full-name "cljs.core/with-out-str",
                                                   :clj-symbol "clojure.core/with-out-str",
                                                   :docstring "Evaluates exprs in a context in which *print-fn* is bound to .append\non a fresh StringBuffer.  Returns the string created by any nested\nprinting calls."},
                         "cljs.core/*3" {:full-name "cljs.core/*3",
                                         :ns "cljs.core",
                                         :name "*3",
                                         :docstring "bound in a repl thread to the third most recent value printed",
                                         :type "var",
                                         :source {:code "(def\n  ^{:doc \"bound in a repl thread to the third most recent value printed\"}\n  *3)",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [38 40],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L38-L40"},
                                         :full-name-encode "cljs.core__STAR_3",
                                         :clj-symbol "clojure.core/*3",
                                         :history [["+" "0.0-927"]]},
                         "cljs.core/memfn" {:ns "cljs.core",
                                            :name "memfn",
                                            :signature ["[name & args]"],
                                            :history [["+" "0.0-1443"]],
                                            :type "macro",
                                            :full-name-encode "cljs.core_memfn",
                                            :source {:code "(defmacro memfn\n  [name & args]\n  (let [t (with-meta (gensym \"target\")\n            (meta name))]\n    `(fn [~t ~@args]\n       (. ~t (~name ~@args)))))",
                                                     :filename "clojure/src/clj/clojure/core.clj",
                                                     :lines [3480
                                                             3491],
                                                     :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L3480-L3491"},
                                            :full-name "cljs.core/memfn",
                                            :clj-symbol "clojure.core/memfn",
                                            :docstring "Expands into code that creates a fn that expects to be passed an\nobject and any args and calls the named instance method on the\nobject passing the args. Use when you want to treat a Java method as\na first-class fn. name may be type-hinted with the method receiver's\ntype in order to avoid reflective calls."},
                         "cljs.core/IEncodeClojure" {:ns "cljs.core",
                                                     :name "IEncodeClojure",
                                                     :type "protocol",
                                                     :full-name-encode "cljs.core_IEncodeClojure",
                                                     :source {:code "(defprotocol IEncodeClojure\n  (-js->clj [x options] \"Transforms JavaScript values to Clojure\"))",
                                                              :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                              :lines [6744
                                                                      6745],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6744-L6745"},
                                                     :methods [{:name "-js->clj",
                                                                :signature ["[x options]"],
                                                                :docstring "Transforms JavaScript values to Clojure"}],
                                                     :full-name "cljs.core/IEncodeClojure",
                                                     :history [["+"
                                                                "0.0-1552"]]},
                         "cljs.core/TransientArrayMap" {:full-name "cljs.core/TransientArrayMap",
                                                        :ns "cljs.core",
                                                        :name "TransientArrayMap",
                                                        :type "type",
                                                        :signature ["[editable? len arr]"],
                                                        :source {:code "(deftype TransientArrayMap [^:mutable editable?\n                            ^:mutable len\n                            arr]\n  ICounted\n  (-count [tcoll]\n    (if editable?\n      (quot len 2)\n      (throw (js/Error. \"count after persistent!\"))))\n\n  ILookup\n  (-lookup [tcoll k]\n    (-lookup tcoll k nil))\n\n  (-lookup [tcoll k not-found]\n    (if editable?\n      (let [idx (array-map-index-of tcoll k)]\n        (if (== idx -1)\n          not-found\n          (aget arr (inc idx))))\n      (throw (js/Error. \"lookup after persistent!\"))))\n\n  ITransientCollection\n  (-conj! [tcoll o]\n    (if editable?\n      (if (satisfies? IMapEntry o)\n        (-assoc! tcoll (key o) (val o))\n        (loop [es (seq o) tcoll tcoll]\n          (if-let [e (first es)]\n            (recur (next es)\n                   (-assoc! tcoll (key e) (val e)))\n            tcoll)))\n      (throw (js/Error. \"conj! after persistent!\"))))\n\n  (-persistent! [tcoll]\n    (if editable?\n      (do (set! editable? false)\n          (PersistentArrayMap. nil (quot len 2) arr nil))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val]\n    (if editable?\n      (let [idx (array-map-index-of tcoll key)]\n        (if (== idx -1)\n          (if (<= (+ len 2) (* 2 cljs.core.PersistentArrayMap/HASHMAP_THRESHOLD))\n            (do (set! len (+ len 2))\n                (.push arr key)\n                (.push arr val)\n                tcoll)\n            (assoc! (array->transient-hash-map len arr) key val))\n          (if (identical? val (aget arr (inc idx)))\n            tcoll\n            (do (aset arr (inc idx) val)\n                tcoll))))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  ITransientMap\n  (-dissoc! [tcoll key]\n    (if editable?\n      (let [idx (array-map-index-of tcoll key)]\n        (when (>= idx 0)\n          (aset arr idx (aget arr (- len 2)))\n          (aset arr (inc idx) (aget arr (dec len)))\n          (doto arr .pop .pop)\n          (set! len (- len 2)))\n        tcoll)\n      (throw (js/Error. \"dissoc! after persistent!\")))))",
                                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                 :lines [4000
                                                                         4066],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L4000-L4066"},
                                                        :full-name-encode "cljs.core_TransientArrayMap",
                                                        :history [["+"
                                                                   "0.0-1211"]]},
                         "cljs.core/cond->>" {:ns "cljs.core",
                                              :name "cond->>",
                                              :signature ["[expr & clauses]"],
                                              :history [["+"
                                                         "0.0-1798"]],
                                              :type "macro",
                                              :full-name-encode "cljs.core_cond-_GT__GT_",
                                              :source {:code "(defmacro cond->>\n  [expr & clauses]\n  (assert (even? (count clauses)))\n  (let [g (gensym)\n        pstep (fn [[test step]] `(if ~test (->> ~g ~step) ~g))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep (partition 2 clauses)))]\n       ~g)))",
                                                       :filename "clojure/src/clj/clojure/core.clj",
                                                       :lines [6789
                                                               6801],
                                                       :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L6789-L6801"},
                                              :full-name "cljs.core/cond->>",
                                              :clj-symbol "clojure.core/cond->>",
                                              :docstring "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\nthrough each form for which the corresponding test expression\nis true.  Note that, unlike cond branching, cond->> threading does not short circuit\nafter the first true test expression."},
                         "cljs.core/number?" {:return-type boolean,
                                              :ns "cljs.core",
                                              :name "number?",
                                              :signature ["[n]"],
                                              :shadowed-sources ({:code "(defmacro number? [x]\n  (bool-expr (list 'js* \"typeof ~{} === 'number'\" x)))",
                                                                  :filename "clojurescript/src/clj/cljs/core.clj",
                                                                  :lines [248
                                                                          249],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L248-L249"}),
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_number_QMARK_",
                                              :source {:code "(defn ^boolean number? [n]\n  (cljs.core/number? n))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1110
                                                               1111],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1110-L1111"},
                                              :full-name "cljs.core/number?",
                                              :clj-symbol "clojure.core/number?"},
                         "cljs.core/array" {:ns "cljs.core",
                                            :name "array",
                                            :signature ["[var-args]"],
                                            :shadowed-sources ({:code "(defmacro array [& rest]\n  (let [xs-str (->> (repeat \"~{}\")\n                    (take (count rest))\n                    (interpose \",\")\n                    (apply core/str))]\n   (concat\n    (list 'js* (core/str \"[\" xs-str \"]\"))\n    rest)))",
                                                                :filename "clojurescript/src/clj/cljs/core.clj",
                                                                :lines [1150
                                                                        1157],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L1150-L1157"}),
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_array",
                                            :source {:code "(defn array\n  [var-args]            ;; [& items]\n  (.call (.-slice (.-prototype js/Array)) (cljs.core/js-arguments)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [109 113],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L109-L113"},
                                            :full-name "cljs.core/array",
                                            :docstring "Creates a new javascript array.\n@param {...*} var_args"},
                         "cljs.core/nthnext" {:ns "cljs.core",
                                              :name "nthnext",
                                              :signature ["[coll n]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_nthnext",
                                              :source {:code "(defn nthnext\n  [coll n]\n  (loop [n n xs (seq coll)]\n    (if (and xs (pos? n))\n      (recur (dec n) (next xs))\n      xs)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1651
                                                               1657],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1651-L1657"},
                                              :full-name "cljs.core/nthnext",
                                              :clj-symbol "clojure.core/nthnext",
                                              :docstring "Returns the nth next of coll, (seq coll) when n is 0."},
                         "cljs.core/re-pattern" {:ns "cljs.core",
                                                 :name "re-pattern",
                                                 :signature ["[s]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_re-pattern",
                                                 :source {:code "(defn re-pattern\n  [s]\n  (let [[_ flags pattern] (re-find #\"^(?:\\(\\?([idmsux]*)\\))?(.*)\" s)]\n    (js/RegExp. pattern flags)))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [6196
                                                                  6200],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6196-L6200"},
                                                 :full-name "cljs.core/re-pattern",
                                                 :clj-symbol "clojure.core/re-pattern",
                                                 :docstring "Returns an instance of RegExp which has compiled the provided string."},
                         "cljs.core/missing-protocol" {:full-name "cljs.core/missing-protocol",
                                                       :ns "cljs.core",
                                                       :name "missing-protocol",
                                                       :type "function",
                                                       :signature ["[proto obj]"],
                                                       :source {:code "(defn missing-protocol [proto obj]\n  (let [ty (type obj)\n        ty (if (and ty (.-cljs$lang$type ty))\n             (.-cljs$lang$ctorStr ty)\n             (goog/typeOf obj))]\n   (js/Error.\n     (.join (array \"No protocol method \" proto\n                   \" defined for type \" ty \": \" obj) \"\"))))",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [93
                                                                        100],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L93-L100"},
                                                       :full-name-encode "cljs.core_missing-protocol",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "clojure.browser.dom/set-text" {:full-name "clojure.browser.dom/set-text",
                                                         :ns "clojure.browser.dom",
                                                         :name "set-text",
                                                         :docstring "Set the text content for the passed element returning the\nelement. If a keyword is passed in the place of e, the element with\nthat id will be used and returned.",
                                                         :type "function",
                                                         :signature ["[e s]"],
                                                         :source {:code "(defn set-text\n  [e s]\n  (gdom/setTextContent (ensure-element e) s))",
                                                                  :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                  :lines [124
                                                                          129],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/dom.cljs#L124-L129"},
                                                         :full-name-encode "clojure.browser.dom_set-text",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "clojure.zip/up" {:ns "clojure.zip",
                                           :name "up",
                                           :signature ["[loc]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.zip_up",
                                           :source {:code "(defn up\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes r :r, changed? :changed?, :as path}] loc]\n      (when pnodes\n        (let [pnode (peek pnodes)]\n          (with-meta (if changed?\n                       [(make-node loc pnode (concat l (cons node r))) \n                        (and ppath (assoc ppath :changed? true))]\n                       [pnode ppath])\n                     (meta loc))))))",
                                                    :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                    :lines [111 122],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L111-L122"},
                                           :full-name "clojure.zip/up",
                                           :clj-symbol "clojure.zip/up",
                                           :docstring "Returns the loc of the parent of the node at this loc, or nil if at\nthe top"},
                         "cljs.core/IWithMeta" {:ns "cljs.core",
                                                :name "IWithMeta",
                                                :type "protocol",
                                                :full-name-encode "cljs.core_IWithMeta",
                                                :source {:code "(defprotocol IWithMeta\n  (-with-meta [o meta]))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [236
                                                                 237],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L236-L237"},
                                                :methods [{:name "-with-meta",
                                                           :signature ["[o meta]"],
                                                           :docstring nil}],
                                                :full-name "cljs.core/IWithMeta",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/bit-and-not" {:ns "cljs.core",
                                                  :name "bit-and-not",
                                                  :signature ["[x y]"],
                                                  :shadowed-sources ({:code "(defmacro bit-and-not\n  ([x y] (list 'js* \"(~{} & ~~{})\" x y))\n  ([x y & more] `(bit-and-not (bit-and-not ~x ~y) ~@more)))",
                                                                      :filename "clojurescript/src/clj/cljs/core.clj",
                                                                      :lines [420
                                                                              422],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L420-L422"}),
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_bit-and-not",
                                                  :source {:code "(defn bit-and-not\n  [x y] (cljs.core/bit-and-not x y))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [1578
                                                                   1580],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1578-L1580"},
                                                  :full-name "cljs.core/bit-and-not",
                                                  :clj-symbol "clojure.core/bit-and-not",
                                                  :docstring "Bitwise and"},
                         "clojure.string/triml" {:ns "clojure.string",
                                                 :name "triml",
                                                 :signature ["[s]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.string_triml",
                                                 :source {:code "(defn triml\n    [s]\n    (gstring/trimLeft s))",
                                                          :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                          :lines [111
                                                                  114],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/string.cljs#L111-L114"},
                                                 :full-name "clojure.string/triml",
                                                 :clj-symbol "clojure.string/triml",
                                                 :docstring "Removes whitespace from the left side of string."},
                         "cljs.core/chunk-append" {:full-name "cljs.core/chunk-append",
                                                   :ns "cljs.core",
                                                   :name "chunk-append",
                                                   :type "function",
                                                   :signature ["[b x]"],
                                                   :source {:code "(defn chunk-append [b x]\n  (.add b x))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [2116
                                                                    2117],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2116-L2117"},
                                                   :full-name-encode "cljs.core_chunk-append",
                                                   :history [["+"
                                                              "0.0-1424"]]},
                         "cljs.core/regexp?" {:full-name "cljs.core/regexp?",
                                              :ns "cljs.core",
                                              :name "regexp?",
                                              :type "function",
                                              :signature ["[o]"],
                                              :source {:code "(defn regexp? [o]\n  (instance? js/RegExp o))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [6163
                                                               6164],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6163-L6164"},
                                              :full-name-encode "cljs.core_regexp_QMARK_",
                                              :history [["+"
                                                         "0.0-1424"]]},
                         "clojure.string/split" {:ns "clojure.string",
                                                 :name "split",
                                                 :signature ["[s re]"
                                                             "[s re limit]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.string_split",
                                                 :source {:code "(defn split\n  ([s re]\n     (vec (.split (str s) re)))\n  ([s re limit]\n     (if (< limit 1)\n       (vec (.split (str s) re))\n       (loop [s s\n              limit limit\n              parts []]\n         (if (= limit 1)\n           (conj parts s)\n           (if-let [m (re-find re s)]\n             (let [index (.indexOf s m)]\n               (recur (.substring s (+ index (count m)))\n                      (dec limit)\n                      (conj parts (.substring s 0 index))))\n             (conj parts s)))))))",
                                                          :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                          :lines [81
                                                                  99],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/string.cljs#L81-L99"},
                                                 :full-name "clojure.string/split",
                                                 :clj-symbol "clojure.string/split",
                                                 :docstring "Splits string on a regular expression. Optional argument limit is\nthe maximum number of splits. Not lazy. Returns vector of the splits."},
                         "cljs.reader/read-4-chars" {:full-name "cljs.reader/read-4-chars",
                                                     :ns "cljs.reader",
                                                     :name "read-4-chars",
                                                     :type "function",
                                                     :signature ["[reader]"],
                                                     :source {:code "(defn read-4-chars [reader]\n  (.toString\n    (gstring/StringBuffer.\n      (read-char reader)\n      (read-char reader)\n      (read-char reader)\n      (read-char reader))))",
                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                              :lines [181
                                                                      187],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L181-L187"},
                                                     :full-name-encode "cljs.reader_read-4-chars",
                                                     :history [["+"
                                                                "0.0-1424"]]},
                         "cljs.core/hash-map" {:ns "cljs.core",
                                               :name "hash-map",
                                               :signature ["[& keyvals]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_hash-map",
                                               :source {:code "(defn hash-map\n  [& keyvals]\n  (loop [in (seq keyvals), out (transient cljs.core.PersistentHashMap/EMPTY)]\n    (if in\n      (recur (nnext in) (assoc! out (first in) (second in)))\n      (persistent! out))))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [5515
                                                                5522],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5515-L5522"},
                                               :full-name "cljs.core/hash-map",
                                               :clj-symbol "clojure.core/hash-map",
                                               :docstring "keyval => key val\nReturns a new hash map with supplied mappings."},
                         "cljs.core/mapv" {:ns "cljs.core",
                                           :name "mapv",
                                           :signature ["[f coll]"
                                                       "[f c1 c2]"
                                                       "[f c1 c2 c3]"
                                                       "[f c1 c2 c3 & colls]"],
                                           :history [["+" "0.0-1211"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_mapv",
                                           :source {:code "(defn mapv\n  ([f coll]\n     (-> (reduce (fn [v o] (conj! v (f o))) (transient []) coll)\n         persistent!))\n  ([f c1 c2]\n     (into [] (map f c1 c2)))\n  ([f c1 c2 c3]\n     (into [] (map f c1 c2 c3)))\n  ([f c1 c2 c3 & colls]\n     (into [] (apply map f c1 c2 c3 colls))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2859 2873],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2859-L2873"},
                                           :full-name "cljs.core/mapv",
                                           :clj-symbol "clojure.core/mapv",
                                           :docstring "Returns a vector consisting of the result of applying f to the\nset of first items of each coll, followed by applying f to the set\nof second items in each coll, until any one of the colls is\nexhausted.  Any remaining items in other colls are ignored. Function\nf should accept number-of-colls arguments."},
                         "cljs.core/rem" {:ns "cljs.core",
                                          :name "rem",
                                          :signature ["[n d]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_rem",
                                          :source {:code "(defn rem\n  [n d]\n  (let [q (quot n d)]\n    (- n (* d q))))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [1551 1555],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1551-L1555"},
                                          :full-name "cljs.core/rem",
                                          :clj-symbol "clojure.core/rem",
                                          :docstring "remainder of dividing numerator by denominator."},
                         "cljs.core/IRecord" {:ns "cljs.core",
                                              :name "IRecord",
                                              :type "protocol",
                                              :full-name-encode "cljs.core_IRecord",
                                              :source {:code "(defprotocol IRecord\n  \"Marker interface indicating a record object\")",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [260
                                                               261],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L260-L261"},
                                              :full-name "cljs.core/IRecord",
                                              :docstring "Marker interface indicating a record object",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/constantly" {:ns "cljs.core",
                                                 :name "constantly",
                                                 :signature ["[x]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_constantly",
                                                 :source {:code "(defn constantly\n  [x] (fn [& args] x))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2438
                                                                  2440],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2438-L2440"},
                                                 :full-name "cljs.core/constantly",
                                                 :clj-symbol "clojure.core/constantly",
                                                 :docstring "Returns a function that takes any number of arguments and returns x."},
                         "clojure.browser.dom/get-element" {:full-name "clojure.browser.dom/get-element",
                                                            :ns "clojure.browser.dom",
                                                            :name "get-element",
                                                            :type "function",
                                                            :signature ["[id]"],
                                                            :source {:code "(defn get-element [id]\n  (gdom/getElement (name id)))",
                                                                     :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                     :lines [98
                                                                             99],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/dom.cljs#L98-L99"},
                                                            :full-name-encode "clojure.browser.dom_get-element",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "cljs.core/UUID" {:full-name "cljs.core/UUID",
                                           :ns "cljs.core",
                                           :name "UUID",
                                           :type "type",
                                           :signature ["[uuid]"],
                                           :source {:code "(deftype UUID [uuid]\n  IEquiv\n  (-equiv [_ other]\n    (and (instance? UUID other) (identical? uuid (.-uuid other))))\n\n  IPrintWithWriter\n  (-pr-writer [_ writer _]\n    (-write writer (str \"#uuid \\\"\" uuid \"\\\"\")))\n\n  IHash\n  (-hash [this]\n    (goog.string/hashCode (pr-str this))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [7111 7122],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L7111-L7122"},
                                           :full-name-encode "cljs.core_UUID",
                                           :history [["+" "0.0-1424"]]},
                         "clojure.core.reducers/reduce" {:ns "clojure.core.reducers",
                                                         :name "reduce",
                                                         :signature ["[f coll]"
                                                                     "[f init coll]"],
                                                         :history [["+"
                                                                    "0.0-1236"]],
                                                         :type "function",
                                                         :full-name-encode "clojure.core.reducers_reduce",
                                                         :source {:code "(defn reduce\n  ([f coll] (reduce f (f) coll))\n  ([f init coll]\n     (if (map? coll)\n       (-kv-reduce coll f init)\n       (if-not (nil? coll)\n         (-reduce coll f init)\n         init))))",
                                                                  :filename "clojurescript/src/cljs/clojure/core/reducers.cljs",
                                                                  :lines [20
                                                                          30],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/core/reducers.cljs#L20-L30"},
                                                         :full-name "clojure.core.reducers/reduce",
                                                         :clj-symbol "clojure.core.reducers/reduce",
                                                         :docstring "Like core/reduce except:\n  When init is not provided, (f) is used.\n  Maps are reduced with reduce-kv"},
                         "cljs.core/and" {:ns "cljs.core",
                                          :name "and",
                                          :signature ["[]"
                                                      "[x]"
                                                      "[x & next]"],
                                          :history [["+" "0.0-927"]],
                                          :type "macro",
                                          :full-name-encode "cljs.core_and",
                                          :source {:code "(defmacro and\n  ([] true)\n  ([x] x)\n  ([x & next]\n   `(let [and# ~x]\n      (if and# (and ~@next) and#))))",
                                                   :filename "clojure/src/clj/clojure/core.clj",
                                                   :lines [794 804],
                                                   :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L794-L804"},
                                          :full-name "cljs.core/and",
                                          :clj-symbol "clojure.core/and",
                                          :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns logical false (nil or false), and returns that value and\ndoesn't evaluate any of the other expressions, otherwise it returns\nthe value of the last expr. (and) returns true."},
                         "clojure.browser.repl/wrap-message" {:full-name "clojure.browser.repl/wrap-message",
                                                              :ns "clojure.browser.repl",
                                                              :name "wrap-message",
                                                              :type "function",
                                                              :signature ["[t data]"],
                                                              :source {:code "(defn wrap-message [t data]\n  (pr-str {:type t :content data :order (swap! order inc)}))",
                                                                       :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                       :lines [57
                                                                               58],
                                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/repl.cljs#L57-L58"},
                                                              :full-name-encode "clojure.browser.repl_wrap-message",
                                                              :history [["+"
                                                                         "0.0-927"]]},
                         "cljs.reader/deregister-tag-parser!" {:full-name "cljs.reader/deregister-tag-parser!",
                                                               :ns "cljs.reader",
                                                               :name "deregister-tag-parser!",
                                                               :type "function",
                                                               :signature ["[tag]"],
                                                               :source {:code "(defn deregister-tag-parser!\n  [tag]\n  (let [tag (str tag)\n        old-parser (get @*tag-table* tag)]\n    (swap! *tag-table* dissoc tag)\n    old-parser))",
                                                                        :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                        :lines [552
                                                                                557],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L552-L557"},
                                                               :full-name-encode "cljs.reader_deregister-tag-parser_BANG_",
                                                               :history [["+"
                                                                          "0.0-1424"]]},
                         "clojure.reflect/print-doc" {:full-name "clojure.reflect/print-doc",
                                                      :ns "clojure.reflect",
                                                      :name "print-doc",
                                                      :type "function",
                                                      :signature ["[{:keys [name method-params doc]}]"],
                                                      :source {:code "(defn print-doc [{:keys [name method-params doc]}]\n  (when-not (empty? name)\n    (println name)\n    (println method-params)\n    (println doc)))",
                                                               :filename "clojurescript/src/cljs/clojure/reflect.cljs",
                                                               :lines [38
                                                                       42],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/reflect.cljs#L38-L42"},
                                                      :full-name-encode "clojure.reflect_print-doc",
                                                      :history [["+"
                                                                 "0.0-1503"]]},
                         "clojure.browser.event/unlisten-by-key" {:full-name "clojure.browser.event/unlisten-by-key",
                                                                  :ns "clojure.browser.event",
                                                                  :name "unlisten-by-key",
                                                                  :type "function",
                                                                  :signature ["[key]"],
                                                                  :source {:code "(defn unlisten-by-key\n  [key]\n  (goog.events/unlistenByKey key))",
                                                                           :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                           :lines [71
                                                                                   73],
                                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/event.cljs#L71-L73"},
                                                                  :full-name-encode "clojure.browser.event_unlisten-by-key",
                                                                  :history [["+"
                                                                             "0.0-927"]]},
                         "cljs.core/try" {:ns "cljs.core",
                                          :name "try",
                                          :signature ["[& forms]"],
                                          :history [["+" "0.0-927"]],
                                          :type "macro",
                                          :full-name-encode "cljs.core_try",
                                          :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (seq? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                                   :filename "clojurescript/src/clj/cljs/core.clj",
                                                   :lines [963 991],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L963-L991"},
                                          :full-name "cljs.core/try",
                                          :clj-symbol "clojure.core/try",
                                          :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions."},
                         "cljs.core/iterate" {:ns "cljs.core",
                                              :name "iterate",
                                              :signature ["[f x]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_iterate",
                                              :source {:code "(defn iterate\n  [f x] (cons x (lazy-seq (iterate f (f x)))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2756
                                                               2759],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2756-L2759"},
                                              :full-name "cljs.core/iterate",
                                              :clj-symbol "clojure.core/iterate",
                                              :docstring "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"},
                         "cljs.core/lazy-seq" {:full-name "cljs.core/lazy-seq",
                                               :ns "cljs.core",
                                               :name "lazy-seq",
                                               :type "macro",
                                               :signature ["[& body]"],
                                               :source {:code "(defmacro lazy-seq [& body]\n  `(new cljs.core/LazySeq nil false (fn [] ~@body) nil))",
                                                        :filename "clojurescript/src/clj/cljs/core.clj",
                                                        :lines [855
                                                                856],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L855-L856"},
                                               :full-name-encode "cljs.core_lazy-seq",
                                               :clj-symbol "clojure.core/lazy-seq",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "specialrepl/load-file" {:full-name "specialrepl/load-file",
                                                  :ns "specialrepl",
                                                  :name "load-file",
                                                  :type "special form (repl)",
                                                  :source {:code "(def default-special-fns\n  (let [load-file-fn (fn [repl-env file] (load-file repl-env file))]\n    {'in-ns (fn [_ quoted-ns]\n              (let [ns-name (second quoted-ns)]\n                (when-not (ana/get-namespace ns-name)\n                  (ana/set-namespace ns-name {:name ns-name}))\n                (set! ana/*cljs-ns* ns-name)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace (fn [repl-env ns] (load-namespace repl-env ns))}))",
                                                           :filename "clojurescript/src/clj/cljs/repl.clj",
                                                           :lines [142
                                                                   151],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/repl.clj#L142-L151"},
                                                  :full-name-encode "specialrepl_load-file",
                                                  :clj-symbol "clojure.core/load-file",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/IndexedSeq" {:full-name "cljs.core/IndexedSeq",
                                                 :ns "cljs.core",
                                                 :name "IndexedSeq",
                                                 :type "type",
                                                 :signature ["[arr i]"],
                                                 :source {:code "(deftype IndexedSeq [arr i]\n  ISeqable\n  (-seq [this] this)\n\n  ASeq\n  ISeq\n  (-first [_] (aget arr i))\n  (-rest [_] (if (< (inc i) (alength arr))\n               (IndexedSeq. arr (inc i))\n               (list)))\n\n  INext\n  (-next [_] (if (< (inc i) (alength arr))\n               (IndexedSeq. arr (inc i))\n               nil))\n\n  ICounted\n  (-count [_] (- (alength arr) i))\n\n  IIndexed\n  (-nth [coll n]\n    (let [i (+ n i)]\n      (when (< i (alength arr))\n        (aget arr i))))\n  (-nth [coll n not-found]\n    (let [i (+ n i)]\n      (if (< i (alength arr))\n        (aget arr i)\n        not-found)))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] cljs.core.List/EMPTY)\n\n  IReduce\n  (-reduce [coll f]\n    (array-reduce arr f (aget arr i) (inc i)))\n  (-reduce [coll f start]\n    (array-reduce arr f start i))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  IReversible\n  (-rseq [coll]\n    (let [c (-count coll)]\n      (if (pos? c)\n        (RSeq. coll (dec c) nil)\n        ()))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [614
                                                                  668],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L614-L668"},
                                                 :full-name-encode "cljs.core_IndexedSeq",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "cljs.core/next" {:return-type seq,
                                           :ns "cljs.core",
                                           :name "next",
                                           :signature ["[coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_next",
                                           :source {:code "(defn ^seq next\n  [coll]\n  (when-not (nil? coll)\n    (if (satisfies? INext coll false)\n      (-next ^not-native coll)\n      (seq (rest coll)))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [424 431],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L424-L431"},
                                           :full-name "cljs.core/next",
                                           :clj-symbol "clojure.core/next",
                                           :docstring "Returns a seq of the items after the first. Calls seq on its\nargument.  If there are no more items, returns nil"},
                         "cljs.core/*print-readably*" {:full-name "cljs.core/*print-readably*",
                                                       :ns "cljs.core",
                                                       :name "*print-readably*",
                                                       :type "var",
                                                       :source {:code "(def *print-readably* true)",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [6361
                                                                        6361],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6361-L6361"},
                                                       :full-name-encode "cljs.core__STAR_print-readably_STAR_",
                                                       :clj-symbol "clojure.core/*print-readably*",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.core/booleans" {:full-name "cljs.core/booleans",
                                               :ns "cljs.core",
                                               :name "booleans",
                                               :type "function",
                                               :signature ["[x]"],
                                               :source {:code "(defn booleans [x] x)",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [1526
                                                                1526],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1526-L1526"},
                                               :full-name-encode "cljs.core_booleans",
                                               :clj-symbol "clojure.core/booleans",
                                               :history [["+"
                                                          "0.0-1798"]]},
                         "cljs.core/not-native" {:full-name "cljs.core/not-native",
                                                 :ns "cljs.core",
                                                 :name "not-native",
                                                 :type "var",
                                                 :source {:code "(def not-native nil)",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [47
                                                                  47],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L47-L47"},
                                                 :full-name-encode "cljs.core_not-native",
                                                 :history [["+"
                                                            "0.0-1798"]]},
                         "cljs.core/last" {:ns "cljs.core",
                                           :name "last",
                                           :signature ["[s]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_last",
                                           :source {:code "(defn last\n  [s]\n  (let [sn (next s)]\n    (if-not (nil? sn)\n      (recur sn)\n      (first s))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [749 755],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L749-L755"},
                                           :full-name "cljs.core/last",
                                           :clj-symbol "clojure.core/last",
                                           :docstring "Return the last item in coll, in linear time"},
                         "cljs.core/bit-shift-left" {:ns "cljs.core",
                                                     :name "bit-shift-left",
                                                     :signature ["[x n]"],
                                                     :shadowed-sources ({:code "(defmacro bit-shift-left [x n]\n  (list 'js* \"(~{} << ~{})\" x n))",
                                                                         :filename "clojurescript/src/clj/cljs/core.clj",
                                                                         :lines [433
                                                                                 434],
                                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L433-L434"}),
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.core_bit-shift-left",
                                                     :source {:code "(defn bit-shift-left\n  [x n] (cljs.core/bit-shift-left x n))",
                                                              :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                              :lines [1606
                                                                      1608],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1606-L1608"},
                                                     :full-name "cljs.core/bit-shift-left",
                                                     :clj-symbol "clojure.core/bit-shift-left",
                                                     :docstring "Bitwise shift left"},
                         "clojure.string/reverse" {:ns "clojure.string",
                                                   :name "reverse",
                                                   :signature ["[s]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.string_reverse",
                                                   :source {:code "(defn reverse\n  [s]\n  (.. s (split \"\") (reverse) (join \"\")))",
                                                            :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                            :lines [18
                                                                    21],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/string.cljs#L18-L21"},
                                                   :full-name "clojure.string/reverse",
                                                   :clj-symbol "clojure.string/reverse",
                                                   :docstring "Returns s with its characters reversed."},
                         "cljs.core/min" {:ns "cljs.core",
                                          :name "min",
                                          :signature ["[x]"
                                                      "[x y]"
                                                      "[x y & more]"],
                                          :shadowed-sources ({:code "(defmacro min\n  ([x] x)\n  ([x y] (list 'js* \"((~{} < ~{}) ? ~{} : ~{})\" x y x y))\n  ([x y & more] `(min (min ~x ~y) ~@more)))",
                                                              :filename "clojurescript/src/clj/cljs/core.clj",
                                                              :lines [389
                                                                      392],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L389-L392"}),
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_min",
                                          :source {:code "(defn min\n  ([x] x)\n  ([x y] (cljs.core/min x y))\n  ([x y & more]\n   (reduce min (cljs.core/min x y) more)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [1402 1407],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1402-L1407"},
                                          :full-name "cljs.core/min",
                                          :clj-symbol "clojure.core/min",
                                          :docstring "Returns the least of the nums."},
                         "cljs.reader/escape-char" {:full-name "cljs.reader/escape-char",
                                                    :ns "cljs.reader",
                                                    :name "escape-char",
                                                    :type "function",
                                                    :signature ["[buffer reader]"],
                                                    :source {:code "(defn escape-char\n  [buffer reader]\n  (let [ch (read-char reader)\n        mapresult (escape-char-map ch)]\n    (if mapresult\n      mapresult\n      (cond\n        (identical? ch \\x)\n        (->> (read-2-chars reader)\n          (validate-unicode-escape unicode-2-pattern reader ch)\n          (make-unicode-char))\n\n        (identical? ch \\u)\n        (->> (read-4-chars reader)\n          (validate-unicode-escape unicode-4-pattern reader ch)\n          (make-unicode-char))\n\n        (numeric? ch)\n        (.fromCharCode js/String ch)\n\n        :else\n        (reader-error reader \"Unexpected unicode escape \\\\\" ch )))))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [201
                                                                     222],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L201-L222"},
                                                    :full-name-encode "cljs.reader_escape-char",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "cljs.core/INext" {:ns "cljs.core",
                                            :name "INext",
                                            :type "protocol",
                                            :full-name-encode "cljs.core_INext",
                                            :source {:code "(defprotocol INext\n  (-next [coll]))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [198 199],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L198-L199"},
                                            :methods [{:name "-next",
                                                       :signature ["[coll]"],
                                                       :docstring nil}],
                                            :full-name "cljs.core/INext",
                                            :history [["+" "0.0-1424"]]},
                         "cljs.reader/read-map" {:full-name "cljs.reader/read-map",
                                                 :ns "cljs.reader",
                                                 :name "read-map",
                                                 :type "function",
                                                 :signature ["[rdr _]"],
                                                 :source {:code "(defn read-map\n  [rdr _]\n  (let [l (read-delimited-list \"}\" rdr true)]\n    (when (odd? (count l))\n      (reader-error rdr \"Map literal must contain an even number of forms\"))\n    (apply hash-map l)))",
                                                          :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                          :lines [282
                                                                  287],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L282-L287"},
                                                 :full-name-encode "cljs.reader_read-map",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "cljs.core/seq" {:return-type seq,
                                          :ns "cljs.core",
                                          :name "seq",
                                          :signature ["[coll]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_seq",
                                          :source {:code "(defn ^seq seq\n  [coll]\n  (when-not (nil? coll)\n    (cond\n      (satisfies? ISeqable coll false)\n      (-seq ^not-native coll)\n\n      (array? coll)\n      (IndexedSeq. coll 0)\n\n      (string? coll)\n      (IndexedSeq. coll 0)\n\n      :else (throw (js/Error. (str coll \"is not ISeqable\"))))))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [382 398],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L382-L398"},
                                          :full-name "cljs.core/seq",
                                          :clj-symbol "clojure.core/seq",
                                          :docstring "Returns a seq on the collection. If the collection is\nempty, returns nil.  (seq nil) returns nil. seq also works on\nStrings."},
                         "cljs.core/long" {:ns "cljs.core",
                                           :name "long",
                                           :signature ["[x]"],
                                           :history [["+" "0.0-1211"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_long",
                                           :source {:code "(defn long\n  [x]\n  (fix x))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1516 1519],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1516-L1519"},
                                           :full-name "cljs.core/long",
                                           :clj-symbol "clojure.core/long",
                                           :docstring "Coerce to long by stripping decimal places. Identical to `int'."},
                         "cljs.core/not-empty" {:ns "cljs.core",
                                                :name "not-empty",
                                                :signature ["[coll]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_not-empty",
                                                :source {:code "(defn not-empty\n  [coll] (when (seq coll) coll))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [2384
                                                                 2386],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2384-L2386"},
                                                :full-name "cljs.core/not-empty",
                                                :clj-symbol "clojure.core/not-empty",
                                                :docstring "If coll is empty, returns nil, else coll"},
                         "cljs.core/println" {:ns "cljs.core",
                                              :name "println",
                                              :signature ["[& objs]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_println",
                                              :source {:code "(defn println\n  [& objs]\n  (pr-with-opts objs (assoc (pr-opts) :readably false))\n  (newline (pr-opts)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [6401
                                                               6405],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6401-L6405"},
                                              :full-name "cljs.core/println",
                                              :clj-symbol "clojure.core/println",
                                              :docstring "Same as print followed by (newline)"},
                         "clojure.browser.repl/connect" {:full-name "clojure.browser.repl/connect",
                                                         :ns "clojure.browser.repl",
                                                         :name "connect",
                                                         :docstring "Connects to a REPL server from an HTML document. After the\nconnection is made, the REPL will evaluate forms in the context of\nthe document that called this function.",
                                                         :type "function",
                                                         :signature ["[repl-server-url]"],
                                                         :source {:code "(defn connect\n  [repl-server-url]\n  (let [repl-connection (net/xpc-connection\n                         {:peer_uri repl-server-url})]\n    (swap! xpc-connection (constantly repl-connection))\n    (net/register-service repl-connection\n                          :evaluate-javascript\n                          (fn [js]\n                            (net/transmit\n                             repl-connection\n                             :send-result\n                             (evaluate-javascript repl-connection js))))\n    (net/connect repl-connection\n                 (constantly nil)\n                 (fn [iframe]\n                   (set! (.-display (.-style iframe))\n                         \"none\")))))",
                                                                  :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                  :lines [90
                                                                          109],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/repl.cljs#L90-L109"},
                                                         :full-name-encode "clojure.browser.repl_connect",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "cljs.core/bytes" {:full-name "cljs.core/bytes",
                                            :ns "cljs.core",
                                            :name "bytes",
                                            :type "function",
                                            :signature ["[x]"],
                                            :source {:code "(defn bytes [x] x)",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [1527
                                                             1527],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1527-L1527"},
                                            :full-name-encode "cljs.core_bytes",
                                            :clj-symbol "clojure.core/bytes",
                                            :history [["+" "0.0-1798"]]},
                         "cljs.core/unchecked-byte" {:ns "cljs.core",
                                                     :name "unchecked-byte",
                                                     :signature ["[x]"],
                                                     :shadowed-sources ({:code "(defmacro unchecked-byte [x] x)",
                                                                         :filename "clojurescript/src/clj/cljs/core.clj",
                                                                         :lines [275
                                                                                 275],
                                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L275-L275"}),
                                                     :history [["+"
                                                                "0.0-1798"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.core_unchecked-byte",
                                                     :source {:code "(defn unchecked-byte [x] x)",
                                                              :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                              :lines [1423
                                                                      1423],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1423-L1423"},
                                                     :full-name "cljs.core/unchecked-byte",
                                                     :clj-symbol "clojure.core/unchecked-byte"},
                         "clojure.browser.dom/insert-at" {:full-name "clojure.browser.dom/insert-at",
                                                          :ns "clojure.browser.dom",
                                                          :name "insert-at",
                                                          :type "function",
                                                          :signature ["[parent child index]"],
                                                          :source {:code "(defn insert-at [parent child index]\n  (gdom/insertChildAt parent child index))",
                                                                   :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                   :lines [104
                                                                           105],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/dom.cljs#L104-L105"},
                                                          :full-name-encode "clojure.browser.dom_insert-at",
                                                          :history [["+"
                                                                     "0.0-927"]]},
                         "cljs.core/quot" {:ns "cljs.core",
                                           :name "quot",
                                           :signature ["[n d]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_quot",
                                           :source {:code "(defn quot\n  [n d]\n  (let [rem (js-mod n d)]\n    (fix (/ (- n rem) d))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1545 1549],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1545-L1549"},
                                           :full-name "cljs.core/quot",
                                           :clj-symbol "clojure.core/quot",
                                           :docstring "quot[ient] of dividing numerator by denominator."},
                         "clojure.browser.event/get-listener" {:full-name "clojure.browser.event/get-listener",
                                                               :ns "clojure.browser.event",
                                                               :name "get-listener",
                                                               :type "function",
                                                               :signature ["[src type listener opt_capt opt_handler]"],
                                                               :source {:code "(defn get-listener [src type listener opt_capt opt_handler])",
                                                                        :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                        :lines [89
                                                                                89],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/event.cljs#L89-L89"},
                                                               :full-name-encode "clojure.browser.event_get-listener",
                                                               :history [["+"
                                                                          "0.0-927"]]},
                         "cljs.core/filter" {:ns "cljs.core",
                                             :name "filter",
                                             :signature ["[pred coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_filter",
                                             :source {:code "(defn filter\n  ([pred coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (when (pred (-nth c i))\n                (chunk-append b (-nth c i))))\n          (chunk-cons (chunk b) (filter pred (chunk-rest s))))\n        (let [f (first s) r (rest s)]\n          (if (pred f)\n            (cons f (filter pred r))\n            (filter pred r))))))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2801
                                                              2818],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2801-L2818"},
                                             :full-name "cljs.core/filter",
                                             :clj-symbol "clojure.core/filter",
                                             :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns true. pred must be free of side-effects."},
                         "cljs.core/RSeq" {:full-name "cljs.core/RSeq",
                                           :ns "cljs.core",
                                           :name "RSeq",
                                           :type "type",
                                           :signature ["[ci i meta]"],
                                           :source {:code "(deftype RSeq [ci i meta]\n  IMeta\n  (-meta [coll] meta)\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (RSeq. ci i new-meta))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ISeq\n  (-first [coll]\n    (-nth ci i))\n  (-rest [coll]\n    (if (pos? i)\n      (RSeq. ci (dec i) nil)\n      ()))\n\n  ICounted\n  (-count [coll] (inc i))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  IHash\n  (-hash [coll] (hash-coll coll)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [689 722],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L689-L722"},
                                           :full-name-encode "cljs.core_RSeq",
                                           :history [["+" "0.0-1424"]]},
                         "clojure.zip/branch?" {:ns "clojure.zip",
                                                :name "branch?",
                                                :signature ["[loc]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.zip_branch_QMARK_",
                                                :source {:code "(defn branch?\n  [loc]\n    ((:zip/branch? (meta loc)) (node loc)))",
                                                         :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                         :lines [64
                                                                 67],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L64-L67"},
                                                :full-name "clojure.zip/branch?",
                                                :clj-symbol "clojure.zip/branch?",
                                                :docstring "Returns true if the node at loc is a branch"},
                         "special/if" {:full-name "special/if",
                                       :ns "special",
                                       :name "if",
                                       :type "special form",
                                       :source {:code "(defmethod parse 'if\n  [op env [_ test then else :as form] name]\n  (assert (>= (count form) 3) \"Too few arguments to if\")\n  (let [test-expr (disallowing-recur (analyze (assoc env :context :expr) test))\n        then-expr (analyze env then)\n        else-expr (analyze env else)]\n    {:env env :op :if :form form\n     :test test-expr :then then-expr :else else-expr\n     :unchecked @*unchecked-if*\n     :children [test-expr then-expr else-expr]}))",
                                                :filename "clojurescript/src/clj/cljs/analyzer.clj",
                                                :lines [244 253],
                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/analyzer.clj#L244-L253"},
                                       :full-name-encode "special_if",
                                       :clj-symbol "clojure.core/if",
                                       :history [["+" "0.0-927"]]},
                         "cljs.core/ObjMap" {:full-name "cljs.core/ObjMap",
                                             :ns "cljs.core",
                                             :name "ObjMap",
                                             :type "type",
                                             :signature ["[meta keys strobj update-count __hash]"],
                                             :source {:code "(deftype ObjMap [meta keys strobj update-count ^:mutable __hash]\n  IWithMeta\n  (-with-meta [coll meta] (ObjMap. meta keys strobj update-count __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.ObjMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? (alength keys))\n      (map #(vector % (aget strobj %))\n           (.sort keys obj-map-compare-keys))))\n\n  ICounted\n  (-count [coll] (alength keys))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      (aget strobj k)\n      not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if ^boolean (goog/isString k)\n        (if (or (> update-count cljs.core.ObjMap/HASHMAP_THRESHOLD)\n                (>= (alength keys) cljs.core.ObjMap/HASHMAP_THRESHOLD))\n          (obj-map->hash-map coll k v)\n          (if-not (nil? (scan-array 1 k keys))\n            (let [new-strobj (obj-clone strobj keys)]\n              (aset new-strobj k v)\n              (ObjMap. meta keys new-strobj (inc update-count) nil)) ; overwrite\n            (let [new-strobj (obj-clone strobj keys) ; append\n                  new-keys (aclone keys)]\n              (aset new-strobj k v)\n              (.push new-keys k)\n              (ObjMap. meta new-keys new-strobj (inc update-count) nil))))\n        ;; non-string key. game over.\n        (obj-map->hash-map coll k v)))\n  (-contains-key? [coll k]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      true\n      false))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [len (alength keys)]\n      (loop [keys (.sort keys obj-map-compare-keys)\n             init init]\n        (if (seq keys)\n          (let [k (first keys)\n                init (f init k (aget strobj k))]\n            (if (reduced? init)\n              @init\n              (recur (rest keys) init)))\n          init))))\n\n  IMap\n  (-dissoc [coll k]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      (let [new-keys (aclone keys)\n            new-strobj (obj-clone strobj keys)]\n        (.splice new-keys (scan-array 1 k new-keys) 1)\n        (js-delete new-strobj k)\n        (ObjMap. meta new-keys new-strobj (inc update-count) nil))\n      coll)) ; key not found, return coll unchanged\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (transient (into (hash-map) coll))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [3710
                                                              3806],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L3710-L3806"},
                                             :full-name-encode "cljs.core_ObjMap",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/zipmap" {:ns "cljs.core",
                                             :name "zipmap",
                                             :signature ["[keys vals]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_zipmap",
                                             :source {:code "(defn zipmap\n  [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [5895
                                                              5905],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5895-L5905"},
                                             :full-name "cljs.core/zipmap",
                                             :clj-symbol "clojure.core/zipmap",
                                             :docstring "Returns a map with the keys mapped to the corresponding vals."},
                         "cljs.core/hash-combine" {:full-name "cljs.core/hash-combine",
                                                   :ns "cljs.core",
                                                   :name "hash-combine",
                                                   :type "function",
                                                   :signature ["[seed hash]"],
                                                   :source {:code "(defn hash-combine [seed hash]\n  ; a la boost\n  (bit-xor seed (+ hash 0x9e3779b9\n                   (bit-shift-left seed 6)\n                   (bit-shift-right seed 2))))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [1730
                                                                    1734],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1730-L1734"},
                                                   :full-name-encode "cljs.core_hash-combine",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "cljs.core/reversible?" {:return-type boolean,
                                                  :ns "cljs.core",
                                                  :name "reversible?",
                                                  :signature ["[coll]"],
                                                  :history [["+"
                                                             "0.0-1211"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_reversible_QMARK_",
                                                  :source {:code "(defn ^boolean reversible? [coll]\n  (satisfies? IReversible coll))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [1861
                                                                   1862],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1861-L1862"},
                                                  :full-name "cljs.core/reversible?",
                                                  :clj-symbol "clojure.core/reversible?"},
                         "clojure.core.reducers/flatten" {:ns "clojure.core.reducers",
                                                          :name "flatten",
                                                          :signature ["[]"
                                                                      "[coll]"],
                                                          :history [["+"
                                                                     "0.0-1236"]],
                                                          :type "function",
                                                          :full-name-encode "clojure.core.reducers_flatten",
                                                          :source {:code "(defcurried flatten\n  \"Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection.\"\n  {}\n  [coll]\n  (folder coll\n   (fn [f1]\n     (fn\n       ([] (f1))\n       ([ret v]\n          (if (sequential? v)\n            (-reduce (flatten v) f1 ret)\n            (f1 ret v)))))))",
                                                                   :filename "clojurescript/src/cljs/clojure/core/reducers.cljs",
                                                                   :lines [121
                                                                           134],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/core/reducers.cljs#L121-L134"},
                                                          :full-name "clojure.core.reducers/flatten",
                                                          :clj-symbol "clojure.core.reducers/flatten",
                                                          :docstring "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection."},
                         "cljs.core/max-key" {:ns "cljs.core",
                                              :name "max-key",
                                              :signature ["[k x]"
                                                          "[k x y]"
                                                          "[k x y & more]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_max-key",
                                              :source {:code "(defn max-key\n  ([k x] x)\n  ([k x y] (if (> (k x) (k y)) x y))\n  ([k x y & more]\n   (reduce #(max-key k %1 %2) (max-key k x y) more)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [5907
                                                               5912],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5907-L5912"},
                                              :full-name "cljs.core/max-key",
                                              :clj-symbol "clojure.core/max-key",
                                              :docstring "Returns the x for which (k x), a number, is greatest."},
                         "clojure.zip/insert-child" {:ns "clojure.zip",
                                                     :name "insert-child",
                                                     :signature ["[loc item]"],
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "clojure.zip_insert-child",
                                                     :source {:code "(defn insert-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (cons item (children loc)))))",
                                                              :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                              :lines [194
                                                                      198],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L194-L198"},
                                                     :full-name "clojure.zip/insert-child",
                                                     :clj-symbol "clojure.zip/insert-child",
                                                     :docstring "Inserts the item as the leftmost child of the node at this loc,\nwithout moving"},
                         "cljs.core/defrecord" {:full-name "cljs.core/defrecord",
                                                :ns "cljs.core",
                                                :name "defrecord",
                                                :type "macro",
                                                :signature ["[rsym fields & impls]"],
                                                :source {:code "(defmacro defrecord [rsym fields & impls]\n  (let [r (:name (cljs.analyzer/resolve-var (dissoc &env :locals) rsym))]\n    `(let []\n       ~(emit-defrecord &env rsym r fields impls)\n       (set! (.-cljs$lang$type ~r) true)\n       (set! (.-cljs$lang$ctorPrSeq ~r) (fn [this#] (list ~(core/str r))))\n       (set! (.-cljs$lang$ctorPrWriter ~r) (fn [this# writer#] (-write writer# ~(core/str r))))\n       ~(build-positional-factory rsym r fields)\n       ~(build-map-factory rsym r fields)\n       ~r)))",
                                                         :filename "clojurescript/src/clj/cljs/core.clj",
                                                         :lines [785
                                                                 794],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L785-L794"},
                                                :full-name-encode "cljs.core_defrecord",
                                                :clj-symbol "clojure.core/defrecord",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/ex-info" {:ns "cljs.core",
                                              :name "ex-info",
                                              :signature ["[msg map]"
                                                          "[msg map cause]"],
                                              :history [["+"
                                                         "0.0-1576"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_ex-info",
                                              :source {:code "(defn ex-info\n  ([msg map]\n     (ExceptionInfo. msg map nil))\n  ([msg map cause]\n     (ExceptionInfo. msg map cause)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [7132
                                                               7139],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L7132-L7139"},
                                              :full-name "cljs.core/ex-info",
                                              :clj-symbol "clojure.core/ex-info",
                                              :docstring "Alpha - subject to change.\nCreate an instance of ExceptionInfo, an Error type that carries a\nmap of additional data."},
                         "cljs.core/butlast" {:full-name "cljs.core/butlast",
                                              :ns "cljs.core",
                                              :name "butlast",
                                              :type "function",
                                              :signature ["[s]"],
                                              :source {:code "(defn butlast [s]\n  (loop [ret [] s s]\n    (if (next s)\n      (recur (conj ret (first s)) (next s))\n      (seq ret))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [5864
                                                               5868],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5864-L5868"},
                                              :full-name-encode "cljs.core_butlast",
                                              :clj-symbol "clojure.core/butlast",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/print-str" {:ns "cljs.core",
                                                :name "print-str",
                                                :signature ["[& objs]"],
                                                :history [["+"
                                                           "0.0-1011"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_print-str",
                                                :source {:code "(defn print-str\n  [& objs]\n  (pr-str-with-opts objs (assoc (pr-opts) :readably false)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [6396
                                                                 6399],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6396-L6399"},
                                                :full-name "cljs.core/print-str",
                                                :clj-symbol "clojure.core/print-str",
                                                :docstring "print to a string, returning it"},
                         "cljs.core/hash" {:full-name "cljs.core/hash",
                                           :ns "cljs.core",
                                           :name "hash",
                                           :type "function",
                                           :signature ["[o]"
                                                       "[o check-cache]"],
                                           :source {:code "(defn hash\n  ([o] (hash o true))\n  ([o ^boolean check-cache]\n     (if (and ^boolean (goog/isString o) check-cache)\n       (check-string-hash-cache o)\n       (-hash o))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [985 990],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L985-L990"},
                                           :full-name-encode "cljs.core_hash",
                                           :clj-symbol "clojure.core/hash",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/bit-set" {:ns "cljs.core",
                                              :name "bit-set",
                                              :signature ["[x n]"],
                                              :shadowed-sources ({:code "(defmacro bit-set [x n]\n  (list 'js* \"(~{} | (1 << ~{}))\" x n))",
                                                                  :filename "clojurescript/src/clj/cljs/core.clj",
                                                                  :lines [442
                                                                          443],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L442-L443"}),
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_bit-set",
                                              :source {:code "(defn bit-set\n  [x n]\n  (cljs.core/bit-set x n))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1596
                                                               1599],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1596-L1599"},
                                              :full-name "cljs.core/bit-set",
                                              :clj-symbol "clojure.core/bit-set",
                                              :docstring "Set bit at index n"},
                         "cljs.core/clj->js" {:full-name "cljs.core/clj->js",
                                              :ns "cljs.core",
                                              :name "clj->js",
                                              :docstring "Recursively transforms ClojureScript values to JavaScript.\nsets/vectors/lists become Arrays, Keywords and Symbol become Strings,\nMaps become Objects. Arbitrary keys are encoded to by key->js.",
                                              :type "function",
                                              :signature ["[x]"],
                                              :source {:code "(defn clj->js\n   [x]\n   (when-not (nil? x)\n     (if (satisfies? IEncodeJS x)\n       (-clj->js x)\n       (cond\n         (keyword? x) (name x)\n         (symbol? x) (str x)\n         (map? x) (let [m (js-obj)]\n                    (doseq [[k v] x]\n                      (aset m (key->js k) (clj->js v)))\n                    m)\n         (coll? x) (apply array (map clj->js x))\n         :else x))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [6726
                                                               6742],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6726-L6742"},
                                              :full-name-encode "cljs.core_clj-_GT_js",
                                              :history [["+"
                                                         "0.0-1552"]]},
                         "cljs.core/concat" {:ns "cljs.core",
                                             :name "concat",
                                             :signature ["[]"
                                                         "[x]"
                                                         "[x y]"
                                                         "[x y & zs]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_concat",
                                             :source {:code "(defn concat\n  ([] (lazy-seq nil))\n  ([x] (lazy-seq x))\n  ([x y]\n    (lazy-seq\n      (let [s (seq x)]\n        (if s\n          (if (chunked-seq? s)\n            (chunk-cons (chunk-first s) (concat (chunk-rest s) y))\n            (cons (first s) (concat (rest s) y)))\n          y))))\n  ([x y & zs]\n     (let [cat (fn cat [xys zs]\n                 (lazy-seq\n                   (let [xys (seq xys)]\n                     (if xys\n                       (if (chunked-seq? xys)\n                         (chunk-cons (chunk-first xys)\n                                     (cat (chunk-rest xys) zs))\n                         (cons (first xys) (cat (rest xys) zs)))\n                       (when zs\n                         (cat (first zs) (next zs)))))))]\n       (cat (concat x y) zs))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2256
                                                              2279],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2256-L2279"},
                                             :full-name "cljs.core/concat",
                                             :clj-symbol "clojure.core/concat",
                                             :docstring "Returns a lazy seq representing the concatenation of the elements in the supplied colls."},
                         "cljs.core/conj" {:ns "cljs.core",
                                           :name "conj",
                                           :signature ["[coll x]"
                                                       "[coll x & xs]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_conj",
                                           :source {:code "(defn conj\n  ([coll x]\n    (if-not (nil? coll)\n      (-conj coll x)\n      (list x)))\n  ([coll x & xs]\n    (if xs\n      (recur (conj coll x) (first xs) (next xs))\n      (conj coll x))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [761 772],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L761-L772"},
                                           :full-name "cljs.core/conj",
                                           :clj-symbol "clojure.core/conj",
                                           :docstring "conj[oin]. Returns a new collection with the xs\n'added'. (conj nil item) returns (item).  The 'addition' may\nhappen at different 'places' depending on the concrete type."},
                         "cljs.core/unchecked-short" {:ns "cljs.core",
                                                      :name "unchecked-short",
                                                      :signature ["[x]"],
                                                      :shadowed-sources ({:code "(defmacro unchecked-short [x] x)",
                                                                          :filename "clojurescript/src/clj/cljs/core.clj",
                                                                          :lines [277
                                                                                  277],
                                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L277-L277"}),
                                                      :history [["+"
                                                                 "0.0-1798"]],
                                                      :type "function",
                                                      :full-name-encode "cljs.core_unchecked-short",
                                                      :source {:code "(defn unchecked-short [x] x)",
                                                               :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                               :lines [1425
                                                                       1425],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1425-L1425"},
                                                      :full-name "cljs.core/unchecked-short",
                                                      :clj-symbol "clojure.core/unchecked-short"},
                         "clojure.set/difference" {:ns "clojure.set",
                                                   :name "difference",
                                                   :signature ["[s1]"
                                                               "[s1 s2]"
                                                               "[s1 s2 & sets]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.set_difference",
                                                   :source {:code "(defn difference\n  ([s1] s1)\n  ([s1 s2] \n     (if (< (count s1) (count s2))\n       (reduce (fn [result item] \n                   (if (contains? s2 item) \n                     (disj result item) \n                     result))\n               s1 s1)\n       (reduce disj s1 s2)))\n  ([s1 s2 & sets] \n     (reduce difference s1 (conj sets s2))))",
                                                            :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                            :lines [46
                                                                    58],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/set.cljs#L46-L58"},
                                                   :full-name "clojure.set/difference",
                                                   :clj-symbol "clojure.set/difference",
                                                   :docstring "Return a set that is the first set without elements of the remaining sets"},
                         "cljs.core/byte" {:ns "cljs.core",
                                           :name "byte",
                                           :signature ["[x]"],
                                           :shadowed-sources ({:code "(defmacro byte [x] x)",
                                                               :filename "clojurescript/src/clj/cljs/core.clj",
                                                               :lines [270
                                                                       270],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L270-L270"}),
                                           :history [["+" "0.0-1798"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_byte",
                                           :source {:code "(defn byte [x] x)",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1409 1409],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1409-L1409"},
                                           :full-name "cljs.core/byte",
                                           :clj-symbol "clojure.core/byte"},
                         "cljs.core/when-first" {:ns "cljs.core",
                                                 :name "when-first",
                                                 :signature ["[bindings & body]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "macro",
                                                 :full-name-encode "cljs.core_when-first",
                                                 :source {:code "(defmacro when-first\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n  (let [[x xs] bindings]\n    `(when-let [xs# (seq ~xs)]\n       (let [~x (first xs#)]\n           ~@body))))",
                                                          :filename "clojure/src/clj/clojure/core.clj",
                                                          :lines [4154
                                                                  4166],
                                                          :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L4154-L4166"},
                                                 :full-name "cljs.core/when-first",
                                                 :clj-symbol "clojure.core/when-first",
                                                 :docstring "bindings => x xs\n\nRoughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once"},
                         "cljs.reader/*tag-table*" {:full-name "cljs.reader/*tag-table*",
                                                    :ns "cljs.reader",
                                                    :name "*tag-table*",
                                                    :type "var",
                                                    :source {:code "(def *tag-table* (atom {\"inst\"  read-date\n                        \"uuid\"  read-uuid\n                        \"queue\" read-queue}))",
                                                             :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                             :lines [526
                                                                     528],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L526-L528"},
                                                    :full-name-encode "cljs.reader__STAR_tag-table_STAR_",
                                                    :history [["+"
                                                               "0.0-1236"]]},
                         "cljs.core/distinct?" {:return-type boolean,
                                                :ns "cljs.core",
                                                :name "distinct?",
                                                :signature ["[x]"
                                                            "[x y]"
                                                            "[x y & more]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_distinct_QMARK_",
                                                :source {:code "(defn ^boolean distinct?\n  ([x] true)\n  ([x y] (not (= x y)))\n  ([x y & more]\n     (if (not (= x y))\n     (loop [s #{x y} xs more]\n       (let [x (first xs)\n             etc (next xs)]\n         (if xs\n           (if (contains? s x)\n             false\n             (recur (conj s x) etc))\n           true)))\n     false)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1146
                                                                 1160],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1146-L1160"},
                                                :full-name "cljs.core/distinct?",
                                                :clj-symbol "clojure.core/distinct?",
                                                :docstring "Returns true if no two of the arguments are ="},
                         "clojure.core.reducers/filter" {:ns "clojure.core.reducers",
                                                         :name "filter",
                                                         :signature ["[pred]"
                                                                     "[pred coll]"],
                                                         :history [["+"
                                                                    "0.0-1236"]],
                                                         :type "function",
                                                         :full-name-encode "clojure.core.reducers_filter",
                                                         :source {:code "(defcurried filter\n  \"Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.\"\n  {}\n  [pred coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               ret))))))",
                                                                  :filename "clojurescript/src/cljs/clojure/core/reducers.cljs",
                                                                  :lines [108
                                                                          119],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/core/reducers.cljs#L108-L119"},
                                                         :full-name "clojure.core.reducers/filter",
                                                         :clj-symbol "clojure.core.reducers/filter",
                                                         :docstring "Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."},
                         "cljs.core/INamed" {:ns "cljs.core",
                                             :name "INamed",
                                             :type "protocol",
                                             :full-name-encode "cljs.core_INamed",
                                             :source {:code "(defprotocol INamed\n  (-name [x])\n  (-namespace [x]))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [325 327],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L325-L327"},
                                             :methods [{:name "-name",
                                                        :signature ["[x]"],
                                                        :docstring nil}
                                                       {:name "-namespace",
                                                        :signature ["[x]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/INamed",
                                             :history [["+"
                                                        "0.0-1798"]]},
                         "cljs.core/add-to-string-hash-cache" {:full-name "cljs.core/add-to-string-hash-cache",
                                                               :ns "cljs.core",
                                                               :name "add-to-string-hash-cache",
                                                               :type "function",
                                                               :signature ["[k]"],
                                                               :source {:code "(defn add-to-string-hash-cache [k]\n  (let [h (goog.string/hashCode k)]\n    (aset string-hash-cache k h)\n    (set! string-hash-cache-count (inc string-hash-cache-count))\n    h))",
                                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                        :lines [968
                                                                                972],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L968-L972"},
                                                               :full-name-encode "cljs.core_add-to-string-hash-cache",
                                                               :history [["+"
                                                                          "0.0-1424"]]},
                         "cljs.core/HashCollisionNode" {:full-name "cljs.core/HashCollisionNode",
                                                        :ns "cljs.core",
                                                        :name "HashCollisionNode",
                                                        :type "type",
                                                        :signature ["[edit collision-hash cnt arr]"],
                                                        :source {:code "(deftype HashCollisionNode [edit\n                            ^:mutable collision-hash\n                            ^:mutable cnt\n                            ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (if (== hash collision-hash)\n      (let [idx (hash-collision-node-find-index arr cnt key)]\n        (if (== idx -1)\n          (let [len (alength arr)\n                new-arr (make-array (+ len 2))]\n            (array-copy arr 0 new-arr 0 len)\n            (aset new-arr len key)\n            (aset new-arr (inc len) val)\n            (set! (.-val added-leaf?) true)\n            (HashCollisionNode. nil collision-hash (inc cnt) new-arr))\n          (if (= (aget arr idx) val)\n            inode\n            (HashCollisionNode. nil collision-hash cnt (clone-and-set arr (inc idx) val)))))\n      (.inode-assoc (BitmapIndexedNode. nil (bitpos collision-hash shift) (array nil inode))\n                    shift hash key val added-leaf?)))\n\n  (inode-without [inode shift hash key]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (== idx -1) inode\n            (== cnt 1)  nil\n            :else (HashCollisionNode. nil collision-hash (dec cnt) (remove-pair arr (quot idx 2))))))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (< idx 0)              not-found\n            (key-test key (aget arr idx)) (aget arr (inc idx))\n            :else                  not-found)))\n\n  (inode-find [inode shift hash key not-found]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (< idx 0)              not-found\n            (key-test key (aget arr idx)) [(aget arr idx) (aget arr (inc idx))]\n            :else                  not-found)))\n\n  (inode-seq [inode]\n    (create-inode-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (let [new-arr (make-array (* 2 (inc cnt)))]\n        (array-copy arr 0 new-arr 0 (* 2 cnt))\n        (HashCollisionNode. e collision-hash cnt new-arr))))\n\n  (ensure-editable-array [inode e count array]\n    (if (identical? e edit)\n      (do (set! arr array)\n          (set! cnt count)\n          inode)\n      (HashCollisionNode. edit collision-hash count array)))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (if (== hash collision-hash)\n      (let [idx (hash-collision-node-find-index arr cnt key)]\n        (if (== idx -1)\n          (if (> (alength arr) (* 2 cnt))\n            (let [editable (edit-and-set inode edit (* 2 cnt) key (inc (* 2 cnt)) val)]\n              (set! (.-val added-leaf?) true)\n              (set! (.-cnt editable) (inc (.-cnt editable)))\n              editable)\n            (let [len     (alength arr)\n                  new-arr (make-array (+ len 2))]\n              (array-copy arr 0 new-arr 0 len)\n              (aset new-arr len key)\n              (aset new-arr (inc len) val)\n              (set! (.-val added-leaf?) true)\n              (.ensure-editable-array inode edit (inc cnt) new-arr)))\n          (if (identical? (aget arr (inc idx)) val)\n            inode\n            (edit-and-set inode edit (inc idx) val))))\n      (.inode-assoc! (BitmapIndexedNode. edit (bitpos collision-hash shift) (array nil inode nil nil))\n                     edit shift hash key val added-leaf?)))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (if (== idx -1)\n        inode\n        (do (aset removed-leaf? 0 true)\n            (if (== cnt 1)\n              nil\n              (let [editable (.ensure-editable inode edit)\n                    earr     (.-arr editable)]\n                (aset earr idx (aget earr (- (* 2 cnt) 2)))\n                (aset earr (inc idx) (aget earr (dec (* 2 cnt))))\n                (aset earr (dec (* 2 cnt)) nil)\n                (aset earr (- (* 2 cnt) 2) nil)\n                (set! (.-cnt editable) (dec (.-cnt editable)))\n                editable))))))\n\n  (kv-reduce [inode f init]\n    (inode-kv-reduce arr f init)))",
                                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                 :lines [4458
                                                                         4554],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L4458-L4554"},
                                                        :full-name-encode "cljs.core_HashCollisionNode",
                                                        :history [["+"
                                                                   "0.0-1211"]]},
                         "cljs.core/pos?" {:return-type boolean,
                                           :ns "cljs.core",
                                           :name "pos?",
                                           :signature ["[n]"],
                                           :shadowed-sources ({:code "(defmacro pos? [x]\n  `(> ~x 0))",
                                                               :filename "clojurescript/src/clj/cljs/core.clj",
                                                               :lines [378
                                                                       379],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L378-L379"}),
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_pos_QMARK_",
                                           :source {:code "(defn ^boolean pos?\n  [n] (cljs.core/pos? n))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1638 1640],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1638-L1640"},
                                           :full-name "cljs.core/pos?",
                                           :clj-symbol "clojure.core/pos?",
                                           :docstring "Returns true if num is greater than zero, else false"},
                         "cljs.core/into-array" {:full-name "cljs.core/into-array",
                                                 :ns "cljs.core",
                                                 :name "into-array",
                                                 :type "function",
                                                 :signature ["[aseq]"
                                                             "[type aseq]"],
                                                 :source {:code "(defn into-array\n  ([aseq]\n     (into-array nil aseq))\n  ([type aseq]\n     (reduce (fn [a x] (.push a x) a) (array) aseq)))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [142
                                                                  146],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L142-L146"},
                                                 :full-name-encode "cljs.core_into-array",
                                                 :clj-symbol "clojure.core/into-array",
                                                 :history [["+"
                                                            "0.0-1211"]]},
                         "cljs.core/PersistentVector" {:full-name "cljs.core/PersistentVector",
                                                       :ns "cljs.core",
                                                       :name "PersistentVector",
                                                       :type "type",
                                                       :signature ["[meta cnt shift root tail __hash]"],
                                                       :source {:code "(deftype PersistentVector [meta cnt shift root tail ^:mutable __hash]\n  IWithMeta\n  (-with-meta [coll meta] (PersistentVector. meta cnt shift root tail __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (when (> cnt 0)\n      (-nth coll (dec cnt))))\n  (-pop [coll]\n    (cond\n     (zero? cnt) (throw (js/Error. \"Can't pop empty vector\"))\n     (== 1 cnt) (-with-meta cljs.core.PersistentVector/EMPTY meta)\n     (< 1 (- cnt (tail-off coll)))\n      (PersistentVector. meta (dec cnt) shift root (.slice tail 0 -1) nil)\n      :else (let [new-tail (array-for coll (- cnt 2))\n                  nr (pop-tail coll shift root)\n                  new-root (if (nil? nr) cljs.core.PersistentVector/EMPTY_NODE nr)\n                  cnt-1 (dec cnt)]\n              (if (and (< 5 shift) (nil? (pv-aget new-root 1)))\n                (PersistentVector. meta cnt-1 (- shift 5) (pv-aget new-root 0) new-tail nil)\n                (PersistentVector. meta cnt-1 shift new-root new-tail nil)))))\n\n  ICollection\n  (-conj [coll o]\n    (if (< (- cnt (tail-off coll)) 32)\n      (let [new-tail (aclone tail)]\n        (.push new-tail o)\n        (PersistentVector. meta (inc cnt) shift root new-tail nil))\n      (let [root-overflow? (> (bit-shift-right-zero-fill cnt 5) (bit-shift-left 1 shift))\n            new-shift (if root-overflow? (+ shift 5) shift)\n            new-root (if root-overflow?\n                       (let [n-r (pv-fresh-node nil)]\n                           (pv-aset n-r 0 root)\n                           (pv-aset n-r 1 (new-path nil shift (VectorNode. nil tail)))\n                           n-r)\n                       (push-tail coll shift root (VectorNode. nil tail)))]\n        (PersistentVector. meta (inc cnt) new-shift new-root (array o) nil))))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.PersistentVector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (cond\n      (zero? cnt) nil\n      (< cnt 32) (array-seq tail)\n      :else (chunked-seq coll 0 0)))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IIndexed\n  (-nth [coll n]\n    (aget (array-for coll n) (bit-and n 0x01f)))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n cnt))\n      (-nth coll n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IMapEntry\n  (-key [coll]\n    (-nth coll 0))\n  (-val [coll]\n    (-nth coll 1))\n\n  IAssociative\n  (-assoc [coll k v]\n    (cond\n       (and (<= 0 k) (< k cnt))\n       (if (<= (tail-off coll) k)\n         (let [new-tail (aclone tail)]\n           (aset new-tail (bit-and k 0x01f) v)\n           (PersistentVector. meta cnt shift root new-tail nil))\n         (PersistentVector. meta cnt shift (do-assoc coll shift root k v) tail nil))\n       (== k cnt) (-conj coll v)\n       :else (throw (js/Error. (str \"Index \" k \" out of bounds  [0,\" cnt \"]\")))))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [v f]\n    (ci-reduce v f))\n  (-reduce [v f start]\n    (ci-reduce v f start))\n\n  IKVReduce\n  (-kv-reduce [v f init]\n    (let [step-init (array 0 init)] ; [step 0 init init]\n      (loop [i 0]\n        (if (< i cnt)\n          (let [arr (array-for v i)\n                len (alength arr)]\n            (let [init (loop [j 0 init (aget step-init 1)]\n                         (if (< j len)\n                           (let [init (f init (+ j i) (aget arr j))]\n                             (if (reduced? init)\n                               init\n                               (recur (inc j) init)))\n                           (do (aset step-init 0 len)\n                               (aset step-init 1 init)\n                               init)))]\n              (if (reduced? init)\n                @init\n                (recur (+ i (aget step-init 0))))))\n          (aget step-init 1)))))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientVector. cnt shift (tv-editable-root root) (tv-editable-tail tail)))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? cnt)\n      (RSeq. coll (dec cnt) nil)\n      ())))",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [3050
                                                                        3185],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L3050-L3185"},
                                                       :full-name-encode "cljs.core_PersistentVector",
                                                       :history [["+"
                                                                  "0.0-1006"]]},
                         "cljs.core/IHash" {:ns "cljs.core",
                                            :name "IHash",
                                            :type "protocol",
                                            :full-name-encode "cljs.core_IHash",
                                            :source {:code "(defprotocol IHash\n  (-hash [o]))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [248 249],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L248-L249"},
                                            :methods [{:name "-hash",
                                                       :signature ["[o]"],
                                                       :docstring nil}],
                                            :full-name "cljs.core/IHash",
                                            :history [["+" "0.0-927"]]},
                         "clojure.reflect/doc" {:full-name "clojure.reflect/doc",
                                                :ns "clojure.reflect",
                                                :name "doc",
                                                :docstring "Queries the reflection api with a fully qualified symbol, then prints\ndocumentation information at the repl.",
                                                :type "function",
                                                :signature ["[sym]"],
                                                :source {:code "(defn doc\n  [sym]\n  (meta sym print-doc))",
                                                         :filename "clojurescript/src/cljs/clojure/reflect.cljs",
                                                         :lines [44
                                                                 48],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/reflect.cljs#L44-L48"},
                                                :full-name-encode "clojure.reflect_doc",
                                                :history [["+"
                                                           "0.0-1503"]]},
                         "cljs.core/is_proto_" {:full-name "cljs.core/is_proto_",
                                                :ns "cljs.core",
                                                :name "is_proto_",
                                                :type "function",
                                                :signature ["[x]"],
                                                :source {:code "(defn is_proto_\n  [x]\n  (identical? (.-prototype (.-constructor x)) x))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [77
                                                                 79],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L77-L79"},
                                                :full-name-encode "cljs.core_is_proto_",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/shorts" {:full-name "cljs.core/shorts",
                                             :ns "cljs.core",
                                             :name "shorts",
                                             :type "function",
                                             :signature ["[x]"],
                                             :source {:code "(defn shorts [x] x)",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1529
                                                              1529],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1529-L1529"},
                                             :full-name-encode "cljs.core_shorts",
                                             :clj-symbol "clojure.core/shorts",
                                             :history [["+"
                                                        "0.0-1798"]]},
                         "cljs.core/TransientVector" {:full-name "cljs.core/TransientVector",
                                                      :ns "cljs.core",
                                                      :name "TransientVector",
                                                      :type "type",
                                                      :signature ["[cnt shift root tail]"],
                                                      :source {:code "(deftype TransientVector [^:mutable cnt\n                          ^:mutable shift\n                          ^:mutable root\n                          ^:mutable tail]\n  ITransientCollection\n  (-conj! [tcoll o]\n    (if ^boolean (.-edit root)\n      (if (< (- cnt (tail-off tcoll)) 32)\n        (do (aset tail (bit-and cnt 0x01f) o)\n            (set! cnt (inc cnt))\n            tcoll)\n        (let [tail-node (VectorNode. (.-edit root) tail)\n              new-tail  (make-array 32)]\n          (aset new-tail 0 o)\n          (set! tail new-tail)\n          (if (> (bit-shift-right-zero-fill cnt 5)\n                 (bit-shift-left 1 shift))\n            (let [new-root-array (make-array 32)\n                  new-shift      (+ shift 5)]\n              (aset new-root-array 0 root)\n              (aset new-root-array 1 (new-path (.-edit root) shift tail-node))\n              (set! root  (VectorNode. (.-edit root) new-root-array))\n              (set! shift new-shift)\n              (set! cnt   (inc cnt))\n              tcoll)\n            (let [new-root (tv-push-tail tcoll shift root tail-node)]\n              (set! root new-root)\n              (set! cnt  (inc cnt))\n              tcoll))))\n      (throw (js/Error. \"conj! after persistent!\"))))\n\n  (-persistent! [tcoll]\n    (if ^boolean (.-edit root)\n      (do (set! (.-edit root) nil)\n          (let [len (- cnt (tail-off tcoll))\n                trimmed-tail (make-array len)]\n            (array-copy tail 0 trimmed-tail 0 len)\n            (PersistentVector. nil cnt shift root trimmed-tail nil)))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val] (-assoc-n! tcoll key val))\n\n  ITransientVector\n  (-assoc-n! [tcoll n val]\n    (if ^boolean (.-edit root)\n      (cond\n        (and (<= 0 n) (< n cnt))\n        (if (<= (tail-off tcoll) n)\n          (do (aset tail (bit-and n 0x01f) val)\n              tcoll)\n          (let [new-root\n                ((fn go [level node]\n                   (let [node (tv-ensure-editable (.-edit root) node)]\n                     (if (zero? level)\n                       (do (pv-aset node (bit-and n 0x01f) val)\n                           node)\n                       (let [subidx (bit-and (bit-shift-right-zero-fill n level)\n                                             0x01f)]\n                         (pv-aset node subidx\n                                  (go (- level 5) (pv-aget node subidx)))\n                         node))))\n                 shift root)]\n            (set! root new-root)\n            tcoll))\n        (== n cnt) (-conj! tcoll val)\n        :else\n        (throw\n         (js/Error.\n          (str \"Index \" n \" out of bounds for TransientVector of length\" cnt))))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  (-pop! [tcoll]\n    (if ^boolean (.-edit root)\n      (cond\n        (zero? cnt) (throw (js/Error. \"Can't pop empty vector\"))\n        (== 1 cnt)                       (do (set! cnt 0) tcoll)\n        (pos? (bit-and (dec cnt) 0x01f)) (do (set! cnt (dec cnt)) tcoll)\n        :else\n        (let [new-tail (editable-array-for tcoll (- cnt 2))\n              new-root (let [nr (tv-pop-tail tcoll shift root)]\n                         (if-not (nil? nr)\n                           nr\n                           (VectorNode. (.-edit root) (make-array 32))))]\n          (if (and (< 5 shift) (nil? (pv-aget new-root 1)))\n            (let [new-root (tv-ensure-editable (.-edit root) (pv-aget new-root 0))]\n              (set! root  new-root)\n              (set! shift (- shift 5))\n              (set! cnt   (dec cnt))\n              (set! tail  new-tail)\n              tcoll)\n            (do (set! root new-root)\n                (set! cnt  (dec cnt))\n                (set! tail new-tail)\n                tcoll))))\n      (throw (js/Error. \"pop! after persistent!\"))))\n\n  ICounted\n  (-count [coll]\n    (if ^boolean (.-edit root)\n      cnt\n      (throw (js/Error. \"count after persistent!\"))))\n\n  IIndexed\n  (-nth [coll n]\n    (if ^boolean (.-edit root)\n      (aget (array-for coll n) (bit-and n 0x01f))\n      (throw (js/Error. \"nth after persistent!\"))))\n\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n cnt))\n      (-nth coll n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                               :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                               :lines [3437
                                                                       3561],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L3437-L3561"},
                                                      :full-name-encode "cljs.core_TransientVector",
                                                      :history [["+"
                                                                 "0.0-1211"]]},
                         "cljs.core/keep-indexed" {:ns "cljs.core",
                                                   :name "keep-indexed",
                                                   :signature ["[f coll]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.core_keep-indexed",
                                                   :source {:code "(defn keep-indexed\n  ([f coll]\n     (letfn [(keepi [idx coll]\n               (lazy-seq\n                (when-let [s (seq coll)]\n                  (if (chunked-seq? s)\n                    (let [c (chunk-first s)\n                          size (count c)\n                          b (chunk-buffer size)]\n                      (dotimes [i size]\n                        (let [x (f (+ idx i) (-nth c i))]\n                          (when-not (nil? x)\n                            (chunk-append b x))))\n                      (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s))))\n                    (let [x (f idx (first s))]\n                      (if (nil? x)\n                        (keepi (inc idx) (rest s))\n                        (cons x (keepi (inc idx) (rest s)))))))))]\n       (keepi 0 coll))))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [2547
                                                                    2568],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2547-L2568"},
                                                   :full-name "cljs.core/keep-indexed",
                                                   :clj-symbol "clojure.core/keep-indexed",
                                                   :docstring "Returns a lazy sequence of the non-nil results of (f index item). Note,\nthis means false return values will be included.  f must be free of\nside-effects."},
                         "cljs.core/bit-shift-right" {:ns "cljs.core",
                                                      :name "bit-shift-right",
                                                      :signature ["[x n]"],
                                                      :shadowed-sources ({:code "(defmacro bit-shift-right [x n]\n  (list 'js* \"(~{} >> ~{})\" x n))",
                                                                          :filename "clojurescript/src/clj/cljs/core.clj",
                                                                          :lines [436
                                                                                  437],
                                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L436-L437"}),
                                                      :history [["+"
                                                                 "0.0-927"]],
                                                      :type "function",
                                                      :full-name-encode "cljs.core_bit-shift-right",
                                                      :source {:code "(defn bit-shift-right\n  [x n] (cljs.core/bit-shift-right x n))",
                                                               :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                               :lines [1610
                                                                       1612],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1610-L1612"},
                                                      :full-name "cljs.core/bit-shift-right",
                                                      :clj-symbol "clojure.core/bit-shift-right",
                                                      :docstring "Bitwise shift right"},
                         "cljs.core/comparator" {:ns "cljs.core",
                                                 :name "comparator",
                                                 :signature ["[pred]"],
                                                 :history [["+"
                                                            "0.0-1586"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_comparator",
                                                 :source {:code "(defn comparator\n  [pred]\n  (fn [x y]\n    (cond (pred x y) -1 (pred y x) 1 :else 0)))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [7166
                                                                  7170],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L7166-L7170"},
                                                 :full-name "cljs.core/comparator",
                                                 :clj-symbol "clojure.core/comparator",
                                                 :docstring "Returns an JavaScript compatible comparator based upon pred."},
                         "cljs.core/PersistentTreeSet" {:full-name "cljs.core/PersistentTreeSet",
                                                        :ns "cljs.core",
                                                        :name "PersistentTreeSet",
                                                        :type "type",
                                                        :signature ["[meta tree-map __hash]"],
                                                        :source {:code "(deftype PersistentTreeSet [meta tree-map ^:mutable __hash]\n  IWithMeta\n  (-with-meta [coll meta] (PersistentTreeSet. meta tree-map __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (PersistentTreeSet. meta (assoc tree-map o nil) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.PersistentTreeSet/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (== (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-iset __hash))\n\n  ISeqable\n  (-seq [coll] (keys tree-map))\n\n  ISorted\n  (-sorted-seq [coll ascending?]\n    (map key (-sorted-seq tree-map ascending?)))\n\n  (-sorted-seq-from [coll k ascending?]\n    (map key (-sorted-seq-from tree-map k ascending?)))\n\n  (-entry-key [coll entry] entry)\n\n  (-comparator [coll] (-comparator tree-map))\n\n  IReversible\n  (-rseq [coll]\n    (map key (rseq tree-map)))\n\n  ICounted\n  (-count [coll] (count tree-map))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (let [n (.entry-at tree-map v)]\n      (if-not (nil? n)\n        (.-key n)\n        not-found)))\n\n  ISet\n  (-disjoin [coll v]\n    (PersistentTreeSet. meta (dissoc tree-map v) nil))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                 :lines [5729
                                                                         5792],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5729-L5792"},
                                                        :full-name-encode "cljs.core_PersistentTreeSet",
                                                        :history [["+"
                                                                   "0.0-1211"]]},
                         "clojure.zip/insert-right" {:ns "clojure.zip",
                                                     :name "insert-right",
                                                     :signature ["[loc item]"],
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "clojure.zip_insert-right",
                                                     :source {:code "(defn insert-right\n  [loc item]\n    (let [[node {r :r :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :r (cons item r) :changed? true)] (meta loc)))))",
                                                              :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                              :lines [174
                                                                      181],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L174-L181"},
                                                     :full-name "clojure.zip/insert-right",
                                                     :clj-symbol "clojure.zip/insert-right",
                                                     :docstring "Inserts the item as the right sibling of the node at this loc,\nwithout moving"},
                         "cljs.core/make-hierarchy" {:ns "cljs.core",
                                                     :name "make-hierarchy",
                                                     :signature ["[]"],
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.core_make-hierarchy",
                                                     :source {:code "(defn make-hierarchy\n  [] {:parents {} :descendants {} :ancestors {}})",
                                                              :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                              :lines [6837
                                                                      6839],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6837-L6839"},
                                                     :full-name "cljs.core/make-hierarchy",
                                                     :clj-symbol "clojure.core/make-hierarchy",
                                                     :docstring "Creates a hierarchy object for use with derive, isa? etc."},
                         "cljs.core/repeat" {:ns "cljs.core",
                                             :name "repeat",
                                             :signature ["[x]"
                                                         "[n x]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_repeat",
                                             :source {:code "(defn repeat\n  ([x] (lazy-seq (cons x (repeat x))))\n  ([n x] (take n (repeat x))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2740
                                                              2743],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2740-L2743"},
                                             :full-name "cljs.core/repeat",
                                             :clj-symbol "clojure.core/repeat",
                                             :docstring "Returns a lazy (infinite!, or length n if supplied) sequence of xs."},
                         "cljs.core/prn-str-with-opts" {:full-name "cljs.core/prn-str-with-opts",
                                                        :ns "cljs.core",
                                                        :name "prn-str-with-opts",
                                                        :docstring "Same as pr-str-with-opts followed by (newline)",
                                                        :type "function",
                                                        :signature ["[objs opts]"],
                                                        :source {:code "(defn prn-str-with-opts\n  [objs opts]\n  (if (empty? objs)\n    \"\\n\"\n    (let [sb (pr-sb-with-opts objs opts)]\n      (.append sb \\newline)\n      (str sb))))",
                                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                 :lines [6340
                                                                         6347],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6340-L6347"},
                                                        :full-name-encode "cljs.core_prn-str-with-opts",
                                                        :history [["+"
                                                                   "0.0-1011"]]},
                         "cljs.core/MultiFn" {:full-name "cljs.core/MultiFn",
                                              :ns "cljs.core",
                                              :name "MultiFn",
                                              :type "type",
                                              :signature ["[name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]"],
                                              :source {:code "(deftype MultiFn [name dispatch-fn default-dispatch-val hierarchy\n                  method-table prefer-table method-cache cached-hierarchy]\n  IMultiFn\n  (-reset [mf]\n    (swap! method-table (fn [mf] {}))\n    (swap! method-cache (fn [mf] {}))\n    (swap! prefer-table (fn [mf] {}))\n    (swap! cached-hierarchy (fn [mf] nil))\n    mf)\n\n  (-add-method [mf dispatch-val method]\n    (swap! method-table assoc dispatch-val method)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-remove-method [mf dispatch-val]\n    (swap! method-table dissoc dispatch-val)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-get-method [mf dispatch-val]\n    (when-not (= @cached-hierarchy @hierarchy)\n      (reset-cache method-cache method-table cached-hierarchy hierarchy))\n    (if-let [target-fn (@method-cache dispatch-val)]\n      target-fn\n      (if-let [target-fn (find-and-cache-best-method name dispatch-val hierarchy method-table\n                                                     prefer-table method-cache cached-hierarchy)]\n        target-fn\n        (@method-table default-dispatch-val))))\n\n  (-prefer-method [mf dispatch-val-x dispatch-val-y]\n    (when (prefers* dispatch-val-x dispatch-val-y prefer-table)\n      (throw (js/Error. (str \"Preference conflict in multimethod '\" name \"': \" dispatch-val-y\n                   \" is already preferred to \" dispatch-val-x))))\n    (swap! prefer-table\n           (fn [old]\n             (assoc old dispatch-val-x\n                    (conj (get old dispatch-val-x #{})\n                          dispatch-val-y))))\n    (reset-cache method-cache method-table cached-hierarchy hierarchy))\n\n  (-methods [mf] @method-table)\n  (-prefers [mf] @prefer-table)\n\n  (-dispatch [mf args] (do-dispatch mf dispatch-fn args))\n\n  IHash\n  (-hash [this] (goog/getUid this)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [7021
                                                               7068],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L7021-L7068"},
                                              :full-name-encode "cljs.core_MultiFn",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/Reduced" {:full-name "cljs.core/Reduced",
                                              :ns "cljs.core",
                                              :name "Reduced",
                                              :type "type",
                                              :signature ["[val]"],
                                              :source {:code "(deftype Reduced [val]\n  IDeref\n  (-deref [o] val))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [526
                                                               528],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L526-L528"},
                                              :full-name-encode "cljs.core_Reduced",
                                              :history [["+"
                                                         "0.0-1211"]]},
                         "cljs.core/not-any?" {:return-type boolean,
                                               :ns "cljs.core",
                                               :name "not-any?",
                                               :signature ["[pred coll]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_not-any_QMARK_",
                                               :source {:code "(defn ^boolean not-any?\n  [pred coll] (not (some pred coll)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [2411
                                                                2414],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2411-L2414"},
                                               :full-name "cljs.core/not-any?",
                                               :clj-symbol "clojure.core/not-any?",
                                               :docstring "Returns false if (pred x) is logical true for any x in coll,\nelse true."},
                         "cljs.reader/read-regex" {:full-name "cljs.reader/read-regex",
                                                   :ns "cljs.reader",
                                                   :name "read-regex",
                                                   :type "function",
                                                   :signature ["[rdr ch]"],
                                                   :source {:code "(defn read-regex\n  [rdr ch]\n  (-> (read-string* rdr ch) re-pattern))",
                                                            :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                            :lines [375
                                                                    377],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L375-L377"},
                                                   :full-name-encode "cljs.reader_read-regex",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "clojure.zip/next" {:ns "clojure.zip",
                                             :name "next",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_next",
                                             :source {:code "(defn next\n  [loc]\n    (if (= :end (loc 1))\n      loc\n      (or \n       (and (branch? loc) (down loc))\n       (right loc)\n       (loop [p loc]\n         (if (up p)\n           (or (right (up p)) (recur (up p)))\n           [(node p) :end])))))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [206 219],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L206-L219"},
                                             :full-name "clojure.zip/next",
                                             :clj-symbol "clojure.zip/next",
                                             :docstring "Moves to the next loc in the hierarchy, depth-first. When reaching\nthe end, returns a distinguished loc detectable via end?. If already\nat the end, stays there."},
                         "cljs.core/IFn" {:ns "cljs.core",
                                          :name "IFn",
                                          :type "protocol",
                                          :full-name-encode "cljs.core_IFn",
                                          :source {:code "(defprotocol IFn\n  (-invoke\n    [this]\n    [this a]\n    [this a b]\n    [this a b c]\n    [this a b c d]\n    [this a b c d e]\n    [this a b c d e f]\n    [this a b c d e f g]\n    [this a b c d e f g h]\n    [this a b c d e f g h i]\n    [this a b c d e f g h i j]\n    [this a b c d e f g h i j k]\n    [this a b c d e f g h i j k l]\n    [this a b c d e f g h i j k l m]\n    [this a b c d e f g h i j k l m n]\n    [this a b c d e f g h i j k l m n o]\n    [this a b c d e f g h i j k l m n o p]\n    [this a b c d e f g h i j k l m n o p q]\n    [this a b c d e f g h i j k l m n o p q s]\n    [this a b c d e f g h i j k l m n o p q s t]\n    [this a b c d e f g h i j k l m n o p q s t rest]))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [153 175],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L153-L175"},
                                          :methods [{:name "-invoke",
                                                     :signature ["[this]"
                                                                 "[this a]"
                                                                 "[this a b]"
                                                                 "[this a b c]"
                                                                 "[this a b c d]"
                                                                 "[this a b c d e]"
                                                                 "[this a b c d e f]"
                                                                 "[this a b c d e f g]"
                                                                 "[this a b c d e f g h]"
                                                                 "[this a b c d e f g h i]"
                                                                 "[this a b c d e f g h i j]"
                                                                 "[this a b c d e f g h i j k]"
                                                                 "[this a b c d e f g h i j k l]"
                                                                 "[this a b c d e f g h i j k l m]"
                                                                 "[this a b c d e f g h i j k l m n]"
                                                                 "[this a b c d e f g h i j k l m n o]"
                                                                 "[this a b c d e f g h i j k l m n o p]"
                                                                 "[this a b c d e f g h i j k l m n o p q]"
                                                                 "[this a b c d e f g h i j k l m n o p q s]"
                                                                 "[this a b c d e f g h i j k l m n o p q s t]"
                                                                 "[this a b c d e f g h i j k l m n o p q s t rest]"],
                                                     :docstring nil}],
                                          :full-name "cljs.core/IFn",
                                          :history [["+" "0.0-971"]]},
                         "cljs.core/aget" {:ns "cljs.core",
                                           :name "aget",
                                           :signature ["[array i]"
                                                       "[array i & idxs]"],
                                           :shadowed-sources ({:code "(defmacro aget\n  ([a i]\n     (list 'js* \"(~{}[~{}])\" a i))\n  ([a i & idxs]\n     (let [astr (apply core/str (repeat (count idxs) \"[~{}]\"))]\n      `(~'js* ~(core/str \"(~{}[~{}]\" astr \")\") ~a ~i ~@idxs))))",
                                                               :filename "clojurescript/src/clj/cljs/core.clj",
                                                               :lines [254
                                                                       259],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L254-L259"}),
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_aget",
                                           :source {:code "(defn aget\n  ([array i]\n     (cljs.core/aget array i))\n  ([array i & idxs]\n     (apply aget (aget array i) idxs)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [123 128],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L123-L128"},
                                           :full-name "cljs.core/aget",
                                           :clj-symbol "clojure.core/aget",
                                           :docstring "Returns the value at the index."},
                         "cljs.core/if-let" {:ns "cljs.core",
                                             :name "if-let",
                                             :signature ["[bindings then]"
                                                         "[bindings then else & oldform]"],
                                             :history [["+" "0.0-927"]],
                                             :type "macro",
                                             :full-name-encode "cljs.core_if-let",
                                             :source {:code "(defmacro if-let\n  ([bindings then]\n   `(if-let ~bindings ~then nil))\n  ([bindings then else & oldform]\n   (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (nil? oldform) \"1 or 2 forms after binding vector\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if temp#\n          (let [~form temp#]\n            ~then)\n          ~else)))))",
                                                      :filename "clojure/src/clj/clojure/core.clj",
                                                      :lines [1684
                                                              1702],
                                                      :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L1684-L1702"},
                                             :full-name "cljs.core/if-let",
                                             :clj-symbol "clojure.core/if-let",
                                             :docstring "bindings => binding-form test\n\nIf test is true, evaluates then with binding-form bound to the value of \ntest, if not, yields else"},
                         "cljs.core//" {:ns "cljs.core",
                                        :name "/",
                                        :signature ["[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :shadowed-sources ({:code "(defmacro /\n  ([x] `(/ 1 ~x))\n  ([x y] (list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [334
                                                                    337],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L334-L337"}),
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core__SLASH_",
                                        :source {:code "(defn /\n  ([x] (/ 1 x))\n  ([x y] (cljs.core/divide x y)) ;; FIXME: waiting on cljs.core//\n  ([x y & more] (reduce / (/ x y) more)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [1336 1341],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1336-L1341"},
                                        :full-name "cljs.core//",
                                        :clj-symbol "clojure.core//",
                                        :docstring "If no denominators are supplied, returns 1/numerator,\nelse returns numerator divided by all of the denominators."},
                         "cljs.core/unchecked-int" {:ns "cljs.core",
                                                    :name "unchecked-int",
                                                    :signature ["[x]"],
                                                    :history [["+"
                                                               "0.0-1798"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_unchecked-int",
                                                    :source {:code "(defn unchecked-int\n  [x]\n  (fix x))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [1511
                                                                     1514],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1511-L1514"},
                                                    :full-name "cljs.core/unchecked-int",
                                                    :clj-symbol "clojure.core/unchecked-int",
                                                    :docstring "Coerce to int by stripping decimal places."},
                         "cljs.core/min-key" {:ns "cljs.core",
                                              :name "min-key",
                                              :signature ["[k x]"
                                                          "[k x y]"
                                                          "[k x y & more]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_min-key",
                                              :source {:code "(defn min-key\n  ([k x] x)\n  ([k x y] (if (< (k x) (k y)) x y))\n  ([k x y & more]\n     (reduce #(min-key k %1 %2) (min-key k x y) more)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [5914
                                                               5919],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5914-L5919"},
                                              :full-name "cljs.core/min-key",
                                              :clj-symbol "clojure.core/min-key",
                                              :docstring "Returns the x for which (k x), a number, is least."},
                         "clojure.zip/root" {:ns "clojure.zip",
                                             :name "root",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_root",
                                             :source {:code "(defn root\n  [loc]\n    (if (= :end (loc 1))\n      (node loc)\n      (let [p (up loc)]\n        (if p\n          (recur p)\n          (node loc)))))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [124 133],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L124-L133"},
                                             :full-name "clojure.zip/root",
                                             :clj-symbol "clojure.zip/root",
                                             :docstring "zips all the way up and returns the root node, reflecting any\nchanges."},
                         "cljs.core/drop-while" {:ns "cljs.core",
                                                 :name "drop-while",
                                                 :signature ["[pred coll]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_drop-while",
                                                 :source {:code "(defn drop-while\n  [pred coll]\n  (let [step (fn [pred coll]\n               (let [s (seq coll)]\n                 (if (and s (pred (first s)))\n                   (recur pred (rest s))\n                   s)))]\n    (lazy-seq (step pred coll))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2718
                                                                  2727],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2718-L2727"},
                                                 :full-name "cljs.core/drop-while",
                                                 :clj-symbol "clojure.core/drop-while",
                                                 :docstring "Returns a lazy sequence of the items in coll starting from the first\nitem for which (pred item) returns nil."},
                         "clojure.browser.repl/evaluate-javascript" {:full-name "clojure.browser.repl/evaluate-javascript",
                                                                     :ns "clojure.browser.repl",
                                                                     :name "evaluate-javascript",
                                                                     :docstring "Process a single block of JavaScript received from the server",
                                                                     :type "function",
                                                                     :signature ["[conn block]"],
                                                                     :source {:code "(defn evaluate-javascript\n  [conn block]\n  (let [result (try {:status :success :value (str (js* \"eval(~{block})\"))}\n                    (catch js/Error e\n                      {:status :exception :value (pr-str e)\n                       :stacktrace (if (.hasOwnProperty e \"stack\")\n                                     (.-stack e)\n                                     \"No stacktrace available.\")}))]\n    (pr-str result)))",
                                                                              :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                              :lines [27
                                                                                      36],
                                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/repl.cljs#L27-L36"},
                                                                     :full-name-encode "clojure.browser.repl_evaluate-javascript",
                                                                     :history [["+"
                                                                                "0.0-927"]]},
                         "cljs.core/set-validator!" {:ns "cljs.core",
                                                     :name "set-validator!",
                                                     :signature ["[iref val]"],
                                                     :history [["+"
                                                                "0.0-927"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.core_set-validator_BANG_",
                                                     :source {:code "(defn set-validator!\n  [iref val]\n  (set! (.-validator iref) val))",
                                                              :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                              :lines [6600
                                                                      6608],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6600-L6608"},
                                                     :full-name "cljs.core/set-validator!",
                                                     :clj-symbol "clojure.core/set-validator!",
                                                     :docstring "Sets the validator-fn for an atom. validator-fn must be nil or a\nside-effect-free fn of one argument, which will be passed the intended\nnew state on any state change. If the new state is unacceptable, the\nvalidator-fn should return false or throw an Error. If the current state\nis not acceptable to the new validator, an Error will be thrown and the\nvalidator will not be changed."},
                         "cljs.core/<" {:return-type boolean,
                                        :ns "cljs.core",
                                        :name "<",
                                        :signature ["[x]"
                                                    "[x y]"
                                                    "[x y & more]"],
                                        :shadowed-sources ({:code "(defmacro <\n  ([x] true)\n  ([x y] (bool-expr (list 'js* \"(~{} < ~{})\" x y)))\n  ([x y & more] `(and (< ~x ~y) (< ~y ~@more))))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [344
                                                                    347],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L344-L347"}),
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "cljs.core__LT_",
                                        :source {:code "(defn ^boolean <\n  ([x] true)\n  ([x y] (cljs.core/< x y))\n  ([x y & more]\n     (if (cljs.core/< x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (cljs.core/< y (first more)))\n       false)))",
                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                 :lines [1343 1353],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1343-L1353"},
                                        :full-name "cljs.core/<",
                                        :clj-symbol "clojure.core/<",
                                        :docstring "Returns non-nil if nums are in monotonically increasing order,\notherwise false."},
                         "cljs.core/fn" {:ns "cljs.core",
                                         :name "fn",
                                         :signature ["[& sigs]"],
                                         :shadowed-sources ({:code "(def\n ^{:macro true\n   :added \"1.0\"}\n fn (fn* fn [&form &env & decl] \n         (.withMeta ^clojure.lang.IObj (cons 'fn* decl) \n                    (.meta ^clojure.lang.IMeta &form))))",
                                                             :filename "clojure/src/clj/clojure/core.clj",
                                                             :lines [42
                                                                     47],
                                                             :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L42-L47"}),
                                         :history [["+" "0.0-927"]],
                                         :type "macro",
                                         :full-name-encode "cljs.core_fn",
                                         :source {:code "(defmacro fn\n  [& sigs]\n    (let [name (if (symbol? (first sigs)) (first sigs) nil)\n          sigs (if name (next sigs) sigs)\n          sigs (if (vector? (first sigs)) \n                 (list sigs) \n                 (if (seq? (first sigs))\n                   sigs\n                   ;; Assume single arity syntax\n                   (throw (IllegalArgumentException. \n                            (if (seq sigs)\n                              (str \"Parameter declaration \" \n                                   (first sigs)\n                                   \" should be a vector\")\n                              (str \"Parameter declaration missing\"))))))\n          psig (fn* [sig]\n                 ;; Ensure correct type before destructuring sig\n                 (when (not (seq? sig))\n                   (throw (IllegalArgumentException.\n                            (str \"Invalid signature \" sig\n                                 \" should be a list\"))))\n                 (let [[params & body] sig\n                       _ (when (not (vector? params))\n                           (throw (IllegalArgumentException. \n                                    (if (seq? (first sigs))\n                                      (str \"Parameter declaration \" params\n                                           \" should be a vector\")\n                                      (str \"Invalid signature \" sig\n                                           \" should be a list\")))))\n                       conds (when (and (next body) (map? (first body))) \n                                           (first body))\n                       body (if conds (next body) body)\n                       conds (or conds (meta params))\n                       pre (:pre conds)\n                       post (:post conds)                       \n                       body (if post\n                              `((let [~'% ~(if (< 1 (count body)) \n                                            `(do ~@body) \n                                            (first body))]\n                                 ~@(map (fn* [c] `(assert ~c)) post)\n                                 ~'%))\n                              body)\n                       body (if pre\n                              (concat (map (fn* [c] `(assert ~c)) pre) \n                                      body)\n                              body)]\n                   (maybe-destructured params body)))\n          new-sigs (map psig sigs)]\n      (with-meta\n        (if name\n          (list* 'fn* name new-sigs)\n          (cons 'fn* new-sigs))\n        (meta &form))))",
                                                  :filename "clojure/src/clj/clojure/core.clj",
                                                  :lines [4067 4127],
                                                  :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L4067-L4127"},
                                         :full-name "cljs.core/fn",
                                         :clj-symbol "clojure.core/fn",
                                         :docstring "params => positional-params* , or positional-params* & next-param\npositional-param => binding-form\nnext-param => binding-form\nname => symbol\n\nDefines a function"},
                         "cljs.core/split-with" {:ns "cljs.core",
                                                 :name "split-with",
                                                 :signature ["[pred coll]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_split-with",
                                                 :source {:code "(defn split-with\n  [pred coll]\n  [(take-while pred coll) (drop-while pred coll)])",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [6059
                                                                  6062],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6059-L6062"},
                                                 :full-name "cljs.core/split-with",
                                                 :clj-symbol "clojure.core/split-with",
                                                 :docstring "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"},
                         "cljs.core/IWriter" {:ns "cljs.core",
                                              :name "IWriter",
                                              :type "protocol",
                                              :full-name-encode "cljs.core_IWriter",
                                              :source {:code "(defprotocol IWriter\n  (-write [writer s])\n  (-flush [writer]))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [272
                                                               274],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L272-L274"},
                                              :methods [{:name "-write",
                                                         :signature ["[writer s]"],
                                                         :docstring nil}
                                                        {:name "-flush",
                                                         :signature ["[writer]"],
                                                         :docstring nil}],
                                              :full-name "cljs.core/IWriter",
                                              :history [["+"
                                                         "0.0-1503"]]},
                         "cljs.core/IReduce" {:ns "cljs.core",
                                              :name "IReduce",
                                              :type "protocol",
                                              :full-name-encode "cljs.core_IReduce",
                                              :source {:code "(defprotocol IReduce\n  (-reduce [coll f] [coll f start]))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [239
                                                               240],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L239-L240"},
                                              :methods [{:name "-reduce",
                                                         :signature ["[coll f]"
                                                                     "[coll f start]"],
                                                         :docstring nil}],
                                              :full-name "cljs.core/IReduce",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.reader/symbol-pattern" {:full-name "cljs.reader/symbol-pattern",
                                                       :ns "cljs.reader",
                                                       :name "symbol-pattern",
                                                       :type "var",
                                                       :source {:code "(def symbol-pattern (re-pattern \"[:]?([^0-9/].*/)?([^0-9/][^/]*)\"))",
                                                                :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                :lines [102
                                                                        102],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L102-L102"},
                                                       :full-name-encode "cljs.reader_symbol-pattern",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.core/repeatedly" {:ns "cljs.core",
                                                 :name "repeatedly",
                                                 :signature ["[f]"
                                                             "[n f]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_repeatedly",
                                                 :source {:code "(defn repeatedly\n  ([f] (lazy-seq (cons (f) (repeatedly f))))\n  ([n f] (take n (repeatedly f))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2749
                                                                  2754],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2749-L2754"},
                                                 :full-name "cljs.core/repeatedly",
                                                 :clj-symbol "clojure.core/repeatedly",
                                                 :docstring "Takes a function of no args, presumably with side effects, and\nreturns an infinite (or length n if supplied) lazy sequence of calls\nto it"},
                         "cljs.reader/read-delimited-list" {:full-name "cljs.reader/read-delimited-list",
                                                            :ns "cljs.reader",
                                                            :name "read-delimited-list",
                                                            :type "function",
                                                            :signature ["[delim rdr recursive?]"],
                                                            :source {:code "(defn read-delimited-list\n  [delim rdr recursive?]\n  (loop [a (transient [])]\n    (let [ch (read-past whitespace? rdr)]\n      (when-not ch (reader-error rdr \"EOF while reading\"))\n      (if (identical? delim ch)\n        (persistent! a)\n        (if-let [macrofn (macros ch)]\n          (let [mret (macrofn rdr ch)]\n            (recur (if (identical? mret rdr) a (conj! a mret))))\n          (do\n            (unread rdr ch)\n            (let [o (read rdr true nil recursive?)]\n              (recur (if (identical? o rdr) a (conj! a o))))))))))",
                                                                     :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                     :lines [233
                                                                             246],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L233-L246"},
                                                            :full-name-encode "cljs.reader_read-delimited-list",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "cljs.core/undefined?" {:return-type boolean,
                                                 :ns "cljs.core",
                                                 :name "undefined?",
                                                 :signature ["[x]"],
                                                 :shadowed-sources ({:code "(defmacro undefined? [x]\n  (bool-expr (list 'js* \"(void 0 === ~{})\" x)))",
                                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                                     :lines [239
                                                                             240],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L239-L240"}),
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_undefined_QMARK_",
                                                 :source {:code "(defn ^boolean undefined? [x]\n  (cljs.core/undefined? x))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [1085
                                                                  1086],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1085-L1086"},
                                                 :full-name "cljs.core/undefined?"},
                         "clojure.zip/prev" {:ns "clojure.zip",
                                             :name "prev",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_prev",
                                             :source {:code "(defn prev\n  [loc]\n    (if-let [lloc (left loc)]\n      (loop [loc lloc]\n        (if-let [child (and (branch? loc) (down loc))]\n          (recur (rightmost child))\n          loc))\n      (up loc)))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [221 230],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L221-L230"},
                                             :full-name "clojure.zip/prev",
                                             :clj-symbol "clojure.zip/prev",
                                             :docstring "Moves to the previous loc in the hierarchy, depth-first. If already\nat the root, returns nil."},
                         "cljs.core/seq?" {:return-type boolean,
                                           :ns "cljs.core",
                                           :name "seq?",
                                           :signature ["[s]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_seq_QMARK_",
                                           :source {:code "(defn ^boolean seq?\n  [s]\n  (if (nil? s)\n    false\n    (satisfies? ISeq s)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1088 1093],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1088-L1093"},
                                           :full-name "cljs.core/seq?",
                                           :clj-symbol "clojure.core/seq?",
                                           :docstring "Return true if s satisfies ISeq"},
                         "cljs.core/prn-str" {:ns "cljs.core",
                                              :name "prn-str",
                                              :signature ["[& objs]"],
                                              :history [["+"
                                                         "0.0-1011"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_prn-str",
                                              :source {:code "(defn prn-str\n  [& objs]\n  (prn-str-with-opts objs (pr-opts)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [6376
                                                               6379],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6376-L6379"},
                                              :full-name "cljs.core/prn-str",
                                              :clj-symbol "clojure.core/prn-str",
                                              :docstring "Same as pr-str followed by (newline)"},
                         "cljs.core/chunk-buffer" {:full-name "cljs.core/chunk-buffer",
                                                   :ns "cljs.core",
                                                   :name "chunk-buffer",
                                                   :type "function",
                                                   :signature ["[capacity]"],
                                                   :source {:code "(defn chunk-buffer [capacity]\n  (ChunkBuffer. (make-array capacity) 0))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [2028
                                                                    2029],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2028-L2029"},
                                                   :full-name-encode "cljs.core_chunk-buffer",
                                                   :history [["+"
                                                              "0.0-1424"]]},
                         "cljs.core/odd?" {:return-type boolean,
                                           :ns "cljs.core",
                                           :name "odd?",
                                           :signature ["[n]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_odd_QMARK_",
                                           :source {:code "(defn ^boolean odd?\n  [n] (not (even? n)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2422 2424],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2422-L2424"},
                                           :full-name "cljs.core/odd?",
                                           :clj-symbol "clojure.core/odd?",
                                           :docstring "Returns true if n is odd, throws an exception if n is not an integer"},
                         "cljs.core/cons" {:ns "cljs.core",
                                           :name "cons",
                                           :signature ["[x coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_cons",
                                           :source {:code "(defn cons\n  [x coll]\n  (if (or (nil? coll)\n          (satisfies? ISeq coll false))\n    (Cons. nil x coll nil)\n    (Cons. nil x (seq coll) nil)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1922 1928],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1922-L1928"},
                                           :full-name "cljs.core/cons",
                                           :clj-symbol "clojure.core/cons",
                                           :docstring "Returns a new seq where x is the first element and seq is the rest."},
                         "special/deftype*" {:full-name "special/deftype*",
                                             :ns "special",
                                             :name "deftype*",
                                             :type "special form",
                                             :source {:code "(defmethod parse 'deftype*\n  [_ env [_ tsym fields pmasks :as form] _]\n  (let [t (:name (resolve-var (dissoc env :locals) tsym))]\n    (swap! namespaces update-in [(-> env :ns :name) :defs tsym]\n           (fn [m]\n             (let [m (assoc (or m {})\n                       :name t\n                       :type true\n                       :num-fields (count fields))]\n               (merge m\n                 {:protocols (-> tsym meta :protocols)}\n                 (source-info tsym env)))))\n    {:env env :op :deftype* :form form :t t :fields fields :pmasks pmasks}))",
                                                      :filename "clojurescript/src/clj/cljs/analyzer.clj",
                                                      :lines [725 737],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/analyzer.clj#L725-L737"},
                                             :full-name-encode "special_deftype_STAR_",
                                             :history [["+" "0.0-927"]]},
                         "cljs.reader/read-set" {:full-name "cljs.reader/read-set",
                                                 :ns "cljs.reader",
                                                 :name "read-set",
                                                 :type "function",
                                                 :signature ["[rdr _]"],
                                                 :source {:code "(defn read-set\n  [rdr _]\n  (set (read-delimited-list \"}\" rdr true)))",
                                                          :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                          :lines [371
                                                                  373],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L371-L373"},
                                                 :full-name-encode "cljs.reader_read-set",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "cljs.core/descendants" {:ns "cljs.core",
                                                  :name "descendants",
                                                  :signature ["[tag]"
                                                              "[h tag]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_descendants",
                                                  :source {:code "(defn descendants\n  ([tag] (descendants @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:descendants h) tag))))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [6887
                                                                   6894],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6887-L6894"},
                                                  :full-name "cljs.core/descendants",
                                                  :clj-symbol "clojure.core/descendants",
                                                  :docstring "Returns the immediate and indirect children of tag, through a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy. Note: does not work on JavaScript type inheritance\nrelationships."},
                         "special/new" {:full-name "special/new",
                                        :ns "special",
                                        :name "new",
                                        :type "special form",
                                        :source {:code "(defmethod parse 'new\n  [_ env [_ ctor & args :as form] _]\n  (assert (symbol? ctor) \"First arg to new must be a symbol\")\n  (disallowing-recur\n   (let [enve (assoc env :context :expr)\n         ctorexpr (analyze enve ctor)\n         argexprs (vec (map #(analyze enve %) args))\n         known-num-fields (:num-fields (resolve-existing-var env ctor))\n         argc (count args)]\n     (when (and known-num-fields (not= known-num-fields argc))\n       (warning env\n         (str \"WARNING: Wrong number of args (\" argc \") passed to \" ctor)))\n\n     {:env env :op :new :form form :ctor ctorexpr :args argexprs\n      :children (into [ctorexpr] argexprs)})))",
                                                 :filename "clojurescript/src/clj/cljs/analyzer.clj",
                                                 :lines [551 565],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/analyzer.clj#L551-L565"},
                                        :full-name-encode "special_new",
                                        :clj-symbol "clojure.core/new",
                                        :history [["+" "0.0-927"]]},
                         "cljs.core/take-nth" {:ns "cljs.core",
                                               :name "take-nth",
                                               :signature ["[n coll]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_take-nth",
                                               :source {:code "(defn take-nth\n  [n coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (cons (first s) (take-nth n (drop n s))))))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [6052
                                                                6057],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6052-L6057"},
                                               :full-name "cljs.core/take-nth",
                                               :clj-symbol "clojure.core/take-nth",
                                               :docstring "Returns a lazy seq of every nth item in coll."},
                         "cljs.reader/throwing-reader" {:full-name "cljs.reader/throwing-reader",
                                                        :ns "cljs.reader",
                                                        :name "throwing-reader",
                                                        :type "function",
                                                        :signature ["[msg]"],
                                                        :source {:code "(defn throwing-reader\n  [msg]\n  (fn [rdr _]\n    (reader-error rdr msg)))",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [356
                                                                         359],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L356-L359"},
                                                        :full-name-encode "cljs.reader_throwing-reader",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/double" {:ns "cljs.core",
                                             :name "double",
                                             :signature ["[x]"],
                                             :shadowed-sources ({:code "(defmacro double [x] x)",
                                                                 :filename "clojurescript/src/clj/cljs/core.clj",
                                                                 :lines [273
                                                                         273],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L273-L273"}),
                                             :history [["+"
                                                        "0.0-1798"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_double",
                                             :source {:code "(defn double [x] x)",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1421
                                                              1421],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1421-L1421"},
                                             :full-name "cljs.core/double",
                                             :clj-symbol "clojure.core/double"},
                         "cljs.core/even?" {:return-type boolean,
                                            :ns "cljs.core",
                                            :name "even?",
                                            :signature ["[n]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_even_QMARK_",
                                            :source {:code "(defn ^boolean even?\n   [n] (if (integer? n)\n        (zero? (bit-and n 1))\n        (throw (js/Error. (str \"Argument must be an integer: \" n)))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2416
                                                             2420],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2416-L2420"},
                                            :full-name "cljs.core/even?",
                                            :clj-symbol "clojure.core/even?",
                                            :docstring "Returns true if n is even, throws an exception if n is not an integer"},
                         "cljs.core/simple-benchmark" {:full-name "cljs.core/simple-benchmark",
                                                       :ns "cljs.core",
                                                       :name "simple-benchmark",
                                                       :docstring "Runs expr iterations times in the context of a let expression with\nthe given bindings, then prints out the bindings and the expr\nfollowed by number of iterations and total time. The optional\nargument print-fn, defaulting to println, sets function used to\nprint the result. expr's string representation will be produced\nusing pr-str in any case.",
                                                       :type "macro",
                                                       :signature ["[bindings expr iterations & {:keys [print-fn], :or {print-fn (quote println)}}]"],
                                                       :source {:code "(defmacro simple-benchmark\n  [bindings expr iterations & {:keys [print-fn] :or {print-fn 'println}}]\n  (let [bs-str   (pr-str bindings)\n        expr-str (pr-str expr)]\n    `(let ~bindings\n       (let [start#   (.getTime (js/Date.))\n             ret#     (dotimes [_# ~iterations] ~expr)\n             end#     (.getTime (js/Date.))\n             elapsed# (- end# start#)]\n         (~print-fn (str ~bs-str \", \" ~expr-str \", \"\n                         ~iterations \" runs, \" elapsed# \" msecs\"))))))",
                                                                :filename "clojurescript/src/clj/cljs/core.clj",
                                                                :lines [1284
                                                                        1300],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L1284-L1300"},
                                                       :full-name-encode "cljs.core_simple-benchmark",
                                                       :history [["+"
                                                                  "0.0-1236"]]},
                         "special/fn*" {:full-name "special/fn*",
                                        :ns "special",
                                        :name "fn*",
                                        :type "special form",
                                        :source {:code "(defmethod parse 'fn*\n  [op env [_ & args :as form] name]\n  (let [[name meths] (if (symbol? (first args))\n                       [(first args) (next args)]\n                       [name (seq args)])\n        ;;turn (fn [] ...) into (fn ([]...))\n        meths (if (vector? (first meths)) (list meths) meths)\n        locals (:locals env)\n        locals (if (and locals name) (assoc locals name {:name name :shadow (locals name)}) locals)\n        type (-> form meta ::type)\n        fields (-> form meta ::fields)\n        protocol-impl (-> form meta :protocol-impl)\n        protocol-inline (-> form meta :protocol-inline)\n        locals (reduce (fn [m fld]\n                         (assoc m fld\n                                {:name fld\n                                 :line (get-line fld env)\n                                 :column (get-col fld env)\n                                 :field true\n                                 :mutable (-> fld meta :mutable)\n                                 :unsynchronized-mutable (-> fld meta :unsynchronized-mutable)\n                                 :volatile-mutable (-> fld meta :volatile-mutable)\n                                 :tag (-> fld meta :tag)\n                                 :shadow (m fld)}))\n                       locals fields)\n\n        menv (if (> (count meths) 1) (assoc env :context :expr) env)\n        menv (merge menv\n               {:protocol-impl protocol-impl\n                :protocol-inline protocol-inline})\n        methods (map #(analyze-fn-method menv locals % type) meths)\n        max-fixed-arity (apply max (map :max-fixed-arity methods))\n        variadic (boolean (some :variadic methods))\n        locals (if name\n                 (update-in locals [name] assoc\n                            :fn-var true\n                            :variadic variadic\n                            :max-fixed-arity max-fixed-arity\n                            :method-params (map :params methods))\n                 locals)\n        methods (if name\n                  ;; a second pass with knowledge of our function-ness/arity\n                  ;; lets us optimize self calls\n                  (no-warn (doall (map #(analyze-fn-method menv locals % type) meths)))\n                  methods)]\n    ;;todo - validate unique arities, at most one variadic, variadic takes max required args\n    {:env env :op :fn :form form :name name :methods methods :variadic variadic\n     :recur-frames *recur-frames* :loop-lets *loop-lets*\n     :jsdoc [(when variadic \"@param {...*} var_args\")]\n     :max-fixed-arity max-fixed-arity\n     :protocol-impl protocol-impl\n     :protocol-inline protocol-inline\n     :children (mapv :expr methods)}))",
                                                 :filename "clojurescript/src/clj/cljs/analyzer.clj",
                                                 :lines [390 442],
                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/analyzer.clj#L390-L442"},
                                        :full-name-encode "special_fn_STAR_",
                                        :history [["+" "0.0-927"]]},
                         "clojure.set/subset?" {:ns "clojure.set",
                                                :name "subset?",
                                                :signature ["[set1 set2]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.set_subset_QMARK_",
                                                :source {:code "(defn subset? \n  [set1 set2]\n  (and (<= (count set1) (count set2))\n       (every? #(contains? set2 %) set1)))",
                                                         :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                         :lines [132
                                                                 136],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/set.cljs#L132-L136"},
                                                :full-name "clojure.set/subset?",
                                                :clj-symbol "clojure.set/subset?",
                                                :docstring "Is set1 a subset of set2?"},
                         "cljs.core/flush" {:full-name "cljs.core/flush",
                                            :ns "cljs.core",
                                            :name "flush",
                                            :type "function",
                                            :signature ["[]"],
                                            :source {:code "(defn flush [] ;stub\n  nil)",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [6221
                                                             6222],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6221-L6222"},
                                            :full-name-encode "cljs.core_flush",
                                            :clj-symbol "clojure.core/flush",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/long-array" {:full-name "cljs.core/long-array",
                                                 :ns "cljs.core",
                                                 :name "long-array",
                                                 :type "function",
                                                 :signature ["[size-or-seq]"
                                                             "[size init-val-or-seq]"],
                                                 :source {:code "(defn long-array\n  ([size-or-seq]\n     (cond\n      (number? size-or-seq) (long-array size-or-seq nil)\n      (seq? size-or-seq) (into-array size-or-seq)\n      :else (throw (js/Error. \"long-array called with something other than size or ISeq\"))))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2177
                                                                  2196],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2177-L2196"},
                                                 :full-name-encode "cljs.core_long-array",
                                                 :clj-symbol "clojure.core/long-array",
                                                 :history [["+"
                                                            "0.0-1211"]]},
                         "cljs.reader/reader-error" {:full-name "cljs.reader/reader-error",
                                                     :ns "cljs.reader",
                                                     :name "reader-error",
                                                     :type "function",
                                                     :signature ["[rdr & msg]"],
                                                     :source {:code "(defn reader-error\n  [rdr & msg]\n  (throw (js/Error. (apply str msg))))",
                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                              :lines [70
                                                                      72],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L70-L72"},
                                                     :full-name-encode "cljs.reader_reader-error",
                                                     :history [["+"
                                                                "0.0-927"]]},
                         "clojure.walk/prewalk-replace" {:ns "clojure.walk",
                                                         :name "prewalk-replace",
                                                         :signature ["[smap form]"],
                                                         :history [["+"
                                                                    "0.0-927"]],
                                                         :type "function",
                                                         :full-name-encode "clojure.walk_prewalk-replace",
                                                         :source {:code "(defn prewalk-replace\n  [smap form]\n  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                                  :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                                  :lines [80
                                                                          86],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/walk.cljs#L80-L86"},
                                                         :full-name "clojure.walk/prewalk-replace",
                                                         :clj-symbol "clojure.walk/prewalk-replace",
                                                         :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the root of the tree first."},
                         "cljs.core/*1" {:full-name "cljs.core/*1",
                                         :ns "cljs.core",
                                         :name "*1",
                                         :docstring "bound in a repl thread to the most recent value printed",
                                         :type "var",
                                         :source {:code "(def\n  ^{:doc \"bound in a repl thread to the most recent value printed\"}\n  *1)",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [30 32],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L30-L32"},
                                         :full-name-encode "cljs.core__STAR_1",
                                         :clj-symbol "clojure.core/*1",
                                         :history [["+" "0.0-927"]]},
                         "cljs.core/subseq" {:ns "cljs.core",
                                             :name "subseq",
                                             :signature ["[sc test key]"
                                                         "[sc start-test start-key end-test end-key]"],
                                             :history [["+"
                                                        "0.0-1211"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_subseq",
                                             :source {:code "(defn subseq\n  ([sc test key]\n     (let [include (mk-bound-fn sc test key)]\n       (if (#{> >=} test)\n         (when-let [[e :as s] (-sorted-seq-from sc key true)]\n           (if (include e) s (next s)))\n         (take-while include (-sorted-seq sc true)))))\n  ([sc start-test start-key end-test end-key]\n     (when-let [[e :as s] (-sorted-seq-from sc start-key true)]\n       (take-while (mk-bound-fn sc end-test end-key)\n                   (if ((mk-bound-fn sc start-test start-key) e) s (next s))))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [5946
                                                              5959],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5946-L5959"},
                                             :full-name "cljs.core/subseq",
                                             :clj-symbol "clojure.core/subseq",
                                             :docstring "sc must be a sorted collection, test(s) one of <, <=, > or\n>=. Returns a seq of those entries with keys ek for\nwhich (test (.. sc comparator (compare ek key)) 0) is true"},
                         "cljs.reader/read-unicode-char" {:full-name "cljs.reader/read-unicode-char",
                                                          :ns "cljs.reader",
                                                          :name "read-unicode-char",
                                                          :type "function",
                                                          :signature ["[reader initch]"],
                                                          :source {:code "(defn read-unicode-char\n  [reader initch]\n  (reader-error reader \"Unicode characters not supported by reader (yet)\"))",
                                                                   :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                   :lines [171
                                                                           173],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1236/src/cljs/cljs/reader.cljs#L171-L173"},
                                                          :full-name-encode "cljs.reader_read-unicode-char",
                                                          :history [["+"
                                                                     "0.0-927"]
                                                                    ["-"
                                                                     "0.0-1424"]],
                                                          :removed {:in "0.0-1424",
                                                                    :last-seen "0.0-1236"}},
                         "cljs.core/dissoc" {:ns "cljs.core",
                                             :name "dissoc",
                                             :signature ["[coll]"
                                                         "[coll k]"
                                                         "[coll k & ks]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_dissoc",
                                             :source {:code "(defn dissoc\n  ([coll] coll)\n  ([coll k]\n     (-dissoc coll k))\n  ([coll k & ks]\n     (let [ret (dissoc coll k)]\n       (if ks\n         (recur ret (first ks) (next ks))\n         ret))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [905 915],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L905-L915"},
                                             :full-name "cljs.core/dissoc",
                                             :clj-symbol "clojure.core/dissoc",
                                             :docstring "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\nthat does not contain a mapping for key(s)."},
                         "cljs.core/exists?" {:full-name "cljs.core/exists?",
                                              :ns "cljs.core",
                                              :name "exists?",
                                              :type "macro",
                                              :signature ["[x]"],
                                              :source {:code "(defmacro exists? [x]\n  (bool-expr (list 'js* \"typeof ~{} !== 'undefined'\" x)))",
                                                       :filename "clojurescript/src/clj/cljs/core.clj",
                                                       :lines [236
                                                               237],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L236-L237"},
                                              :full-name-encode "cljs.core_exists_QMARK_",
                                              :history [["+"
                                                         "0.0-1798"]]},
                         "cljs.core/ffirst" {:ns "cljs.core",
                                             :name "ffirst",
                                             :signature ["[coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_ffirst",
                                             :source {:code "(defn ffirst\n  [coll]\n  (first (first coll)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [729 732],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L729-L732"},
                                             :full-name "cljs.core/ffirst",
                                             :clj-symbol "clojure.core/ffirst",
                                             :docstring "Same as (first (first x))"},
                         "clojure.zip/replace" {:ns "clojure.zip",
                                                :name "replace",
                                                :signature ["[loc node]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.zip_replace",
                                                :source {:code "(defn replace\n  [loc node]\n    (let [[_ path] loc]\n      (with-meta [node (assoc path :changed? true)] (meta loc))))",
                                                         :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                         :lines [183
                                                                 187],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L183-L187"},
                                                :full-name "clojure.zip/replace",
                                                :clj-symbol "clojure.zip/replace",
                                                :docstring "Replaces the node at this loc, without moving"},
                         "cljs.core/vec" {:full-name "cljs.core/vec",
                                          :ns "cljs.core",
                                          :name "vec",
                                          :type "function",
                                          :signature ["[coll]"],
                                          :source {:code "(defn vec [coll]\n  (-persistent!\n   (reduce -conj!\n           (-as-transient cljs.core.PersistentVector/EMPTY)\n           coll)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [3205 3209],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L3205-L3209"},
                                          :full-name-encode "cljs.core_vec",
                                          :clj-symbol "clojure.core/vec",
                                          :history [["+" "0.0-927"]]},
                         "cljs.core/or" {:ns "cljs.core",
                                         :name "or",
                                         :signature ["[]"
                                                     "[x]"
                                                     "[x & next]"],
                                         :history [["+" "0.0-927"]],
                                         :type "macro",
                                         :full-name-encode "cljs.core_or",
                                         :source {:code "(defmacro or\n  ([] nil)\n  ([x] x)\n  ([x & next]\n      `(let [or# ~x]\n         (if or# or# (or ~@next)))))",
                                                  :filename "clojure/src/clj/clojure/core.clj",
                                                  :lines [806 816],
                                                  :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L806-L816"},
                                         :full-name "cljs.core/or",
                                         :clj-symbol "clojure.core/or",
                                         :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns a logical true value, or returns that value and doesn't\nevaluate any of the other expressions, otherwise it returns the\nvalue of the last expression. (or) returns nil."},
                         "cljs.core/doubles" {:full-name "cljs.core/doubles",
                                              :ns "cljs.core",
                                              :name "doubles",
                                              :type "function",
                                              :signature ["[x]"],
                                              :source {:code "(defn doubles [x] x)",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1532
                                                               1532],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1532-L1532"},
                                              :full-name-encode "cljs.core_doubles",
                                              :clj-symbol "clojure.core/doubles",
                                              :history [["+"
                                                         "0.0-1798"]]},
                         "cljs.core/mod" {:ns "cljs.core",
                                          :name "mod",
                                          :signature ["[n d]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_mod",
                                          :source {:code "(defn mod\n  [n d]\n  (js-mod (+ (js-mod n d) d) d))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [1540 1543],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1540-L1543"},
                                          :full-name "cljs.core/mod",
                                          :clj-symbol "clojure.core/mod",
                                          :docstring "Modulus of num and div. Truncates toward negative infinity."},
                         "cljs.core/aset" {:ns "cljs.core",
                                           :name "aset",
                                           :signature ["[array i val]"],
                                           :shadowed-sources ({:code "(defmacro aset [a i v]\n  (list 'js* \"(~{}[~{}] = ~{})\" a i v))",
                                                               :filename "clojurescript/src/clj/cljs/core.clj",
                                                               :lines [261
                                                                       262],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L261-L262"}),
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_aset",
                                           :source {:code "(defn aset\n  [array i val]\n  (cljs.core/aset array i val))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [130 133],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L130-L133"},
                                           :full-name "cljs.core/aset",
                                           :clj-symbol "clojure.core/aset",
                                           :docstring "Sets the value at the index."},
                         "cljs.core/second" {:ns "cljs.core",
                                             :name "second",
                                             :signature ["[coll]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_second",
                                             :source {:code "(defn second\n  [coll]\n  (first (next coll)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [724 727],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L724-L727"},
                                             :full-name "cljs.core/second",
                                             :clj-symbol "clojure.core/second",
                                             :docstring "Same as (first (next x))"},
                         "cljs.core/IChunkedNext" {:ns "cljs.core",
                                                   :name "IChunkedNext",
                                                   :type "protocol",
                                                   :full-name-encode "cljs.core_IChunkedNext",
                                                   :source {:code "(defprotocol IChunkedNext\n  (-chunked-next [coll]))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [322
                                                                    323],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L322-L323"},
                                                   :methods [{:name "-chunked-next",
                                                              :signature ["[coll]"],
                                                              :docstring nil}],
                                                   :full-name "cljs.core/IChunkedNext",
                                                   :history [["+"
                                                              "0.0-1424"]]},
                         "cljs.core/bit-count" {:full-name "cljs.core/bit-count",
                                                :ns "cljs.core",
                                                :name "bit-count",
                                                :docstring "Counts the number of bits set in n",
                                                :type "function",
                                                :signature ["[v]"],
                                                :source {:code "(defn bit-count\n  [v]\n  (let [v (- v (bit-and (bit-shift-right v 1) 0x55555555))\n        v (+ (bit-and v 0x33333333) (bit-and (bit-shift-right v 2) 0x33333333))]\n    (bit-shift-right (* (bit-and (+ v (bit-shift-right v 4)) 0xF0F0F0F) 0x1010101) 24)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1618
                                                                 1623],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1618-L1623"},
                                                :full-name-encode "cljs.core_bit-count",
                                                :history [["+"
                                                           "0.0-1211"]]},
                         "clojure.set/rename" {:ns "clojure.set",
                                               :name "rename",
                                               :signature ["[xrel kmap]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.set_rename",
                                               :source {:code "(defn rename\n  [xrel kmap]\n    (set (map #(rename-keys % kmap) xrel)))",
                                                        :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                        :lines [83 86],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/set.cljs#L83-L86"},
                                               :full-name "clojure.set/rename",
                                               :clj-symbol "clojure.set/rename",
                                               :docstring "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap"},
                         "cljs.core/assoc!" {:full-name "cljs.core/assoc!",
                                             :ns "cljs.core",
                                             :name "assoc!",
                                             :type "function",
                                             :signature ["[tcoll key val]"],
                                             :source {:code "(defn assoc! [tcoll key val]\n  (-assoc! tcoll key val))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2303
                                                              2304],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2303-L2304"},
                                             :full-name-encode "cljs.core_assoc_BANG_",
                                             :clj-symbol "clojure.core/assoc!",
                                             :history [["+"
                                                        "0.0-1211"]]},
                         "cljs.core/delay?" {:return-type boolean,
                                             :ns "cljs.core",
                                             :name "delay?",
                                             :signature ["[x]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_delay_QMARK_",
                                             :source {:code "(defn ^boolean delay?\n  [x] (instance? cljs.core.Delay x))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [6693
                                                              6695],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6693-L6695"},
                                             :full-name "cljs.core/delay?",
                                             :clj-symbol "clojure.core/delay?",
                                             :docstring "returns true if x is a Delay created with delay"},
                         "clojure.zip/left" {:ns "clojure.zip",
                                             :name "left",
                                             :signature ["[loc]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "clojure.zip_left",
                                             :source {:code "(defn left\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (when (and path (seq l))\n        (with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))] (meta loc)))))",
                                                      :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                      :lines [150 155],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L150-L155"},
                                             :full-name "clojure.zip/left",
                                             :clj-symbol "clojure.zip/left",
                                             :docstring "Returns the loc of the left sibling of the node at this loc, or nil"},
                         "cljs.reader/not-implemented" {:full-name "cljs.reader/not-implemented",
                                                        :ns "cljs.reader",
                                                        :name "not-implemented",
                                                        :type "function",
                                                        :signature ["[rdr ch]"],
                                                        :source {:code "(defn not-implemented\n  [rdr ch]\n  (reader-error rdr \"Reader for \" ch \" not implemented yet\"))",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [252
                                                                         254],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L252-L254"},
                                                        :full-name-encode "cljs.reader_not-implemented",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/IAssociative" {:ns "cljs.core",
                                                   :name "IAssociative",
                                                   :type "protocol",
                                                   :full-name-encode "cljs.core_IAssociative",
                                                   :source {:code "(defprotocol IAssociative\n  (-contains-key? [coll k])\n  #_(-entry-at [coll k])\n  (-assoc [coll k v]))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [204
                                                                    207],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L204-L207"},
                                                   :methods [{:name "-contains-key?",
                                                              :signature ["[coll k]"],
                                                              :docstring nil}
                                                             {:name "-assoc",
                                                              :signature ["[coll k v]"],
                                                              :docstring nil}],
                                                   :full-name "cljs.core/IAssociative",
                                                   :history [["+"
                                                              "0.0-927"]]},
                         "cljs.core/group-by" {:ns "cljs.core",
                                               :name "group-by",
                                               :signature ["[f coll]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_group-by",
                                               :source {:code "(defn group-by\n  [f coll]\n  (reduce\n   (fn [ret x]\n     (let [k (f x)]\n       (assoc ret k (conj (get ret k []) x))))\n   {} coll))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [6826
                                                                6835],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6826-L6835"},
                                               :full-name "cljs.core/group-by",
                                               :clj-symbol "clojure.core/group-by",
                                               :docstring "Returns a map of the elements of coll keyed by the result of\nf on each element. The value at each key will be a vector of the\ncorresponding elements, in the order they appeared in coll."},
                         "cljs.reader/*default-data-reader-fn*" {:full-name "cljs.reader/*default-data-reader-fn*",
                                                                 :ns "cljs.reader",
                                                                 :name "*default-data-reader-fn*",
                                                                 :type "var",
                                                                 :source {:code "(def *default-data-reader-fn*\n  (atom nil))",
                                                                          :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                          :lines [530
                                                                                  531],
                                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L530-L531"},
                                                                 :full-name-encode "cljs.reader__STAR_default-data-reader-fn_STAR_",
                                                                 :history [["+"
                                                                            "0.0-1576"]]},
                         "cljs.core/sorted-map-by" {:ns "cljs.core",
                                                    :name "sorted-map-by",
                                                    :signature ["[comparator & keyvals]"],
                                                    :history [["+"
                                                               "0.0-1211"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_sorted-map-by",
                                                    :source {:code "(defn sorted-map-by\n  ([comparator & keyvals]\n     (loop [in (seq keyvals)\n            out (cljs.core.PersistentTreeMap. (fn->comparator comparator) nil 0 nil 0)]\n       (if in\n         (recur (nnext in) (assoc out (first in) (second in)))\n         out))))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [5552
                                                                     5560],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5552-L5560"},
                                                    :full-name "cljs.core/sorted-map-by",
                                                    :clj-symbol "clojure.core/sorted-map-by",
                                                    :docstring "keyval => key val\nReturns a new sorted map with supplied mappings, using the supplied comparator."},
                         "cljs.core/symbol" {:full-name "cljs.core/symbol",
                                             :ns "cljs.core",
                                             :name "symbol",
                                             :type "function",
                                             :signature ["[name]"
                                                         "[ns name]"],
                                             :source {:code "(defn symbol\n  ([name]\n     (if (symbol? name)\n       name\n       (symbol nil name)))\n  ([ns name]\n     (let [sym-str (if-not (nil? ns)\n                     (str ns \"/\" name)\n                     name)]\n       (Symbol. ns name sym-str -1 nil))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [363 372],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L363-L372"},
                                             :full-name-encode "cljs.core_symbol",
                                             :clj-symbol "clojure.core/symbol",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/Delay" {:full-name "cljs.core/Delay",
                                            :ns "cljs.core",
                                            :name "Delay",
                                            :type "type",
                                            :signature ["[state f]"],
                                            :source {:code "(deftype Delay [state f]\n  IDeref\n  (-deref [_]\n    (:value (swap! state (fn [{:keys [done] :as curr-state}]\n                           (if done\n                             curr-state,\n                             {:done true :value (f)})))))\n\n  IPending\n  (-realized? [d]\n    (:done @state)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [6681
                                                             6691],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6681-L6691"},
                                            :full-name-encode "cljs.core_Delay",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/methods" {:ns "cljs.core",
                                              :name "methods",
                                              :signature ["[multifn]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_methods",
                                              :source {:code "(defn methods\n  [multifn] (-methods multifn))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [7096
                                                               7098],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L7096-L7098"},
                                              :full-name "cljs.core/methods",
                                              :clj-symbol "clojure.core/methods",
                                              :docstring "Given a multimethod, returns a map of dispatch values -> dispatch fns"},
                         "cljs.core/vector" {:full-name "cljs.core/vector",
                                             :ns "cljs.core",
                                             :name "vector",
                                             :type "function",
                                             :signature ["[& args]"],
                                             :source {:code "(defn vector [& args] (vec args))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [3211
                                                              3211],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L3211-L3211"},
                                             :full-name-encode "cljs.core_vector",
                                             :clj-symbol "clojure.core/vector",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/rand-int" {:ns "cljs.core",
                                               :name "rand-int",
                                               :signature ["[n]"],
                                               :shadowed-sources ({:code "(defn rand-int\n  [n] (fix (rand n)))",
                                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                   :lines [1562
                                                                           1564],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1562-L1564"}),
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_rand-int",
                                               :source {:code "(defn rand-int\n  [n] (Math/floor (* (Math/random) n)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [6815
                                                                6817],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6815-L6817"},
                                               :full-name "cljs.core/rand-int",
                                               :clj-symbol "clojure.core/rand-int",
                                               :docstring "Returns a random integer between 0 (inclusive) and n (exclusive)."},
                         "cljs.core/unchecked-float" {:ns "cljs.core",
                                                      :name "unchecked-float",
                                                      :signature ["[x]"],
                                                      :shadowed-sources ({:code "(defmacro unchecked-float [x] x)",
                                                                          :filename "clojurescript/src/clj/cljs/core.clj",
                                                                          :lines [278
                                                                                  278],
                                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L278-L278"}),
                                                      :history [["+"
                                                                 "0.0-1798"]],
                                                      :type "function",
                                                      :full-name-encode "cljs.core_unchecked-float",
                                                      :source {:code "(defn unchecked-float [x] x)",
                                                               :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                               :lines [1426
                                                                       1426],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1426-L1426"},
                                                      :full-name "cljs.core/unchecked-float",
                                                      :clj-symbol "clojure.core/unchecked-float"},
                         "clojure.core.reducers/append!" {:ns "clojure.core.reducers",
                                                          :name "append!",
                                                          :signature ["[acc x]"],
                                                          :history [["+"
                                                                     "0.0-1236"]],
                                                          :type "function",
                                                          :full-name-encode "clojure.core.reducers_append_BANG_",
                                                          :source {:code "(defn append!\n  [acc x]\n  (doto acc (.add x)))",
                                                                   :filename "clojurescript/src/cljs/clojure/core/reducers.cljs",
                                                                   :lines [225
                                                                           228],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/core/reducers.cljs#L225-L228"},
                                                          :full-name "clojure.core.reducers/append!",
                                                          :clj-symbol "clojure.core.reducers/append!",
                                                          :docstring ".adds x to acc and returns acc"},
                         "cljs.core/NodeSeq" {:full-name "cljs.core/NodeSeq",
                                              :ns "cljs.core",
                                              :name "NodeSeq",
                                              :type "type",
                                              :signature ["[meta nodes i s __hash]"],
                                              :source {:code "(deftype NodeSeq [meta nodes i s ^:mutable __hash]\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll meta] (NodeSeq. meta nodes i s __hash))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  ISeq\n  (-first [coll]\n    (if (nil? s)\n      [(aget nodes i) (aget nodes (inc i))]\n      (first s)))\n\n  (-rest [coll]\n    (if (nil? s)\n      (create-inode-seq nodes (+ i 2) nil)\n      (create-inode-seq nodes i (next s))))\n\n  ISeqable\n  (-seq [this] this)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [4574
                                                               4612],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L4574-L4612"},
                                              :full-name-encode "cljs.core_NodeSeq",
                                              :history [["+"
                                                         "0.0-1211"]]},
                         "cljs.core/letfn" {:ns "cljs.core",
                                            :name "letfn",
                                            :signature ["[fnspecs & body]"],
                                            :history [["+" "0.0-927"]],
                                            :type "macro",
                                            :full-name-encode "cljs.core_letfn",
                                            :source {:code "(defmacro letfn \n  [fnspecs & body] \n  `(letfn* ~(vec (interleave (map first fnspecs) \n                             (map #(cons `fn %) fnspecs)))\n           ~@body))",
                                                     :filename "clojure/src/clj/clojure/core.clj",
                                                     :lines [5922
                                                             5933],
                                                     :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L5922-L5933"},
                                            :full-name "cljs.core/letfn",
                                            :clj-symbol "clojure.core/letfn",
                                            :docstring "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\nTakes a vector of function specs and a body, and generates a set of\nbindings of functions to their names. All of the names are available\nin all of the definitions of the functions, as well as the body."},
                         "cljs.reader/read-discard" {:full-name "cljs.reader/read-discard",
                                                     :ns "cljs.reader",
                                                     :name "read-discard",
                                                     :type "function",
                                                     :signature ["[rdr _]"],
                                                     :source {:code "(defn read-discard\n  [rdr _]\n  (read rdr true nil true)\n  rdr)",
                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                              :lines [379
                                                                      382],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L379-L382"},
                                                     :full-name-encode "cljs.reader_read-discard",
                                                     :history [["+"
                                                                "0.0-927"]]},
                         "cljs.core/gen-apply-to" {:full-name "cljs.core/gen-apply-to",
                                                   :ns "cljs.core",
                                                   :name "gen-apply-to",
                                                   :type "macro",
                                                   :signature ["[]"],
                                                   :source {:code "(defmacro gen-apply-to []\n  `(do\n     (set! ~'*unchecked-if* true)\n     (defn ~'apply-to [~'f ~'argc ~'args]\n       (let [~'args (seq ~'args)]\n         (if (zero? ~'argc)\n           (~'f)\n           ~(gen-apply-to-helper))))\n     (set! ~'*unchecked-if* false)))",
                                                            :filename "clojurescript/src/clj/cljs/core.clj",
                                                            :lines [1319
                                                                    1327],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L1319-L1327"},
                                                   :full-name-encode "cljs.core_gen-apply-to",
                                                   :history [["+"
                                                              "0.0-1211"]]},
                         "cljs.core/inc" {:ns "cljs.core",
                                          :name "inc",
                                          :signature ["[x]"],
                                          :shadowed-sources ({:code "(defmacro inc [x]\n  `(+ ~x 1))",
                                                              :filename "clojurescript/src/clj/cljs/core.clj",
                                                              :lines [372
                                                                      373],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L372-L373"}),
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_inc",
                                          :source {:code "(defn inc\n  [x] (cljs.core/+ x 1))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [520 522],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L520-L522"},
                                          :full-name "cljs.core/inc",
                                          :clj-symbol "clojure.core/inc",
                                          :docstring "Returns a number one greater than num."},
                         "cljs.core/name" {:ns "cljs.core",
                                           :name "name",
                                           :signature ["[x]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_name",
                                           :source {:code "(defn name\n  [x]\n  (if (satisfies? INamed x false)\n    (-name ^not-native x)\n    (cond\n      (string? x) x\n      (keyword? x)\n      (let [i (.lastIndexOf x \"/\" (- (alength x) 2))]\n        (if (< i 0)\n          (subs x 2)\n          (subs x (inc i))))\n      :else (throw (js/Error. (str \"Doesn't support name: \" x))))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [5870 5882],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5870-L5882"},
                                           :full-name "cljs.core/name",
                                           :clj-symbol "clojure.core/name",
                                           :docstring "Returns the name String of a string, symbol or keyword."},
                         "cljs.core/cycle" {:ns "cljs.core",
                                            :name "cycle",
                                            :signature ["[coll]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_cycle",
                                            :source {:code "(defn cycle\n  [coll] (lazy-seq\n          (when-let [s (seq coll)]\n            (concat s (cycle s)))))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2729
                                                             2733],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2729-L2733"},
                                            :full-name "cljs.core/cycle",
                                            :clj-symbol "clojure.core/cycle",
                                            :docstring "Returns a lazy (infinite!) sequence of repetitions of the items in coll."},
                         "cljs.core/rsubseq" {:ns "cljs.core",
                                              :name "rsubseq",
                                              :signature ["[sc test key]"
                                                          "[sc start-test start-key end-test end-key]"],
                                              :history [["+"
                                                         "0.0-1211"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_rsubseq",
                                              :source {:code "(defn rsubseq\n  ([sc test key]\n     (let [include (mk-bound-fn sc test key)]\n       (if (#{< <=} test)\n         (when-let [[e :as s] (-sorted-seq-from sc key false)]\n           (if (include e) s (next s)))\n         (take-while include (-sorted-seq sc false)))))\n  ([sc start-test start-key end-test end-key]\n     (when-let [[e :as s] (-sorted-seq-from sc end-key false)]\n       (take-while (mk-bound-fn sc start-test start-key)\n                   (if ((mk-bound-fn sc end-test end-key) e) s (next s))))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [5961
                                                               5974],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5961-L5974"},
                                              :full-name "cljs.core/rsubseq",
                                              :clj-symbol "clojure.core/rsubseq",
                                              :docstring "sc must be a sorted collection, test(s) one of <, <=, > or\n>=. Returns a reverse seq of those entries with keys ek for\nwhich (test (.. sc comparator (compare ek key)) 0) is true"},
                         "cljs.core/divide" {:full-name "cljs.core/divide",
                                             :ns "cljs.core",
                                             :name "divide",
                                             :type "macro",
                                             :signature ["[x]"
                                                         "[x y]"
                                                         "[x y & more]"],
                                             :source {:code "(defmacro divide\n  ([x] `(/ 1 ~x))\n  ([x y] (list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))",
                                                      :filename "clojurescript/src/clj/cljs/core.clj",
                                                      :lines [339 342],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L339-L342"},
                                             :full-name-encode "cljs.core_divide",
                                             :history [["+"
                                                        "0.0-1798"]]},
                         "cljs.core/map" {:ns "cljs.core",
                                          :name "map",
                                          :signature ["[f coll]"
                                                      "[f c1 c2]"
                                                      "[f c1 c2 c3]"
                                                      "[f c1 c2 c3 & colls]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_map",
                                          :source {:code "(defn map\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (chunk-append b (f (-nth c i))))\n          (chunk-cons (chunk b) (map f (chunk-rest s))))\n        (cons (f (first s)) (map f (rest s)))))))\n  ([f c1 c2]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2)]\n      (when (and s1 s2)\n        (cons (f (first s1) (first s2))\n              (map f (rest s1) (rest s2)))))))\n  ([f c1 c2 c3]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n      (when (and  s1 s2 s3)\n        (cons (f (first s1) (first s2) (first s3))\n              (map f (rest s1) (rest s2) (rest s3)))))))\n  ([f c1 c2 c3 & colls]\n   (let [step (fn step [cs]\n                 (lazy-seq\n                  (let [ss (map seq cs)]\n                    (when (every? identity ss)\n                      (cons (map first ss) (step (map rest ss)))))))]\n     (map #(apply f %) (step (conj colls c3 c2 c1))))))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [2648 2683],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2648-L2683"},
                                          :full-name "cljs.core/map",
                                          :clj-symbol "clojure.core/map",
                                          :docstring "Returns a lazy sequence consisting of the result of applying f to the\nset of first items of each coll, followed by applying f to the set\nof second items in each coll, until any one of the colls is\nexhausted.  Any remaining items in other colls are ignored. Function\nf should accept number-of-colls arguments."},
                         "cljs.core/ChunkBuffer" {:full-name "cljs.core/ChunkBuffer",
                                                  :ns "cljs.core",
                                                  :name "ChunkBuffer",
                                                  :type "type",
                                                  :signature ["[buf end]"],
                                                  :source {:code "(deftype ChunkBuffer [^:mutable buf ^:mutable end]\n  Object\n  (add [_ o]\n    (aset buf end o)\n    (set! end (inc end)))\n\n  (chunk [_ o]\n    (let [ret (ArrayChunk. buf 0 end)]\n      (set! buf nil)\n      ret))\n\n  ICounted\n  (-count [_] end))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [2014
                                                                   2026],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2014-L2026"},
                                                  :full-name-encode "cljs.core_ChunkBuffer",
                                                  :history [["+"
                                                             "0.0-1424"]]},
                         "cljs.core/amap" {:ns "cljs.core",
                                           :name "amap",
                                           :signature ["[a idx ret expr]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_amap",
                                           :source {:code "(defmacro amap\n  [a idx ret expr]\n  `(let [a# ~a\n         ~ret (aclone a#)]\n     (loop  [~idx 0]\n       (if (< ~idx  (alength a#))\n         (do\n           (aset ~ret ~idx ~expr)\n           (recur (inc ~idx)))\n         ~ret))))",
                                                    :filename "clojurescript/src/clj/cljs/core.clj",
                                                    :lines [1178 1191],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L1178-L1191"},
                                           :full-name "cljs.core/amap",
                                           :clj-symbol "clojure.core/amap",
                                           :docstring "Maps an expression across an array a, using an index named idx, and\nreturn value named ret, initialized to a clone of a, then setting\neach element of ret to the evaluation of expr, returning the new\narray ret."},
                         "clojure.zip/children" {:ns "clojure.zip",
                                                 :name "children",
                                                 :signature ["[loc]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.zip_children",
                                                 :source {:code "(defn children\n  [loc]\n    (if (branch? loc)\n      ((:zip/children (meta loc)) (node loc))\n      (throw \"called children on a leaf node\")))",
                                                          :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                          :lines [69
                                                                  74],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L69-L74"},
                                                 :full-name "clojure.zip/children",
                                                 :clj-symbol "clojure.zip/children",
                                                 :docstring "Returns a seq of the children of node at loc, which must be a branch"},
                         "special/set!" {:full-name "special/set!",
                                         :ns "special",
                                         :name "set!",
                                         :type "special form",
                                         :source {:code "(defmethod parse 'set!\n  [_ env [_ target val alt :as form] _]\n  (let [[target val] (if alt\n                       ;; (set! o -prop val)\n                       [`(. ~target ~val) alt]\n                       [target val])]\n    (disallowing-recur\n     (let [enve (assoc env :context :expr)\n           targetexpr (cond\n                       ;; TODO: proper resolve\n                       (= target '*unchecked-if*)\n                       (do\n                         (reset! *unchecked-if* val)\n                         ::set-unchecked-if)\n\n                       (symbol? target)\n                       (do\n                         (let [local (-> env :locals target)]\n                           (assert (or (nil? local)\n                                       (and (:field local)\n                                            (or (:mutable local)\n                                                (:unsynchronized-mutable local)\n                                                (:volatile-mutable local))))\n                                   \"Can't set! local var or non-mutable field\"))\n                         (analyze-symbol enve target))\n\n                       :else\n                       (when (seq? target)\n                         (let [targetexpr (analyze-seq enve target nil)]\n                           (when (:field targetexpr)\n                             targetexpr))))\n           valexpr (analyze enve val)]\n       (assert targetexpr \"set! target must be a field or a symbol naming a var\")\n       (cond\n        (= targetexpr ::set-unchecked-if) {:env env :op :no-op}\n        :else {:env env :op :set! :form form :target targetexpr :val valexpr\n               :children [targetexpr valexpr]})))))",
                                                  :filename "clojurescript/src/clj/cljs/analyzer.clj",
                                                  :lines [567 603],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/analyzer.clj#L567-L603"},
                                         :full-name-encode "special_set_BANG_",
                                         :clj-symbol "clojure.core/set!",
                                         :history [["+" "0.0-927"]]},
                         "cljs.core/when-not" {:ns "cljs.core",
                                               :name "when-not",
                                               :signature ["[test & body]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "macro",
                                               :full-name-encode "cljs.core_when-not",
                                               :source {:code "(defmacro when-not\n  [test & body]\n    (list 'if test nil (cons 'do body)))",
                                                        :filename "clojure/src/clj/clojure/core.clj",
                                                        :lines [477
                                                                481],
                                                        :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L477-L481"},
                                               :full-name "cljs.core/when-not",
                                               :clj-symbol "clojure.core/when-not",
                                               :docstring "Evaluates test. If logical false, evaluates body in an implicit do."},
                         "clojure.set/index" {:ns "clojure.set",
                                              :name "index",
                                              :signature ["[xrel ks]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.set_index",
                                              :source {:code "(defn index\n  [xrel ks]\n    (reduce\n     (fn [m x]\n       (let [ik (select-keys x ks)]\n         (assoc m ik (conj (get m ik #{}) x))))\n     {} xrel))",
                                                       :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                       :lines [88 96],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/set.cljs#L88-L96"},
                                              :full-name "clojure.set/index",
                                              :clj-symbol "clojure.set/index",
                                              :docstring "Returns a map of the distinct values of ks in the xrel mapped to a\nset of the maps in xrel with the corresponding values of ks."},
                         "cljs.core/chunked-seq?" {:full-name "cljs.core/chunked-seq?",
                                                   :ns "cljs.core",
                                                   :name "chunked-seq?",
                                                   :type "function",
                                                   :signature ["[x]"],
                                                   :return-type boolean,
                                                   :source {:code "(defn ^boolean chunked-seq?\n  [x]\n  (or (instance? ChunkedCons x)\n      (instance? ChunkedSeq x)))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [1037
                                                                    1040],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1037-L1040"},
                                                   :full-name-encode "cljs.core_chunked-seq_QMARK_",
                                                   :history [["+"
                                                              "0.0-1424"]]},
                         "clojure.browser.dom/log" {:full-name "clojure.browser.dom/log",
                                                    :ns "clojure.browser.dom",
                                                    :name "log",
                                                    :type "function",
                                                    :signature ["[& args]"],
                                                    :source {:code "(defn log [& args]\n  (.log js/console (apply pr-str args)))",
                                                             :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                             :lines [20
                                                                     21],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/dom.cljs#L20-L21"},
                                                    :full-name-encode "clojure.browser.dom_log",
                                                    :history [["+"
                                                               "0.0-927"]]},
                         "cljs.core/make-array" {:ns "cljs.core",
                                                 :name "make-array",
                                                 :signature ["[size]"
                                                             "[type size]"],
                                                 :shadowed-sources ({:code "(defmacro make-array\n  [size]\n  `(js/Array. ~size))",
                                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                                     :lines [1159
                                                                             1161],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L1159-L1161"}),
                                                 :history [["+"
                                                            "0.0-1211"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_make-array",
                                                 :source {:code "(defn make-array\n  ([size]\n     (js/Array. size))\n  ([type size]\n     (make-array size)))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [115
                                                                  119],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L115-L119"},
                                                 :full-name "cljs.core/make-array",
                                                 :clj-symbol "clojure.core/make-array"},
                         "cljs.core/sorted-set-by" {:ns "cljs.core",
                                                    :name "sorted-set-by",
                                                    :signature ["[comparator & keys]"],
                                                    :history [["+"
                                                               "0.0-1211"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_sorted-set-by",
                                                    :source {:code "(defn sorted-set-by\n  ([comparator & keys]\n   (reduce -conj\n           (cljs.core.PersistentTreeSet. nil (sorted-map-by comparator) 0)\n           keys)))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [5829
                                                                     5834],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5829-L5834"},
                                                    :full-name "cljs.core/sorted-set-by",
                                                    :clj-symbol "clojure.core/sorted-set-by",
                                                    :docstring "Returns a new sorted set with supplied keys, using the supplied comparator."},
                         "cljs.core/partition-by" {:ns "cljs.core",
                                                   :name "partition-by",
                                                   :signature ["[f coll]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.core_partition-by",
                                                   :source {:code "(defn partition-by\n  [f coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (let [fst (first s)\n           fv (f fst)\n           run (cons fst (take-while #(= fv (f %)) (next s)))]\n       (cons run (partition-by f (seq (drop (count run) s))))))))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [6064
                                                                    6073],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6064-L6073"},
                                                   :full-name "cljs.core/partition-by",
                                                   :clj-symbol "clojure.core/partition-by",
                                                   :docstring "Applies f to each value in coll, splitting it each time f returns\na new value.  Returns a lazy seq of partitions."},
                         "cljs.core/sort-by" {:ns "cljs.core",
                                              :name "sort-by",
                                              :signature ["[keyfn coll]"
                                                          "[keyfn comp coll]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_sort-by",
                                              :source {:code "(defn sort-by\n  ([keyfn coll]\n   (sort-by keyfn compare coll))\n  ([keyfn comp coll]\n     (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1230
                                                               1238],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1230-L1238"},
                                              :full-name "cljs.core/sort-by",
                                              :clj-symbol "clojure.core/sort-by",
                                              :docstring "Returns a sorted sequence of the items in coll, where the sort\norder is determined by comparing (keyfn item).  Comp can be\nboolean-valued comparison funcion, or a -/0/+ valued comparator.\nComp defaults to compare."},
                         "cljs.core/with-meta" {:ns "cljs.core",
                                                :name "with-meta",
                                                :signature ["[o meta]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_with-meta",
                                                :source {:code "(defn with-meta\n  [o meta]\n  (if (and (fn? o) (not (satisfies? IWithMeta o)))\n    (with-meta\n      (reify\n        Fn\n        IFn\n        (-invoke [_ & args]\n          (apply o args)))\n      meta)\n    (-with-meta o meta)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [919
                                                                 931],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L919-L931"},
                                                :full-name "cljs.core/with-meta",
                                                :clj-symbol "clojure.core/with-meta",
                                                :docstring "Returns an object of the same type and value as obj, with\nmap m as its metadata."},
                         "cljs.core/NeverEquiv" {:full-name "cljs.core/NeverEquiv",
                                                 :ns "cljs.core",
                                                 :name "NeverEquiv",
                                                 :type "type",
                                                 :signature ["[]"],
                                                 :source {:code "(deftype NeverEquiv []\n  IEquiv\n  (-equiv [o other] false))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [3644
                                                                  3646],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L3644-L3646"},
                                                 :full-name-encode "cljs.core_NeverEquiv",
                                                 :history [["+"
                                                            "0.0-927"]]},
                         "cljs.core/select-keys" {:ns "cljs.core",
                                                  :name "select-keys",
                                                  :signature ["[map keyseq]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_select-keys",
                                                  :source {:code "(defn select-keys\n  [map keyseq]\n    (loop [ret {} keys (seq keyseq)]\n      (if keys\n        (let [key   (first keys)\n              entry (get map key ::not-found)]\n          (recur\n           (if (not= entry ::not-found)\n             (assoc ret key entry)\n             ret)\n           (next keys)))\n        ret)))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [5606
                                                                   5618],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5606-L5618"},
                                                  :full-name "cljs.core/select-keys",
                                                  :clj-symbol "clojure.core/select-keys",
                                                  :docstring "Returns a map containing only those entries in map whose key is in keys"},
                         "special/loop*" {:full-name "special/loop*",
                                          :ns "special",
                                          :name "loop*",
                                          :type "special form",
                                          :source {:code "(defmethod parse 'loop*\n  [op encl-env form _]\n  (analyze-let encl-env form true))",
                                                   :filename "clojurescript/src/clj/cljs/analyzer.clj",
                                                   :lines [530 532],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/analyzer.clj#L530-L532"},
                                          :full-name-encode "special_loop_STAR_",
                                          :history [["+" "0.0-927"]]},
                         "cljs.core/ISeq" {:ns "cljs.core",
                                           :name "ISeq",
                                           :type "protocol",
                                           :full-name-encode "cljs.core_ISeq",
                                           :source {:code "(defprotocol ISeq\n  (-first [coll])\n  (-rest [coll]))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [194 196],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L194-L196"},
                                           :methods [{:name "-first",
                                                      :signature ["[coll]"],
                                                      :docstring nil}
                                                     {:name "-rest",
                                                      :signature ["[coll]"],
                                                      :docstring nil}],
                                           :full-name "cljs.core/ISeq",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/disj!" {:full-name "cljs.core/disj!",
                                            :ns "cljs.core",
                                            :name "disj!",
                                            :type "function",
                                            :signature ["[tcoll val]"],
                                            :source {:code "(defn disj! [tcoll val]\n  (-disjoin! tcoll val))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [2312
                                                             2313],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2312-L2313"},
                                            :full-name-encode "cljs.core_disj_BANG_",
                                            :clj-symbol "clojure.core/disj!",
                                            :history [["+" "0.0-1211"]]},
                         "clojure.walk/postwalk-replace" {:ns "clojure.walk",
                                                          :name "postwalk-replace",
                                                          :signature ["[smap form]"],
                                                          :history [["+"
                                                                     "0.0-927"]],
                                                          :type "function",
                                                          :full-name-encode "clojure.walk_postwalk-replace",
                                                          :source {:code "(defn postwalk-replace\n  [smap form]\n  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                                   :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                                   :lines [88
                                                                           94],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/walk.cljs#L88-L94"},
                                                          :full-name "clojure.walk/postwalk-replace",
                                                          :clj-symbol "clojure.walk/postwalk-replace",
                                                          :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the leaves of the tree first."},
                         "cljs.core/pr-with-opts" {:ns "cljs.core",
                                                   :name "pr-with-opts",
                                                   :signature ["[objs opts]"],
                                                   :history [["+"
                                                              "0.0-927"]
                                                             ["-"
                                                              "0.0-1503"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.core_pr-with-opts",
                                                   :source {:code "(defn pr-with-opts\n  [objs opts]\n  (doseq [string (pr-seq (first objs) opts)]\n    (string-print string))\n  (doseq [obj (next objs)]\n    (string-print \" \")\n    (doseq [string (pr-seq obj opts)]\n      (string-print string))))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [6171
                                                                    6180],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1450/src/cljs/cljs/core.cljs#L6171-L6180"},
                                                   :full-name "cljs.core/pr-with-opts",
                                                   :docstring "Prints a sequence of objects using string-print, observing all\nthe options given in opts",
                                                   :removed {:in "0.0-1503",
                                                             :last-seen "0.0-1450"}},
                         "cljs.core/->>" {:ns "cljs.core",
                                          :name "->>",
                                          :signature ["[x form]"
                                                      "[x form & more]"],
                                          :history [["+" "0.0-927"]],
                                          :type "macro",
                                          :full-name-encode "cljs.core_-_GT__GT_",
                                          :source {:code "(defmacro ->>\n  ([x form] (if (seq? form)\n              (with-meta `(~(first form) ~@(next form)  ~x) (meta form))\n              (list form x)))\n  ([x form & more] `(->> (->> ~x ~form) ~@more)))",
                                                   :filename "clojure/src/clj/clojure/core.clj",
                                                   :lines [1557 1566],
                                                   :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L1557-L1566"},
                                          :full-name "cljs.core/->>",
                                          :clj-symbol "clojure.core/->>",
                                          :docstring "Threads the expr through the forms. Inserts x as the\nlast item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nlast item in second form, etc."},
                         "cljs.core/nil?" {:return-type boolean,
                                           :ns "cljs.core",
                                           :name "nil?",
                                           :signature ["[x]"],
                                           :shadowed-sources ({:code "(defmacro nil? [x]\n  `(coercive-= ~x nil))",
                                                               :filename "clojurescript/src/clj/cljs/core.clj",
                                                               :lines [196
                                                                       197],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L196-L197"}),
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_nil_QMARK_",
                                           :source {:code "(defn ^boolean nil?\n  [x]\n  (coercive-= x nil))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [54 57],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L54-L57"},
                                           :full-name "cljs.core/nil?",
                                           :clj-symbol "clojure.core/nil?",
                                           :docstring "Returns true if x is nil, false otherwise."},
                         "clojure.walk/stringify-keys" {:ns "clojure.walk",
                                                        :name "stringify-keys",
                                                        :signature ["[m]"],
                                                        :history [["+"
                                                                   "0.0-927"]],
                                                        :type "function",
                                                        :full-name-encode "clojure.walk_stringify-keys",
                                                        :source {:code "(defn stringify-keys\n  [m]\n  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                                 :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                                 :lines [72
                                                                         78],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/walk.cljs#L72-L78"},
                                                        :full-name "clojure.walk/stringify-keys",
                                                        :clj-symbol "clojure.walk/stringify-keys",
                                                        :docstring "Recursively transforms all map keys from keywords to strings."},
                         "clojure.browser.repl/order" {:full-name "clojure.browser.repl/order",
                                                       :ns "clojure.browser.repl",
                                                       :name "order",
                                                       :type "var",
                                                       :source {:code "(def order (atom 0))",
                                                                :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                :lines [55
                                                                        55],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/repl.cljs#L55-L55"},
                                                       :full-name-encode "clojure.browser.repl_order",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.core/memoize" {:ns "cljs.core",
                                              :name "memoize",
                                              :signature ["[f]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_memoize",
                                              :source {:code "(defn memoize\n  [f]\n  (let [mem (atom {})]\n    (fn [& args]\n      (if-let [v (get @mem args)]\n        v\n        (let [ret (apply f args)]\n          (swap! mem assoc args ret)\n          ret)))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [6779
                                                               6791],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6779-L6791"},
                                              :full-name "cljs.core/memoize",
                                              :clj-symbol "clojure.core/memoize",
                                              :docstring "Returns a memoized version of a referentially transparent function. The\nmemoized version of the function keeps a cache of the mapping from arguments\nto results and, when calls with the same arguments are repeated often, has\nhigher performance at the expense of higher memory use."},
                         "cljs.core/pr-sequential" {:ns "cljs.core",
                                                    :name "pr-sequential",
                                                    :signature ["[print-one begin sep end opts coll]"],
                                                    :history [["+"
                                                               "0.0-927"]
                                                              ["-"
                                                               "0.0-1798"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_pr-sequential",
                                                    :source {:code "(defn ^:deprecated pr-sequential\n  [print-one begin sep end opts coll]\n  (concat [begin]\n          (flatten1\n            (interpose [sep] (map #(print-one % opts) coll)))\n          [end]))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [6210
                                                                     6217],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1586/src/cljs/cljs/core.cljs#L6210-L6217"},
                                                    :full-name "cljs.core/pr-sequential",
                                                    :docstring "Do not use this.  It is kept for backwards compatibility with the\nold IPrintable protocol.",
                                                    :removed {:in "0.0-1798",
                                                              :last-seen "0.0-1586"}},
                         "clojure.zip/make-node" {:ns "clojure.zip",
                                                  :name "make-node",
                                                  :signature ["[loc node children]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.zip_make-node",
                                                  :source {:code "(defn make-node\n  [loc node children]\n    ((:zip/make-node (meta loc)) node children))",
                                                           :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                           :lines [76
                                                                   80],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L76-L80"},
                                                  :full-name "clojure.zip/make-node",
                                                  :clj-symbol "clojure.zip/make-node",
                                                  :docstring "Returns a new branch node, given an existing node and new\nchildren. The loc is only used to supply the constructor."},
                         "specialrepl/load-namespace" {:full-name "specialrepl/load-namespace",
                                                       :ns "specialrepl",
                                                       :name "load-namespace",
                                                       :type "special form (repl)",
                                                       :source {:code "(def default-special-fns\n  (let [load-file-fn (fn [repl-env file] (load-file repl-env file))]\n    {'in-ns (fn [_ quoted-ns]\n              (let [ns-name (second quoted-ns)]\n                (when-not (ana/get-namespace ns-name)\n                  (ana/set-namespace ns-name {:name ns-name}))\n                (set! ana/*cljs-ns* ns-name)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace (fn [repl-env ns] (load-namespace repl-env ns))}))",
                                                                :filename "clojurescript/src/clj/cljs/repl.clj",
                                                                :lines [142
                                                                        151],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/repl.clj#L142-L151"},
                                                       :full-name-encode "specialrepl_load-namespace",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.reader/float-pattern" {:full-name "cljs.reader/float-pattern",
                                                      :ns "cljs.reader",
                                                      :name "float-pattern",
                                                      :type "var",
                                                      :source {:code "(def float-pattern (re-pattern \"([-+]?[0-9]+(\\\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?\"))",
                                                               :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                               :lines [101
                                                                       101],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L101-L101"},
                                                      :full-name-encode "cljs.reader_float-pattern",
                                                      :history [["+"
                                                                 "0.0-927"]]},
                         "cljs.core/ancestors" {:ns "cljs.core",
                                                :name "ancestors",
                                                :signature ["[tag]"
                                                            "[h tag]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_ancestors",
                                                :source {:code "(defn ancestors\n  ([tag] (ancestors @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:ancestors h) tag))))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [6879
                                                                 6885],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6879-L6885"},
                                                :full-name "cljs.core/ancestors",
                                                :clj-symbol "clojure.core/ancestors",
                                                :docstring "Returns the immediate and indirect parents of tag, either via a JavaScript type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
                         "cljs.core/integer?" {:return-type boolean,
                                               :ns "cljs.core",
                                               :name "integer?",
                                               :signature ["[n]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_integer_QMARK_",
                                               :source {:code "(defn ^boolean integer?\n  [n]\n  (and (number? n)\n       (not ^boolean (js/isNaN n))\n       (not (identical? n js/Infinity))\n       (== (js/parseFloat n) (js/parseInt n 10))))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [1119
                                                                1125],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1119-L1125"},
                                               :full-name "cljs.core/integer?",
                                               :clj-symbol "clojure.core/integer?",
                                               :docstring "Returns true if n is an integer."},
                         "clojure.zip/xml-zip" {:ns "clojure.zip",
                                                :name "xml-zip",
                                                :signature ["[root]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "clojure.zip_xml-zip",
                                                :source {:code "(defn xml-zip\n  [root]\n    (zipper (complement string?) \n            (comp seq :content)\n            (fn [node children]\n              (assoc node :content (and children (apply vector children))))\n            root))",
                                                         :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                         :lines [50
                                                                 58],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L50-L58"},
                                                :full-name "clojure.zip/xml-zip",
                                                :clj-symbol "clojure.zip/xml-zip",
                                                :docstring "Returns a zipper for xml elements (as from xml/parse),\ngiven a root element"},
                         "clojure.walk/walk" {:ns "clojure.walk",
                                              :name "walk",
                                              :signature ["[inner outer form]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.walk_walk",
                                              :source {:code "(defn walk\n  [inner outer form]\n  (cond\n   (seq? form) (outer (doall (map inner form)))\n   (coll? form) (outer (into (empty form) (map inner form)))\n   :else (outer form)))",
                                                       :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                       :lines [37 48],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/walk.cljs#L37-L48"},
                                              :full-name "clojure.walk/walk",
                                              :clj-symbol "clojure.walk/walk",
                                              :docstring "Traverses form, an arbitrary data structure.  inner and outer are\nfunctions.  Applies inner to each element of form, building up a\ndata structure of the same type, then applies outer to the result.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
                         "cljs.core/ifn?" {:return-type boolean,
                                           :ns "cljs.core",
                                           :name "ifn?",
                                           :signature ["[f]"],
                                           :history [["+" "0.0-1211"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_ifn_QMARK_",
                                           :source {:code "(defn ^boolean ifn? [f]\n  (or (fn? f) (satisfies? IFn f)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1116 1117],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1116-L1117"},
                                           :full-name "cljs.core/ifn?",
                                           :clj-symbol "clojure.core/ifn?"},
                         "cljs.core/bit-xor" {:ns "cljs.core",
                                              :name "bit-xor",
                                              :signature ["[x y]"],
                                              :shadowed-sources ({:code "(defmacro bit-xor\n  ([x y] (list 'js* \"(~{} ^ ~{})\" x y))\n  ([x y & more] `(bit-xor (bit-xor ~x ~y) ~@more)))",
                                                                  :filename "clojurescript/src/clj/cljs/core.clj",
                                                                  :lines [416
                                                                          418],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L416-L418"}),
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_bit-xor",
                                              :source {:code "(defn bit-xor\n  [x y] (cljs.core/bit-xor x y))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1566
                                                               1568],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1566-L1568"},
                                              :full-name "cljs.core/bit-xor",
                                              :clj-symbol "clojure.core/bit-xor",
                                              :docstring "Bitwise exclusive or"},
                         "clojure.set/union" {:ns "clojure.set",
                                              :name "union",
                                              :signature ["[]"
                                                          "[s1]"
                                                          "[s1 s2]"
                                                          "[s1 s2 & sets]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.set_union",
                                              :source {:code "(defn union\n  ([] #{})\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s1) (count s2))\n       (reduce conj s2 s1)\n       (reduce conj s1 s2)))\n  ([s1 s2 & sets]\n     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n       (reduce into (first bubbled-sets) (rest bubbled-sets)))))",
                                                       :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                       :lines [19 29],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/set.cljs#L19-L29"},
                                              :full-name "clojure.set/union",
                                              :clj-symbol "clojure.set/union",
                                              :docstring "Return a set that is the union of the input sets"},
                         "cljs.core/case" {:full-name "cljs.core/case",
                                           :ns "cljs.core",
                                           :name "case",
                                           :type "macro",
                                           :signature ["[e & clauses]"],
                                           :source {:code "(defmacro case [e & clauses]\n  (let [default (if (odd? (count clauses))\n                  (last clauses)\n                  `(throw (js/Error. (core/str \"No matching clause: \" ~e))))\n        assoc-test (fn assoc-test [m test expr]\n                         (if (contains? m test)\n                           (throw (clojure.core/IllegalArgumentException.\n                                   (core/str \"Duplicate case test constant '\"\n                                             test \"'\"\n                                             (when (:line &env)\n                                               (core/str \" on line \" (:line &env) \" \"\n                                                         cljs.analyzer/*cljs-file*)))))\n                           (assoc m test expr)))\n        pairs (reduce (fn [m [test expr]]\n                        (cond\n                         (seq? test) (reduce (fn [m test]\n                                               (let [test (if (core/symbol? test)\n                                                            (list 'quote test)\n                                                            test)]\n                                                 (assoc-test m test expr)))\n                                             m test)\n                         (core/symbol? test) (assoc-test m (list 'quote test) expr)\n                         :else (assoc-test m test expr)))\n                      {} (partition 2 clauses))\n        esym (gensym)]\n   `(let [~esym ~e]\n      (cond\n        ~@(mapcat (fn [[m c]] `((cljs.core/= ~m ~esym) ~c)) pairs)\n        :else ~default))))",
                                                    :filename "clojurescript/src/clj/cljs/core.clj",
                                                    :lines [933 961],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L933-L961"},
                                           :full-name-encode "cljs.core_case",
                                           :clj-symbol "clojure.core/case",
                                           :history [["+" "0.0-1211"]]},
                         "cljs.reader/PushbackReader" {:ns "cljs.reader",
                                                       :name "PushbackReader",
                                                       :type "protocol",
                                                       :full-name-encode "cljs.reader_PushbackReader",
                                                       :source {:code "(defprotocol PushbackReader\n  (read-char [reader] \"Returns the next char from the Reader,\nnil if the end of stream has been reached\")\n  (unread [reader ch] \"Push back a single character on to the stream\"))",
                                                                :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                :lines [12
                                                                        15],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L12-L15"},
                                                       :methods [{:name "read-char",
                                                                  :signature ["[reader]"],
                                                                  :docstring "Returns the next char from the Reader,\nnil if the end of stream has been reached"}
                                                                 {:name "unread",
                                                                  :signature ["[reader ch]"],
                                                                  :docstring "Push back a single character on to the stream"}],
                                                       :full-name "cljs.reader/PushbackReader",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.core/isa?" {:return-type boolean,
                                           :ns "cljs.core",
                                           :name "isa?",
                                           :signature ["[child parent]"
                                                       "[h child parent]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_isa_QMARK_",
                                           :source {:code "(defn ^boolean isa?\n  ([child parent] (isa? @(get-global-hierarchy) child parent))\n  ([h child parent]\n     (or (= child parent)\n         ;; (and (class? parent) (class? child)\n         ;;    (. ^Class parent isAssignableFrom child))\n         (contains? ((:ancestors h) child) parent)\n         ;;(and (class? child) (some #(contains? ((:ancestors h) %) parent) (supers child)))\n         (and (vector? parent) (vector? child)\n              (== (count parent) (count child))\n              (loop [ret true i 0]\n                (if (or (not ret) (== i (count parent)))\n                  ret\n                  (recur (isa? h (child i) (parent i)) (inc i))))))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [6851 6869],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6851-L6869"},
                                           :full-name "cljs.core/isa?",
                                           :clj-symbol "clojure.core/isa?",
                                           :docstring "Returns true if (= child parent), or child is directly or indirectly derived from\nparent, either via a JavaScript type inheritance relationship or a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy"},
                         "clojure.browser.net/xhr-connection" {:full-name "clojure.browser.net/xhr-connection",
                                                               :ns "clojure.browser.net",
                                                               :name "xhr-connection",
                                                               :docstring "Returns an XhrIo connection",
                                                               :type "function",
                                                               :signature ["[]"],
                                                               :source {:code "(defn xhr-connection\n  []\n  (goog.net.XhrIo.))",
                                                                        :filename "clojurescript/src/cljs/clojure/browser/net.cljs",
                                                                        :lines [83
                                                                                86],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/net.cljs#L83-L86"},
                                                               :full-name-encode "clojure.browser.net_xhr-connection",
                                                               :history [["+"
                                                                          "0.0-927"]]},
                         "cljs.core/as->" {:ns "cljs.core",
                                           :name "as->",
                                           :signature ["[expr name & forms]"],
                                           :history [["+" "0.0-1798"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_as-_GT_",
                                           :source {:code "(defmacro as->\n  [expr name & forms]\n  `(let [~name ~expr\n         ~@(interleave (repeat name) forms)]\n     ~name))",
                                                    :filename "clojure/src/clj/clojure/core.clj",
                                                    :lines [6803 6811],
                                                    :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L6803-L6811"},
                                           :full-name "cljs.core/as->",
                                           :clj-symbol "clojure.core/as->",
                                           :docstring "Binds name to expr, evaluates the first form in the lexical context\nof that binding, then binds name to that result, repeating for each\nsuccessive form, returning the result of the last form."},
                         "clojure.core.reducers/reducer" {:ns "clojure.core.reducers",
                                                          :name "reducer",
                                                          :signature ["[coll xf]"],
                                                          :history [["+"
                                                                     "0.0-1236"]],
                                                          :type "function",
                                                          :full-name-encode "clojure.core.reducers_reducer",
                                                          :source {:code "(defn reducer\n  ([coll xf]\n     (reify\n       cljs.core/IReduce\n       (-reduce [this f1]\n         (-reduce this f1 (f1)))\n       (-reduce [_ f1 init]\n         (-reduce coll (xf f1) init)))))",
                                                                   :filename "clojurescript/src/cljs/clojure/core/reducers.cljs",
                                                                   :lines [55
                                                                           66],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/core/reducers.cljs#L55-L66"},
                                                          :full-name "clojure.core.reducers/reducer",
                                                          :clj-symbol "clojure.core.reducers/reducer",
                                                          :docstring "Given a reducible collection, and a transformation function xf,\nreturns a reducible collection, where any supplied reducing\nfn will be transformed by xf. xf is a function of reducing fn to\nreducing fn."},
                         "cljs.core/subs" {:ns "cljs.core",
                                           :name "subs",
                                           :signature ["[s start]"
                                                       "[s start end]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_subs",
                                           :source {:code "(defn subs\n  ([s start] (.substring s start))\n  ([s start end] (.substring s start end)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1690 1694],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1690-L1694"},
                                           :full-name "cljs.core/subs",
                                           :clj-symbol "clojure.core/subs",
                                           :docstring "Returns the substring of s beginning at start inclusive, and ending\nat end (defaults to length of string), exclusive."},
                         "cljs.core/symbol?" {:return-type boolean,
                                              :ns "cljs.core",
                                              :name "symbol?",
                                              :signature ["[x]"],
                                              :shadowed-sources ({:code "(defmacro symbol? [x]\n  (bool-expr `(instance? Symbol ~x)))",
                                                                  :filename "clojurescript/src/clj/cljs/core.clj",
                                                                  :lines [251
                                                                          252],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L251-L252"}),
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_symbol_QMARK_",
                                              :source {:code "(defn ^boolean symbol? [x]\n  (instance? Symbol x))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1107
                                                               1108],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1107-L1108"},
                                              :full-name "cljs.core/symbol?",
                                              :clj-symbol "clojure.core/symbol?"},
                         "clojure.data/Diff" {:ns "clojure.data",
                                              :name "Diff",
                                              :history [["+"
                                                         "0.0-1503"]],
                                              :type "protocol",
                                              :full-name-encode "clojure.data_Diff",
                                              :source {:code "(defprotocol Diff\n  \"Implementation detail. Subject to change.\"\n  (diff-similar [a b] \"Implementation detail. Subject to change.\"))",
                                                       :filename "clojurescript/src/cljs/clojure/data.cljs",
                                                       :lines [79 81],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/data.cljs#L79-L81"},
                                              :methods [{:name "diff-similar",
                                                         :signature ["[a b]"],
                                                         :docstring "Implementation detail. Subject to change."}],
                                              :full-name "clojure.data/Diff",
                                              :clj-symbol "clojure.data/Diff",
                                              :docstring "Implementation detail. Subject to change."},
                         "clojure.string/replace" {:ns "clojure.string",
                                                   :name "replace",
                                                   :signature ["[s match replacement]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.string_replace",
                                                   :source {:code "(defn replace\n  [s match replacement]\n  (cond (string? match)\n        (.replace s (js/RegExp. (gstring/regExpEscape match) \"g\") replacement)\n        (.hasOwnProperty match \"source\")\n        (.replace s (js/RegExp. (.-source match) \"g\") replacement)\n        :else (throw (str \"Invalid match arg: \" match))))",
                                                            :filename "clojurescript/src/cljs/clojure/string.cljs",
                                                            :lines [23
                                                                    34],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/string.cljs#L23-L34"},
                                                   :full-name "clojure.string/replace",
                                                   :clj-symbol "clojure.string/replace",
                                                   :docstring "Replaces all instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
                         "cljs.core/string?" {:return-type boolean,
                                              :ns "cljs.core",
                                              :name "string?",
                                              :signature ["[x]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_string_QMARK_",
                                              :source {:code "(defn ^boolean string? [x]\n  (and ^boolean (goog/isString x)\n    (not (identical? (.charAt x 0) \\uFDD0))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [378
                                                               380],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L378-L380"},
                                              :full-name "cljs.core/string?",
                                              :clj-symbol "clojure.core/string?"},
                         "cljs.core/partition-all" {:ns "cljs.core",
                                                    :name "partition-all",
                                                    :signature ["[n coll]"
                                                                "[n step coll]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.core_partition-all",
                                                    :source {:code "(defn partition-all\n  ([n coll]\n     (partition-all n n coll))\n  ([n step coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (cons (take n s) (partition-all n step (drop step s)))))))",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [5921
                                                                     5929],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5921-L5929"},
                                                    :full-name "cljs.core/partition-all",
                                                    :clj-symbol "clojure.core/partition-all",
                                                    :docstring "Returns a lazy sequence of lists like partition, but may include\npartitions with fewer than n items at the end."},
                         "cljs.core/RedNode" {:full-name "cljs.core/RedNode",
                                              :ns "cljs.core",
                                              :name "RedNode",
                                              :type "type",
                                              :signature ["[key val left right __hash]"],
                                              :source {:code "(deftype RedNode [key val left right ^:mutable __hash]\n  Object\n  (add-left [node ins]\n    (RedNode. key val ins right nil))\n\n  (add-right [node ins]\n    (RedNode. key val left ins nil))\n\n  (remove-left [node del]\n    (RedNode. key val del right nil))\n\n  (remove-right [node del]\n    (RedNode. key val left del nil))\n\n  (blacken [node]\n    (BlackNode. key val left right nil))\n\n  (redden [node]\n    (throw (js/Error. \"red-black tree invariant violation\")))\n\n  (balance-left [node parent]\n    (cond\n      (instance? RedNode left)\n      (RedNode. key val\n                (.blacken left)\n                (BlackNode. (.-key parent) (.-val parent) right (.-right parent) nil)\n                nil)\n\n      (instance? RedNode right)\n      (RedNode. (.-key right) (.-val right)\n                (BlackNode. key val left (.-left right) nil)\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-right right)\n                            (.-right parent)\n                            nil)\n                nil)\n\n      :else\n      (BlackNode. (.-key parent) (.-val parent) node (.-right parent) nil)))\n\n  (balance-right [node parent]\n    (cond\n      (instance? RedNode right)\n      (RedNode. key val\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-left parent)\n                            left\n                            nil)\n                (.blacken right)\n                nil)\n\n      (instance? RedNode left)\n      (RedNode. (.-key left) (.-val left)\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-left parent)\n                            (.-left left)\n                            nil)\n                (BlackNode. key val (.-right left) right nil)\n                nil)\n\n      :else\n      (BlackNode. (.-key parent) (.-val parent) (.-left parent) node nil)))\n\n  (replace [node key val left right]\n    (RedNode. key val left right nil))\n\n  (kv-reduce [node f init]\n    (tree-map-kv-reduce node f init))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] [])\n\n  ISequential\n  ISeqable\n  (-seq [node] (list key val))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    nil))\n\n  (-nth [node n not-found]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-lookup node k))\n\n  (-invoke [node k not-found]\n    (-lookup node k not-found)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [5147
                                                               5286],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5147-L5286"},
                                              :full-name-encode "cljs.core_RedNode",
                                              :history [["+"
                                                         "0.0-1211"]]},
                         "cljs.core/ExceptionInfo" {:full-name "cljs.core/ExceptionInfo",
                                                    :ns "cljs.core",
                                                    :name "ExceptionInfo",
                                                    :type "type",
                                                    :signature ["[message data cause]"],
                                                    :source {:code "(deftype ExceptionInfo [message data cause])",
                                                             :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                             :lines [7126
                                                                     7126],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L7126-L7126"},
                                                    :full-name-encode "cljs.core_ExceptionInfo",
                                                    :history [["+"
                                                               "0.0-1576"]]},
                         "cljs.core/merge-with" {:ns "cljs.core",
                                                 :name "merge-with",
                                                 :signature ["[f & maps]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_merge-with",
                                                 :source {:code "(defn merge-with\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n                        (let [k (first e) v (second e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [5590
                                                                  5604],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5590-L5604"},
                                                 :full-name "cljs.core/merge-with",
                                                 :clj-symbol "clojure.core/merge-with",
                                                 :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping(s)\nfrom the latter (left-to-right) will be combined with the mapping in\nthe result by calling (f val-in-result val-in-latter)."},
                         "cljs.core/key" {:ns "cljs.core",
                                          :name "key",
                                          :signature ["[map-entry]"],
                                          :history [["+" "0.0-1211"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_key",
                                          :source {:code "(defn key\n  [map-entry]\n  (-key map-entry))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [5567 5570],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5567-L5570"},
                                          :full-name "cljs.core/key",
                                          :clj-symbol "clojure.core/key",
                                          :docstring "Returns the key of the map entry."},
                         "clojure.browser.dom/set-properties" {:full-name "clojure.browser.dom/set-properties",
                                                               :ns "clojure.browser.dom",
                                                               :name "set-properties",
                                                               :docstring "Set properties on an element",
                                                               :type "function",
                                                               :signature ["[e m]"],
                                                               :source {:code "(defn set-properties\n  [e m]\n  (gdom/setProperties (ensure-element e)\n                      (apply gobject/create (interleave (keys m) (vals m)))))",
                                                                        :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                        :lines [136
                                                                                140],
                                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/dom.cljs#L136-L140"},
                                                               :full-name-encode "clojure.browser.dom_set-properties",
                                                               :history [["+"
                                                                          "0.0-927"]]},
                         "clojure.data/diff" {:ns "clojure.data",
                                              :name "diff",
                                              :signature ["[a b]"],
                                              :history [["+"
                                                         "0.0-1503"]],
                                              :type "function",
                                              :full-name-encode "clojure.data_diff",
                                              :source {:code "(defn diff\n  [a b]\n  (if (= a b)\n    [nil nil a]\n    (if (= (equality-partition a) (equality-partition b))\n      (diff-similar a b)\n      (atom-diff a b))))",
                                                       :filename "clojurescript/src/cljs/clojure/data.cljs",
                                                       :lines [144
                                                               161],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/data.cljs#L144-L161"},
                                              :full-name "clojure.data/diff",
                                              :clj-symbol "clojure.data/diff",
                                              :docstring "Recursively compares a and b, returning a tuple of\n[things-only-in-a things-only-in-b things-in-both].\nComparison rules:\n\n* For equal a and b, return [nil nil a].\n* Maps are subdiffed where keys match and values differ.\n* Sets are never subdiffed.\n* All sequential things are treated as associative collections\n  by their indexes, with results returned as vectors.\n* Everything else (including strings!) is treated as\n  an atom and compared for equality."},
                         "cljs.core/ITransientAssociative" {:ns "cljs.core",
                                                            :name "ITransientAssociative",
                                                            :type "protocol",
                                                            :full-name-encode "cljs.core_ITransientAssociative",
                                                            :source {:code "(defprotocol ITransientAssociative\n  (-assoc! [tcoll key val]))",
                                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                     :lines [299
                                                                             300],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L299-L300"},
                                                            :methods [{:name "-assoc!",
                                                                       :signature ["[tcoll key val]"],
                                                                       :docstring nil}],
                                                            :full-name "cljs.core/ITransientAssociative",
                                                            :history [["+"
                                                                       "0.0-1211"]]},
                         "cljs.core/trampoline" {:ns "cljs.core",
                                                 :name "trampoline",
                                                 :signature ["[f]"
                                                             "[f & args]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_trampoline",
                                                 :source {:code "(defn trampoline\n  ([f]\n     (let [ret (f)]\n       (if (fn? ret)\n         (recur ret)\n         ret)))\n  ([f & args]\n     (trampoline #(apply f args))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [6793
                                                                  6807],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6793-L6807"},
                                                 :full-name "cljs.core/trampoline",
                                                 :clj-symbol "clojure.core/trampoline",
                                                 :docstring "trampoline can be used to convert algorithms requiring mutual\nrecursion without stack consumption. Calls f with supplied args, if\nany. If f returns a fn, calls that fn with no arguments, and\ncontinues to repeat, until the return value is not a fn, then\nreturns that non-fn value. Note that if you want to return a fn as a\nfinal value, you must wrap it in some data structure and unpack it\nafter trampoline returns."},
                         "clojure.browser.repl/send-print" {:full-name "clojure.browser.repl/send-print",
                                                            :ns "clojure.browser.repl",
                                                            :name "send-print",
                                                            :docstring "Send data to be printed in the REPL. If there is an error, try again\nup to 10 times.",
                                                            :type "function",
                                                            :signature ["[url data]"
                                                                        "[url data n]"],
                                                            :source {:code "(defn send-print\n  ([url data]\n     (send-print url data 0))\n  ([url data n]\n     (let [conn (net/xhr-connection)]\n       (event/listen conn :error\n                     (fn [_]\n                       (if (< n 10)\n                         (send-print url data (inc n))\n                         (.log js/console (str \"Could not send \" data \" after \" n \" attempts.\")))))\n       (net/transmit conn url \"POST\" data nil 0))))",
                                                                     :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                     :lines [41
                                                                             53],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/repl.cljs#L41-L53"},
                                                            :full-name-encode "clojure.browser.repl_send-print",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "cljs.core/ICounted" {:ns "cljs.core",
                                               :name "ICounted",
                                               :type "protocol",
                                               :full-name-encode "cljs.core_ICounted",
                                               :source {:code "(defprotocol ICounted\n  (-count [coll] \"constant time count\"))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [177
                                                                178],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L177-L178"},
                                               :methods [{:name "-count",
                                                          :signature ["[coll]"],
                                                          :docstring "constant time count"}],
                                               :full-name "cljs.core/ICounted",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/IEquiv" {:ns "cljs.core",
                                             :name "IEquiv",
                                             :type "protocol",
                                             :full-name-encode "cljs.core_IEquiv",
                                             :source {:code "(defprotocol IEquiv\n  (-equiv [o other]))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [245 246],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L245-L246"},
                                             :methods [{:name "-equiv",
                                                        :signature ["[o other]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/IEquiv",
                                             :history [["+" "0.0-927"]]},
                         "cljs.core/reduce-kv" {:ns "cljs.core",
                                                :name "reduce-kv",
                                                :signature ["[f init coll]"],
                                                :history [["+"
                                                           "0.0-1211"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_reduce-kv",
                                                :source {:code "(defn reduce-kv\n  ([f init coll]\n     (-kv-reduce coll f init)))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1301
                                                                 1309],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1301-L1309"},
                                                :full-name "cljs.core/reduce-kv",
                                                :clj-symbol "clojure.core/reduce-kv",
                                                :docstring "Reduces an associative collection. f should be a function of 3\narguments. Returns the result of applying f to init, the first key\nand the first value in coll, then applying f to that result and the\n2nd key and value, etc. If coll contains no entries, returns init\nand f is not called. Note that reduce-kv is supported on vectors,\nwhere the keys will be the ordinals."},
                         "cljs.core/js-delete" {:full-name "cljs.core/js-delete",
                                                :ns "cljs.core",
                                                :name "js-delete",
                                                :type "function",
                                                :signature ["[obj key]"],
                                                :source {:code "(defn js-delete [obj key]\n  (cljs.core/js-delete obj key))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [1054
                                                                 1055],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1054-L1055"},
                                                :full-name-encode "cljs.core_js-delete",
                                                :shadowed-sources ({:code "(defmacro js-delete [obj key]\n  (list 'js* \"delete ~{}[~{}]\" obj key))",
                                                                    :filename "clojurescript/src/clj/cljs/core.clj",
                                                                    :lines [224
                                                                            225],
                                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L224-L225"}),
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/comment" {:ns "cljs.core",
                                              :name "comment",
                                              :signature ["[& body]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "macro",
                                              :full-name-encode "cljs.core_comment",
                                              :source {:code "(defmacro comment\n  [& body])",
                                                       :filename "clojure/src/clj/clojure/core.clj",
                                                       :lines [4265
                                                               4268],
                                                       :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L4265-L4268"},
                                              :full-name "cljs.core/comment",
                                              :clj-symbol "clojure.core/comment",
                                              :docstring "Ignores body, yields nil"},
                         "cljs.reader/special-symbols" {:full-name "cljs.reader/special-symbols",
                                                        :ns "cljs.reader",
                                                        :name "special-symbols",
                                                        :type "function",
                                                        :signature ["[t not-found]"],
                                                        :source {:code "(defn special-symbols [t not-found]\n  (cond\n   (identical? t \"nil\") nil\n   (identical? t \"true\") true\n   (identical? t \"false\") false\n   :else not-found))",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [312
                                                                         317],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L312-L317"},
                                                        :full-name-encode "cljs.reader_special-symbols",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.reader/register-default-tag-parser!" {:full-name "cljs.reader/register-default-tag-parser!",
                                                                     :ns "cljs.reader",
                                                                     :name "register-default-tag-parser!",
                                                                     :type "function",
                                                                     :signature ["[f]"],
                                                                     :source {:code "(defn register-default-tag-parser!\n  [f]\n  (let [old-parser @*default-data-reader-fn*]\n    (swap! *default-data-reader-fn* (fn [_] f))\n    old-parser))",
                                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                              :lines [559
                                                                                      563],
                                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L559-L563"},
                                                                     :full-name-encode "cljs.reader_register-default-tag-parser_BANG_",
                                                                     :history [["+"
                                                                                "0.0-1576"]]},
                         "cljs.core/alength" {:ns "cljs.core",
                                              :name "alength",
                                              :signature ["[array]"],
                                              :shadowed-sources ({:code "(defmacro alength [a]\n  (list 'js* \"~{}.length\" a))",
                                                                  :filename "clojurescript/src/clj/cljs/core.clj",
                                                                  :lines [1172
                                                                          1173],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L1172-L1173"}),
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_alength",
                                              :source {:code "(defn alength\n  [array]\n  (cljs.core/alength array))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [135
                                                               138],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L135-L138"},
                                              :full-name "cljs.core/alength",
                                              :clj-symbol "clojure.core/alength",
                                              :docstring "Returns the length of the array. Works on arrays of all types."},
                         "cljs.core/mk-bound-fn" {:full-name "cljs.core/mk-bound-fn",
                                                  :ns "cljs.core",
                                                  :name "mk-bound-fn",
                                                  :type "function",
                                                  :signature ["[sc test key]"],
                                                  :source {:code "(defn mk-bound-fn\n  [sc test key]\n  (fn [e]\n    (let [comp (-comparator sc)]\n      (test (comp (-entry-key sc e) key) 0))))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [5940
                                                                   5944],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5940-L5944"},
                                                  :full-name-encode "cljs.core_mk-bound-fn",
                                                  :history [["+"
                                                             "0.0-1211"]]},
                         "cljs.reader/validate-unicode-escape" {:full-name "cljs.reader/validate-unicode-escape",
                                                                :ns "cljs.reader",
                                                                :name "validate-unicode-escape",
                                                                :type "function",
                                                                :signature ["[unicode-pattern reader escape-char unicode-str]"],
                                                                :source {:code "(defn validate-unicode-escape [unicode-pattern reader escape-char unicode-str]\n  (if (re-matches unicode-pattern unicode-str)\n    unicode-str\n    (reader-error reader \"Unexpected unicode escape \\\\\" escape-char unicode-str)))",
                                                                         :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                         :lines [192
                                                                                 195],
                                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L192-L195"},
                                                                :full-name-encode "cljs.reader_validate-unicode-escape",
                                                                :history [["+"
                                                                           "0.0-1424"]]},
                         "special/quote" {:full-name "special/quote",
                                          :ns "special",
                                          :name "quote",
                                          :type "special form",
                                          :source {:code "(defmethod parse 'quote\n  [_ env [_ x] _]\n  {:op :constant :env env :form x})",
                                                   :filename "clojurescript/src/clj/cljs/analyzer.clj",
                                                   :lines [547 549],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/analyzer.clj#L547-L549"},
                                          :full-name-encode "special_quote",
                                          :clj-symbol "clojure.core/quote",
                                          :history [["+" "0.0-927"]]},
                         "cljs.core/VectorNode" {:full-name "cljs.core/VectorNode",
                                                 :ns "cljs.core",
                                                 :name "VectorNode",
                                                 :type "type",
                                                 :signature ["[edit arr]"],
                                                 :source {:code "(deftype VectorNode [edit arr])",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2965
                                                                  2965],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2965-L2965"},
                                                 :full-name-encode "cljs.core_VectorNode",
                                                 :history [["+"
                                                            "0.0-1211"]]},
                         "cljs.core/string-hash-cache-count" {:full-name "cljs.core/string-hash-cache-count",
                                                              :ns "cljs.core",
                                                              :name "string-hash-cache-count",
                                                              :type "var",
                                                              :source {:code "(def string-hash-cache-count 0)",
                                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                       :lines [966
                                                                               966],
                                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L966-L966"},
                                                              :full-name-encode "cljs.core_string-hash-cache-count",
                                                              :history [["+"
                                                                         "0.0-1424"]]},
                         "cljs.core/tree-seq" {:ns "cljs.core",
                                               :name "tree-seq",
                                               :signature ["[branch? children root]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_tree-seq",
                                               :source {:code "(defn tree-seq\n   [branch? children root]\n   (let [walk (fn walk [node]\n                (lazy-seq\n                 (cons node\n                  (when (branch? node)\n                    (mapcat walk (children node))))))]\n     (walk root)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [2826
                                                                2839],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2826-L2839"},
                                               :full-name "cljs.core/tree-seq",
                                               :clj-symbol "clojure.core/tree-seq",
                                               :docstring "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n branch? must be a fn of one arg that returns true if passed a node\n that can have children (but may not).  children must be a fn of one\n arg that returns a sequence of the children. Will only be called on\n nodes for which branch? returns true. Root is the root node of the\ntree."},
                         "cljs.reader/read-unmatched-delimiter" {:full-name "cljs.reader/read-unmatched-delimiter",
                                                                 :ns "cljs.reader",
                                                                 :name "read-unmatched-delimiter",
                                                                 :type "function",
                                                                 :signature ["[rdr ch]"],
                                                                 :source {:code "(defn read-unmatched-delimiter\n  [rdr ch]\n  (reader-error rdr \"Unmached delimiter \" ch))",
                                                                          :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                          :lines [268
                                                                                  270],
                                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L268-L270"},
                                                                 :full-name-encode "cljs.reader_read-unmatched-delimiter",
                                                                 :history [["+"
                                                                            "0.0-927"]]},
                         "clojure.core.reducers/take-while" {:ns "clojure.core.reducers",
                                                             :name "take-while",
                                                             :signature ["[pred]"
                                                                         "[pred coll]"],
                                                             :history [["+"
                                                                        "0.0-1236"]],
                                                             :type "function",
                                                             :full-name-encode "clojure.core.reducers_take-while",
                                                             :source {:code "(defcurried take-while\n  \"Ends the reduction of coll when (pred val) returns logical false.\"\n  {}\n  [pred coll]\n  (reducer coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               (reduced ret)))))))",
                                                                      :filename "clojurescript/src/cljs/clojure/core/reducers.cljs",
                                                                      :lines [143
                                                                              153],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/core/reducers.cljs#L143-L153"},
                                                             :full-name "clojure.core.reducers/take-while",
                                                             :clj-symbol "clojure.core.reducers/take-while",
                                                             :docstring "Ends the reduction of coll when (pred val) returns logical false."},
                         "cljs.reader/register-tag-parser!" {:full-name "cljs.reader/register-tag-parser!",
                                                             :ns "cljs.reader",
                                                             :name "register-tag-parser!",
                                                             :type "function",
                                                             :signature ["[tag f]"],
                                                             :source {:code "(defn register-tag-parser!\n  [tag f]\n  (let [tag (str tag)\n        old-parser (get @*tag-table* tag)]\n    (swap! *tag-table* assoc tag f)\n    old-parser))",
                                                                      :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                      :lines [545
                                                                              550],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L545-L550"},
                                                             :full-name-encode "cljs.reader_register-tag-parser_BANG_",
                                                             :history [["+"
                                                                        "0.0-1236"]]},
                         "cljs.core/every-pred" {:ns "cljs.core",
                                                 :name "every-pred",
                                                 :signature ["[p]"
                                                             "[p1 p2]"
                                                             "[p1 p2 p3]"
                                                             "[p1 p2 p3 & ps]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_every-pred",
                                                 :source {:code "(defn every-pred\n  ([p]\n     (fn ep1\n       ([] true)\n       ([x] (boolean (p x)))\n       ([x y] (boolean (and (p x) (p y))))\n       ([x y z] (boolean (and (p x) (p y) (p z))))\n       ([x y z & args] (boolean (and (ep1 x y z)\n                                     (every? p args))))))\n  ([p1 p2]\n     (fn ep2\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x))))\n       ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n       ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n       ([x y z & args] (boolean (and (ep2 x y z)\n                                     (every? #(and (p1 %) (p2 %)) args))))))\n  ([p1 p2 p3]\n     (fn ep3\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n       ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n       ([x y z] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z))))\n       ([x y z & args] (boolean (and (ep3 x y z)\n                                     (every? #(and (p1 %) (p2 %) (p3 %)) args))))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn epn\n         ([] true)\n         ([x] (every? #(% x) ps))\n         ([x y] (every? #(and (% x) (% y)) ps))\n         ([x y z] (every? #(and (% x) (% y) (% z)) ps))\n         ([x y z & args] (boolean (and (epn x y z)\n                                       (every? #(every? % args) ps))))))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2570
                                                                  2607],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2570-L2607"},
                                                 :full-name "cljs.core/every-pred",
                                                 :clj-symbol "clojure.core/every-pred",
                                                 :docstring "Takes a set of predicates and returns a function f that returns true if all of its\ncomposing predicates return a logical true value against all of its arguments, else it returns\nfalse. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical false result against the original predicates."},
                         "cljs.core/PersistentHashSet" {:full-name "cljs.core/PersistentHashSet",
                                                        :ns "cljs.core",
                                                        :name "PersistentHashSet",
                                                        :type "type",
                                                        :signature ["[meta hash-map __hash]"],
                                                        :source {:code "(deftype PersistentHashSet [meta hash-map ^:mutable __hash]\n  IWithMeta\n  (-with-meta [coll meta] (PersistentHashSet. meta hash-map __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (PersistentHashSet. meta (assoc hash-map o nil) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.PersistentHashSet/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (== (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-iset __hash))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (-count hash-map))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if (-contains-key? hash-map v)\n      v\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (PersistentHashSet. meta (-dissoc hash-map v) nil))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll] (TransientHashSet. (-as-transient hash-map))))",
                                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                 :lines [5624
                                                                         5674],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5624-L5674"},
                                                        :full-name-encode "cljs.core_PersistentHashSet",
                                                        :history [["+"
                                                                   "0.0-1211"]]},
                         "clojure.set/rename-keys" {:ns "clojure.set",
                                                    :name "rename-keys",
                                                    :signature ["[map kmap]"],
                                                    :history [["+"
                                                               "0.0-927"]],
                                                    :type "function",
                                                    :full-name-encode "clojure.set_rename-keys",
                                                    :source {:code "(defn rename-keys\n  [map kmap]\n    (reduce \n     (fn [m [old new]]\n       (if (and (not= old new)\n                (contains? m old))\n         (-> m (assoc new (get m old)) (dissoc old))\n         m)) \n     map kmap))",
                                                             :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                             :lines [72
                                                                     81],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/set.cljs#L72-L81"},
                                                    :full-name "clojure.set/rename-keys",
                                                    :clj-symbol "clojure.set/rename-keys",
                                                    :docstring "Returns the map with the keys in kmap renamed to the vals in kmap"},
                         "cljs.core/peek" {:ns "cljs.core",
                                           :name "peek",
                                           :signature ["[coll]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_peek",
                                           :source {:code "(defn peek\n  [coll]\n  (-peek coll))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [939 943],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L939-L943"},
                                           :full-name "cljs.core/peek",
                                           :clj-symbol "clojure.core/peek",
                                           :docstring "For a list or queue, same as first, for a vector, same as, but much\nmore efficient than, last. If the collection is empty, returns nil."},
                         "cljs.core/pr-str-with-opts" {:full-name "cljs.core/pr-str-with-opts",
                                                       :ns "cljs.core",
                                                       :name "pr-str-with-opts",
                                                       :docstring "Prints a sequence of objects to a string, observing all the\noptions given in opts",
                                                       :type "function",
                                                       :signature ["[objs opts]"],
                                                       :source {:code "(defn pr-str-with-opts\n  [objs opts]\n  (if (empty? objs)\n    \"\"\n    (str (pr-sb-with-opts objs opts))))",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [6332
                                                                        6338],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6332-L6338"},
                                                       :full-name-encode "cljs.core_pr-str-with-opts",
                                                       :history [["+"
                                                                  "0.0-927"]]},
                         "cljs.core/IChunk" {:ns "cljs.core",
                                             :name "IChunk",
                                             :type "protocol",
                                             :full-name-encode "cljs.core_IChunk",
                                             :source {:code "(defprotocol IChunk\n  (-drop-first [coll]))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [315 316],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L315-L316"},
                                             :methods [{:name "-drop-first",
                                                        :signature ["[coll]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/IChunk",
                                             :history [["+"
                                                        "0.0-1424"]]},
                         "cljs.core/ITransientVector" {:ns "cljs.core",
                                                       :name "ITransientVector",
                                                       :type "protocol",
                                                       :full-name-encode "cljs.core_ITransientVector",
                                                       :source {:code "(defprotocol ITransientVector\n  (-assoc-n! [tcoll n val])\n  (-pop! [tcoll]))",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [305
                                                                        307],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L305-L307"},
                                                       :methods [{:name "-assoc-n!",
                                                                  :signature ["[tcoll n val]"],
                                                                  :docstring nil}
                                                                 {:name "-pop!",
                                                                  :signature ["[tcoll]"],
                                                                  :docstring nil}],
                                                       :full-name "cljs.core/ITransientVector",
                                                       :history [["+"
                                                                  "0.0-1211"]]},
                         "cljs.core/IPrintWithWriter" {:ns "cljs.core",
                                                       :name "IPrintWithWriter",
                                                       :type "protocol",
                                                       :full-name-encode "cljs.core_IPrintWithWriter",
                                                       :source {:code "(defprotocol IPrintWithWriter\n  \"The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.\"\n  (-pr-writer [o writer opts]))",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [276
                                                                        282],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L276-L282"},
                                                       :methods [{:name "-pr-writer",
                                                                  :signature ["[o writer opts]"],
                                                                  :docstring nil}],
                                                       :full-name "cljs.core/IPrintWithWriter",
                                                       :docstring "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.",
                                                       :history [["+"
                                                                  "0.0-1503"]]},
                         "cljs.core/map?" {:return-type boolean,
                                           :ns "cljs.core",
                                           :name "map?",
                                           :signature ["[x]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_map_QMARK_",
                                           :source {:code "(defn ^boolean map?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? IMap x)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1024 1029],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1024-L1029"},
                                           :full-name "cljs.core/map?",
                                           :clj-symbol "clojure.core/map?",
                                           :docstring "Return true if x satisfies IMap"},
                         "cljs.reader/StringPushbackReader" {:full-name "cljs.reader/StringPushbackReader",
                                                             :ns "cljs.reader",
                                                             :name "StringPushbackReader",
                                                             :type "type",
                                                             :signature ["[s index-atom buffer-atom]"],
                                                             :source {:code "(deftype StringPushbackReader [s index-atom buffer-atom]\n  PushbackReader\n  (read-char [reader]\n             (if (empty? @buffer-atom)\n               (let [idx @index-atom]\n                 (swap! index-atom inc)\n                 (aget s idx))\n               (let [buf @buffer-atom]\n                 (swap! buffer-atom rest)\n                 (first buf))))\n  (unread [reader ch] (swap! buffer-atom #(cons ch %))))",
                                                                      :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                      :lines [18
                                                                              28],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L18-L28"},
                                                             :full-name-encode "cljs.reader_StringPushbackReader",
                                                             :history [["+"
                                                                        "0.0-927"]]},
                         "cljs.core/PersistentTreeMap" {:full-name "cljs.core/PersistentTreeMap",
                                                        :ns "cljs.core",
                                                        :name "PersistentTreeMap",
                                                        :type "type",
                                                        :signature ["[comp tree cnt meta __hash]"],
                                                        :source {:code "(deftype PersistentTreeMap [comp tree cnt meta ^:mutable __hash]\n  Object\n  (entry-at [coll k]\n    (loop [t tree]\n      (if-not (nil? t)\n        (let [c (comp k (.-key t))]\n          (cond (zero? c) t\n                (neg? c)  (recur (.-left t))\n                :else     (recur (.-right t)))))))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentTreeMap. comp tree cnt meta __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.PersistentTreeMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (if-not (nil? tree)\n      (tree-map-kv-reduce tree f init)\n      init))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  ISeqable\n  (-seq [coll]\n    (if (pos? cnt)\n      (create-tree-map-seq tree true cnt)))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? cnt)\n      (create-tree-map-seq tree false cnt)))\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (let [n (.entry-at coll k)]\n      (if-not (nil? n)\n        (.-val n)\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [found (array nil)\n          t     (tree-map-add comp tree k v found)]\n      (if (nil? t)\n        (let [found-node (nth found 0)]\n          (if (= v (.-val found-node))\n            coll\n            (PersistentTreeMap. comp (tree-map-replace comp tree k v) cnt meta nil)))\n        (PersistentTreeMap. comp (.blacken t) (inc cnt) meta nil))))\n\n  (-contains-key? [coll k]\n    (not (nil? (.entry-at coll k))))\n\n  IMap\n  (-dissoc [coll k]\n    (let [found (array nil)\n          t     (tree-map-remove comp tree k found)]\n      (if (nil? t)\n        (if (nil? (nth found 0))\n          coll\n          (PersistentTreeMap. comp nil 0 meta nil))\n        (PersistentTreeMap. comp (.blacken t) (dec cnt) meta nil))))\n\n  ISorted\n  (-sorted-seq [coll ascending?]\n    (if (pos? cnt)\n      (create-tree-map-seq tree ascending? cnt)))\n\n  (-sorted-seq-from [coll k ascending?]\n    (if (pos? cnt)\n      (loop [stack nil t tree]\n        (if-not (nil? t)\n          (let [c (comp k (.-key t))]\n            (cond\n              (zero? c)  (PersistentTreeMapSeq. nil (conj stack t) ascending? -1 nil)\n              ascending? (if (neg? c)\n                           (recur (conj stack t) (.-left t))\n                           (recur stack          (.-right t)))\n              :else      (if (pos? c)\n                           (recur (conj stack t) (.-right t))\n                           (recur stack          (.-left t)))))\n          (when-not (nil? stack)\n            (PersistentTreeMapSeq. nil stack ascending? -1 nil))))))\n\n  (-entry-key [coll entry] (key entry))\n\n  (-comparator [coll] comp))",
                                                                 :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                 :lines [5395
                                                                         5511],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5395-L5511"},
                                                        :full-name-encode "cljs.core_PersistentTreeMap",
                                                        :history [["+"
                                                                   "0.0-1211"]]},
                         "cljs.core/deref" {:full-name "cljs.core/deref",
                                            :ns "cljs.core",
                                            :name "deref",
                                            :type "function",
                                            :signature ["[o]"],
                                            :source {:code "(defn deref\n  [o]\n  (-deref o))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [6596
                                                             6598],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6596-L6598"},
                                            :full-name-encode "cljs.core_deref",
                                            :clj-symbol "clojure.core/deref",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/reductions" {:ns "cljs.core",
                                                 :name "reductions",
                                                 :signature ["[f coll]"
                                                             "[f init coll]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_reductions",
                                                 :source {:code "(defn reductions\n  ([f coll]\n     (lazy-seq\n      (if-let [s (seq coll)]\n        (reductions f (first s) (rest s))\n        (list (f)))))\n  ([f init coll]\n     (cons init\n           (lazy-seq\n            (when-let [s (seq coll)]\n              (reductions f (f init (first s)) (rest s)))))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [6084
                                                                  6096],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6084-L6096"},
                                                 :full-name "cljs.core/reductions",
                                                 :clj-symbol "clojure.core/reductions",
                                                 :docstring "Returns a lazy seq of the intermediate values of the reduction (as\nper reduce) of coll by f, starting with init."},
                         "cljs.core/false?" {:return-type boolean,
                                             :ns "cljs.core",
                                             :name "false?",
                                             :signature ["[x]"],
                                             :shadowed-sources ({:code "(defmacro false? [x]\n  (bool-expr (list 'js* \"~{} === false\" x)))",
                                                                 :filename "clojurescript/src/clj/cljs/core.clj",
                                                                 :lines [230
                                                                         231],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L230-L231"}),
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_false_QMARK_",
                                             :source {:code "(defn ^boolean false?\n  [x] (cljs.core/false? x))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [1077
                                                              1079],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1077-L1079"},
                                             :full-name "cljs.core/false?",
                                             :clj-symbol "clojure.core/false?",
                                             :docstring "Returns true if x is the value false, false otherwise."},
                         "cljs.core/bit-flip" {:ns "cljs.core",
                                               :name "bit-flip",
                                               :signature ["[x n]"],
                                               :shadowed-sources ({:code "(defmacro bit-flip [x n]\n  (list 'js* \"(~{} ^ (1 << ~{}))\" x n))",
                                                                   :filename "clojurescript/src/clj/cljs/core.clj",
                                                                   :lines [427
                                                                           428],
                                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L427-L428"}),
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_bit-flip",
                                               :source {:code "(defn bit-flip\n  [x n]\n  (cljs.core/bit-flip x n))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [1587
                                                                1590],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1587-L1590"},
                                               :full-name "cljs.core/bit-flip",
                                               :clj-symbol "clojure.core/bit-flip",
                                               :docstring "Flip bit at index n"},
                         "cljs.core/ISet" {:ns "cljs.core",
                                           :name "ISet",
                                           :type "protocol",
                                           :full-name-encode "cljs.core_ISet",
                                           :source {:code "(defprotocol ISet\n  (-disjoin [coll v]))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [217 218],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L217-L218"},
                                           :methods [{:name "-disjoin",
                                                      :signature ["[coll v]"],
                                                      :docstring nil}],
                                           :full-name "cljs.core/ISet",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/LazySeq" {:full-name "cljs.core/LazySeq",
                                              :ns "cljs.core",
                                              :name "LazySeq",
                                              :type "type",
                                              :signature ["[meta realized x __hash]"],
                                              :source {:code "(deftype LazySeq [meta realized x ^:mutable __hash]\n  IWithMeta\n  (-with-meta [coll meta] (LazySeq. meta realized x __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first (lazy-seq-value coll)))\n  (-rest [coll] (rest (lazy-seq-value coll)))\n\n  INext\n  (-next [coll] (-seq (-rest coll)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (seq (lazy-seq-value coll))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1981
                                                               2010],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1981-L2010"},
                                              :full-name-encode "cljs.core_LazySeq",
                                              :history [["+"
                                                         "0.0-927"]]},
                         "cljs.core/pop!" {:full-name "cljs.core/pop!",
                                           :ns "cljs.core",
                                           :name "pop!",
                                           :type "function",
                                           :signature ["[tcoll]"],
                                           :source {:code "(defn pop! [tcoll]\n  (-pop! tcoll))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [2309 2310],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2309-L2310"},
                                           :full-name-encode "cljs.core_pop_BANG_",
                                           :clj-symbol "clojure.core/pop!",
                                           :history [["+" "0.0-1211"]]},
                         "cljs.reader/parse-timestamp" {:full-name "cljs.reader/parse-timestamp",
                                                        :ns "cljs.reader",
                                                        :name "parse-timestamp",
                                                        :type "function",
                                                        :signature ["[ts]"],
                                                        :source {:code "(defn parse-timestamp\n  [ts]\n  (if-let [[years months days hours minutes seconds ms offset]\n           (parse-and-validate-timestamp ts)]\n    (js/Date.\n     (- (.UTC js/Date years (dec months) days hours minutes seconds ms)\n        (* offset 60 1000)))\n    (reader-error nil (str \"Unrecognized date/time syntax: \" ts))))",
                                                                 :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                                 :lines [497
                                                                         504],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L497-L504"},
                                                        :full-name-encode "cljs.reader_parse-timestamp",
                                                        :history [["+"
                                                                   "0.0-1424"]]},
                         "cljs.core/chunk-first" {:full-name "cljs.core/chunk-first",
                                                  :ns "cljs.core",
                                                  :name "chunk-first",
                                                  :type "function",
                                                  :signature ["[s]"],
                                                  :source {:code "(defn chunk-first [s]\n  (-chunked-first s))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [2122
                                                                   2123],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2122-L2123"},
                                                  :full-name-encode "cljs.core_chunk-first",
                                                  :history [["+"
                                                             "0.0-1424"]]},
                         "cljs.core/ChunkedSeq" {:full-name "cljs.core/ChunkedSeq",
                                                 :ns "cljs.core",
                                                 :name "ChunkedSeq",
                                                 :type "type",
                                                 :signature ["[vec node i off meta __hash]"],
                                                 :source {:code "(deftype ChunkedSeq [vec node i off meta ^:mutable __hash]\n  IWithMeta\n  (-with-meta [coll m]\n    (chunked-seq vec node i off m))\n  (-meta [coll] meta)\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ASeq\n  ISeq\n  (-first [coll]\n    (aget node off))\n  (-rest [coll]\n    (if (< (inc off) (alength node))\n      (let [s (chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          ()\n          s))\n      (-chunked-rest coll)))\n\n  INext\n  (-next [coll]\n    (if (< (inc off) (alength node))\n      (let [s (chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          nil\n          s))\n      (-chunked-next coll)))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll]\n    (with-meta cljs.core.PersistentVector/EMPTY meta))\n\n  IChunkedSeq\n  (-chunked-first [coll]\n    (array-chunk node off))\n  (-chunked-rest [coll]\n    (let [l (alength node)\n          s (when (< (+ i l) (-count vec))\n              (chunked-seq vec (+ i l) 0))]\n      (if (nil? s)\n        ()\n        s)))\n\n  IChunkedNext\n  (-chunked-next [coll]\n    (let [l (alength node)\n          s (when (< (+ i l) (-count vec))\n              (chunked-seq vec (+ i l) 0))]\n      (if (nil? s)\n        nil\n        s)))\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash)))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [3213
                                                                  3275],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L3213-L3275"},
                                                 :full-name-encode "cljs.core_ChunkedSeq",
                                                 :history [["+"
                                                            "0.0-1424"]]},
                         "cljs.core/*2" {:full-name "cljs.core/*2",
                                         :ns "cljs.core",
                                         :name "*2",
                                         :docstring "bound in a repl thread to the second most recent value printed",
                                         :type "var",
                                         :source {:code "(def\n  ^{:doc \"bound in a repl thread to the second most recent value printed\"}\n  *2)",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [34 36],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L34-L36"},
                                         :full-name-encode "cljs.core__STAR_2",
                                         :clj-symbol "clojure.core/*2",
                                         :history [["+" "0.0-927"]]},
                         "clojure.browser.event/total-listener-count" {:full-name "clojure.browser.event/total-listener-count",
                                                                       :ns "clojure.browser.event",
                                                                       :name "total-listener-count",
                                                                       :type "function",
                                                                       :signature ["[]"],
                                                                       :source {:code "(defn total-listener-count []\n  (goog.events/getTotalListenerCount))",
                                                                                :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                                :lines [85
                                                                                        86],
                                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/event.cljs#L85-L86"},
                                                                       :full-name-encode "clojure.browser.event_total-listener-count",
                                                                       :history [["+"
                                                                                  "0.0-927"]]},
                         "cljs.core/alter-meta!" {:ns "cljs.core",
                                                  :name "alter-meta!",
                                                  :signature ["[iref f & args]"],
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.core_alter-meta_BANG_",
                                                  :source {:code "(defn alter-meta!\n  [iref f & args]\n  (set! (.-meta iref) (apply f (.-meta iref) args)))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [6615
                                                                   6622],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6615-L6622"},
                                                  :full-name "cljs.core/alter-meta!",
                                                  :clj-symbol "clojure.core/alter-meta!",
                                                  :docstring "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n(apply f its-current-meta args)\n\nf must be free of side-effects"},
                         "clojure.browser.dom/click-element" {:full-name "clojure.browser.dom/click-element",
                                                              :ns "clojure.browser.dom",
                                                              :name "click-element",
                                                              :type "function",
                                                              :signature ["[e]"],
                                                              :source {:code "(defn click-element\n  [e]\n  (.click (ensure-element e) ()))",
                                                                       :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                       :lines [147
                                                                               149],
                                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/dom.cljs#L147-L149"},
                                                              :full-name-encode "clojure.browser.dom_click-element",
                                                              :history [["+"
                                                                         "0.0-927"]]},
                         "cljs.core/unchecked-remainder-int" {:ns "cljs.core",
                                                              :name "unchecked-remainder-int",
                                                              :signature ["[x n]"],
                                                              :shadowed-sources ({:code "(defmacro unchecked-remainder-int\n  ([x n] `(mod ~x ~n)))",
                                                                                  :filename "clojurescript/src/clj/cljs/core.clj",
                                                                                  :lines [314
                                                                                          315],
                                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L314-L315"}),
                                                              :history [["+"
                                                                         "0.0-1798"]],
                                                              :type "function",
                                                              :full-name-encode "cljs.core_unchecked-remainder-int",
                                                              :source {:code "(defn unchecked-remainder-int [x n]\n  (cljs.core/unchecked-remainder-int x n))",
                                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                       :lines [1484
                                                                               1485],
                                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1484-L1485"},
                                                              :full-name "cljs.core/unchecked-remainder-int",
                                                              :clj-symbol "clojure.core/unchecked-remainder-int"},
                         "cljs.core/bit-shift-right-zero-fill" {:ns "cljs.core",
                                                                :name "bit-shift-right-zero-fill",
                                                                :signature ["[x n]"],
                                                                :shadowed-sources ({:code "(defmacro bit-shift-right-zero-fill [x n]\n  (list 'js* \"(~{} >>> ~{})\" x n))",
                                                                                    :filename "clojurescript/src/clj/cljs/core.clj",
                                                                                    :lines [439
                                                                                            440],
                                                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L439-L440"}),
                                                                :history [["+"
                                                                           "0.0-1211"]],
                                                                :type "function",
                                                                :full-name-encode "cljs.core_bit-shift-right-zero-fill",
                                                                :source {:code "(defn bit-shift-right-zero-fill\n  [x n] (cljs.core/bit-shift-right-zero-fill x n))",
                                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                         :lines [1614
                                                                                 1616],
                                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1614-L1616"},
                                                                :full-name "cljs.core/bit-shift-right-zero-fill",
                                                                :docstring "Bitwise shift right with zero fill"},
                         "cljs.reader/read-meta" {:full-name "cljs.reader/read-meta",
                                                  :ns "cljs.reader",
                                                  :name "read-meta",
                                                  :type "function",
                                                  :signature ["[rdr _]"],
                                                  :source {:code "(defn read-meta\n  [rdr _]\n  (let [m (desugar-meta (read rdr true nil true))]\n    (when-not (map? m)\n      (reader-error rdr \"Metadata must be Symbol,Keyword,String or Map\"))\n    (let [o (read rdr true nil true)]\n      (if (satisfies? IWithMeta o)\n        (with-meta o (merge (meta o) m))\n        (reader-error rdr \"Metadata can only be applied to IWithMetas\")))))",
                                                           :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                           :lines [361
                                                                   369],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L361-L369"},
                                                  :full-name-encode "cljs.reader_read-meta",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "special/try*" {:full-name "special/try*",
                                         :ns "special",
                                         :name "try*",
                                         :type "special form",
                                         :source {:code "(defmethod parse 'try*\n  [op env [_ & body :as form] name]\n  (let [body (vec body)\n        catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        tail (peek body)\n        fblock (when (and (seq? tail) (= 'finally (first tail)))\n                  (rest tail))\n        finally (when fblock\n                  (analyze (assoc env :context :statement) `(do ~@fblock)))\n        body (if finally (pop body) body)\n        tail (peek body)\n        cblock (when (and (seq? tail)\n                          (= 'catch (first tail)))\n                 (rest tail))\n        name (first cblock)\n        locals (:locals catchenv)\n        locals (if name\n                 (assoc locals name\n                   {:name name\n                    :line (get-line name env)\n                    :column (get-col name env)})\n                 locals)\n        catch (when cblock\n                (analyze (assoc catchenv :locals locals) `(do ~@(rest cblock))))\n        body (if name (pop body) body)\n        try (analyze (if (or name finally) catchenv env) `(do ~@body))]\n    (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n    {:env env :op :try* :form form\n     :try try\n     :finally finally\n     :name name\n     :catch catch\n     :children [try catch finally]}))",
                                                  :filename "clojurescript/src/clj/cljs/analyzer.clj",
                                                  :lines [262 294],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/analyzer.clj#L262-L294"},
                                         :full-name-encode "special_try_STAR_",
                                         :history [["+" "0.0-927"]]},
                         "cljs.core/range" {:ns "cljs.core",
                                            :name "range",
                                            :signature ["[]"
                                                        "[end]"
                                                        "[start end]"
                                                        "[start end step]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_range",
                                            :source {:code "(defn range\n  ([] (range 0 js/Number.MAX_VALUE 1))\n  ([end] (range 0 end 1))\n  ([start end] (range start end 1))\n  ([start end step] (Range. nil start end step nil)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [6043
                                                             6050],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6043-L6050"},
                                            :full-name "cljs.core/range",
                                            :clj-symbol "clojure.core/range",
                                            :docstring "Returns a lazy seq of nums from start (inclusive) to end\n(exclusive), by step, where start defaults to 0, step to 1,\nand end to infinity."},
                         "cljs.core/reify" {:full-name "cljs.core/reify",
                                            :ns "cljs.core",
                                            :name "reify",
                                            :type "macro",
                                            :signature ["[& impls]"],
                                            :source {:code "(defmacro reify [& impls]\n  (let [t      (gensym \"t\")\n        meta-sym (gensym \"meta\")\n        this-sym (gensym \"_\")\n        locals (keys (:locals &env))\n        ns     (-> &env :ns :name)\n        munge  cljs.compiler/munge\n        ns-t   (list 'js* (core/str (munge ns) \".\" (munge t)))]\n    `(do\n       (when (undefined? ~ns-t)\n         (deftype ~t [~@locals ~meta-sym]\n           IWithMeta\n           (~'-with-meta [~this-sym ~meta-sym]\n             (new ~t ~@locals ~meta-sym))\n           IMeta\n           (~'-meta [~this-sym] ~meta-sym)\n           ~@impls))\n       (new ~t ~@locals nil))))",
                                                     :filename "clojurescript/src/clj/cljs/core.clj",
                                                     :lines [508 525],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L508-L525"},
                                            :full-name-encode "cljs.core_reify",
                                            :clj-symbol "clojure.core/reify",
                                            :history [["+" "0.0-927"]]},
                         "cljs.core/satisfies?" {:ns "cljs.core",
                                                 :name "satisfies?",
                                                 :signature ["[psym x]"
                                                             "[psym x check-native]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "macro",
                                                 :full-name-encode "cljs.core_satisfies_QMARK_",
                                                 :source {:code "(defmacro satisfies?\n  ([psym x] `(satisfies? ~psym ~x true))\n  ([psym x check-native]\n    (let [p          (:name\n                       (cljs.analyzer/resolve-var\n                         (dissoc &env :locals) psym))\n          prefix     (protocol-prefix p)\n          xsym       (bool-expr (gensym))\n          [part bit] (fast-path-protocols p)\n          msym       (symbol\n                       (core/str \"-cljs$lang$protocol_mask$partition\" part \"$\"))]\n      `(let [~xsym ~x]\n         (if ~xsym\n           (if (or ~(if bit `(unsafe-bit-and (. ~xsym ~msym) ~bit))\n                 ~(bool-expr `(. ~xsym ~(symbol (core/str \"-\" prefix)))))\n             true\n             ~(if check-native\n                `(if (coercive-not (. ~xsym ~msym))\n                   (cljs.core/type_satisfies_ ~psym ~xsym)\n                   false)\n                false))\n           ~(if check-native\n              `(cljs.core/type_satisfies_ ~psym ~xsym)\n              false))))))",
                                                          :filename "clojurescript/src/clj/cljs/core.clj",
                                                          :lines [829
                                                                  853],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L829-L853"},
                                                 :full-name "cljs.core/satisfies?",
                                                 :clj-symbol "clojure.core/satisfies?",
                                                 :docstring "Returns true if x satisfies the protocol"},
                         "cljs.core/nth" {:ns "cljs.core",
                                          :name "nth",
                                          :signature ["[coll n]"
                                                      "[coll n not-found]"],
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "cljs.core_nth",
                                          :source {:code "(defn nth\n  ([coll n]\n     (when-not (nil? coll)\n       (cond\n         (satisfies? IIndexed coll false)\n         (-nth ^not-native coll (.floor js/Math n))\n\n         (array? coll)\n         (when (< n (.-length coll))\n           (aget coll n))\n         \n         (string? coll)\n         (when (< n (.-length coll))\n           (aget coll n))\n         \n         :else\n         (linear-traversal-nth coll (.floor js/Math n)))))\n  ([coll n not-found]\n     (if-not (nil? coll)\n       (cond\n         (satisfies? IIndexed coll false)\n         (-nth ^not-native coll (.floor js/Math n) not-found)\n\n         (array? coll)\n         (if (< n (.-length coll))\n           (aget coll n)\n           not-found)\n         \n         (string? coll)\n         (if (< n (.-length coll))\n           (aget coll n)\n           not-found)\n         \n         :else\n         (linear-traversal-nth coll (.floor js/Math n) not-found))\n       not-found)))",
                                                   :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                   :lines [813 852],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L813-L852"},
                                          :full-name "cljs.core/nth",
                                          :clj-symbol "clojure.core/nth",
                                          :docstring "Returns the value at the index. get returns nil if index out of\nbounds, nth throws an exception unless not-found is supplied.  nth\nalso works for strings, arrays, regex Matchers and Lists, and,\nin O(n) time, for sequences."},
                         "cljs.core/list" {:full-name "cljs.core/list",
                                           :ns "cljs.core",
                                           :name "list",
                                           :type "function",
                                           :signature ["[& xs]"],
                                           :source {:code "(defn list [& xs]\n  (let [arr (if (instance? IndexedSeq xs)\n              (.-arr xs)\n              (let [arr (array)]\n                (loop [^not-native xs xs]\n                  (if-not (nil? xs)\n                    (do\n                      (.push arr (-first xs))\n                      (recur (-next xs)))\n                    arr))))]\n    (loop [i (alength arr) ^not-native r ()]\n      (if (> i 0)\n        (recur (dec i) (-conj r (aget arr (dec i))))\n        r))))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1874 1887],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1874-L1887"},
                                           :full-name-encode "cljs.core_list",
                                           :clj-symbol "clojure.core/list",
                                           :history [["+" "0.0-927"]]},
                         "cljs.core/defn" {:ns "cljs.core",
                                           :name "defn",
                                           :signature ["[name doc-string? attr-map? [params*] prepost-map? body]"
                                                       "[name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?]"],
                                           :history [["+" "0.0-927"]],
                                           :type "macro",
                                           :full-name-encode "cljs.core_defn",
                                           :source {:code "(def \n\n ^{:doc \"Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.\"\n   :arglists '([name doc-string? attr-map? [params*] prepost-map? body]\n                [name doc-string? attr-map? ([params*] prepost-map? body)+ attr-map?])\n   :added \"1.0\"}\n defn (fn defn [&form &env name & fdecl]\n        ;; Note: Cannot delegate this check to def because of the call to (with-meta name ..)\n        (if (instance? clojure.lang.Symbol name)\n          nil\n          (throw (IllegalArgumentException. \"First argument to defn must be a symbol\")))\n        (let [m (if (string? (first fdecl))\n                  {:doc (first fdecl)}\n                  {})\n              fdecl (if (string? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              m (if (map? (first fdecl))\n                  (conj m (first fdecl))\n                  m)\n              fdecl (if (map? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              fdecl (if (vector? (first fdecl))\n                      (list fdecl)\n                      fdecl)\n              m (if (map? (last fdecl))\n                  (conj m (last fdecl))\n                  m)\n              fdecl (if (map? (last fdecl))\n                      (butlast fdecl)\n                      fdecl)\n              m (conj {:arglists (list 'quote (sigs fdecl))} m)\n              m (let [inline (:inline m)\n                      ifn (first inline)\n                      iname (second inline)]\n                  ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)\n                  (if (if (clojure.lang.Util/equiv 'fn ifn)\n                        (if (instance? clojure.lang.Symbol iname) false true))\n                    ;; inserts the same fn name to the inline fn if it does not have one\n                    (assoc m :inline (cons ifn (cons (clojure.lang.Symbol/intern (.concat (.getName ^clojure.lang.Symbol name) \"__inliner\"))\n                                                     (next inline))))\n                    m))\n              m (conj (if (meta name) (meta name) {}) m)]\n          (list 'def (with-meta name m)\n                ;;todo - restore propagation of fn name\n                ;;must figure out how to convey primitive hints to self calls first\n                (cons `fn fdecl) ))))",
                                                    :filename "clojure/src/clj/clojure/core.clj",
                                                    :lines [266 316],
                                                    :link "https://github.com/clojure/clojure/blob/clojure-1.5.1/src/clj/clojure/core.clj#L266-L316"},
                                           :full-name "cljs.core/defn",
                                           :clj-symbol "clojure.core/defn",
                                           :docstring "Same as (def name (fn [params* ] exprs*)) or (def\n name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n to the var metadata. prepost-map defines a map with optional keys\n :pre and :post that contain collections of pre or post conditions."},
                         "cljs.core/rand-nth" {:ns "cljs.core",
                                               :name "rand-nth",
                                               :signature ["[coll]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_rand-nth",
                                               :source {:code "(defn rand-nth\n  [coll]\n  (nth coll (rand-int (count coll))))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [6819
                                                                6824],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6819-L6824"},
                                               :full-name "cljs.core/rand-nth",
                                               :clj-symbol "clojure.core/rand-nth",
                                               :docstring "Return a random element of the (sequential) collection. Will have\nthe same performance characteristics as nth for the given\ncollection."},
                         "cljs.core/ex-cause" {:full-name "cljs.core/ex-cause",
                                               :ns "cljs.core",
                                               :name "ex-cause",
                                               :docstring "Alpha - subject to change.\nReturns exception cause (an Error / ExceptionInfo) if ex is an\nExceptionInfo.\nOtherwise returns nil.",
                                               :type "function",
                                               :signature ["[ex]"],
                                               :source {:code "(defn ex-cause\n  [ex]\n  (when (instance? ExceptionInfo ex)\n    (.-cause ex)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [7157
                                                                7164],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L7157-L7164"},
                                               :full-name-encode "cljs.core_ex-cause",
                                               :history [["+"
                                                          "0.0-1576"]]},
                         "cljs.core/atom" {:ns "cljs.core",
                                           :name "atom",
                                           :signature ["[x]"
                                                       "[x & {:keys [meta validator]}]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_atom",
                                           :source {:code "(defn atom\n  ([x] (Atom. x nil nil nil))\n  ([x & {:keys [meta validator]}] (Atom. x meta validator nil)))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [6540 6555],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6540-L6555"},
                                           :full-name "cljs.core/atom",
                                           :clj-symbol "clojure.core/atom",
                                           :docstring "Creates and returns an Atom with an initial value of x and zero or\nmore options (in any order):\n\n:meta metadata-map\n\n:validator validate-fn\n\nIf metadata-map is supplied, it will be come the metadata on the\natom. validate-fn must be nil or a side-effect-free fn of one\nargument, which will be passed the intended new state on any state\nchange. If the new state is unacceptable, the validate-fn should\nreturn false or throw an Error.  If either of these error conditions\noccur, then the value of the atom will not change."},
                         "cljs.reader/read-keyword" {:full-name "cljs.reader/read-keyword",
                                                     :ns "cljs.reader",
                                                     :name "read-keyword",
                                                     :type "function",
                                                     :signature ["[reader initch]"],
                                                     :source {:code "(defn read-keyword\n  [reader initch]\n  (let [token (read-token reader (read-char reader))\n        a (re-matches* symbol-pattern token)\n        token (aget a 0)\n        ns (aget a 1)\n        name (aget a 2)]\n    (if (or (and (not (undefined? ns))\n                 (identical? (. ns (substring (- (.-length ns) 2) (.-length ns))) \":/\"))\n            (identical? (aget name (dec (.-length name))) \":\")\n            (not (== (.indexOf token \"::\" 1) -1)))\n      (reader-error reader \"Invalid token: \" token)\n      (if (and (not (nil? ns)) (> (.-length ns) 0))\n        (keyword (.substring ns 0 (.indexOf ns \"/\")) name)\n        (keyword token)))))",
                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                              :lines [327
                                                                      341],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L327-L341"},
                                                     :full-name-encode "cljs.reader_read-keyword",
                                                     :history [["+"
                                                                "0.0-927"]]},
                         "cljs.core/Vector" {:full-name "cljs.core/Vector",
                                             :ns "cljs.core",
                                             :name "Vector",
                                             :type "type",
                                             :signature ["[meta array __hash]"],
                                             :source {:code "(deftype Vector [meta array ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (Vector. meta array __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (let [count (alength array)]\n      (when (> count 0)\n        (aget array (dec count)))))\n  (-pop [coll]\n    (if (> (alength array) 0)\n      (let [new-array (aclone array)]\n        (. new-array (pop))\n        (Vector. meta new-array nil))\n      (throw (js/Error. \"Can't pop empty vector\"))))\n\n  ICollection\n  (-conj [coll o]\n    (let [new-array (aclone array)]\n      (.push new-array o)\n      (Vector. meta new-array nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Vector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (> (alength array) 0)\n      (let [vector-seq\n             (fn vector-seq [i]\n               (lazy-seq\n                 (when (< i (alength array))\n                   (cons (aget array i) (vector-seq (inc i))))))]\n        (vector-seq 0))))\n\n  ICounted\n  (-count [coll] (alength array))\n\n  IIndexed\n  (-nth [coll n]\n    (if (and (<= 0 n) (< n (alength array)))\n      (aget array n)\n      #_(throw (js/Error. (str \"No item \" n \" in vector of length \" (alength array))))))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n (alength array)))\n      (aget array n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [new-array (aclone array)]\n      (aset new-array k v)\n      (Vector. meta new-array nil)))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [v f]\n    (ci-reduce array f))\n  (-reduce [v f start]\n    (ci-reduce array f start))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2772
                                                              2857],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1586/src/cljs/cljs/core.cljs#L2772-L2857"},
                                             :full-name-encode "cljs.core_Vector",
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1798"]],
                                             :removed {:in "0.0-1798",
                                                       :last-seen "0.0-1586"}},
                         "cljs.reader/skip-line" {:full-name "cljs.reader/skip-line",
                                                  :ns "cljs.reader",
                                                  :name "skip-line",
                                                  :docstring "Advances the reader to the end of a line. Returns the reader",
                                                  :type "function",
                                                  :signature ["[reader _]"],
                                                  :source {:code "(defn skip-line\n  [reader _]\n  (loop []\n    (let [ch (read-char reader)]\n      (if (or (identical? ch \\n) (identical? ch \\r) (nil? ch))\n        reader\n        (recur)))))",
                                                           :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                           :lines [90
                                                                   97],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L90-L97"},
                                                  :full-name-encode "cljs.reader_skip-line",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/namespace" {:ns "cljs.core",
                                                :name "namespace",
                                                :signature ["[x]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_namespace",
                                                :source {:code "(defn namespace\n  [x]\n  (if (satisfies? INamed x false)\n    (-namespace ^not-native x)\n    (if (keyword? x)\n      (let [i (.lastIndexOf x \"/\" (- (alength x) 2))]\n        (when (> i -1)\n          (subs x 2 i)))\n      (throw (js/Error. (str \"Doesn't support namespace: \" x))))))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [5884
                                                                 5893],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5884-L5893"},
                                                :full-name "cljs.core/namespace",
                                                :clj-symbol "clojure.core/namespace",
                                                :docstring "Returns the namespace String of a symbol or keyword, or nil if not present."},
                         "cljs.nodejs/require" {:full-name "cljs.nodejs/require",
                                                :ns "cljs.nodejs",
                                                :name "require",
                                                :type "var",
                                                :source {:code "(def require (js* \"require\"))",
                                                         :filename "clojurescript/src/cljs/cljs/nodejs.cljs",
                                                         :lines [7 7],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/nodejs.cljs#L7-L7"},
                                                :full-name-encode "cljs.nodejs_require",
                                                :history [["+"
                                                           "0.0-927"]]},
                         "cljs.core/chunk-rest" {:full-name "cljs.core/chunk-rest",
                                                 :ns "cljs.core",
                                                 :name "chunk-rest",
                                                 :type "function",
                                                 :signature ["[s]"],
                                                 :source {:code "(defn chunk-rest [s]\n  (-chunked-rest s))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2125
                                                                  2126],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2125-L2126"},
                                                 :full-name-encode "cljs.core_chunk-rest",
                                                 :history [["+"
                                                            "0.0-1424"]]},
                         "cljs.core/unchecked-long" {:ns "cljs.core",
                                                     :name "unchecked-long",
                                                     :signature ["[x]"],
                                                     :history [["+"
                                                                "0.0-1798"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.core_unchecked-long",
                                                     :source {:code "(defn unchecked-long\n  [x]\n  (fix x))",
                                                              :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                              :lines [1521
                                                                      1524],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1521-L1524"},
                                                     :full-name "cljs.core/unchecked-long",
                                                     :clj-symbol "clojure.core/unchecked-long",
                                                     :docstring "Coerce to long by stripping decimal places. Identical to `int'."},
                         "clojure.browser.event/EventType" {:ns "clojure.browser.event",
                                                            :name "EventType",
                                                            :type "protocol",
                                                            :full-name-encode "clojure.browser.event_EventType",
                                                            :source {:code "(defprotocol EventType\n  (event-types [this]))",
                                                                     :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                     :lines [17
                                                                             18],
                                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/event.cljs#L17-L18"},
                                                            :methods [{:name "event-types",
                                                                       :signature ["[this]"],
                                                                       :docstring nil}],
                                                            :full-name "clojure.browser.event/EventType",
                                                            :history [["+"
                                                                       "0.0-927"]]},
                         "cljs.core/merge" {:ns "cljs.core",
                                            :name "merge",
                                            :signature ["[& maps]"],
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "cljs.core_merge",
                                            :source {:code "(defn merge\n  [& maps]\n  (when (some identity maps)\n    (reduce #(conj (or %1 {}) %2) maps)))",
                                                     :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                     :lines [5582
                                                             5588],
                                                     :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5582-L5588"},
                                            :full-name "cljs.core/merge",
                                            :clj-symbol "clojure.core/merge",
                                            :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping from\nthe latter (left-to-right) will be the mapping in the result."},
                         "clojure.core.reducers/remove" {:ns "clojure.core.reducers",
                                                         :name "remove",
                                                         :signature ["[pred]"
                                                                     "[pred coll]"],
                                                         :history [["+"
                                                                    "0.0-1236"]],
                                                         :type "function",
                                                         :full-name-encode "clojure.core.reducers_remove",
                                                         :source {:code "(defcurried remove\n  \"Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.\"\n  {}\n  [pred coll]\n  (filter (complement pred) coll))",
                                                                  :filename "clojurescript/src/cljs/clojure/core/reducers.cljs",
                                                                  :lines [136
                                                                          141],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/core/reducers.cljs#L136-L141"},
                                                         :full-name "clojure.core.reducers/remove",
                                                         :clj-symbol "clojure.core.reducers/remove",
                                                         :docstring "Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."},
                         "clojure.browser.repl/send-result" {:full-name "clojure.browser.repl/send-result",
                                                             :ns "clojure.browser.repl",
                                                             :name "send-result",
                                                             :type "function",
                                                             :signature ["[connection url data]"],
                                                             :source {:code "(defn send-result [connection url data]\n  (net/transmit connection url \"POST\" data nil 0))",
                                                                      :filename "clojurescript/src/cljs/clojure/browser/repl.cljs",
                                                                      :lines [38
                                                                              39],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/repl.cljs#L38-L39"},
                                                             :full-name-encode "clojure.browser.repl_send-result",
                                                             :history [["+"
                                                                        "0.0-927"]]},
                         "clojure.walk/keywordize-keys" {:ns "clojure.walk",
                                                         :name "keywordize-keys",
                                                         :signature ["[m]"],
                                                         :history [["+"
                                                                    "0.0-927"]],
                                                         :type "function",
                                                         :full-name-encode "clojure.walk_keywordize-keys",
                                                         :source {:code "(defn keywordize-keys\n  [m]\n  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                                  :filename "clojurescript/src/cljs/clojure/walk.cljs",
                                                                  :lines [64
                                                                          70],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/walk.cljs#L64-L70"},
                                                         :full-name "clojure.walk/keywordize-keys",
                                                         :clj-symbol "clojure.walk/keywordize-keys",
                                                         :docstring "Recursively transforms all map keys from strings to keywords."},
                         "cljs.core/reduced" {:ns "cljs.core",
                                              :name "reduced",
                                              :signature ["[x]"],
                                              :history [["+"
                                                         "0.0-1211"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_reduced",
                                              :source {:code "(defn reduced\n  [x]\n  (Reduced. x))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [530
                                                               533],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L530-L533"},
                                              :full-name "cljs.core/reduced",
                                              :clj-symbol "clojure.core/reduced",
                                              :docstring "Wraps x in a way such that a reduce will terminate with the value x"},
                         "cljs.reader/read-string*" {:full-name "cljs.reader/read-string*",
                                                     :ns "cljs.reader",
                                                     :name "read-string*",
                                                     :type "function",
                                                     :signature ["[reader _]"],
                                                     :source {:code "(defn read-string*\n  [reader _]\n  (loop [buffer (gstring/StringBuffer.)\n         ch (read-char reader)]\n    (cond\n     (nil? ch) (reader-error reader \"EOF while reading\")\n     (identical? \"\\\\\" ch) (recur (do (.append buffer (escape-char buffer reader)) buffer)\n                        (read-char reader))\n     (identical? \\\" ch) (. buffer (toString))\n     :default (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                                              :filename "clojurescript/src/cljs/cljs/reader.cljs",
                                                              :lines [301
                                                                      310],
                                                              :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/reader.cljs#L301-L310"},
                                                     :full-name-encode "cljs.reader_read-string_STAR_",
                                                     :history [["+"
                                                                "0.0-1236"]]},
                         "cljs.core/ChunkedCons" {:full-name "cljs.core/ChunkedCons",
                                                  :ns "cljs.core",
                                                  :name "ChunkedCons",
                                                  :type "type",
                                                  :signature ["[chunk more meta __hash]"],
                                                  :source {:code "(deftype ChunkedCons [chunk more meta ^:mutable __hash]\n  IWithMeta\n  (-with-meta [coll m]\n    (ChunkedCons. chunk more m __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ASeq\n  ISeq\n  (-first [coll] (-nth chunk 0))\n  (-rest [coll]\n    (if (> (-count chunk) 1)\n      (ChunkedCons. (-drop-first chunk) more meta nil)\n      (if (nil? more)\n        ()\n        more)))\n\n  IChunkedSeq\n  (-chunked-first [coll] chunk)\n  (-chunked-rest [coll]\n    (if (nil? more)\n      ()\n      more))\n\n  IChunkedNext\n  (-chunked-next [coll]\n    (if (nil? more)\n      nil\n      more))\n\n  ICollection\n  (-conj [this o]\n    (cons o this))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash)))",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [2063
                                                                   2109],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2063-L2109"},
                                                  :full-name-encode "cljs.core_ChunkedCons",
                                                  :history [["+"
                                                             "0.0-1424"]]},
                         "cljs.core/derive" {:ns "cljs.core",
                                             :name "derive",
                                             :signature ["[tag parent]"
                                                         "[h tag parent]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_derive",
                                             :source {:code "(defn derive\n  ([tag parent]\n   (assert (namespace parent))\n   ;; (assert (or (class? tag) (and (instance? cljs.core.Named tag) (namespace tag))))\n   (swap-global-hierarchy! derive tag parent) nil)\n  ([h tag parent]\n   (assert (not= tag parent))\n   ;; (assert (or (class? tag) (instance? clojure.lang.Named tag)))\n   ;; (assert (instance? clojure.lang.INamed tag))\n   ;; (assert (instance? clojure.lang.INamed parent))\n   (let [tp (:parents h)\n         td (:descendants h)\n         ta (:ancestors h)\n         tf (fn [m source sources target targets]\n              (reduce (fn [ret k]\n                        (assoc ret k\n                               (reduce conj (get targets k #{}) (cons target (targets target)))))\n                      m (cons source (sources source))))]\n     (or\n      (when-not (contains? (tp tag) parent)\n        (when (contains? (ta tag) parent)\n          (throw (js/Error. (str tag \"already has\" parent \"as ancestor\"))))\n        (when (contains? (ta parent) tag)\n          (throw (js/Error. (str \"Cyclic derivation:\" parent \"has\" tag \"as ancestor\"))))\n        {:parents (assoc (:parents h) tag (conj (get tp tag #{}) parent))\n         :ancestors (tf (:ancestors h) tag td parent ta)\n         :descendants (tf (:descendants h) parent ta tag td)})\n      h))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [6896
                                                              6928],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6896-L6928"},
                                             :full-name "cljs.core/derive",
                                             :clj-symbol "clojure.core/derive",
                                             :docstring "Establishes a parent/child relationship between parent and\ntag. Parent must be a namespace-qualified symbol or keyword and\nchild can be either a namespace-qualified symbol or keyword or a\nclass. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
                         "clojure.zip/zipper" {:ns "clojure.zip",
                                               :name "zipper",
                                               :signature ["[branch? children make-node root]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.zip_zipper",
                                               :source {:code "(defn zipper\n  [branch? children make-node root]\n    ^{:zip/branch? branch? :zip/children children :zip/make-node make-node}\n    [root nil])",
                                                        :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                        :lines [18 32],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L18-L32"},
                                               :full-name "clojure.zip/zipper",
                                               :clj-symbol "clojure.zip/zipper",
                                               :docstring "Creates a new zipper structure. \n\nbranch? is a fn that, given a node, returns true if can have\nchildren, even if it currently doesn't.\n\nchildren is a fn that, given a branch node, returns a seq of its\nchildren.\n\nmake-node is a fn that, given an existing node and a seq of\nchildren, returns a new branch node with the supplied children.\nroot is the root node."},
                         "clojure.core.reducers/mapcat" {:ns "clojure.core.reducers",
                                                         :name "mapcat",
                                                         :signature ["[f]"
                                                                     "[f coll]"],
                                                         :history [["+"
                                                                    "0.0-1236"]],
                                                         :type "function",
                                                         :full-name-encode "clojure.core.reducers_mapcat",
                                                         :source {:code "(defcurried mapcat\n  \"Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable.\"\n  {}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (reduce f1 ret (f k v)))))))",
                                                                  :filename "clojurescript/src/cljs/clojure/core/reducers.cljs",
                                                                  :lines [97
                                                                          106],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/core/reducers.cljs#L97-L106"},
                                                         :full-name "clojure.core.reducers/mapcat",
                                                         :clj-symbol "clojure.core.reducers/mapcat",
                                                         :docstring "Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable."},
                         "clojure.zip/remove" {:ns "clojure.zip",
                                               :name "remove",
                                               :signature ["[loc]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.zip_remove",
                                               :source {:code "(defn remove\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]\n      (if (nil? path)\n        (throw \"Remove at top\")\n        (if (pos? (count l))\n          (loop [loc (with-meta [(peek l) (assoc path :l (pop l) :changed? true)] (meta loc))]\n            (if-let [child (and (branch? loc) (down loc))]\n              (recur (rightmost child))\n              loc))\n          (with-meta [(make-node loc (peek pnodes) rs) \n                      (and ppath (assoc ppath :changed? true))]\n                     (meta loc))))))",
                                                        :filename "clojurescript/src/cljs/clojure/zip.cljs",
                                                        :lines [237
                                                                251],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/zip.cljs#L237-L251"},
                                               :full-name "clojure.zip/remove",
                                               :clj-symbol "clojure.zip/remove",
                                               :docstring "Removes the node at loc, returning the loc that would have preceded\nit in a depth-first walk."},
                         "cljs.core/find" {:ns "cljs.core",
                                           :name "find",
                                           :signature ["[coll k]"],
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_find",
                                           :source {:code "(defn find\n  [coll k]\n  (when (and (not (nil? coll))\n             (associative? coll)\n             (contains? coll k))\n    [k (get coll k)]))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1138 1144],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1138-L1144"},
                                           :full-name "cljs.core/find",
                                           :clj-symbol "clojure.core/find",
                                           :docstring "Returns the map entry for key, or nil if key not present."},
                         "cljs.core/hash-set" {:full-name "cljs.core/hash-set",
                                               :ns "cljs.core",
                                               :name "hash-set",
                                               :type "function",
                                               :signature ["[]"
                                                           "[& keys]"],
                                               :source {:code "(defn hash-set\n  ([] cljs.core.PersistentHashSet/EMPTY)\n  ([& ^not-native keys]\n     (if (and (instance? IndexedSeq keys)\n              (< (alength (.-arr keys)) cljs.core.PersistentArrayMap/HASHMAP_THRESHOLD))\n       (let [karr (.-arr keys)\n             klen (alength karr)\n             alen (* 2 klen)\n             arr  (make-array alen)]\n         (loop [ki 0]\n           (if (< ki klen)\n             (let [ai (* 2 ki)]\n               (aset arr ai (aget karr ki))\n               (aset arr (inc ai) nil)\n               (recur (inc ki)))\n             (cljs.core.PersistentHashSet/fromArray arr true))))\n       (loop [in keys\n              ^not-native out (-as-transient cljs.core.PersistentHashSet/EMPTY)]\n         (if-not (nil? in)\n           (recur (-next in) (-conj! out (-first in)))\n           (-persistent! out))))))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [5797
                                                                5817],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5797-L5817"},
                                               :full-name-encode "cljs.core_hash-set",
                                               :clj-symbol "clojure.core/hash-set",
                                               :history [["+"
                                                          "0.0-1443"]]},
                         "cljs.core/*print-dup*" {:full-name "cljs.core/*print-dup*",
                                                  :ns "cljs.core",
                                                  :name "*print-dup*",
                                                  :type "var",
                                                  :source {:code "(def *print-dup* false)",
                                                           :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                           :lines [6363
                                                                   6363],
                                                           :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6363-L6363"},
                                                  :full-name-encode "cljs.core__STAR_print-dup_STAR_",
                                                  :clj-symbol "clojure.core/*print-dup*",
                                                  :history [["+"
                                                             "0.0-927"]]},
                         "cljs.core/object-array" {:full-name "cljs.core/object-array",
                                                   :ns "cljs.core",
                                                   :name "object-array",
                                                   :type "function",
                                                   :signature ["[size-or-seq]"
                                                               "[size init-val-or-seq]"],
                                                   :source {:code "(defn object-array\n  ([size-or-seq]\n     (cond\n      (number? size-or-seq) (object-array size-or-seq nil)\n      (seq? size-or-seq) (into-array size-or-seq)\n      :else (throw (js/Error. \"object-array called with something other than size or ISeq\"))))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                                            :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                            :lines [2219
                                                                    2238],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2219-L2238"},
                                                   :full-name-encode "cljs.core_object-array",
                                                   :clj-symbol "clojure.core/object-array",
                                                   :history [["+"
                                                              "0.0-1211"]]},
                         "cljs.core/indexed?" {:return-type boolean,
                                               :ns "cljs.core",
                                               :name "indexed?",
                                               :signature ["[x]"],
                                               :history [["+"
                                                          "0.0-1211"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_indexed_QMARK_",
                                               :source {:code "(defn ^boolean indexed?\n  [x] (satisfies? IIndexed x))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [610
                                                                612],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L610-L612"},
                                               :full-name "cljs.core/indexed?",
                                               :docstring "Returns true if coll implements nth in constant time"},
                         "cljs.core/partial" {:ns "cljs.core",
                                              :name "partial",
                                              :signature ["[f arg1]"
                                                          "[f arg1 arg2]"
                                                          "[f arg1 arg2 arg3]"
                                                          "[f arg1 arg2 arg3 & more]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_partial",
                                              :source {:code "(defn partial\n  ([f arg1]\n   (fn [& args] (apply f arg1 args)))\n  ([f arg1 arg2]\n   (fn [& args] (apply f arg1 arg2 args)))\n  ([f arg1 arg2 arg3]\n   (fn [& args] (apply f arg1 arg2 arg3 args)))\n  ([f arg1 arg2 arg3 & more]\n   (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [2471
                                                               2482],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2471-L2482"},
                                              :full-name "cljs.core/partial",
                                              :clj-symbol "clojure.core/partial",
                                              :docstring "Takes a function f and fewer than the normal arguments to f, and\nreturns a fn that takes a variable number of additional args. When\ncalled, the returned function calls f with args + additional args."},
                         "cljs.core/keyword?" {:return-type boolean,
                                               :ns "cljs.core",
                                               :name "keyword?",
                                               :signature ["[x]"],
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.core_keyword_QMARK_",
                                               :source {:code "(defn ^boolean keyword? [x]\n  (and ^boolean (goog/isString x)\n       (identical? (.charAt x 0) \\uFDD0)))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [1103
                                                                1105],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1103-L1105"},
                                               :full-name "cljs.core/keyword?",
                                               :clj-symbol "clojure.core/keyword?"},
                         "clojure.browser.event/fire-listeners" {:full-name "clojure.browser.event/fire-listeners",
                                                                 :ns "clojure.browser.event",
                                                                 :name "fire-listeners",
                                                                 :type "function",
                                                                 :signature ["[obj type capture event]"],
                                                                 :source {:code "(defn fire-listeners\n  [obj type capture event])",
                                                                          :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                          :lines [82
                                                                                  83],
                                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/event.cljs#L82-L83"},
                                                                 :full-name-encode "clojure.browser.event_fire-listeners",
                                                                 :history [["+"
                                                                            "0.0-927"]]},
                         "cljs.core/interleave" {:ns "cljs.core",
                                                 :name "interleave",
                                                 :signature ["[c1 c2]"
                                                             "[c1 c2 & colls]"],
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "cljs.core_interleave",
                                                 :source {:code "(defn interleave\n  ([c1 c2]\n     (lazy-seq\n      (let [s1 (seq c1) s2 (seq c2)]\n        (when (and s1 s2)\n          (cons (first s1) (cons (first s2)\n                                 (interleave (rest s1) (rest s2))))))))\n  ([c1 c2 & colls]\n     (lazy-seq\n      (let [ss (map seq (conj colls c2 c1))]\n        (when (every? identity ss)\n          (concat (map first ss) (apply interleave (map rest ss))))))))",
                                                          :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                          :lines [2761
                                                                  2773],
                                                          :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2761-L2773"},
                                                 :full-name "cljs.core/interleave",
                                                 :clj-symbol "clojure.core/interleave",
                                                 :docstring "Returns a lazy seq of the first item in each coll, then the second etc."},
                         "cljs.core/TransientHashSet" {:full-name "cljs.core/TransientHashSet",
                                                       :ns "cljs.core",
                                                       :name "TransientHashSet",
                                                       :type "type",
                                                       :signature ["[transient-map]"],
                                                       :source {:code "(deftype TransientHashSet [^:mutable transient-map]\n  ITransientCollection\n  (-conj! [tcoll o]\n    (set! transient-map (assoc! transient-map o nil))\n    tcoll)\n\n  (-persistent! [tcoll]\n    (PersistentHashSet. nil (persistent! transient-map) nil))\n\n  ITransientSet\n  (-disjoin! [tcoll v]\n    (set! transient-map (dissoc! transient-map v))\n    tcoll)\n\n  ICounted\n  (-count [tcoll] (count transient-map))\n\n  ILookup\n  (-lookup [tcoll v]\n    (-lookup tcoll v nil))\n\n  (-lookup [tcoll v not-found]\n    (if (identical? (-lookup transient-map v lookup-sentinel) lookup-sentinel)\n      not-found\n      v))\n\n  IFn\n  (-invoke [tcoll k]\n    (if (identical? (-lookup transient-map k lookup-sentinel) lookup-sentinel)\n      nil\n      k))\n\n  (-invoke [tcoll k not-found]\n    (if (identical? (-lookup transient-map k lookup-sentinel) lookup-sentinel)\n      not-found\n      k)))",
                                                                :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                :lines [5692
                                                                        5727],
                                                                :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L5692-L5727"},
                                                       :full-name-encode "cljs.core_TransientHashSet",
                                                       :history [["+"
                                                                  "0.0-1211"]]},
                         "cljs.core/*flush-on-newline*" {:full-name "cljs.core/*flush-on-newline*",
                                                         :ns "cljs.core",
                                                         :name "*flush-on-newline*",
                                                         :type "var",
                                                         :source {:code "(def *flush-on-newline* true)",
                                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                                  :lines [6360
                                                                          6360],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6360-L6360"},
                                                         :full-name-encode "cljs.core__STAR_flush-on-newline_STAR_",
                                                         :clj-symbol "clojure.core/*flush-on-newline*",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "cljs.core/get-in" {:ns "cljs.core",
                                             :name "get-in",
                                             :signature ["[m ks]"
                                                         "[m ks not-found]"],
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.core_get-in",
                                             :source {:code "(defn get-in\n  ([m ks]\n     (get-in m ks nil))\n  ([m ks not-found]\n     (loop [sentinel lookup-sentinel\n            m m\n            ks (seq ks)]\n       (if ks\n         (if (not (satisfies? ILookup m))\n           not-found\n           (let [m (get m (first ks) sentinel)]\n             (if (identical? sentinel m)\n               not-found\n               (recur sentinel m (next ks)))))\n         m))))",
                                                      :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                      :lines [2906
                                                              2925],
                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L2906-L2925"},
                                             :full-name "cljs.core/get-in",
                                             :clj-symbol "clojure.core/get-in",
                                             :docstring "Returns the value in a nested associative structure,\nwhere ks is a sequence of keys. Returns nil if the key is not present,\nor the not-found value if supplied."},
                         "clojure.browser.dom/element" {:full-name "clojure.browser.dom/element",
                                                        :ns "clojure.browser.dom",
                                                        :name "element",
                                                        :type "function",
                                                        :signature ["[tag-or-text]"
                                                                    "[tag & children]"],
                                                        :source {:code "(defn element\n  ([tag-or-text]\n     (log \"(element \" tag-or-text \")\")\n     (-element tag-or-text))\n  ([tag & children]\n     (log \"(element \" tag \" \" children \")\")\n     (let [attrs (first children)]\n       (if (map? attrs)\n         (-element tag attrs (rest children))\n         (-element tag nil children)))))",
                                                                 :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                 :lines [81
                                                                         90],
                                                                 :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/dom.cljs#L81-L90"},
                                                        :full-name-encode "clojure.browser.dom_element",
                                                        :history [["+"
                                                                   "0.0-927"]]},
                         "cljs.core/prim-seq" {:full-name "cljs.core/prim-seq",
                                               :ns "cljs.core",
                                               :name "prim-seq",
                                               :type "function",
                                               :signature ["[prim]"
                                                           "[prim i]"],
                                               :source {:code "(defn prim-seq\n  ([prim]\n     (prim-seq prim 0))\n  ([prim i]\n     (when (< i (alength prim))\n       (IndexedSeq. prim i))))",
                                                        :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                        :lines [670
                                                                675],
                                                        :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L670-L675"},
                                               :full-name-encode "cljs.core_prim-seq",
                                               :history [["+"
                                                          "0.0-927"]]},
                         "cljs.core/<=" {:return-type boolean,
                                         :ns "cljs.core",
                                         :name "<=",
                                         :signature ["[x]"
                                                     "[x y]"
                                                     "[x y & more]"],
                                         :shadowed-sources ({:code "(defmacro <=\n  ([x] true)\n  ([x y] (bool-expr (list 'js* \"(~{} <= ~{})\" x y)))\n  ([x y & more] `(and (<= ~x ~y) (<= ~y ~@more))))",
                                                             :filename "clojurescript/src/clj/cljs/core.clj",
                                                             :lines [349
                                                                     352],
                                                             :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L349-L352"}),
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core__LT__EQ_",
                                         :source {:code "(defn ^boolean <=\n  ([x] true)\n  ([x y] (cljs.core/<= x y))\n  ([x y & more]\n   (if (cljs.core/<= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/<= y (first more)))\n     false)))",
                                                  :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                  :lines [1355 1365],
                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1355-L1365"},
                                         :full-name "cljs.core/<=",
                                         :clj-symbol "clojure.core/<=",
                                         :docstring "Returns non-nil if nums are in monotonically non-decreasing order,\notherwise false."},
                         "clojure.set/map-invert" {:ns "clojure.set",
                                                   :name "map-invert",
                                                   :signature ["[m]"],
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.set_map-invert",
                                                   :source {:code "(defn map-invert\n  [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))",
                                                            :filename "clojurescript/src/cljs/clojure/set.cljs",
                                                            :lines [98
                                                                    100],
                                                            :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/set.cljs#L98-L100"},
                                                   :full-name "clojure.set/map-invert",
                                                   :clj-symbol "clojure.set/map-invert",
                                                   :docstring "Returns the map with the vals mapped to the keys."},
                         "clojure.browser.event/listen" {:full-name "clojure.browser.event/listen",
                                                         :ns "clojure.browser.event",
                                                         :name "listen",
                                                         :type "function",
                                                         :signature ["[src type fn]"
                                                                     "[src type fn capture?]"],
                                                         :source {:code "(defn listen\n  ([src type fn]\n     (listen src type fn false))\n  ([src type fn capture?]\n     (goog.events/listen src\n                         (get (event-types src) type type)\n                         fn\n                         capture?)))",
                                                                  :filename "clojurescript/src/cljs/clojure/browser/event.cljs",
                                                                  :lines [44
                                                                          51],
                                                                  :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/event.cljs#L44-L51"},
                                                         :full-name-encode "clojure.browser.event_listen",
                                                         :history [["+"
                                                                    "0.0-927"]]},
                         "cljs.core/neg?" {:return-type boolean,
                                           :ns "cljs.core",
                                           :name "neg?",
                                           :signature ["[x]"],
                                           :shadowed-sources ({:code "(defmacro neg? [x]\n  `(< ~x 0))",
                                                               :filename "clojurescript/src/clj/cljs/core.clj",
                                                               :lines [381
                                                                       382],
                                                               :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L381-L382"}),
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core_neg_QMARK_",
                                           :source {:code "(defn ^boolean neg?\n  [x] (cljs.core/neg? x))",
                                                    :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                    :lines [1645 1647],
                                                    :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1645-L1647"},
                                           :full-name "cljs.core/neg?",
                                           :clj-symbol "clojure.core/neg?",
                                           :docstring "Returns true if num is less than zero, else false"},
                         "clojure.browser.dom/replace-node" {:full-name "clojure.browser.dom/replace-node",
                                                             :ns "clojure.browser.dom",
                                                             :name "replace-node",
                                                             :docstring "Replace old-node with new-node. old-node can be an element or a\nkeyword which is the id of the node to replace.  new-node can be an\nelement or an html string.",
                                                             :type "function",
                                                             :signature ["[old-node new-node]"],
                                                             :source {:code "(defn replace-node\n  [old-node new-node]\n  (let [old-node (ensure-element old-node)\n        new-node (ensure-element new-node)]\n    (gdom/replaceNode new-node old-node)\n    new-node))",
                                                                      :filename "clojurescript/src/cljs/clojure/browser/dom.cljs",
                                                                      :lines [114
                                                                              122],
                                                                      :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/clojure/browser/dom.cljs#L114-L122"},
                                                             :full-name-encode "clojure.browser.dom_replace-node",
                                                             :history [["+"
                                                                        "0.0-927"]]},
                         "special/catch" {:ns "special",
                                          :name "catch",
                                          :signature ["[protoname name expr*]"],
                                          :history [["+" "0.0-927"]],
                                          :type "special form",
                                          :full-name-encode "special_catch",
                                          :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (seq? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                                   :filename "clojurescript/src/clj/cljs/core.clj",
                                                   :lines [963 991],
                                                   :link "https://github.com/clojure/clojurescript/blob/r1798/src/clj/cljs/core.clj#L963-L991"},
                                          :full-name "special/catch",
                                          :clj-symbol "clojure.core/catch",
                                          :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions."},
                         "cljs.core/reverse" {:ns "cljs.core",
                                              :name "reverse",
                                              :signature ["[coll]"],
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.core_reverse",
                                              :source {:code "(defn reverse\n  [coll]\n  (if (reversible? coll)\n    (rseq coll)\n    (reduce conj () coll)))",
                                                       :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                       :lines [1867
                                                               1872],
                                                       :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L1867-L1872"},
                                              :full-name "cljs.core/reverse",
                                              :clj-symbol "clojure.core/reverse",
                                              :docstring "Returns a seq of the items in coll in reverse order. Not lazy."},
                         "cljs.core/realized?" {:return-type boolean,
                                                :ns "cljs.core",
                                                :name "realized?",
                                                :signature ["[d]"],
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.core_realized_QMARK_",
                                                :source {:code "(defn ^boolean realized?\n  [d]\n  (-realized? d))",
                                                         :filename "clojurescript/src/cljs/cljs/core.cljs",
                                                         :lines [6704
                                                                 6707],
                                                         :link "https://github.com/clojure/clojurescript/blob/r1798/src/cljs/cljs/core.cljs#L6704-L6707"},
                                                :full-name "cljs.core/realized?",
                                                :clj-symbol "clojure.core/realized?",
                                                :docstring "Returns true if a value has been produced for a promise, delay, future or lazy sequence."}},
               :changes [{:cljs-version "0.0-927",
                          :cljs-date "2012-01-18",
                          :clj-version "1.3.0",
                          :gclosure-lib "20110323-r790",
                          :added #{"cljs.core/keys"
                                   "cljs.core/reset!"
                                   "clojure.set/select"
                                   "cljs.core/delay"
                                   "cljs.core/bit-not"
                                   "cljs.core/partition"
                                   "cljs.core/parents"
                                   "cljs.core/aclone"
                                   "cljs.core/reset-meta!"
                                   "special/defrecord*"
                                   "cljs.reader/dispatch-macros"
                                   "cljs.core/ICollection"
                                   "cljs.core/every?"
                                   "clojure.zip/node"
                                   "cljs.core/IEmptyableCollection"
                                   "clojure.zip/right"
                                   "cljs.core/=="
                                   "special/."
                                   "clojure.browser.net/*timeout*"
                                   "cljs.core/remove-method"
                                   "cljs.core/frequencies"
                                   "cljs.core/pop"
                                   "cljs.core/not-every?"
                                   "cljs.core/some-fn"
                                   "clojure.browser.event/remove-all"
                                   "cljs.core/doto"
                                   "cljs.core/take-while"
                                   "cljs.reader/escape-char-map"
                                   "clojure.browser.event/all-listeners"
                                   "cljs.core/vals"
                                   "cljs.core/IDeref"
                                   "clojure.browser.dom/log-obj"
                                   "cljs.core/for"
                                   "cljs.core/instance?"
                                   "cljs.reader/read-comment"
                                   "cljs.reader/read-number"
                                   "cljs.core/ILookup"
                                   "cljs.core/when"
                                   "clojure.browser.dom/set-value"
                                   "cljs.reader/read-past"
                                   "cljs.core/to-array"
                                   "cljs.core/interpose"
                                   "clojure.browser.net/ICrossPageChannel"
                                   "special/finally"
                                   "cljs.core/Cons"
                                   "cljs.core/re-find"
                                   "cljs.core/IMeta"
                                   "cljs.core/assoc-in"
                                   "clojure.string/join"
                                   "clojure.zip/rights"
                                   "cljs.core/split-at"
                                   "clojure.zip/append-child"
                                   "cljs.core/binding"
                                   "cljs.core/Set"
                                   "cljs.reader/macro-terminating?"
                                   "cljs.core/prefers"
                                   "cljs.core/vary-meta"
                                   "cljs.core/when-let"
                                   "cljs.core/drop"
                                   "cljs.core/while"
                                   "cljs.core/import-macros"
                                   "cljs.core/string-print"
                                   "cljs.core/-"
                                   "clojure.zip/vector-zip"
                                   "cljs.core/js->clj"
                                   "cljs.core/List"
                                   "cljs.core/identical?"
                                   "cljs.core/*main-cli-fn*"
                                   "clojure.browser.dom/html->dom"
                                   "cljs.core/some"
                                   "cljs.core/doall"
                                   "cljs.core/condp"
                                   "clojure.zip/down"
                                   "cljs.core/IPending"
                                   "cljs.core/count"
                                   "cljs.core/bit-test"
                                   "cljs.core/fixture2"
                                   "cljs.core/loop"
                                   "cljs.core/subvec"
                                   "cljs.core/bit-clear"
                                   "cljs.core/gensym"
                                   "special/recur"
                                   "cljs.core/+"
                                   "cljs.core/comp"
                                   "cljs.reader/desugar-meta"
                                   "cljs.core/pr"
                                   "clojure.string/upper-case"
                                   "clojure.browser.event/expose"
                                   "clojure.browser.event/listen-once"
                                   "cljs.core/empty?"
                                   "cljs.core/newline"
                                   "cljs.core/replace"
                                   "cljs.core/rand"
                                   "cljs.core/add-watch"
                                   "clojure.string/capitalize"
                                   "cljs.core/replicate"
                                   "special/do"
                                   "cljs.core/sequential?"
                                   "cljs.core/underive"
                                   "cljs.core/get-method"
                                   "cljs.core/="
                                   "cljs.core/defn-"
                                   "cljs.reader/read-symbol"
                                   "cljs.reader/push-back-reader"
                                   "cljs.core/deftype"
                                   "cljs.core/Subvec"
                                   "special/ns"
                                   "cljs.core/extend-protocol"
                                   "cljs.reader/read"
                                   "cljs.core/EmptyList"
                                   "clojure.walk/postwalk"
                                   "clojure.zip/edit"
                                   "cljs.core/re-seq"
                                   "cljs.reader/read-list"
                                   "cljs.core/Atom"
                                   "cljs.core/IMap"
                                   "cljs.reader/read-vector"
                                   "clojure.set/join"
                                   "cljs.core/HashMap"
                                   "cljs.reader/int-pattern"
                                   "cljs.core/swap!"
                                   "cljs.core/dec"
                                   "clojure.browser.dom/remove-children"
                                   "cljs.core/get-validator"
                                   "cljs.core/coll?"
                                   "cljs.core/bit-or"
                                   "cljs.core/nfirst"
                                   "cljs.core/keep"
                                   "cljs.core/take"
                                   "cljs.core/cond"
                                   "cljs.core/bit-and"
                                   "clojure.browser.event/unique-event-id"
                                   "clojure.set/project"
                                   "special/js*"
                                   "clojure.string/trim-newline"
                                   "specialrepl/in-ns"
                                   "special/let*"
                                   "special/throw"
                                   "clojure.zip/insert-left"
                                   "cljs.core/true?"
                                   "clojure.browser.net/xpc-connection"
                                   "cljs.core/not"
                                   "cljs.core/js-obj"
                                   "cljs.core/complement"
                                   "cljs.core/spread"
                                   "cljs.core/keyword"
                                   "cljs.core/sort"
                                   "clojure.string/trim"
                                   "cljs.core/meta"
                                   "cljs.core/time"
                                   "cljs.core/boolean"
                                   "cljs.reader/read-token"
                                   "cljs.core/update-in"
                                   "cljs.core/map-indexed"
                                   "cljs.core/IStack"
                                   "cljs.core/IIndexed"
                                   "clojure.browser.repl/repl-print"
                                   "clojure.browser.net/xpc-config-fields"
                                   "cljs.core/nnext"
                                   "cljs.core/*print-meta*"
                                   "cljs.reader/read-dispatch"
                                   "cljs.core/distinct"
                                   "cljs.reader/wrapping-reader"
                                   "cljs.core/prn"
                                   "clojure.zip/leftmost"
                                   "cljs.core/>="
                                   "cljs.reader/macros"
                                   "cljs.core/doseq"
                                   "cljs.core/*"
                                   "cljs.core/into"
                                   "cljs.core/defmethod"
                                   "cljs.core/rest"
                                   "cljs.core/dotimes"
                                   "clojure.zip/lefts"
                                   "clojure.browser.dom/ensure-element"
                                   "cljs.core/defmacro"
                                   "cljs.core/remove"
                                   "cljs.core/if-not"
                                   "clojure.zip/path"
                                   "cljs.core/mapcat"
                                   "cljs.core/IWatchable"
                                   "clojure.zip/rightmost"
                                   "cljs.core/->"
                                   "cljs.core/remove-all-methods"
                                   "clojure.string/replace-first"
                                   "clojure.browser.dom/get-value"
                                   "cljs.nodejs/process"
                                   "cljs.core/not="
                                   "cljs.core/js-keys"
                                   "clojure.zip/seq-zip"
                                   "cljs.core/IVector"
                                   "cljs.core/empty"
                                   "cljs.core/re-matches"
                                   "clojure.browser.dom/DOMBuilder"
                                   "cljs.core/fixture1"
                                   "cljs.core/extend-type"
                                   "cljs.core/ISeqable"
                                   "cljs.core/assoc"
                                   "clojure.browser.repl/xpc-connection"
                                   "cljs.core/IDerefWithTimeout"
                                   "clojure.browser.repl/start-evaluator"
                                   "clojure.browser.event/unlisten"
                                   "cljs.core/fnil"
                                   "cljs.core/this-as"
                                   "cljs.core/PersistentQueueSeq"
                                   "cljs.core/counted?"
                                   "clojure.string/trimr"
                                   "cljs.core/force"
                                   "cljs.core/compare-and-set!"
                                   "cljs.core/set?"
                                   "clojure.string/escape"
                                   "cljs.core/remove-watch"
                                   "cljs.core/IMultiFn"
                                   "clojure.zip/end?"
                                   "clojure.set/superset?"
                                   "clojure.browser.net/IConnection"
                                   "cljs.core/let"
                                   "cljs.core/dorun"
                                   "cljs.core/pr-str"
                                   "cljs.core/IPrintable"
                                   "cljs.core/defprotocol"
                                   "cljs.core/assert"
                                   "cljs.core/declare"
                                   "cljs.core/fn?"
                                   "cljs.core/associative?"
                                   "cljs.core/list*"
                                   "cljs.core/reduce"
                                   "clojure.browser.event/has-listener"
                                   "cljs.core/compare"
                                   "cljs.core/contains?"
                                   "cljs.core/prefer-method"
                                   "cljs.core/array-seq"
                                   "cljs.core/PersistentQueue"
                                   "cljs.core/drop-last"
                                   "cljs.reader/read-string"
                                   "cljs.core/vector?"
                                   "cljs.core/defmulti"
                                   "clojure.browser.event/dispatch-event"
                                   "clojure.string/split-lines"
                                   "cljs.core/areduce"
                                   "cljs.core/disj"
                                   "clojure.browser.net/event-types"
                                   "clojure.string/lower-case"
                                   "cljs.core/*print-fn*"
                                   "cljs.core/str"
                                   "cljs.core/ISequential"
                                   "cljs.core/set"
                                   "special/def"
                                   "cljs.core/print"
                                   "clojure.string/blank?"
                                   "clojure.browser.dom/append"
                                   "cljs.core/take-last"
                                   "clojure.set/intersection"
                                   "cljs.core/fnext"
                                   "cljs.core/apply"
                                   "clojure.walk/prewalk"
                                   "cljs.core/flatten"
                                   "cljs.core/get"
                                   "cljs.core/.."
                                   "cljs.core/Range"
                                   "cljs.core/zero?"
                                   "cljs.core/identity"
                                   "cljs.core/first"
                                   "cljs.reader/ratio-pattern"
                                   "cljs.core/>"
                                   "cljs.core/juxt"
                                   "cljs.core/max"
                                   "cljs.core/*3"
                                   "cljs.core/number?"
                                   "cljs.core/array"
                                   "cljs.core/nthnext"
                                   "cljs.core/re-pattern"
                                   "cljs.core/missing-protocol"
                                   "clojure.browser.dom/set-text"
                                   "clojure.zip/up"
                                   "cljs.core/IWithMeta"
                                   "cljs.core/bit-and-not"
                                   "clojure.string/triml"
                                   "clojure.string/split"
                                   "cljs.core/hash-map"
                                   "cljs.core/rem"
                                   "cljs.core/IRecord"
                                   "cljs.core/constantly"
                                   "clojure.browser.dom/get-element"
                                   "cljs.core/and"
                                   "clojure.browser.repl/wrap-message"
                                   "clojure.browser.event/unlisten-by-key"
                                   "cljs.core/try"
                                   "cljs.core/iterate"
                                   "cljs.core/lazy-seq"
                                   "specialrepl/load-file"
                                   "cljs.core/IndexedSeq"
                                   "cljs.core/next"
                                   "cljs.core/*print-readably*"
                                   "cljs.core/last"
                                   "cljs.core/bit-shift-left"
                                   "clojure.string/reverse"
                                   "cljs.core/min"
                                   "cljs.reader/escape-char"
                                   "cljs.reader/read-map"
                                   "cljs.core/seq"
                                   "cljs.core/not-empty"
                                   "cljs.core/println"
                                   "clojure.browser.repl/connect"
                                   "clojure.browser.dom/insert-at"
                                   "cljs.core/quot"
                                   "clojure.browser.event/get-listener"
                                   "cljs.core/filter"
                                   "clojure.zip/branch?"
                                   "special/if"
                                   "cljs.core/ObjMap"
                                   "cljs.core/zipmap"
                                   "cljs.core/hash-combine"
                                   "cljs.core/max-key"
                                   "clojure.zip/insert-child"
                                   "cljs.core/defrecord"
                                   "cljs.core/butlast"
                                   "cljs.core/hash"
                                   "cljs.core/bit-set"
                                   "cljs.core/concat"
                                   "cljs.core/conj"
                                   "clojure.set/difference"
                                   "cljs.core/when-first"
                                   "cljs.core/distinct?"
                                   "cljs.core/pos?"
                                   "cljs.core/IHash"
                                   "cljs.core/is_proto_"
                                   "cljs.core/keep-indexed"
                                   "cljs.core/bit-shift-right"
                                   "clojure.zip/insert-right"
                                   "cljs.core/make-hierarchy"
                                   "cljs.core/repeat"
                                   "cljs.core/MultiFn"
                                   "cljs.core/not-any?"
                                   "cljs.reader/read-regex"
                                   "clojure.zip/next"
                                   "cljs.core/aget"
                                   "cljs.core/if-let"
                                   "cljs.core//"
                                   "cljs.core/min-key"
                                   "clojure.zip/root"
                                   "cljs.core/drop-while"
                                   "clojure.browser.repl/evaluate-javascript"
                                   "cljs.core/set-validator!"
                                   "cljs.core/<"
                                   "cljs.core/fn"
                                   "cljs.core/split-with"
                                   "cljs.core/IReduce"
                                   "cljs.reader/symbol-pattern"
                                   "cljs.core/repeatedly"
                                   "cljs.reader/read-delimited-list"
                                   "cljs.core/undefined?"
                                   "clojure.zip/prev"
                                   "cljs.core/seq?"
                                   "cljs.core/odd?"
                                   "cljs.core/cons"
                                   "special/deftype*"
                                   "cljs.reader/read-set"
                                   "cljs.core/descendants"
                                   "special/new"
                                   "cljs.core/take-nth"
                                   "cljs.reader/throwing-reader"
                                   "cljs.core/even?"
                                   "special/fn*"
                                   "clojure.set/subset?"
                                   "cljs.core/flush"
                                   "cljs.reader/reader-error"
                                   "clojure.walk/prewalk-replace"
                                   "cljs.core/*1"
                                   "cljs.reader/read-unicode-char"
                                   "cljs.core/dissoc"
                                   "cljs.core/ffirst"
                                   "clojure.zip/replace"
                                   "cljs.core/vec"
                                   "cljs.core/or"
                                   "cljs.core/mod"
                                   "cljs.core/aset"
                                   "cljs.core/second"
                                   "clojure.set/rename"
                                   "cljs.core/delay?"
                                   "clojure.zip/left"
                                   "cljs.reader/not-implemented"
                                   "cljs.core/IAssociative"
                                   "cljs.core/group-by"
                                   "cljs.core/symbol"
                                   "cljs.core/Delay"
                                   "cljs.core/methods"
                                   "cljs.core/vector"
                                   "cljs.core/rand-int"
                                   "cljs.core/letfn"
                                   "cljs.reader/read-discard"
                                   "cljs.core/inc"
                                   "cljs.core/name"
                                   "cljs.core/cycle"
                                   "cljs.core/map"
                                   "cljs.core/amap"
                                   "clojure.zip/children"
                                   "special/set!"
                                   "cljs.core/when-not"
                                   "clojure.set/index"
                                   "clojure.browser.dom/log"
                                   "cljs.core/partition-by"
                                   "cljs.core/sort-by"
                                   "cljs.core/with-meta"
                                   "cljs.core/NeverEquiv"
                                   "cljs.core/select-keys"
                                   "special/loop*"
                                   "cljs.core/ISeq"
                                   "clojure.walk/postwalk-replace"
                                   "cljs.core/pr-with-opts"
                                   "cljs.core/->>"
                                   "cljs.core/nil?"
                                   "clojure.walk/stringify-keys"
                                   "clojure.browser.repl/order"
                                   "cljs.core/memoize"
                                   "cljs.core/pr-sequential"
                                   "clojure.zip/make-node"
                                   "specialrepl/load-namespace"
                                   "cljs.reader/float-pattern"
                                   "cljs.core/ancestors"
                                   "cljs.core/integer?"
                                   "clojure.zip/xml-zip"
                                   "clojure.walk/walk"
                                   "cljs.core/bit-xor"
                                   "clojure.set/union"
                                   "cljs.reader/PushbackReader"
                                   "cljs.core/isa?"
                                   "clojure.browser.net/xhr-connection"
                                   "cljs.core/subs"
                                   "cljs.core/symbol?"
                                   "clojure.string/replace"
                                   "cljs.core/string?"
                                   "cljs.core/partition-all"
                                   "cljs.core/merge-with"
                                   "clojure.browser.dom/set-properties"
                                   "cljs.core/trampoline"
                                   "clojure.browser.repl/send-print"
                                   "cljs.core/ICounted"
                                   "cljs.core/IEquiv"
                                   "cljs.core/js-delete"
                                   "cljs.core/comment"
                                   "cljs.reader/special-symbols"
                                   "cljs.core/alength"
                                   "special/quote"
                                   "cljs.core/tree-seq"
                                   "cljs.reader/read-unmatched-delimiter"
                                   "cljs.core/every-pred"
                                   "clojure.set/rename-keys"
                                   "cljs.core/peek"
                                   "cljs.core/pr-str-with-opts"
                                   "cljs.core/map?"
                                   "cljs.reader/StringPushbackReader"
                                   "cljs.core/deref"
                                   "cljs.core/reductions"
                                   "cljs.core/false?"
                                   "cljs.core/bit-flip"
                                   "cljs.core/ISet"
                                   "cljs.core/LazySeq"
                                   "cljs.core/*2"
                                   "clojure.browser.event/total-listener-count"
                                   "cljs.core/alter-meta!"
                                   "clojure.browser.dom/click-element"
                                   "cljs.reader/read-meta"
                                   "special/try*"
                                   "cljs.core/range"
                                   "cljs.core/reify"
                                   "cljs.core/satisfies?"
                                   "cljs.core/nth"
                                   "cljs.core/list"
                                   "cljs.core/defn"
                                   "cljs.core/rand-nth"
                                   "cljs.core/atom"
                                   "cljs.reader/read-keyword"
                                   "cljs.core/Vector"
                                   "cljs.reader/skip-line"
                                   "cljs.core/namespace"
                                   "cljs.nodejs/require"
                                   "clojure.browser.event/EventType"
                                   "cljs.core/merge"
                                   "clojure.browser.repl/send-result"
                                   "clojure.walk/keywordize-keys"
                                   "cljs.core/derive"
                                   "clojure.zip/zipper"
                                   "clojure.zip/remove"
                                   "cljs.core/find"
                                   "cljs.core/*print-dup*"
                                   "cljs.core/partial"
                                   "cljs.core/keyword?"
                                   "clojure.browser.event/fire-listeners"
                                   "cljs.core/interleave"
                                   "cljs.core/*flush-on-newline*"
                                   "cljs.core/get-in"
                                   "clojure.browser.dom/element"
                                   "cljs.core/prim-seq"
                                   "cljs.core/<="
                                   "clojure.set/map-invert"
                                   "clojure.browser.event/listen"
                                   "cljs.core/neg?"
                                   "clojure.browser.dom/replace-node"
                                   "special/catch"
                                   "cljs.core/reverse"
                                   "cljs.core/realized?"}}
                         {:cljs-version "0.0-971",
                          :cljs-date "2012-01-27",
                          :clj-version "1.3.0",
                          :gclosure-lib "20110323-r790",
                          :added #{"cljs.core/type" "cljs.core/IFn"}}
                         {:cljs-version "0.0-993",
                          :cljs-date "2012-02-25",
                          :clj-version "1.3.0",
                          :gclosure-lib "20110323-r790"}
                         {:cljs-version "0.0-1006",
                          :cljs-date "2012-03-30",
                          :clj-version "1.3.0",
                          :gclosure-lib "20110323-r790",
                          :added #{"cljs.core/PersistentVector"}}
                         {:cljs-version "0.0-1011",
                          :cljs-date "2012-03-31",
                          :clj-version "1.3.0",
                          :gclosure-lib "20110323-r790",
                          :added #{"cljs.core/println-str"
                                   "cljs.core/print-str"
                                   "cljs.core/prn-str-with-opts"
                                   "cljs.core/prn-str"}}
                         {:cljs-version "0.0-1211",
                          :cljs-date "2012-05-09",
                          :clj-version "1.4.0",
                          :gclosure-lib "20111110-r1376",
                          :added #{"cljs.core/ITransientCollection"
                                   "cljs.core/transient"
                                   "cljs.core/dissoc!"
                                   "cljs.core/ITransientSet"
                                   "cljs.core/array-map"
                                   "cljs.core/rseq"
                                   "cljs.core/ITransientMap"
                                   "cljs.core/ArrayNodeSeq"
                                   "cljs.core/list?"
                                   "cljs.core/val"
                                   "cljs.core/BitmapIndexedNode"
                                   "cljs.core/IMapEntry"
                                   "cljs.core/*unchecked-if*"
                                   "cljs.core/seqable?"
                                   "cljs.core/sorted-map"
                                   "cljs.core/ASeq"
                                   "cljs.core/reduceable?"
                                   "cljs.core/vector-seq"
                                   "cljs.core/conj!"
                                   "cljs.core/PersistentHashMap"
                                   "cljs.core/IReversible"
                                   "cljs.core/IKVReduce"
                                   "cljs.core/BlackNode"
                                   "cljs.core/PersistentArrayMap"
                                   "cljs.core/int"
                                   "cljs.core/ISorted"
                                   "cljs.core/double-array"
                                   "cljs.core/reduced?"
                                   "cljs.core/PersistentTreeMapSeq"
                                   "cljs.core/persistent!"
                                   "cljs.core/sorted-set"
                                   "cljs.core/IList"
                                   "cljs.core/to-array-2d"
                                   "cljs.core/filterv"
                                   "cljs.core/IEditableCollection"
                                   "cljs.core/ArrayNode"
                                   "cljs.core/TransientHashMap"
                                   "cljs.core/TransientArrayMap"
                                   "cljs.core/mapv"
                                   "cljs.core/long"
                                   "cljs.core/reversible?"
                                   "cljs.core/HashCollisionNode"
                                   "cljs.core/into-array"
                                   "cljs.core/TransientVector"
                                   "cljs.core/PersistentTreeSet"
                                   "cljs.core/Reduced"
                                   "cljs.core/long-array"
                                   "cljs.core/subseq"
                                   "cljs.core/bit-count"
                                   "cljs.core/assoc!"
                                   "cljs.core/sorted-map-by"
                                   "cljs.core/NodeSeq"
                                   "cljs.core/gen-apply-to"
                                   "cljs.core/rsubseq"
                                   "cljs.core/make-array"
                                   "cljs.core/sorted-set-by"
                                   "cljs.core/disj!"
                                   "cljs.core/ifn?"
                                   "cljs.core/case"
                                   "cljs.core/RedNode"
                                   "cljs.core/key"
                                   "cljs.core/ITransientAssociative"
                                   "cljs.core/reduce-kv"
                                   "cljs.core/mk-bound-fn"
                                   "cljs.core/VectorNode"
                                   "cljs.core/PersistentHashSet"
                                   "cljs.core/ITransientVector"
                                   "cljs.core/PersistentTreeMap"
                                   "cljs.core/pop!"
                                   "cljs.core/bit-shift-right-zero-fill"
                                   "cljs.core/reduced"
                                   "cljs.core/object-array"
                                   "cljs.core/indexed?"
                                   "cljs.core/TransientHashSet"},
                          :removed #{"cljs.core/Set"}}
                         {:cljs-version "0.0-1236",
                          :cljs-date "2012-05-15",
                          :clj-version "1.4.0",
                          :gclosure-lib "20111110-r1376",
                          :added #{"clojure.core.reducers/drop"
                                   "special/letfn*"
                                   "clojure.core.reducers/folder"
                                   "clojure.core.reducers/Cat"
                                   "clojure.core.reducers/foldcat"
                                   "clojure.core.reducers/fold"
                                   "clojure.core.reducers/monoid"
                                   "clojure.core.reducers/map"
                                   "clojure.core.reducers/cat"
                                   "clojure.core.reducers/take"
                                   "cljs.reader/maybe-read-tagged-type"
                                   "clojure.core.reducers/reduce"
                                   "clojure.core.reducers/flatten"
                                   "cljs.reader/*tag-table*"
                                   "clojure.core.reducers/filter"
                                   "cljs.core/simple-benchmark"
                                   "clojure.core.reducers/append!"
                                   "clojure.core.reducers/reducer"
                                   "clojure.core.reducers/take-while"
                                   "cljs.reader/register-tag-parser!"
                                   "clojure.core.reducers/remove"
                                   "cljs.reader/read-string*"
                                   "clojure.core.reducers/mapcat"}}
                         {:cljs-version "0.0-1424",
                          :cljs-date "2012-06-15",
                          :clj-version "1.4.0",
                          :gclosure-lib "20111110-r1376",
                          :added #{"cljs.core/Box"
                                   "cljs.core/array-chunk"
                                   "cljs.core/string-hash-cache"
                                   "cljs.reader/read-2-chars"
                                   "cljs.core/chunk"
                                   "cljs.core/chunk-next"
                                   "cljs.reader/make-unicode-char"
                                   "cljs.core/shuffle"
                                   "cljs.core/ArrayChunk"
                                   "cljs.core/chunk-cons"
                                   "cljs.core/chunked-seq"
                                   "cljs.reader/unicode-4-pattern"
                                   "cljs.core/IComparable"
                                   "cljs.reader/unicode-2-pattern"
                                   "cljs.core/check-string-hash-cache"
                                   "cljs.core/Keyword"
                                   "cljs.core/key-test"
                                   "cljs.core/IChunkedSeq"
                                   "cljs.core/chunk-append"
                                   "cljs.core/regexp?"
                                   "cljs.reader/read-4-chars"
                                   "cljs.core/UUID"
                                   "cljs.reader/deregister-tag-parser!"
                                   "cljs.core/INext"
                                   "cljs.core/RSeq"
                                   "cljs.core/add-to-string-hash-cache"
                                   "cljs.core/chunk-buffer"
                                   "cljs.core/IChunkedNext"
                                   "cljs.core/ChunkBuffer"
                                   "cljs.core/chunked-seq?"
                                   "cljs.reader/validate-unicode-escape"
                                   "cljs.core/string-hash-cache-count"
                                   "cljs.core/IChunk"
                                   "cljs.reader/parse-timestamp"
                                   "cljs.core/chunk-first"
                                   "cljs.core/ChunkedSeq"
                                   "cljs.core/chunk-rest"
                                   "cljs.core/ChunkedCons"},
                          :removed #{"cljs.core/vector-seq"
                                     "cljs.reader/read-unicode-char"}}
                         {:cljs-version "0.0-1443",
                          :cljs-date "2012-06-21",
                          :clj-version "1.4.0",
                          :gclosure-lib "20111110-r1376",
                          :added #{"cljs.core/printf"
                                   "cljs.core/format"
                                   "cljs.core/obj-map"
                                   "cljs.core/memfn"
                                   "cljs.core/hash-set"}}
                         {:cljs-version "0.0-1449",
                          :cljs-date "2012-07-16",
                          :clj-version "1.4.0",
                          :gclosure-lib "20111110-r1376"}
                         {:cljs-version "0.0-1450",
                          :cljs-date "2012-07-24",
                          :clj-version "1.4.0",
                          :gclosure-lib "20111110-r1376"}
                         {:cljs-version "0.0-1503",
                          :cljs-date "2012-10-11",
                          :clj-version "1.4.0",
                          :gclosure-lib "20111110-r1376",
                          :added #{"clojure.data/EqualityPartition"
                                   "clojure.reflect/meta"
                                   "cljs.core/write-all"
                                   "cljs.core/pr-sequential-writer"
                                   "cljs.core/StringBufferWriter"
                                   "clojure.reflect/macroexpand"
                                   "cljs.core/pr-seq-writer"
                                   "clojure.reflect/print-doc"
                                   "clojure.reflect/doc"
                                   "cljs.core/IWriter"
                                   "clojure.data/Diff"
                                   "clojure.data/diff"
                                   "cljs.core/IPrintWithWriter"},
                          :removed #{"cljs.core/pr-with-opts"}}
                         {:cljs-version "0.0-1513",
                          :cljs-date "2012-10-18",
                          :clj-version "1.4.0",
                          :gclosure-lib "20111110-r1376"}
                         {:cljs-version "0.0-1535",
                          :cljs-date "2012-11-07",
                          :clj-version "1.4.0",
                          :gclosure-lib "20120710-r2029",
                          :added #{"cljs.core/with-out-str"}}
                         {:cljs-version "0.0-1552",
                          :cljs-date "2012-11-03",
                          :clj-version "1.4.0",
                          :gclosure-lib "20120710-r2029",
                          :added #{"cljs.core/Fn"
                                   "cljs.core/IEncodeJS"
                                   "cljs.core/js-mod"
                                   "cljs.core/IEncodeClojure"
                                   "cljs.core/clj->js"}}
                         {:cljs-version "0.0-1576",
                          :cljs-date "2013-01-26",
                          :clj-version "1.4.0",
                          :gclosure-lib "20120710-r2029",
                          :added #{"cljs.core/ex-message"
                                   "cljs.reader/deregister-default-tag-parser!"
                                   "cljs.core/ex-data"
                                   "cljs.core/ex-info"
                                   "cljs.reader/*default-data-reader-fn*"
                                   "cljs.core/ExceptionInfo"
                                   "cljs.reader/register-default-tag-parser!"
                                   "cljs.core/ex-cause"}}
                         {:cljs-version "0.0-1586",
                          :cljs-date "2013-02-16",
                          :clj-version "1.4.0",
                          :gclosure-lib "20120710-r2029",
                          :added #{"cljs.core/comparator"}}
                         {:cljs-version "0.0-1798",
                          :cljs-date "2013-04-30",
                          :clj-version "1.5.1",
                          :gclosure-lib "0.0-2029-2",
                          :added #{"cljs.core/unchecked-negate"
                                   "cljs.core/float"
                                   "cljs.core/int-array"
                                   "cljs.core/unchecked-multiply-int"
                                   "cljs.core/cond->"
                                   "cljs.core/unchecked-add"
                                   "cljs.core/Symbol"
                                   "cljs.core/chars"
                                   "cljs.core/short"
                                   "cljs.core/longs"
                                   "cljs.core/unchecked-multiply"
                                   "cljs.core/some->"
                                   "cljs.core/unchecked-negate-int"
                                   "cljs.core/unchecked-substract-int"
                                   "cljs.core/unchecked-double"
                                   "cljs.core/set-print-fn!"
                                   "cljs.core/unchecked-inc-int"
                                   "cljs.core/unchecked-subtract"
                                   "cljs.core/unchecked-add-int"
                                   "cljs.core/some->>"
                                   "cljs.core/unchecked-inc"
                                   "cljs.core/unchecked-subtract-int"
                                   "cljs.core/unchecked-substract"
                                   "cljs.core/unchecked-dec"
                                   "cljs.core/unchecked-divide-int"
                                   "cljs.core/ints"
                                   "cljs.core/unchecked-dec-int"
                                   "cljs.core/array?"
                                   "cljs.core/unchecked-char"
                                   "cljs.core/key->js"
                                   "cljs.core/char"
                                   "cljs.core/floats"
                                   "cljs.core/cond->>"
                                   "cljs.core/booleans"
                                   "cljs.core/not-native"
                                   "cljs.core/bytes"
                                   "cljs.core/unchecked-byte"
                                   "cljs.core/unchecked-short"
                                   "cljs.core/byte"
                                   "cljs.core/INamed"
                                   "cljs.core/shorts"
                                   "cljs.core/unchecked-int"
                                   "cljs.core/double"
                                   "cljs.core/exists?"
                                   "cljs.core/doubles"
                                   "cljs.core/unchecked-float"
                                   "cljs.core/divide"
                                   "cljs.core/as->"
                                   "cljs.core/unchecked-remainder-int"
                                   "cljs.core/unchecked-long"},
                          :removed #{"cljs.core/HashMap"
                                     "cljs.core/IPrintable"
                                     "cljs.core/pr-sequential"
                                     "cljs.core/Vector"}}]},
 :compiler-api {:symbols {},
                :changes [{:cljs-version "0.0-927",
                           :cljs-date "2012-01-18",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-971",
                           :cljs-date "2012-01-27",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-993",
                           :cljs-date "2012-02-25",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-1006",
                           :cljs-date "2012-03-30",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-1011",
                           :cljs-date "2012-03-31",
                           :clj-version "1.3.0",
                           :gclosure-lib "20110323-r790"}
                          {:cljs-version "0.0-1211",
                           :cljs-date "2012-05-09",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1236",
                           :cljs-date "2012-05-15",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1424",
                           :cljs-date "2012-06-15",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1443",
                           :cljs-date "2012-06-21",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1449",
                           :cljs-date "2012-07-16",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1450",
                           :cljs-date "2012-07-24",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1503",
                           :cljs-date "2012-10-11",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1513",
                           :cljs-date "2012-10-18",
                           :clj-version "1.4.0",
                           :gclosure-lib "20111110-r1376"}
                          {:cljs-version "0.0-1535",
                           :cljs-date "2012-11-07",
                           :clj-version "1.4.0",
                           :gclosure-lib "20120710-r2029"}
                          {:cljs-version "0.0-1552",
                           :cljs-date "2012-11-03",
                           :clj-version "1.4.0",
                           :gclosure-lib "20120710-r2029"}
                          {:cljs-version "0.0-1576",
                           :cljs-date "2013-01-26",
                           :clj-version "1.4.0",
                           :gclosure-lib "20120710-r2029"}
                          {:cljs-version "0.0-1586",
                           :cljs-date "2013-02-16",
                           :clj-version "1.4.0",
                           :gclosure-lib "20120710-r2029"}
                          {:cljs-version "0.0-1798",
                           :cljs-date "2013-04-30",
                           :clj-version "1.5.1",
                           :gclosure-lib "0.0-2029-2"}]}}
