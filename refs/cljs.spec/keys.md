## cljs.spec/keys



 <table border="1">
<tr>
<td>macro</td>
<td><a href="https://github.com/cljsinfo/cljs-api-docs/tree/1.9.14"><img valign="middle" alt="[+] 1.9.14" title="Added in 1.9.14" src="https://img.shields.io/badge/+-1.9.14-lightgrey.svg"></a> </td>
<td>
[<img height="24px" valign="middle" src="http://i.imgur.com/1GjPKvB.png"> <samp>clojure.spec/keys</samp>](http://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec/keys)
</td>
</tr>
</table>

<samp>(keys & {:keys \[req req-un opt opt-un gen\]})</samp><br>

---

 <samp>
(__keys__ & {:keys \[req req-un opt opt-un gen\]})<br>
</samp>

---





Source docstring:

```
Creates and returns a map validating spec. :req and :opt are both
vectors of namespaced-qualified keywords. The validator will ensure
the :req keys are present. The :opt keys serve as documentation and
may be used by the generator.

The :req key vector supports 'and' and 'or' for key groups:

(s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])

There are also -un versions of :req and :opt. These allow
you to connect unqualified keys to specs.  In each case, fully
qualfied keywords are passed, which name the specs, but unqualified
keys (with the same name component) are expected and checked at
conform-time, and generated during gen:

(s/keys :req-un [:my.ns/x :my.ns/y])

The above says keys :x and :y are required, and will be validated
and generated by specs (if they exist) named :my.ns/x :my.ns/y
respectively.

In addition, the values of *all* namespace-qualified keys will be validated
(and possibly destructured) by any registered specs. Note: there is
no support for inline value specification, by design.

Optionally takes :gen generator-fn, which must be a fn of no args that
returns a test.check generator.
```


Source code @ [github]():

```clj
(defmacro keys
  [& {:keys [req req-un opt opt-un gen]}]
  (let [unk #(-> % name keyword)
        req-keys (filterv keyword? (flatten req))
        req-un-specs (filterv keyword? (flatten req-un))
        _ (assert (every? #(clojure.core/and (keyword? %) (namespace %)) (concat req-keys req-un-specs opt opt-un))
                  "all keys must be namespace-qualified keywords")
        req-specs (into req-keys req-un-specs)
        req-keys (into req-keys (map unk req-un-specs))
        opt-keys (into (vec opt) (map unk opt-un))
        opt-specs (into (vec opt) opt-un)
        parse-req (fn [rk f]
                    (map (fn [x]
                           (if (keyword? x)
                             `#(contains? % ~(f x))
                             (let [gx (gensym)]
                               `(fn* [~gx]
                                  ~(walk/postwalk
                                     (fn [y] (if (keyword? y) `(contains? ~gx ~(f y)) y))
                                     x)))))
                         rk))
        pred-exprs [`map?]
        pred-exprs (into pred-exprs (parse-req req identity))
        pred-exprs (into pred-exprs (parse-req req-un unk))
        pred-forms (walk/postwalk #(res &env %) pred-exprs)]
    ;; `(map-spec-impl ~req-keys '~req ~opt '~pred-forms ~pred-exprs ~gen)
    `(cljs.spec/map-spec-impl {:req '~req :opt '~opt :req-un '~req-un :opt-un '~opt-un
                               :req-keys '~req-keys :req-specs '~req-specs
                               :opt-keys '~opt-keys :opt-specs '~opt-specs
                               :pred-forms '~pred-forms
                               :pred-exprs ~pred-exprs
                               :gfn ~gen})))
```

<!--
Repo - tag - source tree - lines:

 <pre>

</pre>

-->

---



###### External doc links:

[`clojure.spec/keys` @ clojuredocs](http://clojuredocs.org/clojure.spec/keys)<br>
[`clojure.spec/keys` @ grimoire](http://conj.io/store/v1/org.clojure/clojure/1.7.0-beta3/clj/clojure.spec/keys/)<br>
[`clojure.spec/keys` @ crossclj](http://crossclj.info/fun/clojure.spec/keys.html)<br>
[`cljs.spec/keys` @ crossclj](http://crossclj.info/fun/cljs.spec/keys.html)<br>

---

 <table>
<tr><td>
<img valign="middle" align="right" width="48px" src="http://i.imgur.com/Hi20huC.png">
</td><td>
Created for the upcoming ClojureScript website.<br>
[edit here] | [learn how]
</td></tr></table>

[edit here]:https://github.com/cljsinfo/cljs-api-docs/blob/master/cljsdoc/cljs.spec/keys.cljsdoc
[learn how]:https://github.com/cljsinfo/cljs-api-docs/wiki/cljsdoc-files

<!--

This information was too distracting to show to readers, but I'll leave it
commented here since it is helpful to:

- pretty-print the data used to generate this document
- and show how to retrieve that data



The API data for this symbol:

```clj
{:ns "cljs.spec",
 :name "keys",
 :signature ["[& {:keys [req req-un opt opt-un gen]}]"],
 :name-encode "keys",
 :history [["+" "1.9.14"]],
 :type "macro",
 :clj-equiv {:full-name "clojure.spec/keys",
             :url "http://clojure.github.io/clojure/branch-master/clojure.spec-api.html#clojure.spec/keys"},
 :full-name-encode "cljs.spec/keys",
 :source {:code "(defmacro keys\n  [& {:keys [req req-un opt opt-un gen]}]\n  (let [unk #(-> % name keyword)\n        req-keys (filterv keyword? (flatten req))\n        req-un-specs (filterv keyword? (flatten req-un))\n        _ (assert (every? #(clojure.core/and (keyword? %) (namespace %)) (concat req-keys req-un-specs opt opt-un))\n                  \"all keys must be namespace-qualified keywords\")\n        req-specs (into req-keys req-un-specs)\n        req-keys (into req-keys (map unk req-un-specs))\n        opt-keys (into (vec opt) (map unk opt-un))\n        opt-specs (into (vec opt) opt-un)\n        parse-req (fn [rk f]\n                    (map (fn [x]\n                           (if (keyword? x)\n                             `#(contains? % ~(f x))\n                             (let [gx (gensym)]\n                               `(fn* [~gx]\n                                  ~(walk/postwalk\n                                     (fn [y] (if (keyword? y) `(contains? ~gx ~(f y)) y))\n                                     x)))))\n                         rk))\n        pred-exprs [`map?]\n        pred-exprs (into pred-exprs (parse-req req identity))\n        pred-exprs (into pred-exprs (parse-req req-un unk))\n        pred-forms (walk/postwalk #(res &env %) pred-exprs)]\n    ;; `(map-spec-impl ~req-keys '~req ~opt '~pred-forms ~pred-exprs ~gen)\n    `(cljs.spec/map-spec-impl {:req '~req :opt '~opt :req-un '~req-un :opt-un '~opt-un\n                               :req-keys '~req-keys :req-specs '~req-specs\n                               :opt-keys '~opt-keys :opt-specs '~opt-specs\n                               :pred-forms '~pred-forms\n                               :pred-exprs ~pred-exprs\n                               :gfn ~gen})))",
          :title "Source code",
          :repo "clojurescript",
          :tag "r1.9.14",
          :filename "src/main/cljs/cljs/spec.cljc",
          :lines [91 149],
          :url "https://github.com/clojure/clojurescript/blob/r1.9.14/src/main/cljs/cljs/spec.cljc#L91-L149"},
 :usage ["(keys & {:keys [req req-un opt opt-un gen]})"],
 :full-name "cljs.spec/keys",
 :docstring "Creates and returns a map validating spec. :req and :opt are both\nvectors of namespaced-qualified keywords. The validator will ensure\nthe :req keys are present. The :opt keys serve as documentation and\nmay be used by the generator.\n\nThe :req key vector supports 'and' and 'or' for key groups:\n\n(s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])\n\nThere are also -un versions of :req and :opt. These allow\nyou to connect unqualified keys to specs.  In each case, fully\nqualfied keywords are passed, which name the specs, but unqualified\nkeys (with the same name component) are expected and checked at\nconform-time, and generated during gen:\n\n(s/keys :req-un [:my.ns/x :my.ns/y])\n\nThe above says keys :x and :y are required, and will be validated\nand generated by specs (if they exist) named :my.ns/x :my.ns/y\nrespectively.\n\nIn addition, the values of *all* namespace-qualified keys will be validated\n(and possibly destructured) by any registered specs. Note: there is\nno support for inline value specification, by design.\n\nOptionally takes :gen generator-fn, which must be a fn of no args that\nreturns a test.check generator.",
 :cljsdoc-url "https://github.com/cljsinfo/cljs-api-docs/blob/master/cljsdoc/cljs.spec/keys.cljsdoc"}

```

Retrieve the API data for this symbol:

```clj
;; from Clojure REPL
(require '[clojure.edn :as edn])
(-> (slurp "https://raw.githubusercontent.com/cljsinfo/cljs-api-docs/catalog/cljs-api.edn")
    (edn/read-string)
    (get-in [:symbols "cljs.spec/keys"]))
```

-->
