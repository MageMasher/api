(ns cljs-api-gen.catalog
  (:require
    [fipp.edn :refer [pprint]]
    [clojure.edn :as edn]
    [clansi.core :refer [style]]
    [clojure.string :refer [join]]
    [clojure.java.shell :refer [sh]]
    [me.raynes.fs :refer [mkdir exists?]]
    [cljs-api-gen.cljsdoc :refer [build-cljsdoc!]]
    [cljs-api-gen.config :refer [*output-dir*
                                 cache-dir
                                 edn-parsed-file
                                 edn-cljsdoc-file]]
    [cljs-api-gen.parse :refer [parse-all]]
    [cljs-api-gen.repo-cljs :refer [get-cljs-tags-to-parse
                                    published-cljs-tags
                                    with-checkout!
                                    cljs-tag->version
                                    *cljs-tag*
                                    *cljs-date*
                                    *clj-tag*
                                    *cljs-version*
                                    *clj-version*]]
    [cljs-api-gen.result :refer [get-result]]
    [cljs-api-gen.write :refer [dump-result!]]
    ))

;;----------------------------------------------------------------------
;; Catalog Repo Operations
;;----------------------------------------------------------------------

(defn git
  [& args]
  (apply sh "git" (concat args [:dir *output-dir*])))

(defn catalog-tag->cljs
  [v]
  (let [m (re-find #"-\d+" v)
        number (subs m 1)]
    (str "r" number)))

(defn catalog-tag []
  (:out (git "describe" "--tags")))

(defn catalog-clear! []
  (git "rm" "-rf" "."))

(defn catalog-commit! []
  (let [msg (str *cljs-version* "\n"
                 "\n"
                 "- auto-generated by:\n"
                 "  https://github.com/cljsinfo/cljs-api-docs\n"
                 "\n"
                 "- parsed from:\n"
                 "  ClojureScript " *cljs-version* "\n"
                 "  Clojure " *clj-version* "\n")]
    (git "add" ".")
    (git "commit" "-m" msg)
    (git "tag" *cljs-version*)))

;;----------------------------------------------------------------------
;; Catalog Creation
;;----------------------------------------------------------------------

(defn print-summary*
  [parsed]
  (let [ns-groups (group-by :ns parsed)
        pairs (sort-by first ns-groups)]
    (doseq [[ns- symbols] pairs]
      (printf "    %-24s %4s = %s\n"
        ns-
        (count symbols)
        (let [type-groups (group-by :type symbols)
              pairs (sort-by first type-groups)]
          (join " + "
            (for [[type- symbols] pairs]
              (let [total (count symbols)]
                (str total " " (cond-> type- (> total 1) (str "s")))))))))))

(defn print-summary
  [parsed]
  (println " Syntax API:")
  (print-summary* (:syntax parsed))
  (println " Library API:")
  (print-summary* (:library parsed))
  (println " Compiler API:")
  (print-summary* (:compiler parsed)))

(defn create-catalog!
  [{:as options
    :keys [version
           catalog?
           skip-pages?
           skip-parse?]
    :or {version :latest
         catalog? false
         skip-pages? false
         skip-parse? false}}]

  ;; create output directory
  (when-not (exists? *output-dir*)
    (mkdir *output-dir*))

  (let [cache (str *output-dir* "/" cache-dir)
        prev-result (atom nil)
        tags (if (= :latest version)
               @published-cljs-tags
               (concat (take-while (partial not= version) @published-cljs-tags) [version]))]

    ;; make cache directory
    (when-not (exists? cache)
      (mkdir cache))

    (println "Outputting to " (style *output-dir* :cyan))
    (println "   with cache at " (style cache :cyan))

    ;; parse symbol history
    (println "\nStarting first pass (parsing symbol history)...\n")
    (doseq [tag tags]

      ;; check if skip-parse? and if this tag's edn-parsed-file already exists
      (let [out-folder (str cache "/" tag)
            parsed-file (str out-folder "/" edn-parsed-file)
            skip? (and skip-parse?           ;; do we want to skip?
                       (exists? parsed-file) ;; can we skip?
                       )]

        ;; make output folder for this tag
        (when-not (exists? out-folder)
          (mkdir out-folder))

        (if skip?

          (do
            (println "Using cache instead of parsing" (style tag :yellow))
            (reset! prev-result (edn/read-string (slurp parsed-file))))

          ;; parse
          (with-checkout! tag

            (println "\n=========================================================")
            (println "\nChecked out ClojureScript " (style *cljs-tag* :yellow))
            (println "with Clojure:" (style *clj-tag* :yellow))

            (println "\nParsing...")
            (let [parsed (parse-all)]
              (print-summary parsed)

              (println "\nWriting parsed data to" (style parsed-file :cyan))
              (let [result (get-result parsed @prev-result)]
                (spit parsed-file (with-out-str (pprint result)))
                (reset! prev-result result)))

            (println "\nDone.")))))

    ;; compile cljsdoc files (manual docs)
    (let [known-symbols (set (keys (:symbols @prev-result)))
          num-skipped (build-cljsdoc! #_known-symbols) ;; TODO: uncomment param when ready to address symbol errors
          ] 
      (when-not (zero? num-skipped)
        (System/exit 1)))

    ;; TODO: create result data
    ;; TODO: render pages

    ;; third pass
    (if catalog?

      (do
        ;; TODO: delete output-dir/.git
        ;; TODO: create commits
        (comment
          (catalog-clear!)
          (println "\nCommitting docs at tag" *cljs-version* "...")
          (catalog-commit!)
          ))

      (do
        ;; TODO: copy last version files to output-dir
        nil))

    (println (style "Success!" :green))))

